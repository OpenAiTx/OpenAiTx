[
  {
    "Id": 1,
    "Content": "# CVE-2025-32023\n\nPoC & Exploit for CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 \"Zerodeo\"\n\n\n### Repro / Patch\n\nTested against `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\nAffects Redis versions >= 2.8. Patched on 8.0.3, 7.4.5, 7.2.10, 6.2.19, see [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).\n\n\n### Bug\n\nHyperLogLog in Redis is just another string with its own custom encodings. Iterating over a sparse HLL encoding requires adding up run lengths of each sparse representation, which may overflow the total length counted in `int i` into a negative value when operated on a malformed HLL. This allows an attacker to overwrite to negative offsets on the HLL structure, leading to out-of-bounds write on the stack/heap depending on where the HLL structure is from (e.g. `hllMerge()` takes a stack-allocated one, `hllSparseToDense()` takes a heap-allocated one).\n\nSee the patch snippet below:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "ContentSha": "0meY7ebduqK2cUlP2eo5itz1LX0v310i3cllytFC0Ms=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# CVE-2025-32023\n\nPoC و اکسپلویت برای CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 \"Zerodeo\"\n\n\n### بازتولید / وصله\n\nتست شده بر روی `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\nبر روی نسخه‌های Redis برابر یا بالاتر از 2.8 تأثیر می‌گذارد. در نسخه‌های 8.0.3، 7.4.5، 7.2.10، 6.2.19 وصله شده است، مراجعه کنید به [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).\n\n\n### باگ\n\nHyperLogLog در Redis فقط یک رشته دیگر با کدگذاری‌های مخصوص به خود است. پیمایش روی یک کدگذاری HLL پراکنده نیازمند جمع زدن طول اجرای هر نمایش پراکنده است، که ممکن است در صورت کار با یک HLL ناقص، مجموع طول شمارش شده در `int i` را به مقدار منفی سرریز کند. این امکان را به مهاجم می‌دهد که به آفست‌های منفی روی ساختار HLL بنویسد و منجر به نوشتن خارج از محدوده روی پشته/هیپ می‌شود، بسته به اینکه ساختار HLL از کجا آمده است (برای مثال `hllMerge()` یکی را روی پشته تخصیص می‌دهد، `hllSparseToDense()` یکی را روی هیپ تخصیص می‌دهد).\n\nقطعه‌ای از وصله را در زیر ببینید:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "Status": "ok"
  },
  {
    "Id": 2,
    "Content": "\n### Exploit\n\nExploit is standard Redis pwnables:\n1. Corrupt an sds object on the jemalloc heap to make its length large\n2. Spray embstr objects to corrupt into a fake module object\n3. Dump the heap using the corrupted sds object to find target embstr object & leak addresses\n4. Create a fake module object on the target embstr object\n5. Delete the fake module object, triggering destructor & gaining RCE\n\n",
    "ContentSha": "kFCAerupXpXp4PuGom2wnNcH0WwawRLInRHPOAypmfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### اکسپلویت\n\nاکسپلویت در اینجا مشابه استانداردهای پون‌ایبل‌های Redis است:\n1. خراب کردن یک شی sds روی هیپ jemalloc به‌طوری که طول آن بزرگ شود\n2. اسپری کردن اشیاء embstr برای خراب‌سازی و تبدیل به یک شی ماژول جعلی\n3. دامپ کردن هیپ با استفاده از شی sds خراب‌شده به‌منظور یافتن شی embstr هدف و افشای آدرس‌ها\n4. ایجاد یک شی ماژول جعلی روی شی embstr هدف\n5. حذف شی ماژول جعلی، فعال‌سازی دِستراکتور و به‌دست آوردن RCE (اجرای کد از راه دور)",
    "Status": "ok"
  }
]