# CVE-2025-32023

PoC و اکسپلویت برای CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### بازتولید / وصله

تست شده بر روی `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

بر روی نسخه‌های Redis برابر یا بالاتر از 2.8 تأثیر می‌گذارد. در نسخه‌های 8.0.3، 7.4.5، 7.2.10، 6.2.19 وصله شده است، مراجعه کنید به [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### باگ

HyperLogLog در Redis فقط یک رشته دیگر با کدگذاری‌های مخصوص به خود است. پیمایش روی یک کدگذاری HLL پراکنده نیازمند جمع زدن طول اجرای هر نمایش پراکنده است، که ممکن است در صورت کار با یک HLL ناقص، مجموع طول شمارش شده در `int i` را به مقدار منفی سرریز کند. این امکان را به مهاجم می‌دهد که به آفست‌های منفی روی ساختار HLL بنویسد و منجر به نوشتن خارج از محدوده روی پشته/هیپ می‌شود، بسته به اینکه ساختار HLL از کجا آمده است (برای مثال `hllMerge()` یکی را روی پشته تخصیص می‌دهد، `hllSparseToDense()` یکی را روی هیپ تخصیص می‌دهد).

قطعه‌ای از وصله را در زیر ببینید:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### اکسپلویت

اکسپلویت در اینجا مشابه استانداردهای پون‌ایبل‌های Redis است:
1. خراب کردن یک شی sds روی هیپ jemalloc به‌طوری که طول آن بزرگ شود
2. اسپری کردن اشیاء embstr برای خراب‌سازی و تبدیل به یک شی ماژول جعلی
3. دامپ کردن هیپ با استفاده از شی sds خراب‌شده به‌منظور یافتن شی embstr هدف و افشای آدرس‌ها
4. ایجاد یک شی ماژول جعلی روی شی embstr هدف
5. حذف شی ماژول جعلی، فعال‌سازی دِستراکتور و به‌دست آوردن RCE (اجرای کد از راه دور)

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---