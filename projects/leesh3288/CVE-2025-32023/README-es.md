# CVE-2025-32023

PoC y Exploit para CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### Repro / Parche

Probado en `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

Afecta a las versiones de Redis >= 2.8. Corregido en 8.0.3, 7.4.5, 7.2.10, 6.2.19, ver [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### Bug

HyperLogLog en Redis es simplemente otra cadena de texto con sus propios codificadores personalizados. Iterar sobre una codificación HLL dispersa requiere sumar las longitudes de ejecución de cada representación dispersa, lo que puede desbordar el recuento total de longitud en `int i` a un valor negativo cuando se opera sobre un HLL malformado. Esto permite a un atacante sobrescribir en desplazamientos negativos en la estructura HLL, lo que conduce a escritura fuera de límites en la pila o el heap dependiendo de dónde provenga la estructura HLL (por ejemplo, `hllMerge()` toma una asignada en la pila, `hllSparseToDense()` toma una asignada en el heap).

Vea el fragmento del parche a continuación:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Exploit

El exploit sigue el estándar de pwnables de Redis:
1. Corromper un objeto sds en el heap de jemalloc para aumentar artificialmente su longitud
2. Rociar objetos embstr para corromper uno y convertirlo en un objeto módulo falso
3. Volcar el heap usando el objeto sds corrompido para encontrar el objeto embstr objetivo y filtrar direcciones
4. Crear un objeto módulo falso en el objeto embstr objetivo
5. Eliminar el objeto módulo falso, activando el destructor y obteniendo RCE

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---