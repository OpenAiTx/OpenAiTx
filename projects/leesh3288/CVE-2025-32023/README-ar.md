# CVE-2025-32023

PoC واستغلال لـ CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### إعادة الإنتاج / التصحيح

تم الاختبار على `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

تؤثر على إصدارات Redis >= 2.8. تم تصحيحها في 8.0.3، 7.4.5، 7.2.10، 6.2.19، راجع [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### الخلل

HyperLogLog في Redis هو مجرد سلسلة أخرى مع ترميزات مخصصة خاصة به. يتطلب التكرار على ترميز HLL المتناثر جمع أطوال الجري لكل تمثيل متناثر، مما قد يؤدي إلى تجاوز الطول الإجمالي المحسوب في `int i` إلى قيمة سالبة عند العمل على HLL تم تشكيله بشكل غير صحيح. هذا يسمح للمهاجم بالكتابة في مواضع سالبة على بنية HLL، مما يؤدي إلى الكتابة خارج حدود المكدس/الكومة اعتماداً على مصدر بنية HLL (على سبيل المثال، `hllMerge()` يأخذ واحدة مخصصة على المكدس، و`hllSparseToDense()` يأخذ واحدة مخصصة على الكومة).

راجع مقتطف التصحيح أدناه:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### الاستغلال

الاستغلال يتبع أساليب اختراق Redis القياسية:
1. إتلاف كائن sds على كومة jemalloc لجعل طوله كبيرًا
2. رش كائنات embstr بهدف إتلافها وإنشاء كائن وحدة مزيف
3. تفريغ الكومة باستخدام كائن sds التالف للعثور على كائن embstr الهدف وتسريب العناوين
4. إنشاء كائن وحدة مزيف على كائن embstr الهدف
5. حذف كائن الوحدة المزيف، مما يؤدي إلى استدعاء الدالة المدمرة والحصول على تنفيذ أوامر عن بُعد (RCE)

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---