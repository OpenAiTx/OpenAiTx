[
  {
    "Id": 1,
    "Content": "# CVE-2025-32023\n\nPoC & Exploit for CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 \"Zerodeo\"\n\n\n### Repro / Patch\n\nTested against `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\nAffects Redis versions >= 2.8. Patched on 8.0.3, 7.4.5, 7.2.10, 6.2.19, see [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).\n\n\n### Bug\n\nHyperLogLog in Redis is just another string with its own custom encodings. Iterating over a sparse HLL encoding requires adding up run lengths of each sparse representation, which may overflow the total length counted in `int i` into a negative value when operated on a malformed HLL. This allows an attacker to overwrite to negative offsets on the HLL structure, leading to out-of-bounds write on the stack/heap depending on where the HLL structure is from (e.g. `hllMerge()` takes a stack-allocated one, `hllSparseToDense()` takes a heap-allocated one).\n\nSee the patch snippet below:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "ContentSha": "0meY7ebduqK2cUlP2eo5itz1LX0v310i3cllytFC0Ms=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# CVE-2025-32023\n\nPoC y Exploit para CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 \"Zerodeo\"\n\n\n### Repro / Parche\n\nProbado en `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\nAfecta a las versiones de Redis >= 2.8. Corregido en 8.0.3, 7.4.5, 7.2.10, 6.2.19, ver [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).\n\n\n### Bug\n\nHyperLogLog en Redis es simplemente otra cadena de texto con sus propios codificadores personalizados. Iterar sobre una codificación HLL dispersa requiere sumar las longitudes de ejecución de cada representación dispersa, lo que puede desbordar el recuento total de longitud en `int i` a un valor negativo cuando se opera sobre un HLL malformado. Esto permite a un atacante sobrescribir en desplazamientos negativos en la estructura HLL, lo que conduce a escritura fuera de límites en la pila o el heap dependiendo de dónde provenga la estructura HLL (por ejemplo, `hllMerge()` toma una asignada en la pila, `hllSparseToDense()` toma una asignada en el heap).\n\nVea el fragmento del parche a continuación:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "Status": "ok"
  },
  {
    "Id": 2,
    "Content": "\n### Exploit\n\nExploit is standard Redis pwnables:\n1. Corrupt an sds object on the jemalloc heap to make its length large\n2. Spray embstr objects to corrupt into a fake module object\n3. Dump the heap using the corrupted sds object to find target embstr object & leak addresses\n4. Create a fake module object on the target embstr object\n5. Delete the fake module object, triggering destructor & gaining RCE\n\n",
    "ContentSha": "kFCAerupXpXp4PuGom2wnNcH0WwawRLInRHPOAypmfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### Exploit\n\nEl exploit sigue el estándar de pwnables de Redis:\n1. Corromper un objeto sds en el heap de jemalloc para aumentar artificialmente su longitud\n2. Rociar objetos embstr para corromper uno y convertirlo en un objeto módulo falso\n3. Volcar el heap usando el objeto sds corrompido para encontrar el objeto embstr objetivo y filtrar direcciones\n4. Crear un objeto módulo falso en el objeto embstr objetivo\n5. Eliminar el objeto módulo falso, activando el destructor y obteniendo RCE",
    "Status": "ok"
  }
]