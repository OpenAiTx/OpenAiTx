# CVE-2025-32023

CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) PoC & Exploit / PlaidCTF 2025 "Zerodeo"


### 재현 / 패치

`redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952` 환경에서 테스트됨

Redis 버전 >= 2.8에 영향을 미치며, 8.0.3, 7.4.5, 7.2.10, 6.2.19에서 패치됨. 자세한 내용은 [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445) 참고.


### 버그

Redis의 HyperLogLog는 고유한 인코딩을 갖는 또 다른 문자열일 뿐입니다. 희소 HLL 인코딩을 반복(iterate)할 때는 각 희소 표현의 실행(run) 길이를 합산해야 하며, 잘못된 HLL에 대해 연산할 때 `int i`의 총 길이가 오버플로우하여 음수 값이 될 수 있습니다. 이를 통해 공격자는 HLL 구조 내 음수 오프셋에 덮어쓰기를 할 수 있으며, HLL 구조가 어디서 왔는지에 따라(예: `hllMerge()`는 스택에 할당된 구조를, `hllSparseToDense()`는 힙에 할당된 구조를 사용) 스택/힙에서 경계를 벗어난(out-of-bounds) 쓰기가 발생할 수 있습니다.

아래 패치 스니펫을 참고하세요:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Exploit

Exploit은 표준 Redis pwnables입니다:
1. jemalloc 힙에 있는 sds 객체를 손상시켜 그 길이를 크게 만듭니다
2. embstr 객체를 대량으로 뿌려(fake module 객체로 손상시키기 위해) 준비합니다
3. 손상된 sds 객체를 사용해 힙을 덤프하여 대상 embstr 객체를 찾고 주소를 유출합니다
4. 대상 embstr 객체에 가짜 module 객체를 생성합니다
5. 가짜 module 객체를 삭제하여 소멸자를 트리거하고 RCE를 획득합니다

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---