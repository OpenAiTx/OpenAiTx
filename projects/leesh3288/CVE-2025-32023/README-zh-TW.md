# CVE-2025-32023

CVE-2025-32023 的 PoC 及 Exploit（[GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)）/ PlaidCTF 2025 "Zerodeo"


### 重現 / 修補

已在 `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952` 上測試。

影響 Redis 版本 >= 2.8。已於 8.0.3、7.4.5、7.2.10、6.2.19 修補，詳見 [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445)。


### 漏洞說明

Redis 中的 HyperLogLog 其實就是一個帶有自定義編碼的字符串。對稀疏型 HLL 編碼進行迭代時，需要累加每個稀疏表示的運行長度，若針對格式錯誤的 HLL 操作時，這個總長度在 `int i` 中可能溢位為負值。這讓攻擊者能覆寫 HLL 結構的負偏移，導致對堆疊或堆外的越界寫入，具體取決於 HLL 結構的來源（例如 `hllMerge()` 使用堆疊分配，而 `hllSparseToDense()` 則使用堆分配）。

請見以下修補程式片段：

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### 利用方式

利用方式是標準的 Redis pwnables：
1. 損壞 jemalloc 堆上的 sds 物件，使其長度變大
2. 噴灑 embstr 物件，以便破壞成為偽造的 module 物件
3. 使用損壞的 sds 物件傾印堆，找到目標 embstr 物件並洩漏位址
4. 在目標 embstr 物件上建立偽造的 module 物件
5. 刪除偽造的 module 物件，觸發解構子並取得遠端程式碼執行（RCE）

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---