# CVE-2025-32023

PoC & Exploit per CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### Riproduzione / Patch

Testato su `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

Impatta le versioni di Redis >= 2.8. Patch applicata su 8.0.3, 7.4.5, 7.2.10, 6.2.19, vedi [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### Bug

HyperLogLog in Redis è semplicemente un'altra stringa con i propri codifiche personalizzate. Iterare su una codifica HLL sparsa richiede la somma delle lunghezze delle sequenze di ogni rappresentazione sparsa, che può far traboccare la lunghezza totale conteggiata in `int i` in un valore negativo quando viene operato su un HLL malformato. Questo permette a un attaccante di sovrascrivere offset negativi sulla struttura HLL, portando a una scrittura fuori dai limiti su stack/heap a seconda della provenienza della struttura HLL (ad esempio, `hllMerge()` ne prende una allocata sullo stack, `hllSparseToDense()` ne prende una allocata sull'heap).

Vedi la porzione di patch qui sotto:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Exploit

L'exploit segue la metodologia standard dei pwnables Redis:
1. Corrompere un oggetto sds sull'heap jemalloc per aumentarne la lunghezza
2. Spruzzare oggetti embstr da corrompere in un falso oggetto modulo
3. Dumpare l'heap utilizzando l'oggetto sds corrotto per trovare l'oggetto embstr target e ottenere leak di indirizzi
4. Creare un falso oggetto modulo sull'oggetto embstr target
5. Eliminare il falso oggetto modulo, attivando il distruttore e ottenendo RCE

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---