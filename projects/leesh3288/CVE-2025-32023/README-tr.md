# CVE-2025-32023

CVE-2025-32023 için PoC & Exploit ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### Yeniden Üretim / Yama

`redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952` sürümüne karşı test edilmiştir.

Redis sürümleri >= 2.8 etkilenmektedir. 8.0.3, 7.4.5, 7.2.10, 6.2.19 sürümlerinde yamalanmıştır, bkz. [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### Hata

Redis'teki HyperLogLog, kendi özel kodlamalarına sahip başka bir stringden ibarettir. Seyrek bir HLL kodlaması üzerinde yineleme yapmak, her bir seyrek gösterimin çalışma uzunluklarının toplanmasını gerektirir; bu da bozulmuş bir HLL üzerinde çalışıldığında, toplam uzunluğun `int i` içinde negatif bir değere taşmasına neden olabilir. Bu, bir saldırganın HLL yapısı üzerinde negatif ofsetlere yazmasına izin verir ve HLL yapısının nereden geldiğine bağlı olarak (ör. `hllMerge()` yığın üzerinde ayrılmış bir tane alır, `hllSparseToDense()` ise yığın üzerinde ayrılmış bir tane alır) yığın/heap üzerinde sınır dışı yazmaya yol açar.

Aşağıdaki yama parçasına bakınız:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Taşma. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Taşma. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Taşma. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Taşma. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Exploit

Exploit standart Redis pwnable’larıdır:
1. Jemalloc heap’inde bir sds nesnesini bozarak uzunluğunu büyük yapmak
2. Sahte bir modül nesnesine bozulacak şekilde embstr nesneleri yaymak
3. Hedef embstr nesnesini bulmak ve adresleri sızdırmak için bozulmuş sds nesnesiyle heap’i dökmek
4. Hedef embstr nesnesi üzerinde sahte bir modül nesnesi oluşturmak
5. Sahte modül nesnesini silmek, yıkıcıyı tetiklemek ve RCE elde etmek

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---