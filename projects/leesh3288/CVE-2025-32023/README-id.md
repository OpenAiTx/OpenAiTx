# CVE-2025-32023

PoC & Eksploitasi untuk CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### Reproduksi / Patch

Diuji pada `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

Mempengaruhi Redis versi >= 2.8. Sudah ditambal di 8.0.3, 7.4.5, 7.2.10, 6.2.19, lihat [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### Bug

HyperLogLog di Redis hanyalah string lain dengan encoding khusus. Iterasi pada encoding HLL sparse membutuhkan penjumlahan panjang run dari setiap representasi sparse, yang dapat menyebabkan overflow pada total panjang yang dihitung di `int i` menjadi nilai negatif ketika dijalankan pada HLL yang rusak. Ini memungkinkan penyerang untuk menimpa offset negatif pada struktur HLL, yang dapat menyebabkan penulisan di luar batas pada stack/heap tergantung dari mana struktur HLL tersebut berasal (misal, `hllMerge()` menggunakan alokasi stack, `hllSparseToDense()` menggunakan alokasi heap).

Lihat cuplikan patch di bawah ini:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Eksploitasi

Eksploitasi adalah pwnables Redis standar:
1. Merusak objek sds pada jemalloc heap untuk membuat panjangnya menjadi besar
2. Melakukan spray objek embstr untuk dirusak menjadi objek modul palsu
3. Membuang heap menggunakan objek sds yang telah rusak untuk menemukan objek embstr target & membocorkan alamat
4. Membuat objek modul palsu pada objek embstr target
5. Menghapus objek modul palsu, memicu destruktor & mendapatkan RCE

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---