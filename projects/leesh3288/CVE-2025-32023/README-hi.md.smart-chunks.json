[
  {
    "Id": 1,
    "Content": "# CVE-2025-32023\n\nPoC & Exploit for CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 \"Zerodeo\"\n\n\n### Repro / Patch\n\nTested against `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\nAffects Redis versions >= 2.8. Patched on 8.0.3, 7.4.5, 7.2.10, 6.2.19, see [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).\n\n\n### Bug\n\nHyperLogLog in Redis is just another string with its own custom encodings. Iterating over a sparse HLL encoding requires adding up run lengths of each sparse representation, which may overflow the total length counted in `int i` into a negative value when operated on a malformed HLL. This allows an attacker to overwrite to negative offsets on the HLL structure, leading to out-of-bounds write on the stack/heap depending on where the HLL structure is from (e.g. `hllMerge()` takes a stack-allocated one, `hllSparseToDense()` takes a heap-allocated one).\n\nSee the patch snippet below:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "ContentSha": "0meY7ebduqK2cUlP2eo5itz1LX0v310i3cllytFC0Ms=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# CVE-2025-32023\n\nCVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) के लिए PoC और Exploit / PlaidCTF 2025 \"Zerodeo\"\n\n### पुनरुत्पादन / पैच\n\n`redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952` पर परीक्षण किया गया\n\nRedis के संस्करण >= 2.8 प्रभावित होते हैं। 8.0.3, 7.4.5, 7.2.10, 6.2.19 पर पैच किया गया, देखें [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445)।\n\n### बग\n\nRedis में HyperLogLog एक और स्ट्रिंग है जिसमें अपनी कस्टम एनकोडिंग्स होती हैं। एक sparse HLL एनकोडिंग पर इटरेट करने के लिए प्रत्येक sparse प्रतिनिधित्व की रन लेंथ जोड़नी होती है, जो यदि किसी विकृत HLL पर ऑपरेट की जाए तो `int i` में गिनी गई कुल लंबाई को overflow कर सकती है और नेगेटिव वैल्यू में बदल सकती है। इससे हमलावर को HLL संरचना में नेगेटिव ऑफसेट्स पर ओवरराइट करने की अनुमति मिलती है, जिससे स्टैक/हीप पर आउट-ऑफ-बाउंड्स राइट हो सकता है, यह इस पर निर्भर करता है कि HLL संरचना कहाँ से ली गई है (जैसे `hllMerge()` एक स्टैक-एलोकेटेड लेता है, `hllSparseToDense()` एक हीप-एलोकेटेड लेता है)।\n\nनीचे पैच स्निपेट देखें:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "Status": "ok"
  },
  {
    "Id": 2,
    "Content": "\n### Exploit\n\nExploit is standard Redis pwnables:\n1. Corrupt an sds object on the jemalloc heap to make its length large\n2. Spray embstr objects to corrupt into a fake module object\n3. Dump the heap using the corrupted sds object to find target embstr object & leak addresses\n4. Create a fake module object on the target embstr object\n5. Delete the fake module object, triggering destructor & gaining RCE\n\n",
    "ContentSha": "kFCAerupXpXp4PuGom2wnNcH0WwawRLInRHPOAypmfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### Exploit\n\nExploit मानक Redis pwnables है:\n1. jemalloc heap पर एक sds ऑब्जेक्ट को भ्रष्ट करें ताकि उसकी लंबाई बड़ी हो जाए\n2. embstr ऑब्जेक्ट्स को स्प्रे करें ताकि वे एक नकली module ऑब्जेक्ट में भ्रष्ट हो जाएं\n3. भ्रष्ट sds ऑब्जेक्ट का उपयोग करके heap को डंप करें ताकि लक्षित embstr ऑब्जेक्ट पाया जा सके और पते लीक किए जा सकें\n4. लक्षित embstr ऑब्जेक्ट पर एक नकली module ऑब्जेक्ट बनाएं\n5. नकली module ऑब्जेक्ट को हटाएं, जिससे destructor ट्रिगर हो और RCE प्राप्त हो",
    "Status": "ok"
  }
]