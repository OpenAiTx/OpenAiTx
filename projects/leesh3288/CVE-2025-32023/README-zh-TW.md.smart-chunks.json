[
  {
    "Id": 1,
    "Content": "# CVE-2025-32023\n\nPoC & Exploit for CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 \"Zerodeo\"\n\n\n### Repro / Patch\n\nTested against `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\nAffects Redis versions >= 2.8. Patched on 8.0.3, 7.4.5, 7.2.10, 6.2.19, see [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).\n\n\n### Bug\n\nHyperLogLog in Redis is just another string with its own custom encodings. Iterating over a sparse HLL encoding requires adding up run lengths of each sparse representation, which may overflow the total length counted in `int i` into a negative value when operated on a malformed HLL. This allows an attacker to overwrite to negative offsets on the HLL structure, leading to out-of-bounds write on the stack/heap depending on where the HLL structure is from (e.g. `hllMerge()` takes a stack-allocated one, `hllSparseToDense()` takes a heap-allocated one).\n\nSee the patch snippet below:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "ContentSha": "0meY7ebduqK2cUlP2eo5itz1LX0v310i3cllytFC0Ms=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# CVE-2025-32023\n\nCVE-2025-32023 的 PoC 及 Exploit（[GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)）/ PlaidCTF 2025 \"Zerodeo\"\n\n\n### 重現 / 修補\n\n已在 `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952` 上測試。\n\n影響 Redis 版本 >= 2.8。已於 8.0.3、7.4.5、7.2.10、6.2.19 修補，詳見 [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445)。\n\n\n### 漏洞說明\n\nRedis 中的 HyperLogLog 其實就是一個帶有自定義編碼的字符串。對稀疏型 HLL 編碼進行迭代時，需要累加每個稀疏表示的運行長度，若針對格式錯誤的 HLL 操作時，這個總長度在 `int i` 中可能溢位為負值。這讓攻擊者能覆寫 HLL 結構的負偏移，導致對堆疊或堆外的越界寫入，具體取決於 HLL 結構的來源（例如 `hllMerge()` 使用堆疊分配，而 `hllSparseToDense()` 則使用堆分配）。\n\n請見以下修補程式片段：\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "Status": "ok"
  },
  {
    "Id": 2,
    "Content": "\n### Exploit\n\nExploit is standard Redis pwnables:\n1. Corrupt an sds object on the jemalloc heap to make its length large\n2. Spray embstr objects to corrupt into a fake module object\n3. Dump the heap using the corrupted sds object to find target embstr object & leak addresses\n4. Create a fake module object on the target embstr object\n5. Delete the fake module object, triggering destructor & gaining RCE\n\n",
    "ContentSha": "kFCAerupXpXp4PuGom2wnNcH0WwawRLInRHPOAypmfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 利用方式\n\n利用方式是標準的 Redis pwnables：\n1. 損壞 jemalloc 堆上的 sds 物件，使其長度變大\n2. 噴灑 embstr 物件，以便破壞成為偽造的 module 物件\n3. 使用損壞的 sds 物件傾印堆，找到目標 embstr 物件並洩漏位址\n4. 在目標 embstr 物件上建立偽造的 module 物件\n5. 刪除偽造的 module 物件，觸發解構子並取得遠端程式碼執行（RCE）",
    "Status": "ok"
  }
]