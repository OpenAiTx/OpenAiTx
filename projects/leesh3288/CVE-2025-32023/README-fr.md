# CVE-2025-32023

PoC & Exploit pour CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### Reproduction / Correctif

Testé sur `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

Affecte les versions de Redis >= 2.8. Corrigé sur 8.0.3, 7.4.5, 7.2.10, 6.2.19, voir [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### Bug

HyperLogLog dans Redis est simplement une autre chaîne avec ses propres encodages personnalisés. Parcourir un encodage HLL sparse nécessite d’additionner les longueurs de chaque représentation sparse, ce qui peut faire déborder la longueur totale comptée dans `int i` vers une valeur négative lorsqu’on opère sur un HLL mal formé. Cela permet à un attaquant d’écrire à des offsets négatifs dans la structure HLL, ce qui conduit à une écriture hors limites sur la pile/le tas selon la provenance de la structure HLL (par exemple, `hllMerge()` utilise une structure allouée sur la pile, `hllSparseToDense()` utilise une structure allouée sur le tas).

Voir l’extrait du correctif ci-dessous :

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Dépassement. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Dépassement. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Dépassement. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Dépassement. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Exploit

L’exploitation suit les méthodes classiques des pwnables Redis :
1. Corrompre un objet sds sur le tas jemalloc pour augmenter sa longueur
2. Pulvériser des objets embstr pour corrompre en un faux objet module
3. Déverser le tas à l’aide de l’objet sds corrompu pour trouver l’objet embstr cible et divulguer des adresses
4. Créer un faux objet module sur l’objet embstr cible
5. Supprimer le faux objet module, déclenchant le destructeur et obtenant une exécution de code à distance (RCE)


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---