# CVE-2025-32023

PoC & Exploit สำหรับ CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### การทำซ้ำ / แพตช์

ทดสอบกับ `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

ส่งผลกระทบกับ Redis เวอร์ชัน >= 2.8 แพตช์แล้วใน 8.0.3, 7.4.5, 7.2.10, 6.2.19 ดูที่ [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445)


### บั๊ก

HyperLogLog ใน Redis เป็นเพียงสตริงอีกชนิดหนึ่งที่มีการเข้ารหัสแบบกำหนดเอง การวนซ้ำในรหัสแบบ sparse HLL ต้องมีการบวกความยาวของแต่ละ run จากการแทนค่าของ sparse ซึ่งอาจเกิดการ overflow ของค่าความยาวรวมที่นับไว้ใน `int i` ไปเป็นค่าติดลบเมื่อทำงานกับ HLL ที่ถูกทำให้ผิดรูปแบบ สิ่งนี้ทำให้ผู้โจมตีสามารถเขียนทับที่ offset ติดลบบนโครงสร้าง HLL นำไปสู่การเขียนข้อมูลออกนอกขอบเขตบน stack/heap ขึ้นอยู่กับว่าโครงสร้าง HLL มาจากไหน (เช่น `hllMerge()` ใช้ stack-allocated, `hllSparseToDense()` ใช้ heap-allocated)

ดูตัวอย่างแพตช์ด้านล่าง:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Exploit

Exploit เป็นมาตรฐานของ Redis pwnables:
1. ทำลายวัตถุ sds บน heap ของ jemalloc เพื่อให้มีความยาวมากผิดปกติ
2. สร้าง embstr objects จำนวนมากเพื่อให้สามารถทำลายและเปลี่ยนเป็นวัตถุ module ปลอม
3. ดึงข้อมูล heap โดยใช้วัตถุ sds ที่ถูกทำลายเพื่อตามหา embstr object เป้าหมายและหาค่า address ที่รั่วไหล
4. สร้างวัตถุ module ปลอมบน embstr object เป้าหมาย
5. ลบวัตถุ module ปลอมเพื่อเรียกใช้ destructor และได้รับสิทธิ์ RCE

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---