# CVE-2025-32023

PoC & Exploit cho CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 "Zerodeo"


### Tái hiện / Bản vá

Đã kiểm tra với `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

Ảnh hưởng các phiên bản Redis >= 2.8. Đã được vá trên 8.0.3, 7.4.5, 7.2.10, 6.2.19, xem [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).


### Lỗi

HyperLogLog trong Redis chỉ là một chuỗi khác với các kiểu mã hóa riêng. Việc lặp qua một mã hóa HLL dạng sparse yêu cầu cộng dồn chiều dài các run của mỗi đại diện sparse, điều này có thể làm tràn số tổng chiều dài được đếm trong `int i` sang giá trị âm khi thao tác với HLL bị lỗi định dạng. Điều này cho phép kẻ tấn công ghi đè vào các offset âm trên cấu trúc HLL, dẫn đến ghi ngoài phạm vi trên stack/heap tùy thuộc vào nguồn gốc của cấu trúc HLL (ví dụ `hllMerge()` sử dụng biến cục bộ trên stack, `hllSparseToDense()` sử dụng biến trên heap).

Xem đoạn mã vá dưới đây:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Khai thác

Khai thác là các kỹ thuật tiêu chuẩn trong Redis pwnables:
1. Làm hỏng một đối tượng sds trên heap jemalloc để làm cho độ dài của nó lớn
2. Phun các đối tượng embstr để làm hỏng thành một đối tượng module giả
3. Đổ bộ nhớ heap bằng đối tượng sds đã bị hỏng để tìm đối tượng embstr mục tiêu và rò rỉ địa chỉ
4. Tạo một đối tượng module giả trên đối tượng embstr mục tiêu
5. Xóa đối tượng module giả, kích hoạt hàm hủy và chiếm quyền thực thi mã (RCE)

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---