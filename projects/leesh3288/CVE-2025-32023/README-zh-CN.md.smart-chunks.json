[
  {
    "Id": 1,
    "Content": "# CVE-2025-32023\n\nPoC & Exploit for CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) / PlaidCTF 2025 \"Zerodeo\"\n\n\n### Repro / Patch\n\nTested against `redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\nAffects Redis versions >= 2.8. Patched on 8.0.3, 7.4.5, 7.2.10, 6.2.19, see [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445).\n\n\n### Bug\n\nHyperLogLog in Redis is just another string with its own custom encodings. Iterating over a sparse HLL encoding requires adding up run lengths of each sparse representation, which may overflow the total length counted in `int i` into a negative value when operated on a malformed HLL. This allows an attacker to overwrite to negative offsets on the HLL structure, leading to out-of-bounds write on the stack/heap depending on where the HLL structure is from (e.g. `hllMerge()` takes a stack-allocated one, `hllSparseToDense()` takes a heap-allocated one).\n\nSee the patch snippet below:\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "ContentSha": "0meY7ebduqK2cUlP2eo5itz1LX0v310i3cllytFC0Ms=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# CVE-2025-32023\n\nCVE-2025-32023 的 PoC 与利用代码（[GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)）/ PlaidCTF 2025 “Zerodeo”\n\n### 复现 / 补丁\n\n测试环境：`redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`\n\n受影响 Redis 版本：>= 2.8。已在 8.0.3、7.4.5、7.2.10、6.2.19 修复，详见 [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445)。\n\n### 漏洞说明\n\nRedis 中的 HyperLogLog 其实就是一种拥有自定义编码方式的字符串。遍历稀疏 HLL 编码时，需要累加每个稀疏表示的运行长度（run length），如果操作畸形的 HLL 时该长度在 `int i` 中溢出为负值。攻击者可以利用这一点覆盖 HLL 结构的负偏移，从而在栈或堆上实现越界写（取决于 HLL 结构的分配方式，比如 `hllMerge()` 使用栈分配，`hllSparseToDense()` 使用堆分配）。\n\n请参见以下补丁代码片段：\n\n```diff\n int hllMerge(uint8_t *max, robj *hll) {\n     struct hllhdr *hdr = hll->ptr;\n     int i;\n\n     if (hdr->encoding == HLL_DENSE) {\n         hllMergeDense(max, hdr->registers);\n      } else {\n         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);\n         long runlen, regval;\n+        int valid = 1;\n \n         p += HLL_HDR_SIZE;\n         i = 0;\n         while(p < end) {\n             if (HLL_SPARSE_IS_ZERO(p)) {\n                 runlen = HLL_SPARSE_ZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p++;\n             } else if (HLL_SPARSE_IS_XZERO(p)) {\n                 runlen = HLL_SPARSE_XZERO_LEN(p);\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 i += runlen;\n                 p += 2;\n             } else {\n                 runlen = HLL_SPARSE_VAL_LEN(p);\n                 regval = HLL_SPARSE_VAL_VALUE(p);\n-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */\n+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */\n+                    valid = 0;\n+                    break;\n+                }\n                 while(runlen--) {\n                     if (regval > max[i]) max[i] = regval;\n                     i++;\n                }\n                 p++;\n             }\n         }\n-        if (i != HLL_REGISTERS) return C_ERR;\n+        if (!valid || i != HLL_REGISTERS) return C_ERR;\n     }\n     return C_OK;\n }\n```",
    "Status": "ok"
  },
  {
    "Id": 2,
    "Content": "\n### Exploit\n\nExploit is standard Redis pwnables:\n1. Corrupt an sds object on the jemalloc heap to make its length large\n2. Spray embstr objects to corrupt into a fake module object\n3. Dump the heap using the corrupted sds object to find target embstr object & leak addresses\n4. Create a fake module object on the target embstr object\n5. Delete the fake module object, triggering destructor & gaining RCE\n\n",
    "ContentSha": "kFCAerupXpXp4PuGom2wnNcH0WwawRLInRHPOAypmfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 利用方式\n\n利用方式是标准的 Redis pwnables：\n1. 破坏 jemalloc 堆上的一个 sds 对象，使其长度变大\n2. 喷射 embstr 对象，以便破坏成一个伪造的 module 对象\n3. 使用被破坏的 sds 对象转储堆，以找到目标 embstr 对象并泄露地址\n4. 在目标 embstr 对象上创建一个伪造的 module 对象\n5. 删除伪造的 module 对象，触发析构函数并获得 RCE（远程代码执行）",
    "Status": "ok"
  }
]