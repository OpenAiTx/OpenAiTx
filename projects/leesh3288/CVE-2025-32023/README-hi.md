# CVE-2025-32023

CVE-2025-32023 ([GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)) के लिए PoC और Exploit / PlaidCTF 2025 "Zerodeo"

### पुनरुत्पादन / पैच

`redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952` पर परीक्षण किया गया

Redis के संस्करण >= 2.8 प्रभावित होते हैं। 8.0.3, 7.4.5, 7.2.10, 6.2.19 पर पैच किया गया, देखें [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445)।

### बग

Redis में HyperLogLog एक और स्ट्रिंग है जिसमें अपनी कस्टम एनकोडिंग्स होती हैं। एक sparse HLL एनकोडिंग पर इटरेट करने के लिए प्रत्येक sparse प्रतिनिधित्व की रन लेंथ जोड़नी होती है, जो यदि किसी विकृत HLL पर ऑपरेट की जाए तो `int i` में गिनी गई कुल लंबाई को overflow कर सकती है और नेगेटिव वैल्यू में बदल सकती है। इससे हमलावर को HLL संरचना में नेगेटिव ऑफसेट्स पर ओवरराइट करने की अनुमति मिलती है, जिससे स्टैक/हीप पर आउट-ऑफ-बाउंड्स राइट हो सकता है, यह इस पर निर्भर करता है कि HLL संरचना कहाँ से ली गई है (जैसे `hllMerge()` एक स्टैक-एलोकेटेड लेता है, `hllSparseToDense()` एक हीप-एलोकेटेड लेता है)।

नीचे पैच स्निपेट देखें:

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### Exploit

Exploit मानक Redis pwnables है:
1. jemalloc heap पर एक sds ऑब्जेक्ट को भ्रष्ट करें ताकि उसकी लंबाई बड़ी हो जाए
2. embstr ऑब्जेक्ट्स को स्प्रे करें ताकि वे एक नकली module ऑब्जेक्ट में भ्रष्ट हो जाएं
3. भ्रष्ट sds ऑब्जेक्ट का उपयोग करके heap को डंप करें ताकि लक्षित embstr ऑब्जेक्ट पाया जा सके और पते लीक किए जा सकें
4. लक्षित embstr ऑब्जेक्ट पर एक नकली module ऑब्जेक्ट बनाएं
5. नकली module ऑब्जेक्ट को हटाएं, जिससे destructor ट्रिगर हो और RCE प्राप्त हो

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---