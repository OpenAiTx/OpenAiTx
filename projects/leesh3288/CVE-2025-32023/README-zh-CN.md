# CVE-2025-32023

CVE-2025-32023 的 PoC 与利用代码（[GHSA-rp2m-q4j6-gr43](https://github.com/redis/redis/security/advisories/GHSA-rp2m-q4j6-gr43)）/ PlaidCTF 2025 “Zerodeo”

### 复现 / 补丁

测试环境：`redis:7.4.2-alpine3.21@sha256:02419de7eddf55aa5bcf49efb74e88fa8d931b4d77c07eff8a6b2144472b6952`

受影响 Redis 版本：>= 2.8。已在 8.0.3、7.4.5、7.2.10、6.2.19 修复，详见 [redis/redis@5018874](https://github.com/redis/redis/commit/50188747cbfe43528d2719399a2a3c9599169445)。

### 漏洞说明

Redis 中的 HyperLogLog 其实就是一种拥有自定义编码方式的字符串。遍历稀疏 HLL 编码时，需要累加每个稀疏表示的运行长度（run length），如果操作畸形的 HLL 时该长度在 `int i` 中溢出为负值。攻击者可以利用这一点覆盖 HLL 结构的负偏移，从而在栈或堆上实现越界写（取决于 HLL 结构的分配方式，比如 `hllMerge()` 使用栈分配，`hllSparseToDense()` 使用堆分配）。

请参见以下补丁代码片段：

```diff
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;

     if (hdr->encoding == HLL_DENSE) {
         hllMergeDense(max, hdr->registers);
      } else {
         uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
         long runlen, regval;
+        int valid = 1;
 
         p += HLL_HDR_SIZE;
         i = 0;
         while(p < end) {
             if (HLL_SPARSE_IS_ZERO(p)) {
                 runlen = HLL_SPARSE_ZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p++;
             } else if (HLL_SPARSE_IS_XZERO(p)) {
                 runlen = HLL_SPARSE_XZERO_LEN(p);
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 i += runlen;
                 p += 2;
             } else {
                 runlen = HLL_SPARSE_VAL_LEN(p);
                 regval = HLL_SPARSE_VAL_VALUE(p);
-                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
+                if ((runlen + i) > HLL_REGISTERS) { /* Overflow. */
+                    valid = 0;
+                    break;
+                }
                 while(runlen--) {
                     if (regval > max[i]) max[i] = regval;
                     i++;
                }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return C_ERR;
+        if (!valid || i != HLL_REGISTERS) return C_ERR;
     }
     return C_OK;
 }
```
### 利用方式

利用方式是标准的 Redis pwnables：
1. 破坏 jemalloc 堆上的一个 sds 对象，使其长度变大
2. 喷射 embstr 对象，以便破坏成一个伪造的 module 对象
3. 使用被破坏的 sds 对象转储堆，以找到目标 embstr 对象并泄露地址
4. 在目标 embstr 对象上创建一个伪造的 module 对象
5. 删除伪造的 module 对象，触发析构函数并获得 RCE（远程代码执行）

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-09

---