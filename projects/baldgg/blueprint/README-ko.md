<translate-content>게임을 만드는 방법을 배우고 싶다면, [여기](https://learn.randy.gg/?src=template-starter)를 방문하세요.

이와 같은 무료 블루프린트를 가끔씩 이메일로 받아보고 싶다면, [내 메일링 리스트](https://path.randy.gg)를 확인해보세요.

---

이것은 사실상 내가 엔진 없이 게임 개발에 사용하는 전체 툴셋입니다.

여기 있는 개념들을 사용해 만든 게임들:
- https://store.steampowered.com/app/2571560/ARCANA/
- https://store.steampowered.com/app/3309460/Demon_Knives/
- https://store.steampowered.com/app/3433610/Terrafactor/

지난 5년간 엔진 없이 게임을 프로그래밍하는 방법을 배우며 이 아이디어들을 계속 발전시켜 왔습니다.

여러 가지 완성 단계에 있으며, 해야 할 일들이 많고, 성능 병목도 존재합니다. 하지만 현재로서는 지금까지 구현해 본 것 중 가장 프로덕션에 가까운 상태입니다.

게임을 계속 만들고 새로운 것을 배우면서 이 프로젝트를 업데이트할 예정입니다.

# 기능
- `asset_workbench/aseprite_asset_export.lua`를 통해 Aseprite로 매우 빠른 픽셀 아트 자산 제작 및 반복 작업 파이프라인
- 필요한 VFX에 맞게 완전히 개조할 수 있는 렌더링 시스템과 셰이더
- 확장성이 좋은 단일 함수 기반 엔티티 게임플레이 프로그래밍 워크플로우
- FMOD를 활용한 완전한 사운드 디자인 기능과 실제 사운드 재생 훅을 매우 쉽게 프로그래밍할 수 있게 하는 래퍼
- 쉽게 직렬화할 수 있는 매우 견고한 Game_State 및 엔티티 구조

## 언젠가 올 기능™️
이 기능들의 ETA는 전혀 모릅니다. 필요할 때가 되면 만들게 될 겁니다.
- 컨트롤러 지원
- 콘솔 지원을 위한 맞춤 백엔드 (스위치, 엑스박스, PS5)
- 3D 렌더링 패키지 및 파이프라인

# 구조

`/sauce/bald` 패키지 개요
- `/draw` Sokol을 통한 크로스 플랫폼 고성능 2D 스프라이트 렌더링
- `/sound` FMOD를 활용한 간편한 사운드 재생 및 디자인 시스템
- `/input` 간단한 입력 추상화
- `/utils/shape` 충돌을 위한 간단한 도형 추상화

^ 일반적으로 이 패키지들은 쉽게 업그레이드하고 프로젝트 간에 공유할 수 있도록 만들어졌습니다.

## `main.odin`  
이 파일은 진입점이며 메인 루프의 구조를 담고 있습니다.

기본적으로 가변 타임스텝을 사용합니다. 대부분의 상황에서 복잡성을 최소화하면서 잘 작동합니다. 하지만 게임의 제약에 맞게 변경할 수 있습니다. 예를 들어 멀티플레이어라거나 고정 타임스텝이 필요할 수도 있겠죠.

## `game.odin`
대부분의 마법이 일어나는 곳입니다. 모든 기술이 만나는 지점. "그냥 게임을 만드는" 장소입니다.

이 파일에 게임에 새 콘텐츠를 추가하는 데 90%의 시간을 보냅니다. 금세 꽤 커집니다. 게임플레이 코드를 작성하기에 매우 아늑한 공간입니다.

## `entity.odin`
엔티티 메가스트럭처의 중추입니다. [여기](https://randyprime.beehiiv.com/p/entity-structure-made-simple)에서 이야기한 바 있습니다.

## `bald_helpers.odin`
`/bald` 패키지와 게임 특화된 모든 것들이 만나는 지점입니다.


# 빌드

일반적으로 윈도우에서 개발하는 것이 훨씬 쉽습니다. 더 많은 도구가 있고, [~96%](https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam)의 스팀 고객들이 사용하기 때문입니다. 같은 OS를 일상적으로 사용하면서 플랫폼별 문제를 해결할 수 있어 버그가 적습니다. 만약 게임 개발을 전업으로 하고 스팀을 목표로 한다면, 윈도우 환경을 갖추는 것을 강력히 추천합니다.

리눅스나 맥을 선호하는 사람들도 이해합니다. Sokol이 좋아서 네이티브로 작동시키는 것도 비교적 간단하며, 두 플랫폼에 대한 지원도 추가하기 시작했습니다.

## 윈도우
1. [Odin 설치](https://odin-lang.org/docs/install/)
2. `build.bat` 실행
3. `build/windows_debug` 확인
4. 실행 관련 지침은 아래 참조

## 맥
1. [Odin 설치](https://odin-lang.org/docs/install/)
2. `build_mac.sh` 실행
3. `build/mac_debug` 확인
4. 실행 관련 지침은 아래 참조

## 리눅스
준비 중

## 웹
곧 제공 예정™️

# 실행
/`res` 경로에 접근해야 하므로 루트 디렉토리에서 실행해야 합니다.

훌륭한 실행 및 디버깅 경험을 위해 [RAD Debugger](https://github.com/EpicGamesExt/raddebugger) (윈도우 전용) 설정을 추천합니다. 저는 항상 여기서 직접 게임을 실행해서 실시간으로 버그를 잡기 편합니다.

# FAQ
## 이걸로 게임을 만드는 방법은?
이것을 사용하는 방법을 가르치는 데 집중하고 있으며, [내 유료 프로그램](https://learn.randy.gg/?src=template-starter)에서 자세히 다룹니다.

예산이 부족하다면, 무료 대안은 다음과 같습니다:
- 이걸 사용하며 개발하는 [라이브 스트림](https://www.youtube.com/@randyprime2)을 합니다.
- [내 유튜브 채널](https://www.youtube.com/@randyprime)에서 교육 콘텐츠를 만듭니다.

## 왜 이걸 "블루프린트"(라이브러리 아님)라고 하나요?
게임 개발은 복잡합니다.

모든 것을 라이브러리 뒤에 추상화하려는 시도는 실수라고 생각합니다. 그것은 깔끔해 보이고 느껴지게 만들지만, 기능성을 희생시켜 할 수 있는 일을 제한하고, 문제를 해결하기 위해 가장 간단하고 직접적인 방식을 쓰지 못하게 하며, 대신 엉성한 우회 방법을 사용하도록 강요합니다.</translate-content>
old way:
1. 라이브러리 사용
2. 사용 중에 벽에 부딪힘
3. 해킹식으로 우회하거나 아이디어를 포기함

new way:
1. 이 청사진 사용
2. 사용 중에 벽에 부딪힘
3. 그것이 하는 근본적인 것을 배우고, 소스를 조정하여 그 위에 구축함
4. (선택 사항) 이슈를 열어 청사진에 통합할 수 있도록 고려하게 함

> 가장 흔한 예는 렌더링과 관련하여 하고 싶은 일이 있을 때입니다. 그래서 [이것](https://learnopengl.com/)을 통해 그래픽 프로그래밍을 배우고, `/draw`의 자신의 버전을 다시 작성하거나 필요한 작업을 수행하도록 조정합니다. (렌더 텍스처, 버텍스 데이터 조정, 다단계 드로우 패스 및 후처리 등)

핵심 계층 `/bald`를 게임 특정 요소와 분리하려 최선을 다했지만, 많은 곳에서 불가피한 아이디어 얽힘이 있다고 생각합니다.

이것을 계속 단순화하고 완전한 제작 준비 기능을 희생하지 않으면서 가능한 한 읽기 쉽고 사용하기 쉽게 만들려고 합니다.

## 왜 Odin인가?
C와 비교했을 때 훨씬 더 재미있게 작업할 수 있습니다. 전체 타이핑이 적고 기본적으로 더 안전하며, 삶의 질이 뛰어납니다. 행복한 프로그래밍 = 더 많은 게임 플레이.

Jai와 비교하면 사용자 수가 더 많고 공개되어 있습니다 (Jai는 아직 비공개 베타입니다). 즉, 더 많은 사람이 사용하기 때문에 패키지, 도구 등 주변 생태계가 더 안정적이고 좋습니다.

## 왜 Sokol인가?
높고 낮은 수준에서 적절한 균형점처럼 느껴집니다.

Raylib 같은 높은 수준보다는 덜 고수준이라서 더 많은 유연성을 제공합니다. 하지만 사용하려면 그래픽 프로그래밍을 배워야 합니다. 초보자에게는 다소 어렵습니다. 그래서 이 청사진을 만들었습니다. 세밀한 부분을 선택적으로 사용하면서 최종 게임 플레이 프로그래밍 워크플로우를 변경하지 않는 올인원 제작 준비 스위트 같은 것입니다.

그러나 win32 코드와 직접적인 directx11 코드를 수동으로 작성해 화면에 삼각형을 그리는 것만큼 낮은 수준은 아닙니다.



---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-18

---