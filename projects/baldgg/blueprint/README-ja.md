
ゲームの作り方を学びたい場合は、[こちらへ](https://learn.randy.gg/?src=template-starter)

このようなブループリントを時々無料で受け取りたい場合は、[私のメーリングリスト](https://path.randy.gg)をチェックしてください

---

これは私がノーエンジンでゲーム開発に使っているほぼ全てのツールセットです。

ここにあるコンセプトを使って以下のゲームを作りました：
- https://store.steampowered.com/app/2571560/ARCANA/
- https://store.steampowered.com/app/3309460/Demon_Knives/
- https://store.steampowered.com/app/3433610/Terrafactor/

私はエンジンなしでゲームをプログラムする方法を学ぶ中で、これらのアイデアを5年間繰り返し改良してきました。

物事はさまざまな完成段階にあり、多くのTODOが散らばり、愚かなパフォーマンスボトルネックなどもあります。しかし現状では、これまでに私が実現できた中で最もプロダクションレベルに近い状態です。

ゲーム制作と新しいことを学び続ける中でこれを更新していきます。

# 機能
- `asset_workbench/aseprite_asset_export.lua`を使った非常に高速なピクセルアート資産作成＆反復パイプライン
- 必要なVFXに合わせて完全にオーバーホール可能なレンダリングシステム付きシェーダー
- スケールしやすい単一関数エンティティゲームプレイプログラミングワークフロー
- FMODを使った完全機能のサウンドデザインと、実際のサウンド再生フックを非常に簡単にプログラムできるラッパー
- 簡単にシリアライズ可能な非常に堅牢なGame_StateとEntity構造

## いつか来る™️
これらのETAは不明です。実際に必要になった時に実装します。
- コントローラーサポート
- コンソールサポート用カスタムバックエンド（スイッチ、Xbox、PS5）
- 3Dレンダリングパッケージ＆パイプライン

# 構成

`/sauce/bald`内パッケージの概要
- `/draw` Sokolによるクロスプラットフォーム高性能2Dスプライトレンダリング
- `/sound` FMODによる簡単なサウンド再生＆デザインシステム
- `/input` シンプルな入力抽象化
- `/utils/shape` 衝突判定用のシンプルな形状抽象化

^ 一般的に、これらのパッケージはプロジェクト間で簡単にアップグレード・共有できるように作られています。

## `main.odin`  
エントリーポイントでありメインループの構造です。

デフォルトでは可変タイムステップを使用しています。ほとんどの状況で複雑さを最小限に抑えつつうまく機能します。ただしゲームの制約に合わせて変更可能です。例えばマルチプレイヤーや固定タイムステップが必要な場合など。

## `game.odin`
ここが魔法の大部分が起こる場所です。すべての技術が交差する場所で、「ただゲームを作る」場所です。

ここに90％の時間を費やして新しいコンテンツをゲームに追加しています。すぐにかなり大きくなります。ゲームプレイの試行錯誤を書くのに非常に居心地の良い場所です。

## `entity.odin`
エンティティメガストラクチャのバックボーンです。[こちら](https://randyprime.beehiiv.com/p/entity-structure-made-simple)で説明しています。

## `bald_helpers.odin`
`/bald`パッケージとゲーム固有のすべてのものの交差点です。

# ビルド

一般的に、Windowsの方がツールが多く、Steamユーザーの[約96%](https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam)が使用しているため、開発がずっと楽で多くの人にとってバグが少なくなります。もし本格的にゲーム開発をしてSteamをターゲットにするなら、何らかのWindows環境のセットアップを強くお勧めします。

LinuxやMacを好む人もいると思いますが、Sokolが優れているのでネイティブで動作させるのは比較的簡単です。現在両方のサポートを追加し始めています。

## Windows
1. [Odinをインストール](https://odin-lang.org/docs/install/)
2. `build.bat`を実行
3. `build/windows_debug`を確認
4. 実行方法は下記参照

## Mac
1. [Odinをインストール](https://odin-lang.org/docs/install/)
2. `build_mac.sh`を実行
3. `build/mac_debug`を確認
4. 実行方法は下記参照

## Linux
未対応

## Web
近日公開予定™️

# 実行
/resにアクセスするためルートディレクトリから実行する必要があります。

優れた実行＆デバッグ体験のために、[RAD Debugger](https://github.com/EpicGamesExt/raddebugger)（Windows限定）のセットアップをお勧めします。私は常にそこから直接ゲームを起動して、バグを即座に捕まえやすくしています。

# FAQ
## これを使ってゲームを作るには？
私は[有料プログラム](https://learn.randy.gg/?src=template-starter)を通して使い方の指導に注力しています。

予算が限られている場合、以下の無料代替手段があります：
- これを使った開発の[ライブ配信](https://www.youtube.com/@randyprime2)
- [YouTubeチャンネル](https://www.youtube.com/@randyprime)での教育コンテンツ作成

## なぜこれが「ブループリント」なのか（ライブラリではないのか）？
ゲーム開発は複雑です。

すべてをライブラリの背後に抽象化しようとするのは間違いだと思います。そうすると表面的には「クリーン」に見えますが、能力が犠牲になり、できることが制限されてしまいます。問題を解決するために最も単純で直接的な方法を取る代わりに、ハッキーな回避策を使わざるを得なくなるのです。


old way:
1. ライブラリを使う
2. 使う中で壁にぶつかる
3. ハック的な方法で回避するか、アイデアを諦める

new way:
1. このブループリントを使う
2. 使う中で壁にぶつかる
3. その根本的な動作を学び、それを基に構築し、ソースを調整する
4. （任意）Issueを開いてもらえれば、ブループリントに統合することを検討できる

> 最も一般的な例は、レンダリングでやりたいことがある場合です。なので、[こちら](https://learnopengl.com/)を使ってグラフィックスプログラミングを学び、自分なりの`/draw`を再実装したり、必要な処理を実装するために調整したりします。（レンダーテクスチャ、頂点データの調整、マルチステージの描画パスやポストプロセッシングなど）

コアレイヤーの`/bald`をゲーム固有の部分から分離するよう最善を尽くしましたが、多くの箇所で避けられないアイデアの絡まりがあると考えています。

今後もこれを簡素化し、読みやすく使いやすくしつつ、生産現場で使えるパワーを犠牲にしないよう努力を続けます。

## なぜOdin？
Cと比べて、はるかに楽しく作業できます。タイピング量が少なく、デフォルトで安全性が高く、生活の質が向上します。楽しいプログラミング＝より多くのゲームプレイ。

Jaiと比べて、ユーザー数が多く公開されている（Jaiはまだクローズドベータ）。つまり、安定性が高く、パッケージやツールのエコシステムも充実しています。（多くの人が使っているため）

## なぜSokol？
高レベルと低レベルのちょうど良いバランスのように感じます。

Raylibのような高レベルではないので、より自由にできることが多いです。しかし使うにはグラフィックスプログラミングを学ぶ必要があります。初心者にはそれが厳しいです。だからこのブループリントを作りました。細かい部分にオプトインしつつ、最終的なゲームプレイプログラミングのワークフローを変えずに使えるオールインワンの生産準備済みスイートのようなものです。

ただ、win32コードや生のDirectX11を手動で書いて画面に三角形を描画するような低レベルではありません。



---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-18

---