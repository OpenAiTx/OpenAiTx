{
  "id": 1,
  "origin": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- ✅ Call stack spoofing via `Synthetic` and `Desync`.\n- ✅ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- ✅ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ✅ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` 是一個用於 Windows 呼叫堆疊偽造的 Rust 函式庫，可讓你以偽造的呼叫堆疊執行任意函數，以規避在堆疊展開過程中的分析、日誌記錄或偵測。\n\n靈感來自 [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk)，此 crate 將底層偽造能力帶入乾淨、慣用的 Rust 介面，並完全支援 `#[no_std]`、`MSVC` 與 `GNU` 工具鏈，以及自動化 gadget 解析。\n\n## 功能特色\n\n- ✅ 透過 `Synthetic` 及 `Desync` 進行呼叫堆疊偽造。\n- ✅ 相容於 `MSVC` 及 `GNU` 工具鏈（**x64**）。\n- ✅ 內嵌巨集：`spoof!`、`spoof_synthetic!`、`syscall!`、`syscall_synthetic!`。\n- ✅ 支援 `#[no_std]` 環境（需搭配 `alloc`）。\n\n## 快速開始\n\n將 `uwd` 加入你的專案，更新你的 `Cargo.toml`：\n```bash\ncargo add uwd\n```\n\n## 用法\n\n`uwd` 允許你在 Rust 中偽造呼叫堆疊，無論是呼叫標準 Windows API 還是進行間接系統呼叫。該函式庫會自動處理偽造堆疊幀、gadget 鏈，以及暫存器的準備，使執行看起來像是來自合法來源。\n\n你可以偽造：\n\n* 一般函數（如 `VirtualAlloc`、`WinExec` 等）\n* 具自動 SSN 及 stub 解析的原生系統呼叫（如 `NtAllocateVirtualMemory`）\n\n巨集 `spoof!` / `spoof_synthetic!` 及 `syscall!` / `syscall_synthetic!` 將所有複雜性抽象化。\n\n### 偽造 WinExec\n\n此範例展示如何利用偽造堆疊呼叫來啟動 `calc.exe`。我們用 Desync 技術呼叫一次 `WinExec`，再用 Synthetic 技術呼叫一次。\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // 解析要使用的 WinAPI 函數位址\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // 使用 `WinExec` 執行命令\n    // 呼叫堆疊偽造（Desync）\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec 執行失敗\");\n        return Ok(());\n    }\n\n    // 呼叫堆疊偽造（Synthetic）\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec 執行失敗 [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### 偽造間接系統呼叫\n\n此範例利用偽造堆疊對 `NtAllocateVirtualMemory` 進行間接系統呼叫。\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // 使用呼叫堆疊偽造（Desync）執行間接系統呼叫\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory 執行失敗，狀態碼: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] 已配置位址: {:?}\", addr);\n\n    // 使用呼叫堆疊偽造（Synthetic）執行間接系統呼叫\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory 執行失敗 [2]，狀態碼: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}