{
  "id": 1,
  "origin": "# uwd ü¶Ä\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- ‚úÖ Call stack spoofing via `Synthetic` and `Desync`.\n- ‚úÖ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- ‚úÖ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ‚úÖ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd ü¶Ä\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` to biblioteka Rust do spoofowania stosu wywo≈Ça≈Ñ na Windows, umo≈ºliwiajƒÖca wykonywanie dowolnych funkcji z podrobionym stosem wywo≈Ça≈Ñ, kt√≥ry omija analizƒô, logowanie lub wykrywanie podczas odwijania stosu.\n\nZainspirowany przez [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), ten crate wprowadza niskopoziomowe mo≈ºliwo≈õci spoofowania w czysty, idiomatyczny interfejs Rust z pe≈Çnym wsparciem dla `#[no_std]`, toolchain√≥w `MSVC` i `GNU` oraz automatycznym rozwiƒÖzywaniem gadget√≥w.\n\n## Funkcje\n\n- ‚úÖ Spoofowanie stosu wywo≈Ça≈Ñ poprzez `Synthetic` i `Desync`.\n- ‚úÖ Kompatybilno≈õƒá zar√≥wno z toolchainami `MSVC`, jak i `GNU` (**x64**).\n- ‚úÖ Makra inline: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ‚úÖ Wsparcie dla ≈õrodowisk `#[no_std]` (z `alloc`).\n\n## Pierwsze kroki\n\nDodaj `uwd` do swojego projektu, aktualizujƒÖc plik `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## U≈ºytkowanie\n\n`uwd` pozwala na spoofowanie stosu wywo≈Ça≈Ñ w Rust podczas wywo≈Çywania zar√≥wno standardowych API Windows, jak i po≈õrednich syskali. Biblioteka obs≈Çuguje pe≈Çne przygotowanie fa≈Çszywych ramek, ≈Ça≈Ñcuch√≥w gadget√≥w oraz rejestr√≥w, aby wykonanie wyglƒÖda≈Ço na pochodzƒÖce z legalnego ≈∫r√≥d≈Ça.\n\nMo≈ºesz spoofowaƒá:\n\n* Normalne funkcje (takie jak `VirtualAlloc`, `WinExec`, itd.)\n* Natychmiastowe syskale z automatycznym rozwiƒÖzywaniem SSN i stub√≥w (takie jak `NtAllocateVirtualMemory`)\n\nMakra `spoof!` / `spoof_synthetic!` oraz `syscall!` / `syscall_synthetic!` upraszczajƒÖ ca≈ÇƒÖ z≈Ço≈ºono≈õƒá.\n\n### Spoofowanie WinExec\n\nTen przyk≈Çad pokazuje, jak uruchomiƒá `calc.exe` u≈ºywajƒÖc podrobionego stosu wywo≈Ça≈Ñ. Wywo≈Çujemy `WinExec` dwa razy: raz przy u≈ºyciu techniki Desync, a nastƒôpnie przy u≈ºyciu techniki Synthetic.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // RozwiƒÖzuje adresy funkcji WinAPI do u≈ºycia\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Wykonanie polecenia przy u≈ºyciu `WinExec`\n    // Spoofowanie stosu wywo≈Ça≈Ñ (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec nie powiod≈Ço siƒô\");\n        return Ok(());\n    }\n\n    // Spoofowanie stosu wywo≈Ça≈Ñ (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec nie powiod≈Ço siƒô [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofowanie po≈õredniego syscala\n\nTen przyk≈Çad wykonuje po≈õrednie wywo≈Çanie systemowe do `NtAllocateVirtualMemory` z podrobionym stosem wywo≈Ça≈Ñ.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Wykonanie po≈õredniego syscala ze spoofowaniem stosu wywo≈Ça≈Ñ (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory nie powiod≈Ço siƒô ze statusem: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Przydzielony adres: {:?}\", addr);\n\n    // Wykonanie po≈õredniego syscala ze spoofowaniem stosu wywo≈Ça≈Ñ (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory nie powiod≈Ço siƒô ze statusem [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}