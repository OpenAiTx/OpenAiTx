{
  "id": 1,
  "origin": "# uwd ü¶Ä\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- ‚úÖ Call stack spoofing via `Synthetic` and `Desync`.\n- ‚úÖ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- ‚úÖ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ‚úÖ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd ü¶Ä\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` ist eine Rust-Bibliothek f√ºr Call-Stack-Spoofing unter Windows, die es erm√∂glicht, beliebige Funktionen mit einem gef√§lschten Call-Stack auszuf√ºhren, der Analyse, Protokollierung oder Erkennung beim Stack-Unwinding entgeht.\n\nInspiriert von [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk) bringt dieses Crate Low-Level-Spoofing-F√§higkeiten in eine saubere, idiomatische Rust-Schnittstelle mit voller Unterst√ºtzung f√ºr `#[no_std]`, `MSVC` und `GNU` Toolchains sowie automatisierter Gadget-Aufl√∂sung.\n\n## Funktionen\n\n- ‚úÖ Call-Stack-Spoofing √ºber `Synthetic` und `Desync`.\n- ‚úÖ Kompatibel mit sowohl `MSVC` als auch `GNU` Toolchains (**x64**).\n- ‚úÖ Inline-Makros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ‚úÖ Unterst√ºtzt `#[no_std]` Umgebungen (mit `alloc`).\n\n## Einstieg\n\nF√ºgen Sie `uwd` zu Ihrem Projekt hinzu, indem Sie Ihre `Cargo.toml` aktualisieren:\n```bash\ncargo add uwd\n```\n\n## Verwendung\n\n`uwd` erm√∂glicht es Ihnen, den Call-Stack in Rust zu spoofen, wenn Sie entweder Standard-Windows-APIs aufrufen oder indirekte Syscalls durchf√ºhren. Die Bibliothek √ºbernimmt die vollst√§ndige Einrichtung von gef√§lschten Frames, Gadget-Chains und Registervorbereitung, um die Ausf√ºhrung so erscheinen zu lassen, als k√§me sie aus einer legitimen Quelle.\n\nSie k√∂nnen folgende Dinge spoofen:\n\n* Normale Funktionen (wie `VirtualAlloc`, `WinExec` usw.)\n* Native Syscalls mit automatischer SSN- und Stub-Aufl√∂sung (wie `NtAllocateVirtualMemory`)\n\nDie Makros `spoof!` / `spoof_synthetic!` und `syscall!` / `syscall_synthetic!` abstrahieren die gesamte Komplexit√§t.\n\n### WinExec spoofen\n\nDieses Beispiel zeigt, wie man `calc.exe` mit einem gespooften Call-Stack startet. Wir rufen `WinExec` zweimal auf: einmal mit der Desync-Technik und erneut mit der Synthetic-Technik.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Adressen der zu verwendenden WinAPI-Funktionen aufl√∂sen\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Befehl mit `WinExec` ausf√ºhren\n    // Call-Stack-Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec fehlgeschlagen\");\n        return Ok(());\n    }\n\n    // Call-Stack-Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec fehlgeschlagen [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Indirekten Syscall spoofen\n\nDieses Beispiel f√ºhrt einen indirekten Systemaufruf zu `NtAllocateVirtualMemory` mit einem gespooften Call-Stack aus.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Indirekten Syscall mit Call-Stack-Spoofing (Desync) ausf√ºhren\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory fehlgeschlagen mit Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Adresse zugewiesen: {:?}\", addr);\n\n    // Indirekten Syscall mit Call-Stack-Spoofing (Synthetic) ausf√ºhren\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory fehlgeschlagen mit Status [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}