{
  "id": 1,
  "origin": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- ✅ Call stack spoofing via `Synthetic` and `Desync`.\n- ✅ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- ✅ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ✅ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` เป็นไลบรารี Rust สำหรับการปลอมแปลง call stack บน Windows ซึ่งช่วยให้คุณสามารถเรียกใช้ฟังก์ชันใดๆ ก็ได้โดยมี call stack ที่ถูกสร้างขึ้นใหม่เพื่อหลบเลี่ยงการวิเคราะห์ การบันทึก หรือการตรวจจับระหว่างการ stack unwinding\n\nได้รับแรงบันดาลใจจาก [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk) crate นี้นำความสามารถในการปลอมแปลงระดับล่างเข้าสู่อินเทอร์เฟซ Rust ที่สะอาดและเป็นไปตามหลัก idiomatic พร้อมรองรับ `#[no_std]`, toolchain `MSVC` และ `GNU` อย่างเต็มรูปแบบ รวมถึงการแก้ไข gadget อัตโนมัติ\n\n## คุณสมบัติ\n\n- ✅ ปลอมแปลง call stack ผ่าน `Synthetic` และ `Desync`\n- ✅ ใช้งานร่วมกับ toolchain ทั้ง `MSVC` และ `GNU` (**x64**)\n- ✅ มี Inline macro: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`\n- ✅ รองรับสภาพแวดล้อม `#[no_std]` (เมื่อใช้ `alloc`)\n\n## เริ่มต้นใช้งาน\n\nเพิ่ม `uwd` ในโปรเจกต์ของคุณโดยแก้ไขไฟล์ `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## วิธีใช้งาน\n\n`uwd` ช่วยให้คุณปลอมแปลง call stack ใน Rust เมื่อต้องเรียกใช้ Windows API มาตรฐาน หรือการ syscall ทางอ้อม ไลบรารีนี้จะจัดการสร้าง fake frame, สร้าง gadget chain และเตรียม register ให้ทั้งหมด เพื่อให้การรันดูเหมือนว่ามาจากแหล่งที่ถูกต้อง\n\nคุณสามารถปลอมแปลงได้กับ:\n\n* ฟังก์ชันปกติ (เช่น `VirtualAlloc`, `WinExec` เป็นต้น)\n* Native syscall พร้อมการแก้ไข SSN และ stub อัตโนมัติ (เช่น `NtAllocateVirtualMemory`)\n\nMacro `spoof!` / `spoof_synthetic!` และ `syscall!` / `syscall_synthetic!` จะช่วยจัดการความซับซ้อนทั้งหมด\n\n### ตัวอย่างปลอมแปลง WinExec\n\nตัวอย่างนี้จะแสดงการรัน `calc.exe` ด้วย call stack ที่ถูกปลอมแปลง โดยเรียกใช้ `WinExec` สองครั้ง ครั้งแรกด้วยเทคนิค Desync และอีกครั้งด้วย Synthetic\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // แก้ไขที่อยู่ของฟังก์ชัน WinAPI ที่จะใช้งาน\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // รันคำสั่งด้วย `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### ตัวอย่างปลอมแปลง Indirect Syscall\n\nตัวอย่างนี้เป็นการ syscall ทางอ้อมไปยัง `NtAllocateVirtualMemory` พร้อมกับ call stack ที่ถูกปลอมแปลง\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // รัน indirect syscall พร้อม Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // รัน indirect syscall พร้อม Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}