{
  "id": 1,
  "origin": "# uwd ğŸ¦€\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- âœ… Call stack spoofing via `Synthetic` and `Desync`.\n- âœ… Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- âœ… Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- âœ… Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd ğŸ¦€\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd`ã¯Windowsä¸Šã§ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã‚’è¡Œã†ãŸã‚ã®Rustãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚ã‚Šã€ã‚¹ã‚¿ãƒƒã‚¯ã®å·»ãæˆ»ã—ä¸­ã«è§£æã€ãƒ­ã‚°è¨˜éŒ²ã€ã¾ãŸã¯æ¤œå‡ºã‚’å›é¿ã™ã‚‹å½è£…ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã§ä»»æ„ã®é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚\n\n[SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk)ã«ã‚¤ãƒ³ã‚¹ãƒ‘ã‚¤ã‚¢ã•ã‚Œã€ã“ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã¯ä½ãƒ¬ãƒ™ãƒ«ã®ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°æ©Ÿèƒ½ã‚’ã€ã‚¯ãƒªãƒ¼ãƒ³ã§ã‚¤ãƒ‡ã‚£ã‚ªãƒãƒ†ã‚£ãƒƒã‚¯ãªRustã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«ã¾ã¨ã‚ã€`#[no_std]`ã€`MSVC`ãŠã‚ˆã³`GNU`ãƒ„ãƒ¼ãƒ«ãƒã‚§ãƒ¼ãƒ³ã€ãã—ã¦è‡ªå‹•ã‚¬ã‚¸ã‚§ãƒƒãƒˆè§£æ±ºã«å®Œå…¨å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚\n\n## ç‰¹å¾´\n\n- âœ… `Synthetic`ã¨`Desync`ã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã€‚\n- âœ… `MSVC`ãŠã‚ˆã³`GNU`ãƒ„ãƒ¼ãƒ«ãƒã‚§ãƒ¼ãƒ³ï¼ˆ**x64**ï¼‰ã®ä¸¡æ–¹ã«å¯¾å¿œã€‚\n- âœ… ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒã‚¯ãƒ­: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`ã€‚\n- âœ… `#[no_std]`ç’°å¢ƒï¼ˆ`alloc`ãŒå¿…è¦ï¼‰ã‚’ã‚µãƒãƒ¼ãƒˆã€‚\n\n## ã¯ã˜ã‚ã«\n\n`Cargo.toml`ã‚’æ›´æ–°ã—ã¦`uwd`ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ ã—ã¾ã™:\n```bash\ncargo add uwd\n```\n\n## ä½¿ã„æ–¹\n\n`uwd`ã¯ã€æ¨™æº–ã®Windows APIå‘¼ã³å‡ºã—ã‚„é–“æ¥çš„ãªã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹éš›ã«ã€Rustã§ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’å½è£…ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€å½ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã€ã‚¬ã‚¸ã‚§ãƒƒãƒˆãƒã‚§ãƒ¼ãƒ³ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã®æº–å‚™ã®å…¨ã¦ã‚’å‡¦ç†ã—ã€å®Ÿè¡ŒãŒæ­£è¦ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ç™ºç”Ÿã—ãŸã‚ˆã†ã«è¦‹ã›ã‹ã‘ã¾ã™ã€‚\n\nã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã§ãã‚‹ã‚‚ã®:\n\n* é€šå¸¸ã®é–¢æ•°ï¼ˆä¾‹: `VirtualAlloc`, `WinExec`ãªã©ï¼‰\n* SSNã¨ã‚¹ã‚¿ãƒ–ã®è‡ªå‹•è§£æ±ºã‚’å‚™ãˆãŸãƒã‚¤ãƒ†ã‚£ãƒ–ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ï¼ˆä¾‹: `NtAllocateVirtualMemory`ï¼‰\n\nãƒã‚¯ãƒ­`spoof!` / `spoof_synthetic!`ã€`syscall!` / `syscall_synthetic!`ãŒå…¨ã¦ã®è¤‡é›‘ã•ã‚’æŠ½è±¡åŒ–ã—ã¾ã™ã€‚\n\n### WinExecã®ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°\n\nã“ã®ä¾‹ã§ã¯ã€ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã£ã¦`calc.exe`ã‚’èµ·å‹•ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚`WinExec`ã‚’Desyncæ‰‹æ³•ã¨Syntheticæ‰‹æ³•ã§ãã‚Œãã‚Œ2å›å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // ä½¿ç”¨ã™ã‚‹WinAPIé–¢æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è§£æ±º\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // `WinExec`ã§ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ\n    // ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ï¼ˆDesyncï¼‰\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ï¼ˆSyntheticï¼‰\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### é–“æ¥Syscallã®ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°\n\nã“ã®ä¾‹ã¯ã€ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã§`NtAllocateVirtualMemory`ã¸ã®é–“æ¥çš„ãªã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ï¼ˆDesyncï¼‰ã«ã‚ˆã‚‹é–“æ¥Syscallã®å®Ÿè¡Œ\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¹ãƒ—ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ï¼ˆSyntheticï¼‰ã«ã‚ˆã‚‹é–“æ¥Syscallã®å®Ÿè¡Œ\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}