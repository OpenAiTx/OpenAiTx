{
  "id": 1,
  "origin": "# uwd ЁЯжА\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- тЬЕ Call stack spoofing via `Synthetic` and `Desync`.\n- тЬЕ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- тЬЕ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- тЬЕ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd ЁЯжА\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` рд╡рд┐рдВрдбреЛрдЬрд╝ рдкрд░ рдХреЙрд▓ рд╕реНрдЯреИрдХ рд╕реНрдкреВрдлрд┐рдВрдЧ рдХреЗ рд▓рд┐рдП рдПрдХ рд░рд╕реНрдЯ рд▓рд╛рдЗрдмреНрд░реЗрд░реА рд╣реИ, рдЬреЛ рдЖрдкрдХреЛ рдПрдХ рдирдХрд▓реА рдХреЙрд▓ рд╕реНрдЯреИрдХ рдХреЗ рд╕рд╛рде рдордирдорд╛рдиреЗ рдлрдВрдХреНрд╢рди рдХреЛ рдирд┐рд╖реНрдкрд╛рджрд┐рдд рдХрд░рдиреЗ рдХреА рдЕрдиреБрдорддрд┐ рджреЗрддреА рд╣реИ, рдЬрд┐рд╕рд╕реЗ рдпрд╣ рд╡рд┐рд╢реНрд▓реЗрд╖рдг, рд▓реЙрдЧрд┐рдВрдЧ, рдпрд╛ рд╕реНрдЯреИрдХ рдЕрдирд╡рд╛рдЗрдВрдбрд┐рдВрдЧ рдХреЗ рджреМрд░рд╛рди рдбрд┐рдЯреЗрдХреНрд╢рди рд╕реЗ рдмрдЪ рдЬрд╛рддрд╛ рд╣реИред\n\n[SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk) рд╕реЗ рдкреНрд░реЗрд░рд┐рдд, рдпрд╣ рдХреНрд░реЗрдЯ рдирд┐рдореНрди-рд╕реНрддрд░реАрдп рд╕реНрдкреВрдлрд┐рдВрдЧ рдХреНрд╖рдорддрд╛рдУрдВ рдХреЛ рдПрдХ рд╕реНрд╡рдЪреНрдЫ, рдЖрджрд░реНрд╢ рд░рд╕реНрдЯ рдЗрдВрдЯрд░рдлрд╝реЗрд╕ рдореЗрдВ рд▓рд╛рддрд╛ рд╣реИ рдЬрд┐рд╕рдореЗрдВ `#[no_std]`, `MSVC` рдФрд░ `GNU` рдЯреВрд▓рдЪреЗрди рдХреЗ рд▓рд┐рдП рдкреВрд░реНрдг рд╕рдорд░реНрдерди рдФрд░ рд╕реНрд╡рдЪрд╛рд▓рд┐рдд рдЧреИрдЬреЗрдЯ рд░реЗрдЬрд╝реЛрд▓реНрдпреВрд╢рди рд╢рд╛рдорд┐рд▓ рд╣реИред\n\n## рд╡рд┐рд╢реЗрд╖рддрд╛рдПрдБ\n\n- тЬЕ `Synthetic` рдФрд░ `Desync` рдХреЗ рдорд╛рдзреНрдпрдо рд╕реЗ рдХреЙрд▓ рд╕реНрдЯреИрдХ рд╕реНрдкреВрдлрд┐рдВрдЧред\n- тЬЕ рджреЛрдиреЛрдВ `MSVC` рдФрд░ `GNU` рдЯреВрд▓рдЪреЗрди (**x64**) рдХреЗ рд╕рд╛рде рд╕рдВрдЧрддред\n- тЬЕ рдЗрдирд▓рд╛рдЗрди рдореИрдХреНрд░реЛрдЬрд╝: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`ред\n- тЬЕ `#[no_std]` рдкрд░рд┐рд╡реЗрд╢реЛрдВ рдХрд╛ рд╕рдорд░реНрдерди рдХрд░рддрд╛ рд╣реИ (рдпрджрд┐ `alloc` рдЙрдкрд▓рдмреНрдз рд╣реИ)ред\n\n## рд╢реБрд░реВ рдХрд░рдирд╛\n\nрдЕрдкрдиреЗ рдкреНрд░реЛрдЬреЗрдХреНрдЯ рдореЗрдВ `uwd` рдЬреЛрдбрд╝рдиреЗ рдХреЗ рд▓рд┐рдП рдЕрдкрдиреЗ `Cargo.toml` рдХреЛ рдЕрдкрдбреЗрдЯ рдХрд░реЗрдВ:\n```bash\ncargo add uwd\n```\n\n## рдЙрдкрдпреЛрдЧ\n\n`uwd` рдЖрдкрдХреЛ рд░рд╕реНрдЯ рдореЗрдВ рдпрд╛ рддреЛ рдорд╛рдирдХ рд╡рд┐рдВрдбреЛрдЬрд╝ API рдпрд╛ рдЕрдкреНрд░рддреНрдпрдХреНрд╖ рд╕рд┐рд╕реНрдЯрдо рдХреЙрд▓ рдХрд░рддреЗ рд╕рдордп рдХреЙрд▓ рд╕реНрдЯреИрдХ рд╕реНрдкреВрдл рдХрд░рдиреЗ рдХреА рдЕрдиреБрдорддрд┐ рджреЗрддрд╛ рд╣реИред рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдирдХрд▓реА рдлреНрд░реЗрдо, рдЧреИрдЬреЗрдЯ рдЪреЗрди рдФрд░ рд░рдЬрд┐рд╕реНрдЯрд░ рдХреА рддреИрдпрд╛рд░реА рдХреА рдкреВрд░реА рд╕реЗрдЯрдЕрдк рдХреЛ рд╕рдВрднрд╛рд▓рддреА рд╣реИ рдЬрд┐рд╕рд╕реЗ рдирд┐рд╖реНрдкрд╛рджрди рдРрд╕рд╛ рдкреНрд░рддреАрдд рд╣реЛрддрд╛ рд╣реИ рдЬреИрд╕реЗ рд╡рд╣ рдПрдХ рд╡реИрдз рд╕реНрд░реЛрдд рд╕реЗ рдЖрдпрд╛ рд╣реЛред\n\nрдЖрдк рдирд┐рдореНрди рдХреЛ рд╕реНрдкреВрдл рдХрд░ рд╕рдХрддреЗ рд╣реИрдВ:\n\n* рд╕рд╛рдорд╛рдиреНрдп рдлрдВрдХреНрд╢рди (рдЬреИрд╕реЗ `VirtualAlloc`, `WinExec` рдЖрджрд┐)\n* рд╕реНрд╡рдЪрд╛рд▓рд┐рдд SSN рдФрд░ рд╕реНрдЯрдм рд░реЗрдЬрд╝реЛрд▓реНрдпреВрд╢рди рдХреЗ рд╕рд╛рде рдиреЗрдЯрд┐рд╡ рд╕рд┐рд╕реНрдЯрдо рдХреЙрд▓ (рдЬреИрд╕реЗ `NtAllocateVirtualMemory`)\n\nрдореИрдХреНрд░реЛрдЬрд╝ `spoof!` / `spoof_synthetic!` рдФрд░ `syscall!` / `syscall_synthetic!` рд╕рд╛рд░реА рдЬрдЯрд┐рд▓рддрд╛ рдХреЛ рдЕрдореВрд░реНрдд рдХрд░ рджреЗрддреЗ рд╣реИрдВред\n\n### WinExec рдХреЛ рд╕реНрдкреВрдл рдХрд░рдирд╛\n\nрдпрд╣ рдЙрджрд╛рд╣рд░рдг рджрд┐рдЦрд╛рддрд╛ рд╣реИ рдХрд┐ рдХреИрд╕реЗ рдПрдХ рд╕реНрдкреВрдл рдХрд┐рдП рдЧрдП рдХреЙрд▓ рд╕реНрдЯреИрдХ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдХреЗ `calc.exe` рдХреЛ рд╢реБрд░реВ рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИред рд╣рдо `WinExec` рдХреЛ рджреЛ рдмрд╛рд░ рдХреЙрд▓ рдХрд░рддреЗ рд╣реИрдВ тАФ рдПрдХ рдмрд╛рд░ Desync рддрдХрдиреАрдХ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдХреЗ, рдФрд░ рдлрд┐рд░ Synthetic рддрдХрдиреАрдХ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдХреЗред\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд┐рдП рдЬрд╛рдиреЗ рд╡рд╛рд▓реЗ WinAPI рдлрдВрдХреНрд╢рди рдХреЗ рдкрддреЗ рдХреЛ рд░реЗрдЬрд╝реЙрд▓реНрд╡ рдХрд░рддрд╛ рд╣реИ\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // `WinExec` рдХреЗ рд╕рд╛рде рдХрдорд╛рдВрдб рдирд┐рд╖реНрдкрд╛рджрд┐рдд рдХрд░реЗрдВ\n    // рдХреЙрд▓ рд╕реНрдЯреИрдХ рд╕реНрдкреВрдлрд┐рдВрдЧ (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec рдЕрд╕рдлрд▓ рд╣реБрдЖ\");\n        return Ok(());\n    }\n\n    // рдХреЙрд▓ рд╕реНрдЯреИрдХ рд╕реНрдкреВрдлрд┐рдВрдЧ (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec рдЕрд╕рдлрд▓ рд╣реБрдЖ [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### рдПрдХ рдЕрдкреНрд░рддреНрдпрдХреНрд╖ рд╕рд┐рд╕реНрдЯрдо рдХреЙрд▓ рдХреЛ рд╕реНрдкреВрдл рдХрд░рдирд╛\n\nрдпрд╣ рдЙрджрд╛рд╣рд░рдг рдПрдХ рд╕реНрдкреВрдл рдХрд┐рдП рдЧрдП рдХреЙрд▓ рд╕реНрдЯреИрдХ рдХреЗ рд╕рд╛рде `NtAllocateVirtualMemory` рдХреЗ рд▓рд┐рдП рдЕрдкреНрд░рддреНрдпрдХреНрд╖ рд╕рд┐рд╕реНрдЯрдо рдХреЙрд▓ рдХрд░рддрд╛ рд╣реИред\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // рдХреЙрд▓ рд╕реНрдЯреИрдХ рд╕реНрдкреВрдлрд┐рдВрдЧ (Desync) рдХреЗ рд╕рд╛рде рдЕрдкреНрд░рддреНрдпрдХреНрд╖ рд╕рд┐рд╕реНрдЯрдо рдХреЙрд▓ рдЪрд▓рд╛рдирд╛\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory рдЕрд╕рдлрд▓ рд░рд╣рд╛, рд╕реНрдерд┐рддрд┐: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] рдкрддрд╛ рдЖрд╡рдВрдЯрд┐рдд рдХрд┐рдпрд╛ рдЧрдпрд╛: {:?}\", addr);\n\n    // рдХреЙрд▓ рд╕реНрдЯреИрдХ рд╕реНрдкреВрдлрд┐рдВрдЧ (Synthetic) рдХреЗ рд╕рд╛рде рдЕрдкреНрд░рддреНрдпрдХреНрд╖ рд╕рд┐рд╕реНрдЯрдо рдХреЙрд▓ рдЪрд▓рд╛рдирд╛\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory рдЕрд╕рдлрд▓ рд░рд╣рд╛ [2], рд╕реНрдерд┐рддрд┐: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}