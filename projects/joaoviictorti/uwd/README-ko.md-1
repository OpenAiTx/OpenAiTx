{
  "id": 1,
  "origin": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- ✅ Call stack spoofing via `Synthetic` and `Desync`.\n- ✅ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- ✅ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ✅ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd`는 Windows에서 호출 스택 위조(Call Stack Spoofing)를 위한 Rust 라이브러리로, 스택 언와인딩(Unwinding) 중 분석, 로깅 또는 탐지를 회피하며 임의의 함수를 위조된 호출 스택으로 실행할 수 있게 해줍니다.\n\n[SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk)에서 영감을 받아, 이 크레이트는 저수준 위조 기능을 깔끔하고 직관적인 Rust 인터페이스로 제공하며, `#[no_std]`, `MSVC` 및 `GNU` 툴체인, 자동 가젯 해상도를 완벽하게 지원합니다.\n\n## 특징\n\n- ✅ `Synthetic` 및 `Desync`를 통한 호출 스택 위조\n- ✅ `MSVC`와 `GNU` 툴체인(**x64**) 모두와 호환\n- ✅ 인라인 매크로: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`\n- ✅ `#[no_std]` 환경 지원(`alloc` 필요)\n\n## 시작하기\n\n`Cargo.toml`을 다음과 같이 수정하여 `uwd`를 프로젝트에 추가하세요:\n```bash\ncargo add uwd\n```\n\n## 사용법\n\n`uwd`를 사용하면 표준 Windows API 호출 또는 간접 시스템 콜을 수행할 때 Rust에서 호출 스택을 위조할 수 있습니다. 이 라이브러리는 위조된 프레임, 가젯 체인, 레지스터 준비 등 전체 과정을 처리하여 실행이 합법적인 소스에서 발생한 것처럼 보이도록 만듭니다.\n\n다음과 같이 위조할 수 있습니다:\n\n* 일반 함수(예: `VirtualAlloc`, `WinExec` 등)\n* 자동 SSN 및 스텁 해상도를 사용하는 네이티브 시스템 콜(예: `NtAllocateVirtualMemory`)\n\n매크로 `spoof!` / `spoof_synthetic!`, `syscall!` / `syscall_synthetic!`는 모든 복잡성을 추상화합니다.\n\n### WinExec 스택 위조\n\n이 예제는 위조된 호출 스택을 사용하여 `calc.exe`를 실행하는 방법을 보여줍니다. `WinExec`를 두 번 호출하며, 한 번은 Desync 기법, 한 번은 Synthetic 기법을 사용합니다.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // 사용할 WinAPI 함수 주소를 해상\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // `WinExec`로 명령 실행\n    // 호출 스택 위조 (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec 실패\");\n        return Ok(());\n    }\n\n    // 호출 스택 위조 (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec 실패 [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### 간접 시스템 콜 스택 위조\n\n이 예제는 위조된 호출 스택으로 `NtAllocateVirtualMemory` 간접 시스템 콜을 수행합니다.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // 호출 스택 위조(Desync)로 간접 시스템 콜 실행\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory 실패, 상태: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] 할당된 주소: {:?}\", addr);\n\n    // 호출 스택 위조(Synthetic)로 간접 시스템 콜 실행\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory 실패 [2], 상태: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}