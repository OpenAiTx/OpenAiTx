{
  "id": 1,
  "origin": "# uwd ü¶Ä\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- ‚úÖ Call stack spoofing via `Synthetic` and `Desync`.\n- ‚úÖ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- ‚úÖ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ‚úÖ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd ü¶Ä\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` es una biblioteca de Rust para suplantaci√≥n de pila de llamadas en Windows, que te permite ejecutar funciones arbitrarias con una pila de llamadas falsificada que evade el an√°lisis, registro o detecci√≥n durante el desenrollado de la pila.\n\nInspirado en [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), este crate lleva capacidades de suplantaci√≥n de bajo nivel a una interfaz Rust limpia e idiom√°tica, con soporte completo para `#[no_std]`, toolchains `MSVC` y `GNU`, y resoluci√≥n automatizada de gadgets.\n\n## Caracter√≠sticas\n\n- ‚úÖ Suplantaci√≥n de pila de llamadas v√≠a `Synthetic` y `Desync`.\n- ‚úÖ Compatible con toolchains `MSVC` y `GNU` (**x64**).\n- ‚úÖ Macros inline: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ‚úÖ Soporte para entornos `#[no_std]` (con `alloc`).\n\n## Primeros pasos\n\nAgrega `uwd` a tu proyecto actualizando tu `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Uso\n\n`uwd` te permite suplantar la pila de llamadas en Rust al invocar APIs est√°ndar de Windows o realizar syscalls indirectas. La biblioteca gestiona la configuraci√≥n completa de frames falsos, cadenas de gadgets y preparaci√≥n de registros para que la ejecuci√≥n parezca provenir de una fuente leg√≠tima.\n\nPuedes suplantar:\n\n* Funciones normales (como `VirtualAlloc`, `WinExec`, etc.)\n* Syscalls nativas con resoluci√≥n autom√°tica de SSN y stubs (como `NtAllocateVirtualMemory`)\n\nLas macros `spoof!` / `spoof_synthetic!` y `syscall!` / `syscall_synthetic!` abstraen toda la complejidad.\n\n### Suplantando WinExec\n\nEste ejemplo muestra c√≥mo lanzar `calc.exe` usando una pila de llamadas suplantada. Llamamos a `WinExec` dos veces: una usando la t√©cnica Desync y otra usando la t√©cnica Synthetic.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resuelve las direcciones de las funciones WinAPI a usar\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Ejecuta el comando con `WinExec`\n    // Suplantaci√≥n de pila de llamadas (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Fall√≥\");\n        return Ok(());\n    }\n\n    // Suplantaci√≥n de pila de llamadas (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Fall√≥ [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Suplantando un Syscall Indirecto\n\nEste ejemplo realiza una syscall indirecta a `NtAllocateVirtualMemory` con una pila de llamadas suplantada.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Ejecutando syscall indirecta con suplantaci√≥n de pila de llamadas (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Fall√≥ con Estado: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Direcci√≥n asignada: {:?}\", addr);\n\n    // Ejecutando syscall indirecta con suplantaci√≥n de pila de llamadas (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Fall√≥ con Estado [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}