{
  "id": 1,
  "origin": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- ✅ Call stack spoofing via `Synthetic` and `Desync`.\n- ✅ Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- ✅ Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- ✅ Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd 🦀\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` هي مكتبة Rust لتزوير مكدس الاستدعاء على نظام Windows، مما يسمح لك بتنفيذ دوال عشوائية بمكدس استدعاء مزور يتجنب التحليل أو التسجيل أو الاكتشاف أثناء عملية فك المكدس.\n\nمستوحاة من [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk)، تقدم هذه الحزمة قدرات تزوير منخفضة المستوى ضمن واجهة Rust نظيفة وأنيقة مع دعم كامل لـ `#[no_std]`، وسلاسل أدوات `MSVC` و `GNU`، وحل تلقائي للأدوات البرمجية (gadgets).\n\n## الميزات\n\n- ✅ تزوير مكدس الاستدعاء عبر `Synthetic` و `Desync`.\n- ✅ متوافقة مع كل من سلاسل الأدوات `MSVC` و `GNU` (**x64**).\n- ✅ ماكروز مضمنة: `spoof!`، `spoof_synthetic!`، `syscall!`، `syscall_synthetic!`.\n- ✅ تدعم بيئات `#[no_std]` (مع `alloc`).\n\n## البدء\n\nأضف `uwd` إلى مشروعك من خلال تحديث ملف `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## الاستخدام\n\nتتيح لك مكتبة `uwd` تزوير مكدس الاستدعاء في Rust عند استدعاء واجهات برمجة تطبيقات Windows القياسية أو عند تنفيذ system calls غير مباشرة. تتولى المكتبة إعداد كافة الإطارات المزيفة، وسلاسل الأدوات البرمجية (gadget chains)، وتجهيز المسجلات لجعل التنفيذ يبدو وكأنه جاء من مصدر شرعي.\n\nيمكنك تزوير استدعاء:\n\n* الدوال العادية (مثل `VirtualAlloc`، `WinExec`، إلخ)\n* نداءات النظام الأصلية مع حل تلقائي لـ SSN و stub (مثل `NtAllocateVirtualMemory`)\n\nتقوم الماكروز `spoof!` / `spoof_synthetic!` و `syscall!` / `syscall_synthetic!` بتجريد جميع التعقيدات.\n\n### تزوير WinExec\n\nيوضح هذا المثال كيفية تشغيل `calc.exe` باستخدام مكدس استدعاء مزور. نستدعي الدالة `WinExec` مرتين؛ مرة باستخدام تقنية Desync، ومرة أخرى باستخدام تقنية Synthetic.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // حل عناوين دوال WinAPI المطلوب استخدامها\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // تنفيذ الأمر باستخدام `WinExec`\n    // تزوير مكدس الاستدعاء (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"فشل WinExec\");\n        return Ok(());\n    }\n\n    // تزوير مكدس الاستدعاء (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"فشل WinExec [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### تزوير نداء نظام غير مباشر\n\nيوضح هذا المثال تنفيذ نداء نظام غير مباشر إلى `NtAllocateVirtualMemory` مع مكدس استدعاء مزور.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // تنفيذ نداء نظام غير مباشر مع تزوير مكدس الاستدعاء (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"فشل NtAllocateVirtualMemory مع الحالة: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] تم تخصيص العنوان: {:?}\", addr);\n\n    // تنفيذ نداء نظام غير مباشر مع تزوير مكدس الاستدعاء (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"فشل NtAllocateVirtualMemory مع الحالة [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}