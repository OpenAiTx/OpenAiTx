{
  "id": 1,
  "origin": "# uwd ğŸ¦€\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- âœ… Call stack spoofing via `Synthetic` and `Desync`.\n- âœ… Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- âœ… Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- âœ… Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd ğŸ¦€\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd`, Windows Ã¼zerinde Ã§aÄŸrÄ± yÄ±ÄŸÄ±nÄ± sahteciliÄŸi (call stack spoofing) iÃ§in kullanÄ±lan bir Rust kÃ¼tÃ¼phanesidir ve sahte bir Ã§aÄŸrÄ± yÄ±ÄŸÄ±nÄ± ile keyfi fonksiyonlarÄ± Ã§alÄ±ÅŸtÄ±rmanÄ±za, analizden, kayÄ±ttan veya yÄ±ÄŸÄ±n Ã§Ã¶zme sÄ±rasÄ±nda tespit edilmekten kaÃ§Ä±nmanÄ±za olanak tanÄ±r.\n\n[SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk)'tan esinlenen bu crate, dÃ¼ÅŸÃ¼k seviyeli sahtecilik yeteneklerini temiz, idiyomatik bir Rust arayÃ¼zÃ¼ne taÅŸÄ±r. `#[no_std]`, `MSVC` ve `GNU` derleyici zincirleriyle tam uyumlu olup, otomatik gadget Ã§Ã¶zÃ¼mlemesi de iÃ§erir.\n\n## Ã–zellikler\n\n- âœ… `Synthetic` ve `Desync` ile Ã§aÄŸrÄ± yÄ±ÄŸÄ±nÄ± sahteciliÄŸi.\n- âœ… Hem `MSVC` hem de `GNU` derleyici zincirleriyle uyumlu (**x64**).\n- âœ… SatÄ±r iÃ§i makrolar: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- âœ… `#[no_std]` ortamlarÄ±nÄ± destekler (`alloc` ile birlikte).\n\n## BaÅŸlarken\n\n`Cargo.toml` dosyanÄ±zÄ± gÃ¼ncelleyerek projenize `uwd` ekleyin:\n```bash\ncargo add uwd\n```\n\n## KullanÄ±m\n\n`uwd`, Rust'ta standart Windows API'lerini Ã§aÄŸÄ±rÄ±rken ya da dolaylÄ± sistem Ã§aÄŸrÄ±larÄ± gerÃ§ekleÅŸtirirken Ã§aÄŸrÄ± yÄ±ÄŸÄ±nÄ±nÄ± sahteleyebilmenizi saÄŸlar. KÃ¼tÃ¼phane, sahte Ã§erÃ§evelerin, gadget zincirlerinin ve kayÄ±t hazÄ±rlÄ±klarÄ±nÄ±n tam kurulumunu otomatik olarak yapar ve yÃ¼rÃ¼tmenin yasal bir kaynaktan gelmiÅŸ gibi gÃ¶rÃ¼nmesini saÄŸlar.\n\nSahteleyebileceÄŸiniz ÅŸeyler:\n\n* Normal fonksiyonlar (Ã¶r. `VirtualAlloc`, `WinExec` vb.)\n* Otomatik SSN ve stub Ã§Ã¶zÃ¼mÃ¼ ile yerel sistem Ã§aÄŸrÄ±larÄ± (Ã¶r. `NtAllocateVirtualMemory`)\n\n`spoof!` / `spoof_synthetic!` ve `syscall!` / `syscall_synthetic!` makrolarÄ± tÃ¼m karmaÅŸÄ±klÄ±ÄŸÄ± soyutlar.\n\n### WinExec SahteciliÄŸi\n\nBu Ã¶rnek, sahte bir Ã§aÄŸrÄ± yÄ±ÄŸÄ±nÄ± kullanarak `calc.exe` baÅŸlatmayÄ± gÃ¶sterir. `WinExec` iki kez Ã§aÄŸrÄ±lÄ±r; bir kez Desync tekniÄŸi, tekrar da Synthetic tekniÄŸiyle.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // KullanÄ±lacak WinAPI fonksiyonlarÄ±nÄ±n adreslerini Ã§Ã¶zÃ¼mler\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // `WinExec` ile komutu Ã§alÄ±ÅŸtÄ±r\n    // Ã‡aÄŸrÄ± YÄ±ÄŸÄ±nÄ± SahteciliÄŸi (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec BaÅŸarÄ±sÄ±z\");\n        return Ok(());\n    }\n\n    // Ã‡aÄŸrÄ± YÄ±ÄŸÄ±nÄ± SahteciliÄŸi (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec BaÅŸarÄ±sÄ±z [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### DolaylÄ± Sistem Ã‡aÄŸrÄ±sÄ± SahteciliÄŸi\n\nBu Ã¶rnek, sahte bir Ã§aÄŸrÄ± yÄ±ÄŸÄ±nÄ± ile `NtAllocateVirtualMemory` iÃ§in dolaylÄ± bir sistem Ã§aÄŸrÄ±sÄ± gerÃ§ekleÅŸtirir.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Ã‡aÄŸrÄ± YÄ±ÄŸÄ±nÄ± SahteciliÄŸi ile dolaylÄ± sistem Ã§aÄŸrÄ±sÄ± (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Durumuyla BaÅŸarÄ±sÄ±z Oldu: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Adres tahsis edildi: {:?}\", addr);\n\n    // Ã‡aÄŸrÄ± YÄ±ÄŸÄ±nÄ± SahteciliÄŸi ile dolaylÄ± sistem Ã§aÄŸrÄ±sÄ± (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Durumuyla BaÅŸarÄ±sÄ±z Oldu [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}