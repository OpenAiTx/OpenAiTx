{
  "id": 1,
  "origin": "# uwd ðŸ¦€\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` is a Rust library for call stack spoofing on Windows, allowing you to execute arbitrary functions with a forged call stack that evades analysis, logging, or detection during stack unwinding.\n\nInspired by [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), this crate brings low-level spoofing capabilities into a clean, idiomatic Rust interface with full support for `#[no_std]`, `MSVC` and `GNU` toolchains, and automated gadget resolution.\n\n## Features\n\n- âœ… Call stack spoofing via `Synthetic` and `Desync`.\n- âœ… Compatible with both `MSVC` and `GNU` toolchains (**x64**).\n- âœ… Inline macros: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- âœ… Supports `#[no_std]` environments (with `alloc`).\n\n## Getting started\n\nAdd `uwd` to your project by updating your `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Usage\n\n`uwd` allows you to spoof the call stack in Rust when calling either standard Windows APIs or performing indirect syscalls. The library handles the full setup of fake frames, gadget chains, and register preparation to make execution appear as if it came from a legitimate source.\n\nYou can spoof:\n\n* Normal functions (like `VirtualAlloc`, `WinExec`, etc.)\n* Native syscalls with automatic SSN and stub resolution (like `NtAllocateVirtualMemory`)\n\nThe macros `spoof!` / `spoof_synthetic!` and `syscall!` / `syscall_synthetic!` abstract all the complexity.\n\n### Spoofing WinExec\n\nThis example shows how to spawn `calc.exe` using a spoofed call stack. We call `WinExec` twice once using the Desync technique, and again using the Synthetic one.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolves addresses of the WinAPI functions to be used\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Execute command with `WinExec`\n    // Call Stack Spoofing (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed\");\n        return Ok(());\n    }\n\n    // Call Stack Spoofing (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Failed [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing an Indirect Syscall\n\nThis example performs a indirect system call to `NtAllocateVirtualMemory` with a spoofed call stack.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Running indirect syscall with Call Stack Spoofing (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] Address allocated: {:?}\", addr);\n\n    // Running indirect syscall with Call Stack Spoofing (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Failed With Status [2]: {status:#X}\");\n        return Ok(())",
  "origin_sha": "XMVG2C/OeHNg495vqFN1i34ScoExbukFmmu61cjgrA4=",
  "translate": "# uwd ðŸ¦€\n\n![Rust](https://img.shields.io/badge/made%20with-Rust-red)\n![crate](https://img.shields.io/crates/v/uwd.svg)\n![docs](https://docs.rs/uwd/badge.svg)\n[![build](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml/badge.svg)](https://github.com/joaoviictorti/uwd/actions/workflows/ci.yml)\n![Forks](https://img.shields.io/github/forks/joaoviictorti/uwd)\n![Stars](https://img.shields.io/github/stars/joaoviictorti/uwd)\n![License](https://img.shields.io/github/license/joaoviictorti/uwd)\n\n`uwd` Ã© uma biblioteca Rust para spoofing da pilha de chamadas no Windows, permitindo executar funÃ§Ãµes arbitrÃ¡rias com uma pilha de chamadas forjada que evita anÃ¡lise, registro ou detecÃ§Ã£o durante o desempilhamento.\n\nInspirada no [SilentMoonwalk](https://github.com/klezVirus/SilentMoonwalk), esta crate traz capacidades de spoofing de baixo nÃ­vel para uma interface Rust limpa e idiomÃ¡tica, com suporte total a `#[no_std]`, toolchains `MSVC` e `GNU`, e resoluÃ§Ã£o automatizada de gadgets.\n\n## Recursos\n\n- âœ… Spoofing de pilha de chamadas via `Synthetic` e `Desync`.\n- âœ… CompatÃ­vel com os toolchains `MSVC` e `GNU` (**x64**).\n- âœ… Macros inline: `spoof!`, `spoof_synthetic!`, `syscall!`, `syscall_synthetic!`.\n- âœ… Suporte a ambientes `#[no_std]` (com `alloc`).\n\n## ComeÃ§ando\n\nAdicione `uwd` ao seu projeto atualizando seu `Cargo.toml`:\n```bash\ncargo add uwd\n```\n\n## Uso\n\n`uwd` permite que vocÃª faÃ§a spoofing da pilha de chamadas em Rust ao chamar APIs padrÃ£o do Windows ou ao realizar syscalls indiretos. A biblioteca gerencia toda a configuraÃ§Ã£o de frames falsos, cadeias de gadgets e preparaÃ§Ã£o de registradores para fazer a execuÃ§Ã£o parecer que veio de uma fonte legÃ­tima.\n\nVocÃª pode fazer spoof em:\n\n* FunÃ§Ãµes normais (como `VirtualAlloc`, `WinExec`, etc.)\n* Syscalls nativos com resoluÃ§Ã£o automÃ¡tica de SSN e stub (como `NtAllocateVirtualMemory`)\n\nAs macros `spoof!` / `spoof_synthetic!` e `syscall!` / `syscall_synthetic!` abstraem toda a complexidade.\n\n### Spoofing de WinExec\n\nEste exemplo mostra como executar `calc.exe` usando uma pilha de chamadas spoofada. Chamamos `WinExec` duas vezes, uma usando a tÃ©cnica Desync e novamente usando a tÃ©cnica Synthetic.\n\n```rs\nuse dinvk::{GetModuleHandle, GetProcAddress};\nuse uwd::{spoof, spoof_synthetic};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Resolve os endereÃ§os das funÃ§Ãµes WinAPI a serem usadas\n    let kernel32 = GetModuleHandle(\"kernel32.dll\", None);\n    let win_exec = GetProcAddress(kernel32, \"WinExec\", None);\n    \n    // Executa comando com `WinExec`\n    // Spoofing da pilha de chamadas (Desync)\n    let cmd = c\"calc.exe\";\n    let mut result = spoof!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Falhou\");\n        return Ok(());\n    }\n\n    // Spoofing da pilha de chamadas (Synthetic)\n    result = spoof_synthetic!(win_exec, cmd.as_ptr(), 1)?;\n    if result.is_null() {\n        eprintln!(\"WinExec Falhou [2]\");\n        return Ok(());\n    }\n\n    Ok(())\n}\n```\n\n### Spoofing de uma Syscall Indireta\n\nEste exemplo realiza uma syscall indireta para `NtAllocateVirtualMemory` com uma pilha de chamadas spoofada.\n\n```rs\nuse std::{ffi::c_void, ptr::null_mut};\nuse dinvk::NT_SUCCESS;\nuse uwd::{syscall, syscall_synthetic, AsUwd};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Executando syscall indireta com spoofing da pilha de chamadas (Desync)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    let mut status = syscall!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Falhou Com Status: {status:#X}\");\n        return Ok(())\n    }\n\n    println!(\"[+] EndereÃ§o alocado: {:?}\", addr);\n\n    // Executando syscall indireta com spoofing da pilha de chamadas (Synthetic)\n    let mut addr = null_mut::<c_void>();\n    let mut size = (1 << 12) as usize;\n    status = syscall_synthetic!(\"NtAllocateVirtualMemory\", -1isize, addr.as_uwd_mut(), 0, size.as_uwd_mut(), 0x3000, 0x04)? as i32;\n    if !NT_SUCESS(status) {\n        eprintln!(\"NtAllocateVirtualMemory Falhou Com Status [2]: {status:#X}\");\n        return Ok(())",
  "status": "ok"
}