*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*

**Help [vertaal](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) deze gids!**

# De System Design Primer

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png">
  <br/>
</p>

## Motivatie

> Leer hoe je grootschalige systemen ontwerpt.
>
> Bereid je voor op het system design interview.

### Leer hoe je grootschalige systemen ontwerpt

Leren hoe je schaalbare systemen ontwerpt helpt je om een betere engineer te worden.

Systeemontwerp is een breed onderwerp.  Er zijn **een enorme hoeveelheid bronnen verspreid over het web** over principes van systeemontwerp.

Deze repo is een **georganiseerde verzameling** van bronnen om je te helpen leren hoe je systemen op schaal bouwt.

### Leer van de open source community

Dit is een voortdurend geüpdatet, open source project.

[Bijdragen](#contributing) zijn welkom!

### Bereid je voor op het system design interview

Naast codeer-interviews is systeemontwerp een **verplicht onderdeel** van het **technisch sollicitatieproces** bij veel techbedrijven.

**Oefen veel voorkomende systeemontwerp interviewvragen** en **vergelijk** je resultaten met **voorbeeldoplossingen**: discussies, code en diagrammen.

Extra onderwerpen voor interviewvoorbereiding:

* [Studiemateriaal](#study-guide)
* [Hoe een systeemontwerp interviewvraag aan te pakken](#how-to-approach-a-system-design-interview-question)
* [Systeemontwerp interviewvragen, **met oplossingen**](#system-design-interview-questions-with-solutions)
* [Object-georiënteerd ontwerp interviewvragen, **met oplossingen**](#object-oriented-design-interview-questions-with-solutions)
* [Aanvullende systeemontwerp interviewvragen](#additional-system-design-interview-questions)

## Anki-flashcards

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png">
  <br/>
</p>

De aangeboden [Anki-flashcarddecks](https://apps.ankiweb.net/) gebruiken gespreide herhaling om je te helpen belangrijke systeemontwerpconcepten te onthouden.

* [Systeemontwerpdeck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)
* [Systeemontwerpoefeningen deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)
* [Objectgeoriënteerde ontwerpoefeningen deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)

Ideaal om onderweg te gebruiken.

### Codering Resource: Interactieve programmeeruitdagingen

Op zoek naar bronnen om je voor te bereiden op het [**Programmeergesprek**](https://github.com/donnemartin/interactive-coding-challenges)?

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png">
  <br/>
</p>

Bekijk de zusterrepo [**Interactieve programmeeruitdagingen**](https://github.com/donnemartin/interactive-coding-challenges), die een extra Anki-deck bevat:

* [Programmeerdeck](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)

## Bijdragen

> Leer van de community.

Voel je vrij om pull requests in te dienen om te helpen:

* Fouten te corrigeren
* Secties te verbeteren
* Nieuwe secties toevoegen
* [Vertalen](https://github.com/donnemartin/system-design-primer/issues/28)

Inhoud die nog wat verfijning nodig heeft, is geplaatst [onder ontwikkeling](#onder-ontwikkeling).

Bekijk de [Richtlijnen voor bijdragen](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).

## Index van systeemontwerponderwerpen

> Samenvattingen van verschillende systeemontwerponderwerpen, inclusief voor- en nadelen.  **Alles is een afweging**.
>
> Elke sectie bevat links naar meer diepgaande bronnen.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png">
  <br/>
</p>

* [Systeemontwerponderwerpen: begin hier](#system-design-topics-start-here)
    * [Stap 1: Bekijk de videolezing over schaalbaarheid](#step-1-review-the-scalability-video-lecture)
    * [Stap 2: Lees het artikel over schaalbaarheid](#step-2-review-the-scalability-article)
    * [Volgende stappen](#next-steps)
* [Prestaties vs schaalbaarheid](#performance-vs-scalability)
* [Latentie vs doorvoer](#latency-vs-throughput)
* [Beschikbaarheid vs consistentie](#availability-vs-consistency)
    * [CAP-theorema](#cap-theorem)
        * [CP - consistentie en partitie-tolerantie](#cp---consistency-and-partition-tolerance)
        * [AP - beschikbaarheid en partitie-tolerantie](#ap---availability-and-partition-tolerance)
* [Consistentiepatronen](#consistency-patterns)
    * [Zwakke consistentie](#weak-consistency)
    * [Eventuele consistentie](#eventual-consistency)
    * [Sterke consistentie](#strong-consistency)
* [Beschikbaarheids­patronen](#availability-patterns)
    * [Fail-over](#fail-over)
    * [Replicatie](#replication)
    * [Beschikbaarheid in cijfers](#availability-in-numbers)
* [Domeinnaamsysteem](#domain-name-system)
* [Content delivery network](#content-delivery-network)
    * [Push-CDNs](#push-cdns)
    * [Pull-CDNs](#pull-cdns)
* [Load balancer](#load-balancer)
    * [Actief-passief](#actief-passief)
    * [Actief-actief](#actief-actief)
    * [Laag 4 load balancing](#laag-4-load-balancing)
    * [Laag 7 load balancing](#laag-7-load-balancing)
    * [Horizontale schaalvergroting](#horizontale-schaalvergroting)
* [Reverse proxy (webserver)](#reverse-proxy-web-server)
    * [Load balancer vs reverse proxy](#load-balancer-vs-reverse-proxy)
* [Applicatielaag](#application-layer)
    * [Microservices](#microservices)
    * [Service discovery](#service-discovery)
* [Database](#database)
    * [Relationeel databasemanagementsysteem (RDBMS)](#relational-database-management-system-rdbms)
        * [Master-slave replicatie](#master-slave-replicatie)
        * [Master-master replicatie](#master-master-replicatie)
        * [Federatie](#federatie)
        * [Sharding](#sharding)
        * [Denormalisatie](#denormalisatie)
        * [SQL tuning](#sql-tuning)
    * [NoSQL](#nosql)
        * [Key-value store](#key-value-store)
        * [Document store](#document-store)
        * [Wide column store](#wide-column-store)
        * [Graph Database](#graph-database)
    * [SQL of NoSQL](#sql-or-nosql)
* [Cache](#cache)
    * [Client caching](#client-caching)
    * [CDN caching](#cdn-caching)
    * [Webserver caching](#web-server-caching)
    * [Database caching](#database-caching)
    * [Applicatie caching](#application-caching)
    * [Caching op het niveau van databasequery's](#caching-at-the-database-query-level)
    * [Caching op objectniveau](#caching-at-the-object-level)
    * [Wanneer de cache bijwerken](#when-to-update-the-cache)
        * [Cache-aside](#cache-aside)
        * [Write-through](#write-through)
        * [Write-behind (write-back)](#write-behind-write-back)
        * [Refresh-ahead](#refresh-ahead)
* [Asynchronisme](#asynchronism)
    * [Message queues](#message-queues)
    * [Taakwachtrijen](#taakwachtrijen)
    * [Terugdruk](#terugdruk)
* [Communicatie](#communicatie)
    * [Transmission Control Protocol (TCP)](#transmission-control-protocol-tcp)
    * [User Datagram Protocol (UDP)](#user-datagram-protocol-udp)
    * [Remote Procedure Call (RPC)](#remote-procedure-call-rpc)
    * [Representational State Transfer (REST)](#representational-state-transfer-rest)
* [Beveiliging](#beveiliging)
* [Appendix](#appendix)
    * [Tabel machten van twee](#tabel-machten-van-twee)
    * [Latentiecijfers die elke programmeur zou moeten kennen](#latentiecijfers-die-elke-programmeur-zou-moeten-kennen)
    * [Extra systeemontwerp interviewvragen](#extra-systeemontwerp-interviewvragen)
    * [Architecturen uit de echte wereld](#architecturen-uit-de-echte-wereld)
    * [Architecturen van bedrijven](#architecturen-van-bedrijven)
    * [Engineeringblogs van bedrijven](#engineeringblogs-van-bedrijven)
* [In ontwikkeling](#in-ontwikkeling)
* [Credits](#credits)
* [Contactinformatie](#contactinformatie)
* [Licentie](#licentie)

## Studiegids

> Voorgestelde onderwerpen om te herzien op basis van je interviewplanning (kort, middellang, lang).

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)

**V: Moet ik alles hier weten voor interviews?**

**A: Nee, je hoeft niet alles hier te weten om je voor te bereiden op het interview**.

Wat je gevraagd wordt in een interview hangt af van variabelen zoals:

* Hoeveel ervaring je hebt
* Wat je technische achtergrond is
* Voor welke functies je solliciteert
* Bij welke bedrijven je solliciteert
* Geluk

Meer ervaren kandidaten worden over het algemeen geacht meer te weten over systeemontwerp. Architecten of teamleads worden geacht meer te weten dan individuele medewerkers. Top techbedrijven hebben waarschijnlijk een of meer ontwerp-interviewrondes.

Begin breed en ga dieper in op enkele gebieden. Het is nuttig om een beetje te weten over verschillende belangrijke onderwerpen in systeemontwerp. Pas de volgende gids aan op basis van je tijdlijn, ervaring, voor welke functies je solliciteert, en bij welke bedrijven je solliciteert.

* **Korte tijdlijn** - Richt je op **breedte** bij systeemontwerp onderwerpen. Oefen door **enkele** interviewvragen op te lossen.
* **Middel lange tijdlijn** - Richt je op **breedte** en **enige diepte** bij systeemontwerp onderwerpen. Oefen door **veel** interviewvragen op te lossen.
* **Lange tijdlijn** - Richt je op **breedte** en **meer diepte** bij systeemontwerp onderwerpen. Oefen door **de meeste** interviewvragen op te lossen.

| | Kort | Middel | Lang |
|---|---|---|---|
| Lees de [Systeemontwerp onderwerpen](#index-of-system-design-topics) door om een breed begrip te krijgen van hoe systemen werken | :+1: | :+1: | :+1: |
| Lees enkele artikelen in de [Bedrijfs engineering blogs](#company-engineering-blogs) voor de bedrijven waar je solliciteert | :+1: | :+1: | :+1: |
| Lees enkele [Architecturen uit de praktijk](#real-world-architectures) door | :+1: | :+1: | :+1: |
| Bekijk [Hoe een systeemontwerp interviewvraag aan te pakken](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |
| Werk door [Systeemontwerp interviewvragen met oplossingen](#system-design-interview-questions-with-solutions) | Enkele | Veel | Meeste |
| Werk door [Object-georiënteerde ontwerp interviewvragen met oplossingen](#object-oriented-design-interview-questions-with-solutions) | Enkele | Veel | Meeste |
| Bekijk [Aanvullende systeemontwerp interviewvragen](#additional-system-design-interview-questions) | Enkele | Veel | Meeste |

## Hoe een systeemontwerp interviewvraag aan te pakken

> Hoe je een systeemontwerp interviewvraag aanpakt.

Het systeemontwerp interview is een **open gesprek**. Je wordt verwacht het gesprek te leiden.

Je kunt de volgende stappen gebruiken om het gesprek te sturen. Om dit proces te versterken, werk door de sectie [Systeemontwerp interviewvragen met oplossingen](#system-design-interview-questions-with-solutions) met de volgende stappen.

### Stap 1: Schets gebruiksscenario's, beperkingen en aannames

Verzamel eisen en bepaal de omvang van het probleem. Stel vragen om gebruiksscenario's en beperkingen te verduidelijken. Bespreek aannames.

* Wie gaat het gebruiken?
* Hoe gaan ze het gebruiken?
* Hoeveel gebruikers zijn er?
* Wat doet het systeem?
* Wat zijn de inputs en outputs van het systeem?
* Hoeveel data verwachten we te verwerken?
* Hoeveel verzoeken per seconde verwachten we?
* Wat is de verwachte lees-schrijf verhouding?

### Stap 2: Maak een hoog-niveau ontwerp

Schets een hoog-niveau ontwerp met alle belangrijke componenten.

* Schets de hoofdcomponenten en verbindingen
* Motiveer je ideeën

### Stap 3: Ontwerp kerncomponenten

Ga in op details voor elke kerncomponent.  Bijvoorbeeld, als je gevraagd werd om een [url-verkortingsdienst te ontwerpen](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), bespreek dan:

* Het genereren en opslaan van een hash van de volledige url
    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) en [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)
    * Hash-botsingen
    * SQL of NoSQL
    * Databaseschema
* Het vertalen van een gehashte url naar de volledige url
    * Database-opzoeking
* API- en objectgeoriënteerd ontwerp

### Stap 4: Schaal het ontwerp op

Identificeer en pak knelpunten aan, gegeven de beperkingen.  Heb je bijvoorbeeld het volgende nodig om schaalbaarheidsproblemen aan te pakken?

* Load balancer
* Horizontaal schalen
* Caching
* Database sharding

Bespreek mogelijke oplossingen en afwegingen.  Alles is een afweging.  Pak knelpunten aan met behulp van [principes van schaalbaar systeemontwerp](#index-of-system-design-topics).

### Berekeningen op de achterkant van een envelop

Het kan zijn dat je enkele schattingen met de hand moet maken.  Raadpleeg de [Appendix](#appendix) voor de volgende bronnen:

* [Gebruik berekeningen op de achterkant van een envelop](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)
* [Tabel machten van twee](#powers-of-two-table)
* [Latentiecijfers die elke programmeur moet weten](#latency-numbers-every-programmer-should-know)

### Bron(nen) en verdere literatuur

Bekijk de volgende links om een beter idee te krijgen van wat je kunt verwachten:

* [Hoe je een systems design interview kunt halen](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)
* [Het system design interview](http://www.hiredintech.com/system-design)
* [Introductie tot architectuur en systems design interviews](https://www.youtube.com/watch?v=ZgdS0EUmn70)
* [System design sjabloon](https://leetcode.com/discuss/career/229177/My-System-Design-Template)

## System design interview vragen met oplossingen

> Veelvoorkomende system design interviewvragen met voorbeeldbesprekingen, code en diagrammen.
>
> Oplossingen gekoppeld aan inhoud in de map `solutions/`.

| Vraag | |
|---|---|
| Ontwerp Pastebin.com (of Bit.ly) | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |
| Ontwerp de Twitter-tijdlijn en zoekfunctie (of Facebook-feed en zoekfunctie) | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |
| Ontwerp een webcrawler | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |
| Ontwerp Mint.com | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |
| Ontwerp de datastructuren voor een sociaal netwerk | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |
| Ontwerp een key-value store voor een zoekmachine | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |
| Ontwerp Amazons verkoopranking per categorie | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |
| Ontwerp een systeem dat schaalt naar miljoenen gebruikers op AWS | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |
| Voeg een system design vraag toe | [Bijdragen](#contributing) |

### Ontwerp Pastebin.com (of Bit.ly)

[Bekijk oefening en oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)

### Ontwerp de Twitter-tijdlijn en zoekfunctie (of Facebook-feed en zoekfunctie)

[Bekijk oefening en oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)

### Ontwerp een webcrawler

[Bekijk oefening en oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)

### Design Mint.com

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)

### Design the data structures for a social network

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)

### Design a key-value store for a search engine

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)

### Design Amazon's sales ranking by category feature

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)

### Design a system that scales to millions of users on AWS

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)

## Object-oriented design interview questions with solutions

> Common object-oriented design interview questions with sample discussions, code, and diagrams.
>
> Solutions linked to content in the `solutions/` folder.

>**Note: This section is under development**

| Question | |
|---|---|
| Ontwerp een hash map | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |
| Ontwerp een least recently used cache | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |
| Ontwerp een callcenter | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |
| Ontwerp een kaartspel | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |
| Ontwerp een parkeerplaats | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |
| Ontwerp een chatserver | [Oplossing](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |
| Ontwerp een circulaire array | [Bijdragen](#contributing)  |
| Voeg een objectgeoriënteerde ontwerpopgave toe | [Bijdragen](#contributing) |

## Systeemontwerp onderwerpen: begin hier

Nieuw met systeemontwerp?

Ten eerste heb je een basisbegrip nodig van algemene principes, leren wat ze zijn, hoe ze worden gebruikt, en hun voor- en nadelen.

### Stap 1: Bekijk de schaalbaarheidsvideolezing

[Schaalbaarheidslezing aan Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)

* Onderwerpen:
    * Verticaal schalen
    * Horizontaal schalen
    * Caching
    * Load balancing
    * Database replicatie
    * Database partitionering

### Stap 2: Bekijk het schaalbaarheidsartikel

[Schaalbaarheid](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)

* Onderwerpen:
    * [Clones](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
    * [Databases](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
    * [Caches](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
    * [Asynchronisme](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)

### Volgende stappen

Vervolgens bekijken we trade-offs op hoog niveau:

* **Performance** versus **schaalbaarheid**
* **Latentie** versus **doorvoer**
* **Beschikbaarheid** versus **consistentie**

Onthoud dat **alles een trade-off is**.

Daarna duiken we in meer specifieke onderwerpen zoals DNS, CDN's en load balancers.

## Performance versus schaalbaarheid

Een dienst is **schaalbaar** als deze leidt tot een verhoogde **performance** op een manier die proportioneel is aan de toegevoegde resources. Over het algemeen betekent het verhogen van de performance dat er meer eenheden werk worden bediend, maar het kan ook betekenen dat grotere eenheden werk worden verwerkt, bijvoorbeeld wanneer datasets groeien.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>

Een andere manier om naar performance versus schaalbaarheid te kijken:

* Als je een **performance** probleem hebt, is je systeem traag voor één gebruiker.
* Als je een **schaalbaarheids**probleem hebt, is je systeem snel voor één gebruiker maar traag bij zware belasting.

### Bron(nen) en verdere literatuur

* [Een woord over schaalbaarheid](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)
* [Schaalbaarheid, beschikbaarheid, stabiliteit, patronen](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)

## Latentie versus doorvoer

**Latentie** is de tijd die nodig is om een bepaalde actie uit te voeren of een resultaat te produceren.

**Doorvoer** is het aantal van dergelijke acties of resultaten per tijdseenheid.

Over het algemeen moet je streven naar **maximale doorvoer** met **acceptabele latentie**.

### Bron(nen) en verdere literatuur

* [Latentie versus doorvoer begrijpen](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)

## Beschikbaarheid versus consistentie

### CAP-theorema

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Bron: CAP theorem revisited</a></i>
</p>

In een gedistribueerd computersysteem kun je slechts twee van de volgende garanties ondersteunen:

* **Consistentie** - Elke leesactie ontvangt de meest recente schrijfbeurt of een foutmelding
* **Beschikbaarheid** - Elke aanvraag ontvangt een reactie, zonder garantie dat deze de meest recente versie van de informatie bevat
* **Partitioneringstolerantie** - Het systeem blijft functioneren ondanks willekeurige partitionering door netwerkstoringen

*Netwerken zijn niet betrouwbaar, dus je zult partitioneringstolerantie moeten ondersteunen. Je zult een software-afweging moeten maken tussen consistentie en beschikbaarheid.*

#### CP - consistentie en partitioneringstolerantie

Wachten op een reactie van het gescheiden knooppunt kan resulteren in een timeout-fout. CP is een goede keuze als je zakelijke behoeften atomische lees- en schrijfbeurten vereisen.

#### AP - beschikbaarheid en partitioneringstolerantie

Reacties leveren de meest direct beschikbare versie van de gegevens op elk knooppunt, wat mogelijk niet de nieuwste is. Schrijfacties kunnen enige tijd duren om te propagateren wanneer de partitionering is opgelost.

AP is een goede keuze als de zakelijke behoeften [eventuele consistentie](#eventual-consistency) toestaan of wanneer het systeem moet blijven werken ondanks externe fouten.

### Bron(nen) en verdere lectuur

* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)
* [Een eenvoudig Engelse introductie tot de CAP-theorema](http://ksat.me/a-plain-english-introduction-to-cap-theorem)
* [CAP FAQ](https://github.com/henryr/cap-faq)
* [Het CAP-theorema](https://www.youtube.com/watch?v=k-Yaq8AHlFA)

## Consistentiepatronen

Met meerdere kopieën van dezelfde gegevens staan we voor keuzes over hoe we ze synchroniseren zodat cliënten een consistent beeld van de gegevens hebben. Herinner je de definitie van consistentie uit het [CAP-theorema](#cap-theorem) - Elke leesactie ontvangt de meest recente schrijfbeurt of een fout.

### Zwakke consistentie

Na een schrijfbeurt kunnen leesacties deze wel of niet zien. Er wordt een best effort benadering genomen.

Deze aanpak zie je in systemen zoals memcached. Zwakke consistentie werkt goed in realtime use cases zoals VoIP, videochat en realtime multiplayer games. Bijvoorbeeld, als je aan het bellen bent en enkele seconden geen verbinding hebt, hoor je bij het terugkrijgen van de verbinding niet wat er gezegd is tijdens het verlies van de verbinding.

### Eventuele consistentie

Na een schrijfoperatie zullen lezers deze uiteindelijk zien (meestal binnen milliseconden). Gegevens worden asynchroon gerepliceerd.

Deze aanpak wordt gebruikt in systemen zoals DNS en e-mail. Eventuele consistentie werkt goed in systemen met hoge beschikbaarheid.

### Sterke consistentie

Na een schrijfoperatie zullen lezers deze direct zien. Gegevens worden synchroon gerepliceerd.

Deze aanpak wordt gebruikt in bestandssystemen en relationele databases. Sterke consistentie werkt goed in systemen die transacties vereisen.

### Bron(nen) en verdere literatuur

* [Transacties over datacenters](http://snarfed.org/transactions_across_datacenters_io.html)

## Beschikbaarheids­patronen

Er zijn twee complementaire patronen om hoge beschikbaarheid te ondersteunen: **failover** en **replicatie**.

### Failover

#### Actief-passief

Bij actief-passief failover worden hartslagen verstuurd tussen de actieve en passieve server in standby. Als de hartslag wordt onderbroken, neemt de passieve server het IP-adres van de actieve over en hervat de dienst.

De lengte van de downtime wordt bepaald door of de passieve server al draait in 'hot' standby of nog moet opstarten vanuit 'cold' standby. Alleen de actieve server verwerkt verkeer.

Actief-passief failover wordt ook wel master-slave failover genoemd.

#### Actief-actief

Bij actief-actief beheren beide servers het verkeer en verdelen ze de belasting.

Als de servers publiek toegankelijk zijn, moet de DNS op de hoogte zijn van de publieke IP-adressen van beide servers. Als de servers intern zijn, moet de applicatielogica beide servers kennen.

Actief-actief failover wordt ook wel master-master failover genoemd.

### Nadeel/Nadelen: failover
* Failover voegt meer hardware en extra complexiteit toe.
* Er is een potentieel voor dataverlies als het actieve systeem faalt voordat nieuw geschreven data naar het passieve systeem gerepliceerd kan worden.

### Reproductie

#### Master-slave en master-master

Dit onderwerp wordt verder besproken in de [Database](#database) sectie:

* [Master-slave-replicatie](#master-slave-replication)
* [Master-master-replicatie](#master-master-replication)

### Beschikbaarheid in cijfers

Beschikbaarheid wordt vaak gekwantificeerd door uptime (of downtime) als een percentage van de tijd dat de dienst beschikbaar is. Beschikbaarheid wordt meestal gemeten in aantal negens—een dienst met 99,99% beschikbaarheid wordt aangeduid als vier negens.

#### 99,9% beschikbaarheid - drie negens

| Duur                | Acceptabele uitvaltijd|
|---------------------|----------------------|
| Uitvaltijd per jaar | 8u 45min 57s         |
| Uitvaltijd per maand| 43m 49,7s            |
| Uitvaltijd per week | 10m 4,8s             |
| Uitvaltijd per dag  | 1m 26,4s             |

#### 99,99% beschikbaarheid - vier negens

| Duur                | Acceptabele uitvaltijd|
|---------------------|----------------------|
| Uitvaltijd per jaar | 52min 35,7s          |
| Uitvaltijd per maand| 4m 23s               |
| Uitvaltijd per week | 1m 5s                |
| Uitvaltijd per dag  | 8,6s                 |

#### Beschikbaarheid in parallel versus in serie

Als een dienst bestaat uit meerdere componenten die kunnen falen, hangt de totale beschikbaarheid van de dienst af van of de componenten in serie of parallel staan.

###### In serie

De algehele beschikbaarheid neemt af wanneer twee componenten met een beschikbaarheid < 100% in serie staan:


```
Availability (Total) = Availability (Foo) * Availability (Bar)
```

Als zowel `Foo` als `Bar` elk 99,9% beschikbaarheid hadden, zou hun totale beschikbaarheid in serie 99,8% zijn.

###### Parallel

De totale beschikbaarheid neemt toe wanneer twee componenten met een beschikbaarheid < 100% parallel staan:

```
Availability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))
```

Als zowel `Foo` als `Bar` elk 99,9% beschikbaarheid hadden, zou hun totale beschikbaarheid in parallel 99,9999% zijn.

## Domain Name System

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Bron: DNS beveiligingspresentatie</a></i>
</p>

Een Domain Name System (DNS) vertaalt een domeinnaam zoals www.example.com naar een IP-adres.

DNS is hiërarchisch, met enkele gezaghebbende servers op het hoogste niveau.  Je router of ISP geeft informatie over welke DNS-server(s) je moet contacteren bij een opzoeking.  Lagere DNS-servers cachen koppelingen, die verouderd kunnen raken door DNS-propagatievertragingen.  DNS-resultaten kunnen ook worden gecachet door je browser of besturingssysteem voor een bepaalde periode, bepaald door de [time to live (TTL)](https://nl.wikipedia.org/wiki/Time_to_live).

* **NS-record (name server)** - Specificeert de DNS-servers voor je domein/subdomein.
* **MX-record (mail exchange)** - Specificeert de mailservers voor het accepteren van berichten.
* **A-record (address)** - Verwijst een naam naar een IP-adres.
* **CNAME (canonical)** - Verwijst een naam naar een andere naam of `CNAME` (example.com naar www.example.com) of naar een `A`-record.

Diensten zoals [CloudFlare](https://www.cloudflare.com/dns/) en [Route 53](https://aws.amazon.com/route53/) bieden beheerde DNS-diensten.  Sommige DNS-diensten kunnen verkeer routeren via verschillende methoden:

* [Weighted round robin](https://www.jscape.com/blog/load-balancing-algorithms)
    * Voorkom dat verkeer naar servers gaat die in onderhoud zijn
    * Balans tussen verschillende cluster-groottes
    * A/B-testen
* [Latency-based](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)
* [Geolocatie-gebaseerd](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)

### Nadeel(en): DNS

* Toegang tot een DNS-server veroorzaakt een kleine vertraging, hoewel dit wordt verminderd door caching zoals hierboven beschreven.
* DNS-serverbeheer kan complex zijn en wordt doorgaans beheerd door [overheden, ISP's en grote bedrijven](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).
* DNS-diensten zijn onlangs doelwit geweest van [DDoS-aanvallen](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), waardoor gebruikers geen toegang hadden tot websites zoals Twitter zonder het IP-adres(sen) van Twitter te kennen.

### Bron(nen) en verdere literatuur

* [DNS-architectuur](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)
* [Wikipedia](https://nl.wikipedia.org/wiki/Domain_Name_System)
* [DNS-artikelen](https://support.dnsimple.com/categories/dns/)

## Content delivery network

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Bron: Waarom een CDN gebruiken</a></i>
</p>

Een content delivery network (CDN) is een wereldwijd verspreid netwerk van proxyservers die content leveren vanaf locaties dichter bij de gebruiker. Over het algemeen worden statische bestanden zoals HTML/CSS/JS, foto's en video's via CDN geleverd, hoewel sommige CDNs zoals Amazon's CloudFront ook dynamische content ondersteunen. De DNS-resolutie van de site vertelt cliënten welke server ze moeten benaderen.

Het leveren van content via CDNs kan de prestaties aanzienlijk verbeteren op twee manieren:

* Gebruikers ontvangen content van datacenters in hun nabijheid
* Je servers hoeven geen verzoeken te verwerken die door de CDN worden afgehandeld

### Push CDNs

Push CDNs ontvangen nieuwe content wanneer er wijzigingen plaatsvinden op je server. Je bent volledig verantwoordelijk voor het aanleveren van de content, uploadt deze direct naar de CDN en herschrijft URLs zodat ze naar de CDN verwijzen. Je kunt instellen wanneer content verloopt en wanneer deze wordt geüpdatet. Content wordt alleen geüpload als deze nieuw of gewijzigd is, wat het verkeer minimaliseert maar de opslag maximaliseert.

Sites met weinig verkeer of sites waarvan de content niet vaak wordt bijgewerkt, werken goed met push CDNs. Content wordt één keer naar de CDN gebracht, in plaats van op vaste tijdstippen opnieuw te worden opgehaald.

### Pull CDNs

Pull CDNs halen nieuwe content van je server wanneer de eerste gebruiker erom vraagt. Je laat de content op je eigen server staan en herschrijft URLs zodat ze naar de CDN verwijzen. Dit resulteert in een trager verzoek totdat de content op de CDN is gecached.

Een [time-to-live (TTL)](https://nl.wikipedia.org/wiki/Time_to_live) bepaalt hoe lang content wordt gecached. Pull CDNs minimaliseren de opslagruimte op de CDN, maar kunnen voor overbodig verkeer zorgen als bestanden verlopen en opnieuw worden opgehaald voordat ze daadwerkelijk zijn gewijzigd.

Sites met veel verkeer werken goed met pull CDNs, omdat het verkeer gelijkmatiger wordt verdeeld en alleen recent opgevraagde content op de CDN blijft.

### Nadelen: CDN

* CDN-kosten kunnen aanzienlijk zijn afhankelijk van het verkeer, hoewel dit moet worden afgewogen tegen extra kosten die je zou maken als je geen CDN gebruikt.
* Content kan verouderd zijn als het wordt bijgewerkt voordat de TTL verloopt.
* CDNs vereisen het wijzigen van URLs voor statische content zodat ze naar de CDN verwijzen.

### Bron(nen) en verdere literatuur

* [Wereldwijd verspreide content delivery](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)
* [De verschillen tussen push en pull CDNs](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)
* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)

## Load balancer

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Bron: Schaalbare systeemontwerp patronen</a></i>
</p>

Load balancers verdelen binnenkomende clientverzoeken over computerbronnen zoals applicatieservers en databases. In elk geval stuurt de load balancer het antwoord van de computerbron terug naar de juiste client. Load balancers zijn effectief bij:

* Voorkomen dat verzoeken naar ongezonde servers gaan
* Voorkomen van overbelasting van bronnen
* Helpen om een enkelvoudig faalpunt te elimineren

Load balancers kunnen worden geïmplementeerd met hardware (duur) of met software zoals HAProxy.

Extra voordelen zijn onder andere:

* **SSL-terminatie** - Ontsleutelt binnenkomende verzoeken en versleutelt serverantwoorden zodat backendservers deze mogelijk dure bewerkingen niet hoeven uit te voeren
    * Verwijdert de noodzaak om [X.509 certificaten](https://en.wikipedia.org/wiki/X.509) op elke server te installeren
* **Sessie persistentie** - Geeft cookies uit en leidt de verzoeken van een specifieke client naar dezelfde instantie indien de webapplicaties geen sessies bijhouden

Om te beschermen tegen storingen is het gebruikelijk om meerdere load balancers op te zetten, hetzij in [actief-passief](#active-passive) of [actief-actief](#active-active) modus.

Load balancers kunnen verkeer routeren op basis van verschillende criteria, waaronder:

* Willekeurig
* Minst belast
* Sessie/cookies
* [Round robin of gewogen round robin](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)
* [Laag 4](#layer-4-load-balancing)
* [Laag 7](#layer-7-load-balancing)

### Laag 4 load balancing

Laag 4 load balancers kijken naar informatie op de [transportlaag](#communication) om te beslissen hoe verzoeken te verdelen. Dit betreft doorgaans de bron-, bestemming-IP-adressen en poorten in de header, maar niet de inhoud van het pakket. Laag 4 load balancers sturen netwerkpakketten door naar en van de upstream-server en voeren [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/) uit.

### Laag 7 load balancing
Laag 7 load balancers kijken naar de [applicatielaag](#communication) om te bepalen hoe aanvragen worden verdeeld. Dit kan betrekking hebben op de inhoud van de header, het bericht en cookies. Laag 7 load balancers beëindigen netwerkverkeer, lezen het bericht, nemen een load-balancing beslissing en openen vervolgens een verbinding met de geselecteerde server. Een laag 7 load balancer kan bijvoorbeeld videoverkeer naar servers sturen die video's hosten, terwijl gevoeliger betalingsverkeer van gebruikers naar extra beveiligde servers wordt geleid.

Ten koste van flexibiliteit vereist load balancing op laag 4 minder tijd en rekenkracht dan op laag 7, hoewel de prestatie-impact op moderne standaardhardware minimaal kan zijn.

### Horizontaal schalen

Load balancers kunnen ook helpen met horizontaal schalen, wat prestaties en beschikbaarheid verbetert. Uitbreiden met standaardmachines is kostenefficiënter en resulteert in een hogere beschikbaarheid dan het opschalen van één enkele server op duurdere hardware, ook wel **Verticale Schaling** genoemd. Het is ook makkelijker om personeel te vinden voor standaardhardware dan voor gespecialiseerde bedrijfsystemen.

#### Nadeel(en): horizontaal schalen

* Horizontaal schalen introduceert complexiteit en omvat het klonen van servers
    * Servers moeten stateless zijn: ze mogen geen gebruikersgegevens bevatten zoals sessies of profielfoto's
    * Sessies kunnen worden opgeslagen in een gecentraliseerde opslag zoals een [database](#database) (SQL, NoSQL) of een persistente [cache](#cache) (Redis, Memcached)
* Downstream servers zoals caches en databases moeten meer gelijktijdige verbindingen aankunnen naarmate upstream servers worden uitgebreid

### Nadeel(en): load balancer

* De load balancer kan een prestatiedrempel worden als deze niet genoeg middelen heeft of niet goed geconfigureerd is.
* Het introduceren van een load balancer om een single point of failure te elimineren, zorgt voor meer complexiteit.
* Een enkele load balancer is een single point of failure; het configureren van meerdere load balancers verhoogt de complexiteit verder.

### Bron(nen) en verdere lectuur

* [NGINX architectuur](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy architectuurgids](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Schaalbaarheid](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
* [Wikipedia](https://nl.wikipedia.org/wiki/Load_balancing_(computing))
* [Laag 4 load balancing](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)
* [Laag 7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)
* [ELB listener config](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)

## Reverse proxy (webserver)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Bron: Wikipedia</a></i>
  <br/>
</p>

Een reverse proxy is een webserver die interne diensten centraliseert en uniforme interfaces aan het publiek aanbiedt. Verzoeken van clients worden doorgestuurd naar een server die het kan afhandelen, waarna de reverse proxy het antwoord van de server terugstuurt naar de client.

Aanvullende voordelen zijn onder andere:

* **Verhoogde veiligheid** - Verberg informatie over backend-servers, blokkeer IP-adressen, beperk het aantal verbindingen per client
* **Grotere schaalbaarheid en flexibiliteit** - Clients zien alleen het IP-adres van de reverse proxy, waardoor je servers kunt schalen of hun configuratie kunt wijzigen
* **SSL-terminatie** - Ontcijfer inkomende verzoeken en versleutel serverantwoorden zodat backend-servers deze mogelijk dure operaties niet hoeven uit te voeren
    * Verwijdert de noodzaak om [X.509-certificaten](https://en.wikipedia.org/wiki/X.509) op elke server te installeren
* **Compressie** - Comprimeer serverantwoorden
* **Caching** - Geef het antwoord op gecachte verzoeken terug
* **Statische content** - Bedien statische content direct
    * HTML/CSS/JS
    * Foto's
    * Video's
    * Etc

### Load balancer versus reverse proxy

* Het inzetten van een load balancer is nuttig wanneer je meerdere servers hebt. Vaak sturen load balancers verkeer naar een set servers met dezelfde functie.
* Reverse proxies kunnen ook nuttig zijn met slechts één webserver of applicatieserver, waardoor je de hierboven beschreven voordelen krijgt.
* Oplossingen zoals NGINX en HAProxy ondersteunen zowel layer 7 reverse proxying als load balancing.

### Nadeel/nadelen: reverse proxy

* Het introduceren van een reverse proxy zorgt voor verhoogde complexiteit.
* Een enkele reverse proxy is een single point of failure; het configureren van meerdere reverse proxies (bijvoorbeeld een [failover](https://en.wikipedia.org/wiki/Failover)) vergroot de complexiteit verder.

### Bron(nen) en verder lezen

* [Reverse proxy versus load balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)
* [NGINX-architectuur](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy architectuurgids](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)

## Applicatielaag

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png">
  <br/>

  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Bron: Introductie tot het ontwerpen van systemen voor schaalbaarheid</a></i>
</p>

Het scheiden van de weblaag van de applicatielaag (ook bekend als platformlaag) stelt je in staat beide lagen onafhankelijk te schalen en te configureren.  Het toevoegen van een nieuwe API leidt tot het toevoegen van applicatieservers zonder noodzakelijkerwijs extra webservers toe te voegen.  Het **single responsibility principle** pleit voor kleine en autonome services die samenwerken.  Kleine teams met kleine services kunnen agressiever plannen voor snelle groei.

Workers in de applicatielaag helpen ook bij het mogelijk maken van [asynchroniteit](#asynchronism).

### Microservices

Hieraan gerelateerd zijn [microservices](https://nl.wikipedia.org/wiki/Microservices), die omschreven kunnen worden als een verzameling onafhankelijk uitrolbare, kleine, modulaire services.  Elke service draait een uniek proces en communiceert via een goed gedefinieerd, lichtgewicht mechanisme om een zakelijk doel te dienen. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>

Pinterest zou bijvoorbeeld de volgende microservices kunnen hebben: gebruikersprofiel, volger, feed, zoekfunctie, foto uploaden, enzovoort.

### Service Discovery

Systemen zoals [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), en [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) kunnen services helpen elkaar te vinden door geregistreerde namen, adressen en poorten bij te houden.  [Health checks](https://www.consul.io/intro/getting-started/checks.html) helpen bij het verifiëren van de integriteit van services en worden vaak uitgevoerd via een [HTTP](#hypertext-transfer-protocol-http) endpoint.  Zowel Consul als Etcd hebben een ingebouwde [key-value store](#key-value-store) die nuttig kan zijn voor het opslaan van configuratiewaarden en andere gedeelde data.

### Nadelen: applicatielaag

* Het toevoegen van een applicatielaag met losjes gekoppelde services vereist een andere benadering vanuit architectuur-, operations- en procesperspectief (vs een monolithisch systeem).
* Microservices kunnen complexiteit toevoegen op het gebied van deployment en beheer.

### Bronnen en verdere literatuur

* [Introductie tot het ontwerpen van systemen voor schaalbaarheid](http://lethain.com/introduction-to-architecting-systems-for-scale)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Service oriented architecture](https://nl.wikipedia.org/wiki/Service-oriented_architecture)
* [Introductie tot Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)
* [Dit is wat je moet weten over het bouwen van microservices](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)

## Database

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Bron: Opschalen tot je eerste 10 miljoen gebruikers</a></i>
</p>

### Relationeel databasemanagementsysteem (RDBMS)

Een relationele database zoals SQL is een verzameling gegevens die in tabellen zijn georganiseerd.

**ACID** is een reeks eigenschappen van relationele database-[transacties](https://en.wikipedia.org/wiki/Database_transaction).

* **Atomiciteit** - Elke transactie is alles of niets
* **Consistentie** - Elke transactie brengt de database van één geldige toestand naar een andere
* **Isolatie** - Het gelijktijdig uitvoeren van transacties levert dezelfde resultaten op als wanneer de transacties serieel werden uitgevoerd
* **Duurzaamheid** - Zodra een transactie is bevestigd, blijft deze zo

Er zijn veel technieken om een relationele database te schalen: **master-slave replicatie**, **master-master replicatie**, **federatie**, **sharding**, **denormalisatie** en **SQL-tuning**.

#### Master-slave replicatie

De master verzorgt lees- en schrijfbewerkingen en replikeert schrijfbewerkingen naar één of meer slaves, die alleen leesbewerkingen uitvoeren. Slaves kunnen ook naar extra slaves repliceren in een boomstructuur. Als de master offline gaat, kan het systeem in alleen-lezen modus blijven werken totdat een slave tot master wordt gepromoveerd of een nieuwe master wordt voorzien.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Bron: Scalability, availability, stability, patterns</a></i>
</p>

##### Nadeel/nadelen: master-slave replicatie

* Extra logica is nodig om een slave tot master te promoveren.
* Zie [Nadeel/nadelen: replicatie](#disadvantages-replication) voor punten die betrekking hebben op **zowel** master-slave als master-master.

#### Master-master replicatie

Beide masters verzorgen lees- en schrijfbewerkingen en coördineren onderling bij schrijven. Als één van de masters uitvalt, kan het systeem blijven werken met zowel lezen als schrijven.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Bron: Scalability, availability, stability, patterns</a></i>
</p>

##### Nadeel/nadelen: master-master replicatie

* Je hebt een load balancer nodig of je moet wijzigingen aanbrengen in de applicatielogica om te bepalen waar te schrijven.
* De meeste master-master systemen zijn ofwel losjes consistent (ACID wordt geschonden) of hebben verhoogde schrijflatentie door synchronisatie.
* Conflictoplossing speelt een grotere rol naarmate er meer schrijfnodes worden toegevoegd en de latentie toeneemt.
* Zie [Nadeel(en): replicatie](#disadvantages-replication) voor punten die betrekking hebben op **zowel** master-slave als master-master.

##### Nadeel(en): replicatie

* Er is een potentieel voor dataverlies als de master faalt voordat nieuw geschreven data naar andere nodes kan worden gerepliceerd.
* Schrijfacties worden opnieuw afgespeeld op de leesreplica's. Als er veel schrijfacties zijn, kunnen de leesreplica's vertraging oplopen door het herhalen van schrijfacties en minder leesacties uitvoeren.
* Hoe meer lees-slaves, hoe meer je moet repliceren, wat leidt tot grotere replicatielag.
* Op sommige systemen kan schrijven naar de master meerdere threads starten om parallel te schrijven, terwijl leesreplica's alleen sequentieel schrijven met één thread ondersteunen.
* Replicatie vereist meer hardware en extra complexiteit.

##### Bron(nen) en verdere literatuur: replicatie

* [Schaalbaarheid, beschikbaarheid, stabiliteit, patronen](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Multi-master replicatie](https://en.wikipedia.org/wiki/Multi-master_replication)

#### Federatie

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Bron: Opschalen naar je eerste 10 miljoen gebruikers</a></i>
</p>

Federatie (of functionele partitionering) splitst databases op basis van functie. Bijvoorbeeld, in plaats van een enkele, monolithische database, kun je drie databases hebben: **forums**, **gebruikers** en **producten**, wat resulteert in minder lees- en schrijverkeer naar elke database en daardoor minder replicatielag. Kleinere databases zorgen ervoor dat meer data in het geheugen past, wat op zijn beurt leidt tot meer cache hits door verbeterde cache-lokaliteit. Omdat er geen centrale master is die schrijfacties serialiseert, kun je parallel schrijven, waardoor de throughput toeneemt.

##### Nadeel(en): federatie

* Federatie is niet effectief als je schema enorme functies of tabellen vereist.
* Je moet je applicatielogica aanpassen om te bepalen uit welke database je leest en schrijft.
* Het joinen van data uit twee databases is complexer met een [serverlink](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).
* Federatie vereist meer hardware en extra complexiteit.

##### Bron(nen) en verdere literatuur: federatie

* [Opschalen naar je eerste 10 miljoen gebruikers](https://www.youtube.com/watch?v=kKjm4ehYiMs)

#### Sharding

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Bron: Scalability, availability, stability, patterns</a></i>
</p>

Sharding verdeelt data over verschillende databases zodat elke database slechts een subset van de data beheert. Neem bijvoorbeeld een gebruikersdatabase: naarmate het aantal gebruikers toeneemt, worden er meer shards aan de cluster toegevoegd.

Net als bij de voordelen van [federatie](#federation), resulteert sharding in minder lees- en schrijverkeer, minder replicatie en meer cache-hits. Ook de indexgrootte wordt verkleind, wat over het algemeen de prestaties verbetert door snellere queries. Als één shard uitvalt, blijven de andere shards operationeel, hoewel je een vorm van replicatie wilt toevoegen om dataverlies te voorkomen. Net als bij federatie is er geen centrale master die schrijfacties serialiseert, waardoor je parallel kunt schrijven met een hogere throughput.

Veelgebruikte manieren om een tabel met gebruikers te sharden zijn op basis van de beginletter van de achternaam van de gebruiker of de geografische locatie van de gebruiker.

##### Nadeel/nadelen: sharding

* Je moet je applicatielogica aanpassen om met shards te werken, wat kan resulteren in complexe SQL-query's.
* De dataverdeling kan scheefgroeien binnen een shard. Bijvoorbeeld, een groep power users op een shard kan leiden tot een hogere belasting voor die shard ten opzichte van andere shards.
    * Herverdelen voegt extra complexiteit toe. Een shardingfunctie gebaseerd op [consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) kan de hoeveelheid overgedragen data verminderen.
* Het samenvoegen van data uit meerdere shards is complexer.
* Sharding vereist meer hardware en extra complexiteit.

##### Bron(nen) en verdiepende literatuur: sharding

* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)
* [Shard database architectuur](https://nl.wikipedia.org/wiki/Shard_(database_architecture))
* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)

#### Denormalisatie

Denormalisatie probeert de leesprestaties te verbeteren ten koste van wat schrijfprestaties. Redundante kopieën van de data worden in meerdere tabellen geschreven om dure joins te vermijden. Sommige RDBMS zoals [PostgreSQL](https://nl.wikipedia.org/wiki/PostgreSQL) en Oracle ondersteunen [materialized views](https://nl.wikipedia.org/wiki/Materialized_view), die het werk doen van het opslaan van redundante informatie en het consistent houden van kopieën.

Zodra data wordt gedistribueerd met technieken zoals [federatie](#federation) en [sharding](#sharding), maakt het beheren van joins over datacenters de complexiteit nog groter. Denormalisatie kan de noodzaak voor zulke complexe joins omzeilen.

In de meeste systemen zijn lezingen veel talrijker dan schrijfacties, bijvoorbeeld 100:1 of zelfs 1000:1. Een lezing die resulteert in een complexe database-join kan erg duur zijn, doordat er veel tijd aan schijfoperaties wordt besteed.

##### Nadeel/nadelen: denormalisatie

* Data wordt gedupliceerd.
* Constraints kunnen helpen om redundante kopieën van informatie synchroon te houden, maar verhogen de complexiteit van het databaseontwerp.
* Een gedennormaliseerde database onder zware schrijfbelasting kan slechter presteren dan een genormaliseerde variant.

###### Bron(nen) en verdiepende literatuur: denormalisatie

* [Denormalisatie](https://nl.wikipedia.org/wiki/Denormalisatie)

#### SQL-optimalisatie

SQL-optimalisatie is een breed onderwerp en er zijn veel [boeken](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) als referentie geschreven.

Het is belangrijk om te **benchmarken** en **profileren** om knelpunten te simuleren en te ontdekken.

* **Benchmark** - Simuleer situaties met hoge belasting met tools zoals [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).
* **Profileren** - Schakel tools in zoals het [slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) om prestatieproblemen te traceren.

Benchmarken en profileren kunnen wijzen op de volgende optimalisaties.

##### Schema optimaliseren

* MySQL dumpt naar disk in aaneengesloten blokken voor snelle toegang.
* Gebruik `CHAR` in plaats van `VARCHAR` voor velden met vaste lengte.
    * `CHAR` maakt snelle, willekeurige toegang mogelijk, terwijl bij `VARCHAR` eerst het einde van een string gevonden moet worden voordat je naar de volgende gaat.
* Gebruik `TEXT` voor grote tekstblokken zoals blogposts. `TEXT` maakt ook booleaanse zoekopdrachten mogelijk. Het gebruik van een `TEXT`-veld zorgt ervoor dat er een pointer op de schijf wordt opgeslagen die wordt gebruikt om het tekstblok te vinden.
* Gebruik `INT` voor grotere getallen tot 2^32 of 4 miljard.
* Gebruik `DECIMAL` voor valuta om fouten in drijvende-kommagetallen te voorkomen.
* Vermijd het opslaan van grote `BLOBS`, sla in plaats daarvan de locatie op waar het object te vinden is.
* `VARCHAR(255)` is het grootste aantal tekens dat kan worden geteld in een 8-bits getal, wat vaak het gebruik van een byte in sommige RDBMS maximaliseert.
* Stel waar mogelijk de `NOT NULL`-beperking in om [zoekprestaties te verbeteren](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).

##### Gebruik goede indexen

* Kolommen waarop je queryt (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) kunnen sneller zijn met indexen.
* Indexen worden meestal weergegeven als zelf-balancerende [B-boom](https://nl.wikipedia.org/wiki/B-boom) die data sorteert en zoeken, sequentiële toegang, invoegingen en verwijderingen in logaritmische tijd mogelijk maakt.
* Het plaatsen van een index kan ervoor zorgen dat de data in het geheugen blijft, wat meer ruimte vereist.
* Schrijfbewerkingen kunnen ook trager zijn omdat de index ook geüpdatet moet worden.
* Bij het laden van grote hoeveelheden data kan het sneller zijn om indexen uit te schakelen, de data te laden en daarna de indexen opnieuw op te bouwen.

##### Vermijd dure joins

* [Denormaliseer](#denormalisatie) waar de prestaties dit vereisen.

##### Partitioneer tabellen

* Splits een tabel op door hot spots in een aparte tabel te plaatsen om te helpen het in het geheugen te houden.

##### Stem de querycache af

* In sommige gevallen kan de [querycache](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) leiden tot [prestatieproblemen](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).

##### Bron(nen) en verdere literatuur: SQL tuning

* [Tips voor het optimaliseren van MySQL-query's](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)
* [Is er een goede reden waarom ik VARCHAR(255) zo vaak zie?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [Hoe beïnvloeden null-waarden de prestaties?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)

### NoSQL

NoSQL is een verzameling gegevensitems weergegeven in een **key-value store**, **document store**, **wide column store** of een **grafendatabase**. Gegevens zijn gedenormaliseerd en joins worden doorgaans in de applicatiecode uitgevoerd. De meeste NoSQL-stores missen echte ACID-transacties en geven de voorkeur aan [eventual consistency](#eventual-consistency).

**BASE** wordt vaak gebruikt om de eigenschappen van NoSQL-databases te beschrijven. In vergelijking met de [CAP Theorema](#cap-theorem), kiest BASE voor beschikbaarheid boven consistentie.

* **Basically available** - het systeem garandeert beschikbaarheid.
* **Soft state** - de toestand van het systeem kan in de loop van de tijd veranderen, zelfs zonder invoer.
* **Eventual consistency** - het systeem zal consistent worden over een bepaalde periode, mits het systeem in die periode geen invoer ontvangt.

Naast de keuze tussen [SQL of NoSQL](#sql-or-nosql), is het nuttig om te begrijpen welk type NoSQL-database het beste bij jouw gebruikssituatie(s) past. We bespreken **key-value stores**, **document stores**, **wide column stores** en **grafendatabases** in het volgende gedeelte.

#### Key-value store

> Abstractie: hashtabel

Een key-value store staat doorgaans O(1) lezen en schrijven toe en wordt vaak ondersteund door geheugen of SSD. Datastores kunnen sleutels in [lexicografische volgorde](https://en.wikipedia.org/wiki/Lexicographical_order) bewaren, waardoor efficiënte retrieval van sleutelbereiken mogelijk is. Key-value stores kunnen het opslaan van metadata bij een waarde toestaan.

Key-value stores bieden hoge prestaties en worden vaak gebruikt voor eenvoudige datamodellen of voor snel veranderende data, zoals een in-memory cachelaag. Omdat ze slechts een beperkte set aan bewerkingen bieden, verschuift de complexiteit naar de applicatielaag als er extra operaties nodig zijn.

Een key-value store vormt de basis voor complexere systemen zoals een document store, en in sommige gevallen een grafendatabase.

##### Bron(nen) en verdere literatuur: key-value store

* [Key-value database](https://en.wikipedia.org/wiki/Key-value_database)
* [Nadelen van key-value stores](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)
* [Redis-architectuur](http://qnimate.com/overview-of-redis-architecture/)
* [Memcached-architectuur](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)

#### Document store

> Abstractie: key-value store met documenten opgeslagen als waarden

Een document store is gericht op documenten (XML, JSON, binair, enz.), waarbij een document alle informatie voor een bepaald object opslaat. Document stores bieden API's of een querytaal om te zoeken op basis van de interne structuur van het document zelf. *Let op, veel key-value stores bevatten functies om met de metadata van een waarde te werken, waardoor de grenzen tussen deze twee opslagtypen vervagen.*

Afhankelijk van de onderliggende implementatie worden documenten georganiseerd via collecties, tags, metadata of mappen. Hoewel documenten georganiseerd of gegroepeerd kunnen worden, kunnen documenten velden bevatten die volledig verschillend zijn van elkaar.

Sommige document stores zoals [MongoDB](https://www.mongodb.com/mongodb-architecture) en [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) bieden ook een SQL-achtige taal om complexe queries uit te voeren. [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) ondersteunt zowel key-values als documenten.

Document stores bieden hoge flexibiliteit en worden vaak gebruikt voor het werken met af en toe veranderende data.

##### Bron(nen) en verdere literatuur: document store

* [Documentgeoriënteerde database](https://nl.wikipedia.org/wiki/Documentgeori%C3%ABnteerde_database)
* [MongoDB-architectuur](https://www.mongodb.com/mongodb-architecture)
* [CouchDB-architectuur](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Elasticsearch-architectuur](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)

#### Wide column store

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Bron: SQL & NoSQL, een korte geschiedenis</a></i>
</p>

> Abstractie: geneste map `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`

De basis eenheid van data in een wide column store is een kolom (naam/waarde-paar). Een kolom kan worden gegroepeerd in kolomfamilies (vergelijkbaar met een SQL-tabel). Super column families groeperen kolomfamilies verder. Je kunt elke kolom onafhankelijk benaderen met een rij-sleutel, en kolommen met dezelfde rij-sleutel vormen een rij. Elke waarde bevat een timestamp voor versiebeheer en conflictoplossing.

Google introduceerde [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) als de eerste wide column store, wat invloed had op de open-source [HBase](https://www.edureka.co/blog/hbase-architecture/) die vaak gebruikt wordt in het Hadoop-ecosysteem, en [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) van Facebook. Stores zoals BigTable, HBase en Cassandra houden sleutels in lexicografische volgorde bij, waardoor efficiënte opvraging van selectieve sleutelbereiken mogelijk is.

Wide column stores bieden hoge beschikbaarheid en hoge schaalbaarheid. Ze worden vaak gebruikt voor zeer grote datasets.

##### Bron(nen) en verdere literatuur: wide column store

* [SQL & NoSQL, een korte geschiedenis](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)
* [Bigtable-architectuur](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)
* [HBase-architectuur](https://www.edureka.co/blog/hbase-architecture/)
* [Cassandra-architectuur](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)

#### Grafendatabase

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png">
  <br/>
  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Bron: Grafendatabase</a></i>
</p>

> Abstractie: graaf

In een grafendatabase is elke knoop een record en elke boog een relatie tussen twee knopen. Grafendatabases zijn geoptimaliseerd om complexe relaties met veel vreemde sleutels of veel-naar-veel-relaties weer te geven.

Grafendatabases bieden hoge prestaties voor datamodellen met complexe relaties, zoals een sociaal netwerk. Ze zijn relatief nieuw en nog niet wijdverspreid gebruikt; het kan moeilijker zijn om ontwikkeltools en bronnen te vinden. Veel grafen zijn alleen toegankelijk via [REST API's](#representational-state-transfer-rest).

##### Bron(nen) en verdere literatuur: graaf

* [Grafendatabase](https://en.wikipedia.org/wiki/Graph_database)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)

#### Bron(nen) en verdere literatuur: NoSQL

* [Uitleg van base terminologie](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [NoSQL-databases: een overzicht en beslissingshulp](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [Schaalbaarheid](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [Introductie tot NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [NoSQL-patronen](http://horicky.blogspot.com/2009/11/nosql-patterns.html)

### SQL of NoSQL

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Bron: Overgang van RDBMS naar NoSQL</a></i>
</p>

Redenen voor **SQL**:

* Gestructureerde data
* Strikt schema
* Relationele data
* Behoefte aan complexe joins
* Transacties
* Duidelijke patronen voor schaalbaarheid
* Meer gevestigd: ontwikkelaars, community, code, tools, enz.
* Opzoeken via index is erg snel

Redenen voor **NoSQL**:

* Semi-gestructureerde data
* Dynamisch of flexibel schema
* Niet-relationele data
* Geen behoefte aan complexe joins
* Opslaan van vele TB (of PB) aan data
* Zeer data-intensieve workload
* Zeer hoge doorvoer voor IOPS

Voorbeelddata die goed geschikt is voor NoSQL:

* Snelle opname van clickstream- en logdata
* Leaderboard- of scoringsdata
* Tijdelijke data, zoals een winkelwagen
* Vaak geraadpleegde ('hot') tabellen
* Metadata/lookup-tabellen

##### Bron(nen) en verdere literatuur: SQL of NoSQL

* [Schaalbaar tot je eerste 10 miljoen gebruikers](https://www.youtube.com/watch?v=kKjm4ehYiMs)
* [SQL vs NoSQL verschillen](https://www.sitepoint.com/sql-vs-nosql-differences/)

## Cache

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Bron: Schaalbare systeemontwerppatronen</a></i>
</p>

Caching verbetert de laadtijden van pagina's en kan de belasting van uw servers en databases verminderen. In dit model zal de dispatcher eerst controleren of het verzoek eerder is gedaan en proberen het eerdere resultaat te vinden om terug te geven, om zo de daadwerkelijke uitvoering te besparen.

Databases profiteren vaak van een uniforme verdeling van lees- en schrijfbewerkingen over hun partities. Populaire items kunnen de verdeling verstoren, wat knelpunten veroorzaakt. Een cache voor een database kan helpen om onevenwichtige belasting en pieken in verkeer op te vangen.

### Client-caching

Caches kunnen zich bevinden aan de clientzijde (OS of browser), [serverzijde](#reverse-proxy-web-server), of in een aparte cachelaag.

### CDN-caching

[CDN's](#content-delivery-network) worden beschouwd als een type cache.

### Webserver-caching

[Reverse proxies](#reverse-proxy-web-server) en caches zoals [Varnish](https://www.varnish-cache.org/) kunnen statische en dynamische inhoud direct serveren. Webservers kunnen ook verzoeken cachen, waardoor ze antwoorden kunnen geven zonder applicatieservers te hoeven raadplegen.

### Database-caching

Uw database bevat meestal een bepaald niveau van caching in de standaardconfiguratie, geoptimaliseerd voor een generiek gebruiksscenario. Het aanpassen van deze instellingen voor specifieke gebruikspatronen kan de prestaties verder verbeteren.

### Applicatie-caching

In-memory caches zoals Memcached en Redis zijn key-value stores tussen uw applicatie en uw gegevensopslag. Omdat de gegevens in RAM worden gehouden, is het veel sneller dan typische databases waar gegevens op schijf worden opgeslagen. RAM is beperkter dan schijf, dus [cache-invalidatie](https://en.wikipedia.org/wiki/Cache_algorithms) algoritmes zoals [least recently used (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)) kunnen helpen om 'koude' items te verwijderen en 'hete' data in RAM te houden.

Redis heeft de volgende extra functies:

* Optie voor persistentie
* Ingebouwde datastructuren zoals gesorteerde sets en lijsten

Er zijn meerdere niveaus waarop u kunt cachen, die in twee algemene categorieën vallen: **databasequery's** en **objecten**:

* Rij-niveau
* Query-niveau
* Volledig gevormde serialiseerbare objecten
* Volledig gerenderde HTML

Over het algemeen moet u proberen bestandgebaseerde caching te vermijden, omdat dit het klonen en automatisch schalen bemoeilijkt.

### Caching op het niveau van databasequery's

Wanneer je de database bevraagt, hash je de query als een sleutel en sla je het resultaat op in de cache. Deze aanpak heeft te maken met problemen rondom verlopen:

* Moeilijk om een gecachet resultaat met complexe queries te verwijderen
* Als één stukje data verandert, zoals een tabelcel, moet je alle gecachete queries verwijderen die de gewijzigde cel kunnen bevatten

### Caching op objectniveau

Zie je data als een object, vergelijkbaar met wat je doet met je applicatiecode. Laat je applicatie de dataset uit de database samenstellen tot een klasse-instantie of een datastructuur(en):

* Verwijder het object uit de cache als de onderliggende data is gewijzigd
* Staat asynchrone verwerking toe: workers stellen objecten samen door het meest recente gecachete object te gebruiken

Suggesties voor wat je kunt cachen:

* Gebruikerssessies
* Volledig gerenderde webpagina's
* Activiteitenstromen
* Gebruikersgrafiekdata

### Wanneer de cache bijwerken

Aangezien je maar een beperkte hoeveelheid data in de cache kunt opslaan, moet je bepalen welke cache-update strategie het beste werkt voor jouw use case.

#### Cache-aside

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Bron: From cache to in-memory data grid</a></i>
</p>

De applicatie is verantwoordelijk voor het lezen en schrijven vanuit de opslag. De cache werkt niet direct samen met de opslag. De applicatie doet het volgende:

* Zoek naar een item in de cache, wat resulteert in een cache-miss
* Laad item uit de database
* Voeg item toe aan de cache
* Geef item terug

```python
def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```

[Memcached](https://memcached.org/) wordt doorgaans op deze manier gebruikt.

Latere uitlezingen van gegevens die aan de cache zijn toegevoegd, zijn snel. Cache-aside wordt ook wel lazy loading genoemd. Alleen opgevraagde gegevens worden gecachet, waardoor wordt voorkomen dat de cache vol raakt met niet-opgevraagde gegevens.

##### Nadeel(en): cache-aside

* Elke cache miss resulteert in drie bewerkingen, wat een merkbare vertraging kan veroorzaken.
* Gegevens kunnen verouderd raken als ze worden bijgewerkt in de database. Dit probleem wordt verminderd door een time-to-live (TTL) in te stellen, waardoor een update van het cache-item wordt afgedwongen, of door write-through te gebruiken.
* Wanneer een node faalt, wordt deze vervangen door een nieuwe, lege node, wat de latentie verhoogt.

#### Write-through

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Bron: Scalability, availability, stability, patterns</a></i>
</p>

De applicatie gebruikt de cache als hoofdgegevensopslag, waarbij het lezen en schrijven van gegevens via de cache verloopt, terwijl de cache verantwoordelijk is voor het lezen en schrijven naar de database:

* Applicatie voegt een item toe aan de cache of werkt deze bij
* Cache schrijft het item synchroon naar de datastore
* Retourneer

Applicatiecode:

```python
set_user(12345, {"foo":"bar"})
```

Cachecode:

```python
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```
Write-through is een trage algehele bewerking vanwege de schrijfbewerking, maar daaropvolgende lezingen van zojuist geschreven data zijn snel.  Gebruikers zijn over het algemeen toleranter voor latentie bij het bijwerken van data dan bij het lezen van data.  Data in de cache is niet verouderd.

##### Nadeel/nadelen: write through

* Wanneer er een nieuwe node wordt aangemaakt door een storing of opschaling, zal de nieuwe node geen items cachen totdat het item is bijgewerkt in de database.  Cache-aside in combinatie met write through kan dit probleem verminderen.
* De meeste geschreven data wordt mogelijk nooit gelezen, wat kan worden geminimaliseerd met een TTL.

#### Write-behind (write-back)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Bron: Scalability, availability, stability, patterns</a></i>
</p>

Bij write-behind voert de applicatie het volgende uit:

* Item toevoegen/bijwerken in de cache
* Item asynchroon schrijven naar de datastore, wat de schrijfprestaties verbetert

##### Nadeel/nadelen: write-behind

* Er kan dataverlies optreden als de cache uitvalt voordat de inhoud naar de datastore is weggeschreven.
* Het is complexer om write-behind te implementeren dan cache-aside of write-through.

#### Refresh-ahead

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Bron: From cache to in-memory data grid</a></i>
</p>

Je kunt de cache zo configureren dat deze automatisch elke recent geraadpleegde cache-entry ververst voordat deze verloopt.

Refresh-ahead kan resulteren in lagere latentie t.o.v. read-through als de cache nauwkeurig kan voorspellen welke items waarschijnlijk in de toekomst nodig zijn.

##### Nadeel/nadelen: refresh-ahead


* Het niet nauwkeurig voorspellen welke items waarschijnlijk in de toekomst nodig zullen zijn, kan leiden tot een lagere prestatie dan zonder refresh-ahead.

### Nadeel/nadelen: cache

* Consistentie moet worden behouden tussen caches en de bron van waarheid, zoals de database, door middel van [cache-invalidatie](https://nl.wikipedia.org/wiki/Cache_algoritmen).
* Cache-invalidatie is een lastig probleem, er is extra complexiteit verbonden aan het moment waarop de cache moet worden bijgewerkt.
* Er moeten applicatiewijzigingen worden doorgevoerd, zoals het toevoegen van Redis of memcached.

### Bron(nen) en verdere literatuur

* [Van cache naar in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [Schaalbare systeemontwerp-patronen](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [Introductie tot het ontwerpen van systemen voor schaalbaarheid](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [Schaalbaarheid, beschikbaarheid, stabiliteit, patronen](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Schaalbaarheid](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [AWS ElastiCache strategieën](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)
* [Wikipedia](https://nl.wikipedia.org/wiki/Cache_(computing))

## Asynchronisme

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Bron: Introductie tot het ontwerpen van systemen voor schaalbaarheid</a></i>
</p>

Asynchrone workflows helpen om verzoektijden te verkorten voor dure operaties die anders in-line zouden worden uitgevoerd. Ze kunnen ook helpen door tijdrovend werk vooraf uit te voeren, zoals periodieke aggregatie van data.

### Message queues

Message queues ontvangen, bewaren en leveren berichten. Als een operatie te traag is om in-line uit te voeren, kun je een message queue gebruiken met de volgende workflow:

* Een applicatie publiceert een taak naar de queue en meldt vervolgens de status aan de gebruiker
* Een worker haalt de taak uit de queue, verwerkt deze, en geeft daarna aan dat de taak voltooid is

De gebruiker wordt niet geblokkeerd en de taak wordt op de achtergrond verwerkt. Gedurende deze tijd kan de client eventueel een kleine hoeveelheid verwerking doen om het te laten lijken alsof de taak al voltooid is. Bijvoorbeeld: als je een tweet plaatst, kan deze direct op je tijdlijn verschijnen, maar kan het enige tijd duren voordat je tweet daadwerkelijk bij al je volgers is afgeleverd.

**[Redis](https://redis.io/)** is bruikbaar als eenvoudige message broker, maar berichten kunnen verloren gaan.

**[RabbitMQ](https://www.rabbitmq.com/)** is populair maar vereist dat je je aanpast aan het 'AMQP'-protocol en je eigen nodes beheert.
**[Amazon SQS](https://aws.amazon.com/sqs/)** is gehost maar kan hoge latentie hebben en berichten kunnen mogelijk dubbel worden afgeleverd.

### Taakwachtrijen

Taakwachtrijen ontvangen taken en de bijbehorende data, voeren deze uit en leveren vervolgens de resultaten af. Ze kunnen planning ondersteunen en worden gebruikt voor het uitvoeren van rekenintensieve taken op de achtergrond.

**[Celery](https://docs.celeryproject.org/en/stable/)** ondersteunt planning en heeft voornamelijk ondersteuning voor Python.

### Terugdruk (Back pressure)

Als wachtrijen aanzienlijk beginnen te groeien, kan de wachtrij groter worden dan het geheugen, wat leidt tot cache-misses, schijflezingen en zelfs tragere prestaties. [Terugdruk](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) kan helpen door de wachtrijgrootte te beperken, waardoor een hoge doorvoersnelheid en goede responstijden voor reeds aanwezige taken in de wachtrij behouden blijven. Zodra de wachtrij vol is, krijgen clients een 'server busy' of HTTP 503 statuscode om het later opnieuw te proberen. Clients kunnen het verzoek op een later tijdstip opnieuw proberen, eventueel met [exponentiële back-off](https://nl.wikipedia.org/wiki/Exponential_backoff).

### Nadeel/nadelen: asynchronisme

* Gebruiksscenario's zoals goedkope berekeningen en realtime workflows zijn mogelijk beter geschikt voor synchrone operaties, omdat het introduceren van wachtrijen vertragingen en complexiteit kan toevoegen.

### Bron(nen) en verdere lectuur

* [Het is allemaal een kwestie van cijfers](https://www.youtube.com/watch?v=1KRYH75wgy4)
* [Terugdruk toepassen bij overbelasting](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [Wet van Little](https://nl.wikipedia.org/wiki/Wet_van_Little)
* [Wat is het verschil tussen een berichtwachtrij en een taakwachtrij?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)

## Communicatie

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Bron: OSI 7 lagen model</a></i>
</p>

### Hypertext transfer protocol (HTTP)

HTTP is een methode voor het coderen en transporteren van data tussen een client en een server. Het is een request/response-protocol: clients sturen verzoeken en servers sturen antwoorden met relevante inhoud en statusinformatie over het verzoek. HTTP is zelfvoorzienend, waardoor verzoeken en antwoorden door veel tussenliggende routers en servers kunnen stromen die load balancing, caching, encryptie en compressie uitvoeren.

Een basale HTTP-aanvraag bestaat uit een werkwoord (methode) en een bron (endpoint). Hieronder staan gangbare HTTP-werkwoorden:

| Werkwoord | Beschrijving | Idempotent* | Veilig | Cachebaar |
|---|---|---|---|---|

| GET | Leest een resource | Ja | Ja | Ja |
| POST | Creëert een resource of start een proces dat gegevens verwerkt | Nee | Nee | Ja, als de reactie versheidsinformatie bevat |
| PUT | Creëert of vervangt een resource | Ja | Nee | Nee |
| PATCH | Past een resource gedeeltelijk aan | Nee | Nee | Ja, als de reactie versheidsinformatie bevat |
| DELETE | Verwijdert een resource | Ja | Nee | Nee |

*Kan meerdere keren worden aangeroepen zonder verschillende uitkomsten.

HTTP is een applicatielaagprotocol dat afhankelijk is van onderliggende protocollen zoals **TCP** en **UDP**.

#### Bron(nen) en verder lezen: HTTP

* [Wat is HTTP?](https://www.nginx.com/resources/glossary/http/)
* [Verschil tussen HTTP en TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [Verschil tussen PUT en PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)

### Transmission Control Protocol (TCP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Bron: How to make a multiplayer game</a></i>
</p>

TCP is een verbindingsgericht protocol via een [IP-netwerk](https://en.wikipedia.org/wiki/Internet_Protocol).  Verbinding wordt opgezet en beëindigd met een [handshake](https://en.wikipedia.org/wiki/Handshaking).  Alle verzonden pakketten worden gegarandeerd in de originele volgorde en zonder fouten afgeleverd door:

* Sequentienummers en [checksumvelden](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) voor elk pakket
* [Bevestigings](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks))pakketten en automatische hertransmissie

Als de verzender geen correcte reactie ontvangt, stuurt hij de pakketten opnieuw.  Bij meerdere time-outs wordt de verbinding beëindigd.  TCP implementeert ook [flow control](https://en.wikipedia.org/wiki/Flow_control_(data)) en [congestion control](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control).  Deze garanties veroorzaken vertragingen en resulteren doorgaans in minder efficiënte transmissie dan UDP.

Om een hoge doorvoersnelheid te garanderen, kunnen webservers een groot aantal TCP-verbindingen open houden, wat leidt tot hoog geheugengebruik.  Het kan kostbaar zijn om veel open verbindingen te hebben tussen webserverthreads en bijvoorbeeld een [memcached](https://memcached.org/) server.  [Connection pooling](https://en.wikipedia.org/wiki/Connection_pool) kan helpen, naast overschakelen op UDP waar mogelijk.

TCP is nuttig voor toepassingen die hoge betrouwbaarheid vereisen, maar minder tijdkritisch zijn.  Enkele voorbeelden zijn webservers, database-informatie, SMTP, FTP en SSH.

Gebruik TCP boven UDP wanneer:

* Je wilt dat alle gegevens intact aankomen
* Je automatisch het beste gebruik van de netwerkdoorvoer wilt maken

### User datagram protocol (UDP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Bron: Hoe maak je een multiplayer spel</a></i>
</p>

UDP is verbindingloos. Datagrammen (vergelijkbaar met pakketten) zijn alleen gegarandeerd op het niveau van het datagram. Datagrammen kunnen hun bestemming in verkeerde volgorde bereiken of helemaal niet. UDP ondersteunt geen congestiecontrole. Zonder de garanties die TCP biedt, is UDP over het algemeen efficiënter.

UDP kan broadcasten, datagrammen versturen naar alle apparaten op het subnet. Dit is handig bij [DHCP](https://nl.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) omdat de client nog geen IP-adres heeft ontvangen, waardoor TCP niet kan streamen zonder het IP-adres.

UDP is minder betrouwbaar maar werkt goed in real-time toepassingen zoals VoIP, videochat, streaming en realtime multiplayer games.

Gebruik UDP boven TCP wanneer:

* Je de laagste latency nodig hebt
* Late gegevens zijn erger dan verlies van gegevens
* Je je eigen foutcorrectie wilt implementeren

#### Bron(nen) en verdere lectuur: TCP en UDP

* [Netwerken voor game-programmering](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)
* [Belangrijkste verschillen tussen TCP- en UDP-protocollen](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Verschil tussen TCP en UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Transmission control protocol](https://nl.wikipedia.org/wiki/Transmission_Control_Protocol)
* [User datagram protocol](https://nl.wikipedia.org/wiki/User_Datagram_Protocol)
* [Memcache schalen bij Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)

### Remote procedure call (RPC)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Bron: Crack the system design interview</a></i>
</p>

Bij een RPC zorgt een client ervoor dat een procedure wordt uitgevoerd op een ander adresruimte, meestal een externe server. De procedure wordt gecodeerd alsof het een lokale procedure-aanroep is, waarbij de details van de communicatie met de server voor het clientprogramma worden geabstraheerd. Externe aanroepen zijn meestal trager en minder betrouwbaar dan lokale aanroepen, dus het is nuttig om RPC-aanroepen te onderscheiden van lokale aanroepen. Populaire RPC-frameworks zijn onder andere [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/) en [Avro](https://avro.apache.org/docs/current/).

RPC is een request-response protocol:

* **Clientprogramma** - Roept de client-stubprocedure aan. De parameters worden op de stack geplaatst zoals bij een lokale procedureaanroep.
* **Client-stubprocedure** - Verpakt (marshalt) het procedure-ID en de argumenten in een verzoekbericht.
* **Communicatiemodule cliënt** - Het besturingssysteem verzendt het bericht van de cliënt naar de server.
* **Communicatiemodule server** - Het besturingssysteem geeft de binnenkomende pakketten door aan de server-stubprocedure.
* **Server-stubprocedure** - Haalt de resultaten uit elkaar (unmarshalt), roept de serverprocedure aan die overeenkomt met het procedure-ID en geeft de meegegeven argumenten door.
* De serverreactie herhaalt bovenstaande stappen in omgekeerde volgorde.

Voorbeelden van RPC-aanroepen:

```
GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
```

RPC is gericht op het blootleggen van gedragingen. RPC's worden vaak gebruikt om prestatie-redenen bij interne communicatie, omdat je native aanroepen handmatig kunt aanpassen aan je use-cases.

Kies een native bibliotheek (ook wel SDK) wanneer:

* Je weet wat je doelsysteem is.
* Je wilt controleren hoe je "logica" toegankelijk is.
* Je wilt controleren hoe foutafhandeling buiten je bibliotheek gebeurt.
* Prestaties en gebruikerservaring zijn je primaire zorg.

HTTP-API's volgens **REST** worden vaker gebruikt voor publieke API's.

#### Nadelen: RPC

* RPC-clients worden sterk gekoppeld aan de implementatie van de service.
* Voor elke nieuwe operatie of use-case moet een nieuwe API worden gedefinieerd.
* Het kan lastig zijn om RPC te debuggen.
* Mogelijk kun je bestaande technologieën niet direct gebruiken. Bijvoorbeeld, het kan extra inspanning kosten om te zorgen dat [RPC-aanroepen correct worden gecached](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) op caching servers zoals [Squid](http://www.squid-cache.org/).

### Representational state transfer (REST)

REST is een architecturale stijl die een client/server-model afdwingt waarbij de client werkt op een set resources beheerd door de server. De server biedt een representatie van resources en acties die resources kunnen manipuleren of een nieuwe representatie kunnen ophalen. Alle communicatie moet stateless en cachebaar zijn.

Er zijn vier kwaliteiten van een RESTful interface:

* **Identificeer resources (URI in HTTP)** - gebruik dezelfde URI ongeacht de operatie.
* **Wijzig met representaties (Werkwoorden in HTTP)** - gebruik werkwoorden, headers en body.
* **Zelfbeschrijvende foutmelding (statusrespons in HTTP)** - Gebruik statuscodes, bedenk het wiel niet opnieuw.
* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML-interface voor HTTP)** - je webservice moet volledig toegankelijk zijn in een browser.

Voorbeeld REST-aanroepen:

```
GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
```
REST is gericht op het beschikbaar stellen van data. Het minimaliseert de koppeling tussen client/server en wordt vaak gebruikt voor publieke HTTP API's. REST gebruikt een meer generieke en uniforme methode om resources bloot te stellen via URI's, [representatie via headers](https://github.com/for-GET/know-your-http-well/blob/master/headers.md), en acties via werkwoorden zoals GET, POST, PUT, DELETE en PATCH. Omdat het stateloos is, is REST uitstekend voor horizontale schaalbaarheid en partitionering.

#### Nadeel/nadelen: REST

* Omdat REST zich richt op het beschikbaar stellen van data, is het misschien niet geschikt als resources niet op natuurlijke wijze georganiseerd zijn of niet eenvoudig via een hiërarchie benaderd kunnen worden. Bijvoorbeeld, het teruggeven van alle bijgewerkte records van het afgelopen uur die overeenkomen met een bepaalde set gebeurtenissen is niet eenvoudig uit te drukken als een pad. Bij REST wordt dit waarschijnlijk geïmplementeerd met een combinatie van URI-pad, queryparameters en mogelijk de request body.
* REST vertrouwt doorgaans op een paar werkwoorden (GET, POST, PUT, DELETE en PATCH) die soms niet bij je use case passen. Bijvoorbeeld, het verplaatsen van verlopen documenten naar de archiefmap past misschien niet goed binnen deze werkwoorden.
* Het ophalen van ingewikkelde resources met geneste hiërarchieën vereist meerdere roundtrips tussen client en server om één enkele view weer te geven, bijvoorbeeld het ophalen van de inhoud van een blogbericht en de reacties op dat bericht. Voor mobiele applicaties die werken onder wisselende netwerkcondities zijn deze meerdere roundtrips zeer ongewenst.
* Na verloop van tijd kunnen er meer velden worden toegevoegd aan een API-respons en oudere clients ontvangen dan alle nieuwe datavelden, zelfs diegene die ze niet nodig hebben, wat leidt tot een opgeblazen payload en grotere latenties.

### Vergelijking RPC- en REST-aanroepen

| Operatie | RPC | REST |
|---|---|---|
| Aanmelden    | **POST** /signup | **POST** /persons |
| Afmelden    | **POST** /resign<br/>{<br/>"personid": "1234"<br/>} | **DELETE** /persons/1234 |
| Lees een persoon | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |
| Lees de itemlijst van een persoon | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |
| Voeg een item toe aan de items van een persoon | **POST** /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | **POST** /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Update een item    | **POST** /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | **PUT** /items/456<br/>{<br/>"key": "value"<br/>} |
| Verwijder een item | **POST** /removeItem<br/>{<br/>"itemid": "456"<br/>} | **DELETE** /items/456 |

<p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Bron: Weet je echt waarom je REST verkiest boven RPC?</a></i>
</p>

#### Bron(nen) en verder lezen: REST en RPC

* [Weet je echt waarom je REST verkiest boven RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [Wanneer zijn RPC-achtige benaderingen geschikter dan REST?](http://programmers.stackexchange.com/a/181186)
* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [Mythes over RPC en REST ontkracht](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)
* [Wat zijn de nadelen van het gebruik van REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Kraak het system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Thrift](https://code.facebook.com/posts/1468950976659943/)
* [Waarom REST voor intern gebruik en niet RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)

## Beveiliging

Deze sectie kan wel wat updates gebruiken. Overweeg om [bij te dragen](#contributing)!


Beveiliging is een breed onderwerp. Tenzij je aanzienlijke ervaring hebt, een achtergrond in beveiliging, of solliciteert naar een functie die kennis van beveiliging vereist, hoef je waarschijnlijk niet meer te weten dan de basis:

* Versleutel tijdens transport en opslag.
* Sanitize alle gebruikersinvoer of elke invoerparameter die aan de gebruiker wordt blootgesteld om [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) en [SQL-injectie](https://en.wikipedia.org/wiki/SQL_injection) te voorkomen.
* Gebruik geparameteriseerde queries om SQL-injectie te voorkomen.
* Gebruik het principe van [least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege).

### Bron(nen) en verdere literatuur

* [API-beveiligingschecklist](https://github.com/shieldfy/API-Security-Checklist)
* [Beveiligingsgids voor ontwikkelaars](https://github.com/FallibleInc/security-guide-for-developers)
* [OWASP top tien](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)

## Appendix

Je zult soms worden gevraagd om 'back-of-the-envelope' schattingen te maken. Bijvoorbeeld, je moet misschien bepalen hoe lang het duurt om 100 afbeeldingsminiaturen van schijf te genereren of hoeveel geheugen een datastructuur zal innemen. De **Twee machten-tabel** en **Latentiecijfers die elke programmeur zou moeten kennen** zijn handige referenties.

### Twee machten-tabel

```
Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
```

#### Bron(nen) en verdere literatuur

* [Machten van twee](https://nl.wikipedia.org/wiki/Macht_van_twee)

### Latency-cijfers die elke programmeur zou moeten kennen

```
Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
HDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
```
Handige statistieken gebaseerd op bovenstaande cijfers:

* Sequentieel lezen van HDD met 30 MB/s
* Sequentieel lezen via 1 Gbps Ethernet met 100 MB/s
* Sequentieel lezen van SSD met 1 GB/s
* Sequentieel lezen uit hoofdgeheugen met 4 GB/s
* 6-7 wereldwijde roundtrips per seconde
* 2.000 roundtrips per seconde binnen een datacenter

#### Latentiegetallen gevisualiseerd

![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)

#### Bron(nen) en verdere literatuur

* [Latentiegetallen die elke programmeur zou moeten weten - 1](https://gist.github.com/jboner/2841832)
* [Latentiegetallen die elke programmeur zou moeten weten - 2](https://gist.github.com/hellerbarde/2843375)
* [Ontwerpen, lessen en advies uit het bouwen van grote gedistribueerde systemen](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)
* [Advies software engineering uit het bouwen van grootschalige gedistribueerde systemen](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)

### Extra systeemontwerp interviewvragen

> Veelvoorkomende systeemontwerp interviewvragen, met links naar bronnen over hoe je ze oplost.

| Vraag | Referentie(s) |
|---|---|
| Ontwerp een bestandsynchronisatieservice zoals Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| Ontwerp een zoekmachine zoals Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |
| Ontwerp een schaalbare webcrawler zoals Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |
| Ontwerp Google docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |
| Ontwerp een key-value store zoals Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| Ontwerp een cachesysteem zoals Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Ontwerp een aanbevelingssysteem zoals dat van Amazon | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |
| Ontwerp een tinyurl systeem zoals Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |
| Ontwerp een chatapp zoals WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)
| Ontwerp een fotosharing systeem zoals Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |
| Ontwerp de Facebook nieuwsfeed functie | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |
| Ontwerp de Facebook tijdlijnfunctie | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |
| Ontwerp de Facebook chatfunctie | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |

| Ontwerp een grafzoekfunctie zoals die van Facebook | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |
| Ontwerp een content delivery network zoals CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |
| Ontwerp een trending topic systeem zoals dat van Twitter | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |
| Ontwerp een willekeurig ID-generatiesysteem | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |
| Geef de top k verzoeken terug binnen een tijdsinterval | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |
| Ontwerp een systeem dat data uit meerdere datacenters serveert | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |
| Ontwerp een online multiplayer kaartspel | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |
| Ontwerp een garbage collection systeem | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |
| Ontwerp een API rate limiter | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |
| Ontwerp een effectenbeurs (zoals NASDAQ of Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |
| Voeg een systeemontwerpvraag toe | [Bijdragen](#contributing) |

### Architecturen uit de echte wereld

> Artikelen over hoe systemen uit de echte wereld zijn ontworpen.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Bron: Twitter tijdlijnen op schaal</a></i>
</p>

**Focus niet op de kleine details in de volgende artikelen, maar:**

* Identificeer gedeelde principes, gemeenschappelijke technologieën en patronen binnen deze artikelen
* Bestudeer welke problemen door elk component worden opgelost, waar het werkt en waar niet
* Bekijk de geleerde lessen

|Type | Systeem | Referentie(s) |
|---|---|---|
| Data verwerking | **MapReduce** - Gedistribueerde dataverwerking van Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |
| Data verwerking | **Spark** - Gedistribueerde dataverwerking van Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |
| Data verwerking | **Storm** - Gedistribueerde dataverwerking van Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |
| | | |
| Data opslag | **Bigtable** - Gedistribueerde kolom-georiënteerde database van Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |
| Data opslag | **HBase** - Open source implementatie van Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |
| Data opslag | **Cassandra** - Gedistribueerde kolom-georiënteerde database van Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)
| Data opslag | **DynamoDB** - Document-georiënteerde database van Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |
| Data opslag | **MongoDB** - Document-georiënteerde database | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |
| Data opslag | **Spanner** - Mondiaal gedistribueerde database van Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |
| Dataopslag | **Memcached** - Gedistribueerd geheugen caching systeem | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Dataopslag | **Redis** - Gedistribueerd geheugen caching systeem met persistentie en waardetypen | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| | | |
| Bestandssysteem | **Google File System (GFS)** - Gedistribueerd bestandssysteem | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |
| Bestandssysteem | **Hadoop File System (HDFS)** - Open source implementatie van GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |
| | | |
| Diversen | **Chubby** - Lockservice voor losgekoppelde gedistribueerde systemen van Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |
| Diversen | **Dapper** - Gedistribueerde systemen tracing infrastructuur | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)
| Diversen | **Kafka** - Pub/sub berichtenwachtrij van LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |
| Diversen | **Zookeeper** - Gecentraliseerde infrastructuur en diensten voor synchronisatie | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |
| | Voeg een architectuur toe | [Bijdragen](#contributing) |

### Bedrijfsarchitecturen

| Bedrijf | Referentie(s) |
|---|---|
| Amazon | [Amazon architectuur](http://highscalability.com/amazon-architecture) |
| Cinchcast | [Dagelijks 1.500 uur audio produceren](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |
| DataSift | [Realtime datamining bij 120.000 tweets per seconde](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |
| Dropbox | [Hoe we Dropbox hebben opgeschaald](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| ESPN | [Werken op 100.000 duh nuh nuhs per seconde](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |
| Google | [Google architectuur](http://highscalability.com/google-architecture) |
| Instagram | [14 miljoen gebruikers, terabytes aan foto's](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Wat Instagram aandrijft](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |
| Justin.tv | [Live video-uitzendarchitectuur van Justin.tv](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |
| Facebook | [Memcached opschalen bij Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebook’s gedistribueerde datastore voor het sociale netwerk](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook’s foto-opslag](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Hoe Facebook Live streams naar 800.000 gelijktijdige kijkers](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |
| Flickr | [Flickr architectuur](http://highscalability.com/flickr-architecture) |
| Mailbox | [Van 0 naar een miljoen gebruikers in 6 weken](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |
| Netflix | [Een 360 graden blik op de volledige Netflix stack](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: Wat gebeurt er als je op Play drukt?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |
| Pinterest | [Van 0 naar tientallen miljarden pageviews per maand](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 miljoen bezoekers, 10x groei, 12 werknemers](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |
| Playfish | [50 miljoen maandelijkse gebruikers en groeiend](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |
| PlentyOfFish | [PlentyOfFish architectuur](http://highscalability.com/plentyoffish-architecture) |
| Salesforce | [Hoe ze 1,3 miljard transacties per dag verwerken](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |
| Stack Overflow | [Stack Overflow architectuur](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |
| TripAdvisor | [40M bezoekers, 200M dynamische pageviews, 30TB data](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |
| Tumblr | [15 miljard pageviews per maand](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |
| Twitter | [Twitter 10.000 procent sneller maken](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[250 miljoen tweets per dag opslaan met MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M actieve gebruikers, 300K QPS, een 22 MB/S firehose](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Tijdlijnen op schaal](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Big en small data bij Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operaties bij Twitter: opschalen tot boven de 100 miljoen gebruikers](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[Hoe Twitter 3.000 afbeeldingen per seconde verwerkt](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |
| Uber | [Hoe Uber hun realtime marktplaats platform opschaalt](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lessen van het opschalen van Uber naar 2000 engineers, 1000 services, en 8000 Git repositories](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |
| WhatsApp | [De WhatsApp architectuur die Facebook kocht voor $19 miljard](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| YouTube | [YouTube schaalbaarheid](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube architectuur](http://highscalability.com/youtube-architecture) |

### Engineering blogs van bedrijven

> Architecturen voor bedrijven waar je solliciteert.
>
> Vragen die je tegenkomt kunnen uit hetzelfde domein komen.

* [Airbnb Engineering](http://nerds.airbnb.com/)
* [Atlassian Developers](https://developer.atlassian.com/blog/)
* [AWS Blog](https://aws.amazon.com/blogs/aws/)
* [Bitly Engineering Blog](http://word.bitly.com/)
* [Box Blogs](https://blog.box.com/blog/category/engineering)
* [Cloudera Developer Blog](http://blog.cloudera.com/)
* [Dropbox Tech Blog](https://tech.dropbox.com/)
* [Engineering at Quora](https://www.quora.com/q/quoraengineering)
* [Ebay Tech Blog](http://www.ebaytechblog.com/)
* [Evernote Tech Blog](https://blog.evernote.com/tech/)
* [Etsy Code as Craft](http://codeascraft.com/)
* [Facebook Engineering](https://www.facebook.com/Engineering)
* [Flickr Code](http://code.flickr.net/)
* [Foursquare Engineering Blog](http://engineering.foursquare.com/)
* [GitHub Engineering Blog](https://github.blog/category/engineering)
* [Google Research Blog](http://googleresearch.blogspot.com/)
* [Groupon Engineering Blog](https://engineering.groupon.com/)
* [Heroku Engineering Blog](https://engineering.heroku.com/)
* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)
* [High Scalability](http://highscalability.com/)
* [Instagram Engineering](http://instagram-engineering.tumblr.com/)
* [Intel Software Blog](https://software.intel.com/en-us/blogs/)
* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)
* [LinkedIn Engineering](http://engineering.linkedin.com/blog)
* [Microsoft Engineering](https://engineering.microsoft.com/)
* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)
* [Netflix Tech Blog](http://techblog.netflix.com/)
* [Paypal Developer Blog](https://medium.com/paypal-engineering)
* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)
* [Reddit Blog](http://www.redditblog.com/)
* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)
* [Slack Engineering Blog](https://slack.engineering/)
* [Spotify Labs](https://labs.spotify.com/)
* [Stripe Engineering Blog](https://stripe.com/blog/engineering)
* [Twilio Engineering Blog](http://www.twilio.com/engineering)
* [Twitter Engineering](https://blog.twitter.com/engineering/)
* [Uber Engineering Blog](http://eng.uber.com/)
* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)
* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)
* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)

#### Bron(nen) en verder lezen

Wil je een blog toevoegen? Om dubbel werk te voorkomen, overweeg dan om de blog van jouw bedrijf toe te voegen aan de volgende repo:

* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)

## In ontwikkeling

Geïnteresseerd om een sectie toe te voegen of te helpen met het afronden van een sectie die nog in ontwikkeling is? [Draag bij](#contributing)!

* Gedistribueerd rekenen met MapReduce
* Consistente hashing
* Scatter gather
* [Draag bij](#contributing)

## Dankbetuigingen

Dankbetuigingen en bronnen zijn door deze repo heen vermeld.

Speciale dank aan:

* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)
* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)
* [High scalability](http://highscalability.com/)
* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)
* [shashank88/system_design](https://github.com/shashank88/system_design)
* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)
* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
* [A distributed systems reading list](http://dancres.github.io/Pages/)
* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)

## Contactinformatie

Neem gerust contact met mij op om eventuele problemen, vragen of opmerkingen te bespreken.

Mijn contactgegevens zijn te vinden op mijn [GitHub-pagina](https://github.com/donnemartin).

## Licentie

*Ik stel code en bronnen in deze repository aan u beschikbaar onder een open source-licentie. Omdat dit mijn persoonlijke repository is, ontvangt u de licentie voor mijn code en bronnen van mij en niet van mijn werkgever (Facebook).*

    Copyright 2017 Donne Martin

    Creative Commons Attribution 4.0 International License (CC BY 4.0)

    http://creativecommons.org/licenses/by/4.0/


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-08-09

---