*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*

**¡Ayuda a [traducir](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) esta guía!**

# El Manual de Diseño de Sistemas

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png">
  <br/>
</p>

## Motivación

> Aprende cómo diseñar sistemas a gran escala.
>
> Prepárate para la entrevista de diseño de sistemas.

### Aprende cómo diseñar sistemas a gran escala

Aprender a diseñar sistemas escalables te ayudará a convertirte en un mejor ingeniero.

El diseño de sistemas es un tema amplio. Hay una **gran cantidad de recursos dispersos por la web** sobre principios de diseño de sistemas.

Este repositorio es una **colección organizada** de recursos para ayudarte a aprender cómo construir sistemas a escala.

### Aprende de la comunidad de código abierto

Este es un proyecto de código abierto, actualizado continuamente.

¡[Contribuciones](#contributing) son bienvenidas!

### Prepárate para la entrevista de diseño de sistemas

Además de las entrevistas de programación, el diseño de sistemas es un **componente requerido** del **proceso técnico de entrevistas** en muchas empresas tecnológicas.

**Practica preguntas comunes de entrevistas de diseño de sistemas** y **compara** tus resultados con **soluciones de ejemplo**: discusiones, código y diagramas.

Temas adicionales para la preparación de entrevistas:

* [Guía de estudio](#study-guide)
* [Cómo abordar una pregunta de entrevista de diseño de sistemas](#how-to-approach-a-system-design-interview-question)
* [Preguntas de entrevista sobre diseño de sistemas, **con soluciones**](#system-design-interview-questions-with-solutions)
* [Preguntas de entrevista sobre diseño orientado a objetos, **con soluciones**](#object-oriented-design-interview-questions-with-solutions)
* [Preguntas adicionales de entrevista sobre diseño de sistemas](#additional-system-design-interview-questions)

## Tarjetas Anki

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png">
  <br/>
</p>

Los [mazos de tarjetas Anki](https://apps.ankiweb.net/) proporcionados usan repetición espaciada para ayudarte a retener conceptos clave de diseño de sistemas.

* [Mazo de diseño de sistemas](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)
* [Mazo de ejercicios de diseño de sistemas](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)
* [Mazo de ejercicios de diseño orientado a objetos](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)

Ideal para usar mientras estás en movimiento.

### Recurso de codificación: Desafíos de codificación interactivos

¿Buscas recursos para ayudarte a prepararte para la [**Entrevista de codificación**](https://github.com/donnemartin/interactive-coding-challenges)?

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png">
  <br/>
</p>

Consulta el repositorio hermano [**Desafíos de codificación interactivos**](https://github.com/donnemartin/interactive-coding-challenges), que contiene un mazo adicional de Anki:

* [Mazo de codificación](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)

## Contribuciones

> Aprende de la comunidad.

No dudes en enviar pull requests para ayudar a:

* Corregir errores
* Mejorar secciones
* Añadir nuevas secciones  
* [Traducir](https://github.com/donnemartin/system-design-primer/issues/28)  

El contenido que necesita pulirse está colocado [en desarrollo](#under-development).  

Revise las [Pautas para contribuir](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).  

## Índice de temas de diseño de sistemas  

> Resúmenes de varios temas de diseño de sistemas, incluyendo pros y contras.  **Todo es un compromiso**.  
>  
> Cada sección contiene enlaces a recursos más profundos.  

<p align="center">  
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png">  
  <br/>  
</p>  

* [Temas de diseño de sistemas: empezar aquí](#system-design-topics-start-here)  
    * [Paso 1: Revisar la conferencia en video sobre escalabilidad](#step-1-review-the-scalability-video-lecture)  
    * [Paso 2: Revisar el artículo sobre escalabilidad](#step-2-review-the-scalability-article)  
    * [Próximos pasos](#next-steps)  
* [Rendimiento vs escalabilidad](#performance-vs-scalability)  
* [Latencia vs rendimiento](#latency-vs-throughput)  
* [Disponibilidad vs consistencia](#availability-vs-consistency)  
    * [Teorema CAP](#cap-theorem)  
        * [CP - consistencia y tolerancia a particiones](#cp---consistency-and-partition-tolerance)  
        * [AP - disponibilidad y tolerancia a particiones](#ap---availability-and-partition-tolerance)  
* [Patrones de consistencia](#consistency-patterns)  
    * [Consistencia débil](#weak-consistency)  
    * [Consistencia eventual](#eventual-consistency)  
    * [Consistencia fuerte](#strong-consistency)  
* [Patrones de disponibilidad](#availability-patterns)  
    * [Conmutación por error](#fail-over)  
    * [Replicación](#replication)  
    * [Disponibilidad en números](#availability-in-numbers)  
* [Sistema de nombres de dominio](#domain-name-system)  
* [Red de entrega de contenido](#content-delivery-network)  
    * [CDNs push](#push-cdns)  
    * [CDNs pull](#pull-cdns)
* [Balanceador de carga](#load-balancer)
    * [Activo-pasivo](#active-passive)
    * [Activo-activo](#active-active)
    * [Balanceo de carga en capa 4](#layer-4-load-balancing)
    * [Balanceo de carga en capa 7](#layer-7-load-balancing)
    * [Escalado horizontal](#horizontal-scaling)
* [Proxy inverso (servidor web)](#reverse-proxy-web-server)
    * [Balanceador de carga vs proxy inverso](#load-balancer-vs-reverse-proxy)
* [Capa de aplicación](#application-layer)
    * [Microservicios](#microservices)
    * [Descubrimiento de servicios](#service-discovery)
* [Base de datos](#database)
    * [Sistema de gestión de bases de datos relacionales (RDBMS)](#relational-database-management-system-rdbms)
        * [Replicación maestro-esclavo](#master-slave-replication)
        * [Replicación maestro-maestro](#master-master-replication)
        * [Federación](#federation)
        * [Fragmentación (Sharding)](#sharding)
        * [Desnormalización](#denormalization)
        * [Optimización de SQL](#sql-tuning)
    * [NoSQL](#nosql)
        * [Almacén clave-valor](#key-value-store)
        * [Almacén de documentos](#document-store)
        * [Almacén de columnas anchas](#wide-column-store)
        * [Base de datos de grafos](#graph-database)
    * [SQL o NoSQL](#sql-or-nosql)
* [Caché](#cache)
    * [Caché del cliente](#client-caching)
    * [Caché de CDN](#cdn-caching)
    * [Caché del servidor web](#web-server-caching)
    * [Caché de la base de datos](#database-caching)
    * [Caché de la aplicación](#application-caching)
    * [Caché a nivel de consulta de base de datos](#caching-at-the-database-query-level)
    * [Caché a nivel de objeto](#caching-at-the-object-level)
    * [Cuándo actualizar la caché](#when-to-update-the-cache)
        * [Cache-aside](#cache-aside)
        * [Write-through](#write-through)
        * [Write-behind (escritura diferida)](#write-behind-write-back)
        * [Refresh-ahead](#refresh-ahead)
* [Asincronismo](#asynchronism)
    * [Colas de mensajes](#message-queues)
    * [Colas de tareas](#task-queues)
    * [Presión de retorno](#back-pressure)
* [Comunicación](#communication)
    * [Protocolo de control de transmisión (TCP)](#transmission-control-protocol-tcp)
    * [Protocolo de datagramas de usuario (UDP)](#user-datagram-protocol-udp)
    * [Llamada a procedimiento remoto (RPC)](#remote-procedure-call-rpc)
    * [Transferencia de estado representacional (REST)](#representational-state-transfer-rest)
* [Seguridad](#security)
* [Apéndice](#appendix)
    * [Tabla de potencias de dos](#powers-of-two-table)
    * [Números de latencia que todo programador debería conocer](#latency-numbers-every-programmer-should-know)
    * [Preguntas adicionales para entrevistas de diseño de sistemas](#additional-system-design-interview-questions)
    * [Arquitecturas del mundo real](#real-world-architectures)
    * [Arquitecturas de empresas](#company-architectures)
    * [Blogs de ingeniería de empresas](#company-engineering-blogs)
* [En desarrollo](#under-development)
* [Créditos](#credits)
* [Información de contacto](#contact-info)
* [Licencia](#license)

## Guía de estudio

> Temas sugeridos para revisar según tu cronograma de entrevistas (corto, medio, largo).

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)

**P: Para las entrevistas, ¿necesito saber todo lo que está aquí?**

**R: No, no necesitas saber todo esto para prepararte para la entrevista**.

Lo que te pregunten en una entrevista depende de variables como:

* Cuánta experiencia tienes
* Cuál es tu formación técnica
* Para qué puestos estás entrevistando
* Con qué empresas estás entrevistando
* Suerte

Generalmente se espera que los candidatos con más experiencia sepan más sobre diseño de sistemas. Los arquitectos o líderes de equipo podrían esperarse que sepan más que los colaboradores individuales. Las principales empresas tecnológicas probablemente tengan una o más rondas de entrevistas de diseño.

Comienza de forma amplia y profundiza en algunas áreas. Ayuda conocer un poco sobre varios temas clave de diseño de sistemas. Ajusta la siguiente guía según tu cronograma, experiencia, los puestos para los que estás entrevistando y las empresas con las que estás en proceso de selección.

* **Cronograma corto** - Apunta a la **amplitud** en temas de diseño de sistemas. Practica resolviendo **algunas** preguntas de entrevista.
* **Cronograma medio** - Apunta a la **amplitud** y **algo de profundidad** en temas de diseño de sistemas. Practica resolviendo **muchas** preguntas de entrevista.
* **Cronograma largo** - Apunta a la **amplitud** y **más profundidad** en temas de diseño de sistemas. Practica resolviendo **la mayoría** de preguntas de entrevista.

| | Corto | Medio | Largo |
|---|---|---|---|
| Lee los [Temas de diseño de sistemas](#index-of-system-design-topics) para obtener una comprensión amplia de cómo funcionan los sistemas | :+1: | :+1: | :+1: |
| Lee algunos artículos en los [Blogs de ingeniería de empresas](#company-engineering-blogs) para las empresas con las que estás entrevistando | :+1: | :+1: | :+1: |
| Lee algunas [Arquitecturas del mundo real](#real-world-architectures) | :+1: | :+1: | :+1: |
| Revisa [Cómo abordar una pregunta de entrevista de diseño de sistemas](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |
| Trabaja con [Preguntas de entrevistas de diseño de sistemas con soluciones](#system-design-interview-questions-with-solutions) | Algunas | Muchas | La mayoría |
| Trabaja con [Preguntas de entrevistas de diseño orientado a objetos con soluciones](#object-oriented-design-interview-questions-with-solutions) | Algunas | Muchas | La mayoría |
| Revisa [Preguntas adicionales de entrevistas de diseño de sistemas](#additional-system-design-interview-questions) | Algunas | Muchas | La mayoría |

## Cómo abordar una pregunta de entrevista de diseño de sistemas

> Cómo enfrentar una pregunta de entrevista de diseño de sistemas.

La entrevista de diseño de sistemas es una **conversación abierta**. Se espera que tú la lideres.

Puedes usar los siguientes pasos para guiar la discusión. Para ayudar a consolidar este proceso, trabaja la sección de [Preguntas de entrevistas de diseño de sistemas con soluciones](#system-design-interview-questions-with-solutions) usando los siguientes pasos.

### Paso 1: Delimitar casos de uso, restricciones y suposiciones

Reúne los requisitos y define el alcance del problema. Haz preguntas para clarificar casos de uso y restricciones. Discute las suposiciones.

* ¿Quién lo va a usar?
* ¿Cómo lo van a usar?
* ¿Cuántos usuarios hay?
* ¿Qué hace el sistema?
* ¿Cuáles son las entradas y salidas del sistema?
* ¿Cuánta información esperamos manejar?
* ¿Cuántas solicitudes por segundo esperamos?
* ¿Cuál es la proporción esperada de lectura a escritura?

### Paso 2: Crear un diseño a alto nivel

Esboza un diseño a alto nivel con todos los componentes importantes.
* Esboza los componentes principales y las conexiones  
* Justifica tus ideas  

### Paso 3: Diseñar los componentes centrales  

Profundiza en los detalles de cada componente central. Por ejemplo, si te piden [diseñar un servicio de acortamiento de URLs](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), discute:  

* Generar y almacenar un hash de la URL completa  
    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) y [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)  
    * Colisiones de hash  
    * SQL o NoSQL  
    * Esquema de base de datos  
* Traducir una URL hasheada a la URL completa  
    * Consulta en base de datos  
* Diseño de API y orientado a objetos  

### Paso 4: Escalar el diseño  

Identifica y soluciona los cuellos de botella, dadas las restricciones. Por ejemplo, ¿necesitas lo siguiente para abordar problemas de escalabilidad?  

* Balanceador de carga  
* Escalado horizontal  
* Caché  
* Fragmentación de base de datos  

Discute posibles soluciones y compensaciones. Todo es una compensación. Resuelve los cuellos de botella usando [principios de diseño de sistemas escalables](#index-of-system-design-topics).  

### Cálculos aproximados  

Podrías necesitar hacer algunas estimaciones a mano. Consulta el [Apéndice](#appendix) para los siguientes recursos:  

* [Usar cálculos aproximados](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)  
* [Tabla de potencias de dos](#powers-of-two-table)  
* [Números de latencia que todo programador debería conocer](#latency-numbers-every-programmer-should-know)  

### Fuente(s) y lectura adicional  

Consulta los siguientes enlaces para tener una mejor idea de qué esperar:


* [Cómo triunfar en una entrevista de diseño de sistemas](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)
* [La entrevista de diseño de sistemas](http://www.hiredintech.com/system-design)
* [Introducción a la arquitectura y entrevistas de diseño de sistemas](https://www.youtube.com/watch?v=ZgdS0EUmn70)
* [Plantilla de diseño de sistemas](https://leetcode.com/discuss/career/229177/My-System-Design-Template)

## Preguntas de entrevistas de diseño de sistemas con soluciones

> Preguntas comunes de entrevistas de diseño de sistemas con discusiones de ejemplo, código y diagramas.
>
> Soluciones enlazadas al contenido en la carpeta `solutions/`.

| Pregunta | |
|---|---|
| Diseñar Pastebin.com (o Bit.ly) | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |
| Diseñar la línea de tiempo y búsqueda de Twitter (o el feed y búsqueda de Facebook) | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |
| Diseñar un rastreador web | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |
| Diseñar Mint.com | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |
| Diseñar las estructuras de datos para una red social | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |
| Diseñar un almacén clave-valor para un motor de búsqueda | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |
| Diseñar la función de clasificación de ventas por categoría de Amazon | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |
| Diseñar un sistema que escale a millones de usuarios en AWS | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |
| Añadir una pregunta de diseño de sistemas | [Contribuir](#contributing) |

### Diseñar Pastebin.com (o Bit.ly)

[Ver ejercicio y solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)

### Diseñar la línea de tiempo y búsqueda de Twitter (o el feed y búsqueda de Facebook)

[Ver ejercicio y solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)

### Diseñar un rastreador web

[Ver ejercicio y solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)

### Design Mint.com

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)

### Design the data structures for a social network

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)

### Design a key-value store for a search engine

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)

### Design Amazon's sales ranking by category feature

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)

### Design a system that scales to millions of users on AWS

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)

## Object-oriented design interview questions with solutions

> Common object-oriented design interview questions with sample discussions, code, and diagrams.
>
> Solutions linked to content in the `solutions/` folder.

>**Note: This section is under development**

| Question | |
|---|---|
| Diseñar un mapa hash | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |
| Diseñar una caché LRU (menos recientemente usada) | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |
| Diseñar un centro de llamadas | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |
| Diseñar una baraja de cartas | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |
| Diseñar un estacionamiento | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |
| Diseñar un servidor de chat | [Solución](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |
| Diseñar un arreglo circular | [Contribuir](#contributing)  |
| Añadir una pregunta de diseño orientado a objetos | [Contribuir](#contributing) |

## Temas de diseño de sistemas: comienza aquí

¿Nuevo en diseño de sistemas?

Primero, necesitarás una comprensión básica de principios comunes, aprendiendo qué son, cómo se usan y sus pros y contras.

### Paso 1: Revisar la clase magistral sobre escalabilidad

[Clase sobre escalabilidad en Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)

* Temas cubiertos:
    * Escalado vertical
    * Escalado horizontal
    * Caché
    * Balanceo de carga
    * Replicación de bases de datos
    * Particionamiento de bases de datos

### Paso 2: Revisar el artículo sobre escalabilidad

[Escalabilidad](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)

* Temas cubiertos:
    * [Clones](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
    * [Bases de datos](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
    * [Cachés](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
    * [Asincronismo](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)

### Próximos pasos

A continuación, analizaremos las compensaciones a alto nivel:

* **Rendimiento** vs **escalabilidad**
* **Latencia** vs **rendimiento**
* **Disponibilidad** vs **consistencia**

Ten en cuenta que **todo es una compensación**.

Luego profundizaremos en temas más específicos como DNS, CDN y balanceadores de carga.

## Rendimiento vs escalabilidad

Un servicio es **escalable** si resulta en un aumento del **rendimiento** de manera proporcional a los recursos añadidos. Generalmente, aumentar el rendimiento significa servir más unidades de trabajo, pero también puede ser para manejar unidades de trabajo más grandes, como cuando los conjuntos de datos crecen.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>

Otra forma de ver rendimiento vs escalabilidad:

* Si tienes un problema de **rendimiento**, tu sistema es lento para un solo usuario.
* Si tienes un problema de **escalabilidad**, tu sistema es rápido para un solo usuario pero lento bajo una carga pesada.

### Fuente(s) y lectura adicional

* [Una palabra sobre escalabilidad](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)
* [Escalabilidad, disponibilidad, estabilidad, patrones](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)

## Latencia vs rendimiento

**Latencia** es el tiempo para realizar alguna acción o producir algún resultado.

**Rendimiento** es el número de tales acciones o resultados por unidad de tiempo.

Generalmente, debes apuntar a un **rendimiento máximo** con una **latencia aceptable**.

### Fuente(s) y lectura adicional

* [Entendiendo latencia vs rendimiento](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)

## Disponibilidad vs consistencia

### Teorema CAP

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Fuente: Teorema CAP revisitado</a></i>
</p>

En un sistema informático distribuido, solo puedes soportar dos de las siguientes garantías:

* **Consistencia** - Cada lectura recibe la escritura más reciente o un error
* **Disponibilidad** - Cada solicitud recibe una respuesta, sin garantía de que contenga la versión más reciente de la información
* **Tolerancia a particiones** - El sistema continúa operando a pesar de particionamientos arbitrarios debido a fallos en la red

*Las redes no son confiables, por lo que necesitarás soportar tolerancia a particiones. Tendrás que hacer un compromiso en el software entre consistencia y disponibilidad.*

#### CP - consistencia y tolerancia a particiones

Esperar una respuesta del nodo particionado podría resultar en un error de tiempo de espera. CP es una buena opción si las necesidades de tu negocio requieren lecturas y escrituras atómicas.

#### AP - disponibilidad y tolerancia a particiones

Las respuestas devuelven la versión más fácilmente disponible de los datos en cualquier nodo, que podría no ser la más reciente. Las escrituras podrían tardar en propagarse cuando se resuelve la partición.

AP es una buena opción si el negocio necesita permitir la [consistencia eventual](#eventual-consistency) o cuando el sistema debe continuar funcionando a pesar de errores externos.

### Fuente(s) y lectura adicional

* [Teorema CAP revisitado](http://robertgreiner.com/2014/08/cap-theorem-revisited/)
* [Una introducción sencilla al teorema CAP](http://ksat.me/a-plain-english-introduction-to-cap-theorem)
* [FAQ del teorema CAP](https://github.com/henryr/cap-faq)
* [El teorema CAP](https://www.youtube.com/watch?v=k-Yaq8AHlFA)

## Patrones de consistencia

Con múltiples copias de los mismos datos, enfrentamos opciones sobre cómo sincronizarlas para que los clientes tengan una vista consistente de los datos. Recuerda la definición de consistencia del [teorema CAP](#cap-theorem): cada lectura recibe la escritura más reciente o un error.

### Consistencia débil

Después de una escritura, las lecturas pueden o no verla. Se adopta un enfoque de mejor esfuerzo.

Este enfoque se observa en sistemas como memcached. La consistencia débil funciona bien en casos de uso en tiempo real como VoIP, chat de video y juegos multijugador en tiempo real. Por ejemplo, si estás en una llamada telefónica y pierdes la señal por unos segundos, cuando recuperas la conexión no escuchas lo que se dijo durante la pérdida de conexión.

### Consistencia eventual

Después de una escritura, las lecturas eventualmente la verán (normalmente en milisegundos). Los datos se replican de forma asincrónica.

Este enfoque se observa en sistemas como DNS y correo electrónico. La consistencia eventual funciona bien en sistemas altamente disponibles.

### Consistencia fuerte

Después de una escritura, las lecturas la verán. Los datos se replican de forma sincrónica.

Este enfoque se observa en sistemas de archivos y RDBMS. La consistencia fuerte funciona bien en sistemas que necesitan transacciones.

### Fuente(s) y lectura adicional

* [Transacciones entre centros de datos](http://snarfed.org/transactions_across_datacenters_io.html)

## Patrones de disponibilidad

Existen dos patrones complementarios para soportar alta disponibilidad: **fail-over** y **replicación**.

### Fail-over

#### Activo-pasivo

Con fail-over activo-pasivo, se envían latidos entre el servidor activo y el servidor pasivo en espera. Si el latido se interrumpe, el servidor pasivo toma la dirección IP del activo y reanuda el servicio.

La duración del tiempo de inactividad depende de si el servidor pasivo ya está funcionando en espera "caliente" o si necesita arrancar desde una espera "fría". Solo el servidor activo maneja el tráfico.

El failover activo-pasivo también puede denominarse failover maestro-esclavo.

#### Activo-activo

En activo-activo, ambos servidores gestionan el tráfico, distribuyendo la carga entre ellos.

Si los servidores están expuestos al público, el DNS necesitaría conocer las IP públicas de ambos servidores. Si los servidores están orientados internamente, la lógica de la aplicación debería conocer ambos servidores.

El failover activo-activo también puede denominarse failover maestro-maestro.

### Desventaja(s): failover
* La conmutación por error añade más hardware y complejidad adicional.
* Existe un potencial de pérdida de datos si el sistema activo falla antes de que cualquier dato recién escrito pueda ser replicado al pasivo.

### Replicación

#### Maestro-esclavo y maestro-maestro

Este tema se discute más a fondo en la sección de [Base de datos](#database):

* [Replicación maestro-esclavo](#master-slave-replication)
* [Replicación maestro-maestro](#master-master-replication)

### Disponibilidad en números

La disponibilidad a menudo se cuantifica por el tiempo de actividad (o inactividad) como un porcentaje del tiempo que el servicio está disponible. La disponibilidad generalmente se mide en número de nueves: un servicio con 99.99% de disponibilidad se describe como que tiene cuatro nueves.

#### Disponibilidad del 99.9% - tres nueves

| Duración            | Tiempo de inactividad aceptable |
|---------------------|--------------------------------|
| Inactividad por año | 8h 45min 57s                   |
| Inactividad por mes | 43m 49.7s                      |
| Inactividad por semana | 10m 4.8s                    |
| Inactividad por día | 1m 26.4s                      |

#### Disponibilidad del 99.99% - cuatro nueves

| Duración            | Tiempo de inactividad aceptable |
|---------------------|--------------------------------|
| Inactividad por año | 52min 35.7s                    |
| Inactividad por mes | 4m 23s                        |
| Inactividad por semana | 1m 5s                      |
| Inactividad por día | 8.6s                          |

#### Disponibilidad en paralelo vs en secuencia

Si un servicio consiste en múltiples componentes propensos a fallos, la disponibilidad general del servicio depende de si los componentes están en secuencia o en paralelo.

###### En secuencia


La disponibilidad general disminuye cuando dos componentes con disponibilidad < 100 % están en secuencia:

```
Availability (Total) = Availability (Foo) * Availability (Bar)
```
Si tanto `Foo` como `Bar` tuvieran cada uno un 99.9% de disponibilidad, su disponibilidad total en secuencia sería del 99.8%.

###### En paralelo

La disponibilidad general aumenta cuando dos componentes con disponibilidad < 100% están en paralelo:


```
Availability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))
```
Si tanto `Foo` como `Bar` tuvieran cada uno un 99.9% de disponibilidad, su disponibilidad total en paralelo sería del 99.9999%.

## Sistema de nombres de dominio

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Fuente: Presentación de seguridad DNS</a></i>
</p>

Un Sistema de Nombres de Dominio (DNS) traduce un nombre de dominio como www.example.com a una dirección IP.

El DNS es jerárquico, con algunos servidores autorizados en el nivel superior.  Tu router o ISP proporciona información sobre qué servidor(es) DNS contactar al realizar una consulta.  Los servidores DNS de nivel inferior almacenan en caché los mapeos, que podrían volverse obsoletos debido a retrasos en la propagación del DNS.  Los resultados DNS también pueden ser almacenados en caché por tu navegador o sistema operativo durante un cierto período, determinado por el [tiempo de vida (TTL)](https://es.wikipedia.org/wiki/Time_to_live).

* **Registro NS (servidor de nombres)** - Especifica los servidores DNS para tu dominio/subdominio.
* **Registro MX (intercambio de correo)** - Especifica los servidores de correo para aceptar mensajes.
* **Registro A (dirección)** - Apunta un nombre a una dirección IP.
* **CNAME (canónico)** - Apunta un nombre a otro nombre o `CNAME` (example.com a www.example.com) o a un registro `A`.

Servicios como [CloudFlare](https://www.cloudflare.com/dns/) y [Route 53](https://aws.amazon.com/route53/) ofrecen servicios DNS gestionados.  Algunos servicios DNS pueden enrutar el tráfico mediante varios métodos:

* [Round robin ponderado](https://www.jscape.com/blog/load-balancing-algorithms)
    * Evitar que el tráfico vaya a servidores en mantenimiento
    * Balancear entre tamaños variables de clúster
    * Pruebas A/B
* [Basado en latencia](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)
* [Basado en geolocalización](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)

### Desventaja(s): DNS

* Acceder a un servidor DNS introduce una pequeña demora, aunque mitigada por el almacenamiento en caché descrito arriba.
* La gestión de servidores DNS puede ser compleja y generalmente está a cargo de [gobiernos, ISP y grandes empresas](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).
* Los servicios DNS han sido recientemente objeto de [ataques DDoS](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), impidiendo que los usuarios accedan a sitios web como Twitter sin conocer la(s) dirección(es) IP de Twitter.

### Fuente(s) y lecturas adicionales

* [Arquitectura DNS](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)
* [Wikipedia](https://es.wikipedia.org/wiki/Domain_Name_System)
* [Artículos DNS](https://support.dnsimple.com/categories/dns/)


## Red de entrega de contenido

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Fuente: Por qué usar una CDN</a></i>
</p>

Una red de entrega de contenido (CDN) es una red distribuida globalmente de servidores proxy, que sirven contenido desde ubicaciones más cercanas al usuario. Generalmente, archivos estáticos como HTML/CSS/JS, fotos y videos son servidos desde la CDN, aunque algunas CDNs como CloudFront de Amazon soportan contenido dinámico. La resolución DNS del sitio indicará a los clientes qué servidor contactar.

Servir contenido desde CDNs puede mejorar significativamente el rendimiento de dos maneras:

* Los usuarios reciben contenido desde centros de datos cercanos a ellos
* Tus servidores no tienen que atender solicitudes que la CDN cumple

### CDNs Push

Las CDNs push reciben contenido nuevo cada vez que ocurren cambios en tu servidor. Asumes plena responsabilidad por proporcionar contenido, subiéndolo directamente a la CDN y reescribiendo URLs para apuntar a la CDN. Puedes configurar cuándo expira el contenido y cuándo se actualiza. El contenido se sube solo cuando es nuevo o cambiado, minimizando el tráfico, pero maximizando el almacenamiento.

Los sitios con poco tráfico o sitios con contenido que no se actualiza con frecuencia funcionan bien con CDNs push. El contenido se coloca en las CDNs una sola vez, en lugar de ser recuperado repetidamente en intervalos regulares.

### CDNs Pull

Las CDNs pull obtienen contenido nuevo de tu servidor cuando el primer usuario solicita el contenido. Dejas el contenido en tu servidor y reescribes URLs para apuntar a la CDN. Esto resulta en una solicitud más lenta hasta que el contenido se cachea en la CDN.

Un [tiempo de vida (TTL)](https://es.wikipedia.org/wiki/Time_to_live) determina cuánto tiempo se cachea el contenido. Las CDNs pull minimizan el espacio de almacenamiento en la CDN, pero pueden crear tráfico redundante si los archivos expiran y se recuperan antes de que hayan cambiado realmente.

Los sitios con tráfico elevado funcionan bien con CDNs pull, ya que el tráfico se distribuye de manera más uniforme y solo el contenido solicitado recientemente permanece en la CDN.

### Desventaja(s): CDN

* Los costos de CDN podrían ser significativos dependiendo del tráfico, aunque esto debe ponderarse con los costos adicionales que incurrirías al no usar una CDN.
* El contenido podría estar desactualizado si se actualiza antes de que expire el TTL.
* Las CDNs requieren cambiar URLs para el contenido estático para apuntar a la CDN.

### Fuente(s) y lectura adicional

* [Entrega de contenido distribuida globalmente](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)
* [Las diferencias entre CDNs push y pull](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)
* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)

## Balanceador de carga

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Fuente: Patrones de diseño de sistemas escalables</a></i>
</p>

Los balanceadores de carga distribuyen las solicitudes entrantes de los clientes a recursos informáticos como servidores de aplicaciones y bases de datos. En cada caso, el balanceador de carga devuelve la respuesta del recurso informático al cliente correspondiente. Los balanceadores de carga son efectivos para:

* Prevenir que las solicitudes se dirijan a servidores no saludables
* Evitar la sobrecarga de recursos
* Ayudar a eliminar un punto único de fallo

Los balanceadores de carga pueden implementarse con hardware (costoso) o con software como HAProxy.

Beneficios adicionales incluyen:

* **Terminación SSL** - Desencriptar solicitudes entrantes y encriptar respuestas del servidor para que los servidores backend no tengan que realizar estas operaciones potencialmente costosas
    * Elimina la necesidad de instalar [certificados X.509](https://en.wikipedia.org/wiki/X.509) en cada servidor
* **Persistencia de sesión** - Emitir cookies y enrutar las solicitudes de un cliente específico a la misma instancia si las aplicaciones web no mantienen el seguimiento de las sesiones

Para proteger contra fallos, es común configurar múltiples balanceadores de carga, ya sea en modo [activo-pasivo](#active-passive) o [activo-activo](#active-active).

Los balanceadores de carga pueden enrutar el tráfico basándose en varias métricas, incluyendo:

* Aleatorio
* Menos cargado
* Sesión/cookies
* [Round robin o round robin ponderado](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)
* [Capa 4](#layer-4-load-balancing)
* [Capa 7](#layer-7-load-balancing)

### Balanceo de carga en capa 4

Los balanceadores de carga de capa 4 analizan la información en la [capa de transporte](#communication) para decidir cómo distribuir las solicitudes. Generalmente, esto involucra las direcciones IP de origen y destino, y los puertos en el encabezado, pero no el contenido del paquete. Los balanceadores de carga de capa 4 reenvían paquetes de red hacia y desde el servidor ascendente, realizando [Traducción de Direcciones de Red (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/).

### Balanceo de carga en capa 7

Los balanceadores de carga de capa 7 analizan la [capa de aplicación](#communication) para decidir cómo distribuir las solicitudes. Esto puede involucrar el contenido del encabezado, el mensaje y las cookies. Los balanceadores de carga de capa 7 terminan el tráfico de red, leen el mensaje, toman una decisión de balanceo de carga y luego abren una conexión con el servidor seleccionado. Por ejemplo, un balanceador de carga de capa 7 puede dirigir el tráfico de video a servidores que alojan videos mientras dirige el tráfico más sensible de facturación de usuarios a servidores reforzados en seguridad.

A costa de la flexibilidad, el balanceo de carga de capa 4 requiere menos tiempo y recursos computacionales que la capa 7, aunque el impacto en el rendimiento puede ser mínimo en hardware moderno y común.

### Escalamiento horizontal

Los balanceadores de carga también pueden ayudar con el escalamiento horizontal, mejorando el rendimiento y la disponibilidad. Escalar usando máquinas comunes es más eficiente en costos y resulta en mayor disponibilidad que escalar un solo servidor con hardware más costoso, llamado **Escalamiento Vertical**. También es más fácil contratar talento que trabaje con hardware común que con sistemas empresariales especializados.

#### Desventaja(s): escalamiento horizontal

* Escalar horizontalmente introduce complejidad e implica clonar servidores
    * Los servidores deben ser sin estado: no deben contener datos relacionados con el usuario como sesiones o fotos de perfil
    * Las sesiones pueden almacenarse en un almacén de datos centralizado como una [base de datos](#database) (SQL, NoSQL) o una [caché](#cache) persistente (Redis, Memcached)
* Los servidores aguas abajo, como cachés y bases de datos, necesitan manejar más conexiones simultáneas a medida que los servidores aguas arriba escalan

### Desventaja(s): balanceador de carga

* El balanceador de carga puede convertirse en un cuello de botella de rendimiento si no tiene suficientes recursos o si no está configurado correctamente.
* Introducir un balanceador de carga para ayudar a eliminar un único punto de falla resulta en mayor complejidad.
* Un solo balanceador de carga es un único punto de falla; configurar múltiples balanceadores de carga aumenta aún más la complejidad.

### Fuente(s) y lectura adicional

* [Arquitectura de NGINX](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [Guía de arquitectura de HAProxy](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Escalabilidad](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
* [Wikipedia](https://en.wikipedia.org/wiki/Load_balancing_(computing))
* [Balanceo de carga de capa 4](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)
* [Balanceo de carga de capa 7](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)
* [Configuración de listener ELB](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)

## Proxy inverso (servidor web)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Fuente: Wikipedia</a></i>
  <br/>
</p>
Un proxy inverso es un servidor web que centraliza servicios internos y proporciona interfaces unificadas al público. Las solicitudes de los clientes se reenvían a un servidor que puede cumplirlas antes de que el proxy inverso devuelva la respuesta del servidor al cliente.

Beneficios adicionales incluyen:

* **Mayor seguridad** - Ocultar información sobre los servidores backend, bloquear IPs, limitar el número de conexiones por cliente
* **Mayor escalabilidad y flexibilidad** - Los clientes solo ven la IP del proxy inverso, lo que permite escalar servidores o cambiar su configuración
* **Terminación SSL** - Desencriptar solicitudes entrantes y encriptar respuestas del servidor para que los servidores backend no tengan que realizar estas operaciones potencialmente costosas
    * Elimina la necesidad de instalar [certificados X.509](https://en.wikipedia.org/wiki/X.509) en cada servidor
* **Compresión** - Comprimir respuestas del servidor
* **Caché** - Devolver la respuesta para solicitudes en caché
* **Contenido estático** - Servir contenido estático directamente
    * HTML/CSS/JS
    * Fotos
    * Videos
    * Etc

### Balanceador de carga vs proxy inverso

* Implementar un balanceador de carga es útil cuando se tienen múltiples servidores. A menudo, los balanceadores de carga dirigen el tráfico a un conjunto de servidores que cumplen la misma función.
* Los proxies inversos pueden ser útiles incluso con un solo servidor web o servidor de aplicaciones, abriendo los beneficios descritos en la sección anterior.
* Soluciones como NGINX y HAProxy pueden soportar tanto proxy inverso en capa 7 como balanceo de carga.

### Desventaja(s): proxy inverso

* Introducir un proxy inverso resulta en una mayor complejidad.
* Un solo proxy inverso es un único punto de fallo, configurar múltiples proxies inversos (es decir, un [failover](https://en.wikipedia.org/wiki/Failover)) aumenta aún más la complejidad.

### Fuente(s) y lectura adicional

* [Proxy inverso vs balanceador de carga](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)
* [Arquitectura de NGINX](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [Guía de arquitectura de HAProxy](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)

## Capa de aplicación

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png">
  <br/>

  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Fuente: Introducción a la arquitectura de sistemas para escalabilidad</a></i>
</p>

Separar la capa web de la capa de aplicación (también conocida como capa de plataforma) permite escalar y configurar ambas capas de manera independiente. Agregar una nueva API resulta en añadir servidores de aplicación sin necesariamente añadir servidores web adicionales. El **principio de responsabilidad única** aboga por servicios pequeños y autónomos que trabajan juntos. Equipos pequeños con servicios pequeños pueden planificar de forma más agresiva para un crecimiento rápido.

Los trabajadores en la capa de aplicación también ayudan a habilitar el [asincronismo](#asynchronism).

### Microservicios

Relacionado con esta discusión están los [microservicios](https://es.wikipedia.org/wiki/Microservicio), que pueden describirse como un conjunto de servicios pequeños, modulares e independientemente desplegables. Cada servicio ejecuta un proceso único y se comunica a través de un mecanismo ligero y bien definido para cumplir un objetivo de negocio. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>

Pinterest, por ejemplo, podría tener los siguientes microservicios: perfil de usuario, seguidores, feed, búsqueda, subida de fotos, etc.

### Descubrimiento de servicios

Sistemas como [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), y [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) pueden ayudar a que los servicios se encuentren entre sí manteniendo un registro de nombres, direcciones y puertos registrados. Los [chequeos de salud](https://www.consul.io/intro/getting-started/checks.html) ayudan a verificar la integridad del servicio y a menudo se realizan usando un endpoint [HTTP](#hypertext-transfer-protocol-http). Tanto Consul como Etcd tienen una [almacén clave-valor](#key-value-store) incorporado que puede ser útil para almacenar valores de configuración y otros datos compartidos.

### Desventaja(s): capa de aplicación

* Agregar una capa de aplicación con servicios débilmente acoplados requiere un enfoque diferente desde el punto de vista arquitectónico, operativo y de procesos (vs un sistema monolítico).
* Los microservicios pueden añadir complejidad en términos de despliegues y operaciones.

### Fuente(s) y lectura adicional

* [Introducción a la arquitectura de sistemas para escalabilidad](http://lethain.com/introduction-to-architecting-systems-for-scale)
* [Domina la entrevista de diseño de sistemas](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Arquitectura orientada a servicios](https://es.wikipedia.org/wiki/Arquitectura_orientada_a_servicios)
* [Introducción a Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)
* [Esto es lo que necesitas saber sobre la construcción de microservicios](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)

## Base de datos

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Fuente: Escalando hasta tus primeros 10 millones de usuarios</a></i>
</p>

### Sistema de gestión de bases de datos relacionales (RDBMS)

Una base de datos relacional como SQL es una colección de elementos de datos organizados en tablas.

**ACID** es un conjunto de propiedades de las [transacciones](https://es.wikipedia.org/wiki/Transacci%C3%B3n_(inform%C3%A1tica)) en bases de datos relacionales.

* **Atomicidad** - Cada transacción es todo o nada
* **Consistencia** - Cualquier transacción llevará la base de datos de un estado válido a otro
* **Aislamiento** - Ejecutar transacciones concurrentemente tiene los mismos resultados que si se ejecutaran en serie
* **Durabilidad** - Una vez que una transacción ha sido confirmada, permanecerá así

Existen muchas técnicas para escalar una base de datos relacional: **replicación maestro-esclavo**, **replicación maestro-maestro**, **federación**, **sharding**, **desnormalización** y **optimización de SQL**.

#### Replicación maestro-esclavo

El maestro atiende lecturas y escrituras, replicando las escrituras a uno o más esclavos, que solo atienden lecturas. Los esclavos también pueden replicar a esclavos adicionales en forma de árbol. Si el maestro se desconecta, el sistema puede continuar operando en modo solo lectura hasta que un esclavo sea promovido a maestro o se configure un nuevo maestro.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fuente: Escalabilidad, disponibilidad, estabilidad, patrones</a></i>
</p>

##### Desventaja(s): replicación maestro-esclavo

* Se necesita lógica adicional para promover un esclavo a maestro.
* Ver [Desventaja(s): replicación](#disadvantages-replication) para puntos relacionados con **ambos** maestro-esclavo y maestro-maestro.

#### Replicación maestro-maestro

Ambos maestros atienden lecturas y escrituras y coordinan entre sí las escrituras. Si alguno de los maestros falla, el sistema puede continuar operando con lecturas y escrituras.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fuente: Escalabilidad, disponibilidad, estabilidad, patrones</a></i>
</p>

##### Desventaja(s): replicación maestro-maestro

* Necesitarás un balanceador de carga o deberás hacer cambios en la lógica de tu aplicación para determinar dónde escribir.
* La mayoría de sistemas maestro-maestro son o bien débilmente consistentes (violando ACID) o tienen mayor latencia de escritura debido a la sincronización.
* La resolución de conflictos cobra mayor importancia a medida que se añaden más nodos de escritura y aumenta la latencia.  
* Consulte [Desventaja(s): replicación](#disadvantages-replication) para puntos relacionados con **ambos** master-esclavo y master-master.

##### Desventaja(s): replicación

* Existe la posibilidad de pérdida de datos si el maestro falla antes de que los datos recién escritos puedan replicarse a otros nodos.  
* Las escrituras se reproducen en las réplicas de lectura. Si hay muchas escrituras, las réplicas de lectura pueden saturarse con la reproducción de escrituras y no pueden realizar tantas lecturas.  
* Cuantos más esclavos de lectura, más tiene que replicar, lo que conduce a una mayor latencia de replicación.  
* En algunos sistemas, escribir en el maestro puede generar múltiples hilos para escribir en paralelo, mientras que las réplicas de lectura solo admiten escritura secuencial con un solo hilo.  
* La replicación añade más hardware y complejidad adicional.

##### Fuente(s) y lectura adicional: replicación

* [Escalabilidad, disponibilidad, estabilidad, patrones](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)  
* [Replicación multi-maestro](https://es.wikipedia.org/wiki/Replicaci%C3%B3n_multi-maestro)

#### Federación

<p align="center">  
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png">  
  <br/>  
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Fuente: Escalando hasta tus primeros 10 millones de usuarios</a></i>  
</p>

La federación (o partición funcional) divide las bases de datos por función. Por ejemplo, en lugar de una base de datos monolítica única, podrías tener tres bases de datos: **foros**, **usuarios** y **productos**, lo que resulta en menos tráfico de lectura y escritura para cada base de datos y por lo tanto menos latencia de replicación. Bases de datos más pequeñas resultan en más datos que pueden caber en memoria, lo que a su vez resulta en más aciertos de caché debido a una mejor localidad de caché. Sin un maestro central único que serialice las escrituras, puedes escribir en paralelo, aumentando el rendimiento.

##### Desventaja(s): federación

* La federación no es efectiva si tu esquema requiere funciones o tablas enormes.  
* Necesitarás actualizar la lógica de tu aplicación para determinar qué base de datos leer y escribir.  
* Unir datos de dos bases de datos es más complejo con un [enlace de servidor](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).  
* La federación añade más hardware y complejidad adicional.

##### Fuente(s) y lectura adicional: federación

* [Escalando hasta tus primeros 10 millones de usuarios](https://www.youtube.com/watch?v=kKjm4ehYiMs)

#### Sharding

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fuente: Escalabilidad, disponibilidad, estabilidad, patrones</a></i>
</p>

El sharding distribuye datos a través de diferentes bases de datos de modo que cada base de datos solo puede gestionar un subconjunto de los datos. Tomando como ejemplo una base de datos de usuarios, a medida que aumenta el número de usuarios, se añaden más shards al clúster.

De manera similar a las ventajas de la [federación](#federation), el sharding resulta en menos tráfico de lectura y escritura, menos replicación y más aciertos en caché. El tamaño del índice también se reduce, lo que generalmente mejora el rendimiento con consultas más rápidas. Si un shard falla, los otros shards siguen operativos, aunque querrás añadir alguna forma de replicación para evitar la pérdida de datos. Al igual que la federación, no hay un maestro central único que serialice las escrituras, lo que permite escribir en paralelo con mayor rendimiento.

Las formas comunes de shardear una tabla de usuarios son a través de la inicial del apellido del usuario o la ubicación geográfica del usuario.

##### Desventaja(s): sharding

* Necesitarás actualizar la lógica de tu aplicación para trabajar con shards, lo que podría resultar en consultas SQL complejas.
* La distribución de datos puede volverse desigual en un shard. Por ejemplo, un conjunto de usuarios con mucha actividad en un shard podría resultar en una carga mayor en ese shard comparado con otros.
    * El rebalanceo añade complejidad adicional. Una función de sharding basada en [hashing consistente](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) puede reducir la cantidad de datos transferidos.
* Realizar joins de datos desde múltiples shards es más complejo.
* El sharding añade más hardware y complejidad adicional.

##### Fuente(s) y lectura adicional: sharding

* [La llegada del shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)
* [Arquitectura de base de datos shard](https://en.wikipedia.org/wiki/Shard_(database_architecture))
* [Hashing consistente](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)

#### Desnormalización

La desnormalización intenta mejorar el rendimiento de lectura a expensas de algo de rendimiento en escritura. Se escriben copias redundantes de los datos en múltiples tablas para evitar joins costosos. Algunos RDBMS como [PostgreSQL](https://en.wikipedia.org/wiki/PostgreSQL) y Oracle soportan [vistas materializadas](https://en.wikipedia.org/wiki/Materialized_view) que gestionan el trabajo de almacenar información redundante y mantener las copias redundantes consistentes.

Una vez que los datos se distribuyen con técnicas como la [federación](#federation) y el [sharding](#sharding), gestionar joins entre centros de datos incrementa aún más la complejidad. La desnormalización podría evitar la necesidad de esos joins complejos.

En la mayoría de los sistemas, las lecturas pueden superar ampliamente a las escrituras en una proporción de 100:1 o incluso 1000:1. Una lectura que resulta en un join complejo puede ser muy costosa, consumiendo una cantidad significativa de tiempo en operaciones de disco.

##### Desventaja(s): desnormalización

* Los datos se duplican.
* Las restricciones pueden ayudar a que las copias redundantes de información se mantengan sincronizadas, lo que aumenta la complejidad del diseño de la base de datos.
* Una base de datos desnormalizada bajo una carga pesada de escrituras podría rendir peor que su contraparte normalizada.

###### Fuente(s) y lectura adicional: desnormalización
* [Desnormalización](https://es.wikipedia.org/wiki/Desnormalizaci%C3%B3n)

#### Afinación de SQL

La afinación de SQL es un tema amplio y se han escrito muchos [libros](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) como referencia.

Es importante **realizar pruebas de rendimiento** y **perfiles** para simular y descubrir cuellos de botella.

* **Prueba de rendimiento** - Simular situaciones de alta carga con herramientas como [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).
* **Perfil** - Habilitar herramientas como el [registro de consultas lentas](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) para ayudar a rastrear problemas de rendimiento.

Las pruebas de rendimiento y los perfiles podrían indicarle las siguientes optimizaciones.

##### Ajustar el esquema

* MySQL volca a disco en bloques contiguos para acceso rápido.
* Use `CHAR` en lugar de `VARCHAR` para campos de longitud fija.
    * `CHAR` permite un acceso rápido y aleatorio, mientras que con `VARCHAR` debe encontrar el final de una cadena antes de pasar a la siguiente.
* Use `TEXT` para grandes bloques de texto como entradas de blog. `TEXT` también permite búsquedas booleanas. Usar un campo `TEXT` implica almacenar un puntero en disco que se usa para localizar el bloque de texto.
* Use `INT` para números grandes hasta 2^32 o 4 mil millones.
* Use `DECIMAL` para moneda para evitar errores de representación en punto flotante.
* Evite almacenar `BLOBS` grandes, almacene la ubicación de donde obtener el objeto en su lugar.
* `VARCHAR(255)` es el número máximo de caracteres que se pueden contar en un número de 8 bits, maximizando a menudo el uso de un byte en algunos RDBMS.
* Establezca la restricción `NOT NULL` donde sea aplicable para [mejorar el rendimiento de búsqueda](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).

##### Use buenos índices

* Las columnas que consulte (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) podrían ser más rápidas con índices.
* Los índices generalmente se representan como [B-tree](https://es.wikipedia.org/wiki/%C3%81rbol_B) autoequilibrados que mantienen los datos ordenados y permiten búsquedas, acceso secuencial, inserciones y eliminaciones en tiempo logarítmico.
* Colocar un índice puede mantener los datos en memoria, requiriendo más espacio.
* Las escrituras también podrían ser más lentas ya que el índice debe actualizarse.
* Al cargar grandes cantidades de datos, puede ser más rápido deshabilitar los índices, cargar los datos y luego reconstruir los índices.

##### Evite joins costosos

* [Desnormalice](#desnormalización) donde el rendimiento lo demande.

##### Particione tablas


* Dividir una tabla poniendo puntos calientes en una tabla separada para ayudar a mantenerla en memoria.

##### Ajustar la caché de consultas

* En algunos casos, la [caché de consultas](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) podría causar [problemas de rendimiento](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).

##### Fuente(s) y lecturas adicionales: Optimización SQL

* [Consejos para optimizar consultas MySQL](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)
* [¿Hay una buena razón para ver VARCHAR(255) usado tan frecuentemente?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [¿Cómo afectan los valores nulos al rendimiento?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Registro de consultas lentas](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)

### NoSQL

NoSQL es una colección de elementos de datos representados en un **almacén clave-valor**, **almacén de documentos**, **almacén de columnas anchas**, o una **base de datos de grafos**.  Los datos están desnormalizados, y las uniones generalmente se hacen en el código de la aplicación.  La mayoría de los almacenes NoSQL carecen de transacciones ACID verdaderas y prefieren la [consistencia eventual](#eventual-consistency).

**BASE** se usa a menudo para describir las propiedades de las bases de datos NoSQL.  En comparación con el [Teorema CAP](#cap-theorem), BASE elige disponibilidad sobre consistencia.

* **Básicamente disponible** - el sistema garantiza disponibilidad.
* **Estado blando** - el estado del sistema puede cambiar con el tiempo, incluso sin entrada.
* **Consistencia eventual** - el sistema se volverá consistente en un período de tiempo, dado que el sistema no reciba entrada durante ese período.

Además de elegir entre [SQL o NoSQL](#sql-or-nosql), es útil entender qué tipo de base de datos NoSQL se adapta mejor a su(s) caso(s) de uso.  Revisaremos **almacenes clave-valor**, **almacenes de documentos**, **almacenes de columnas anchas** y **bases de datos de grafos** en la siguiente sección.

#### Almacén clave-valor

> Abstracción: tabla hash

Un almacén clave-valor generalmente permite lecturas y escrituras O(1) y a menudo está respaldado por memoria o SSD.  Los almacenes de datos pueden mantener claves en [orden lexicográfico](https://en.wikipedia.org/wiki/Lexicographical_order), permitiendo una recuperación eficiente de rangos de claves.  Los almacenes clave-valor pueden permitir almacenar metadatos junto con un valor.

Los almacenes clave-valor ofrecen alto rendimiento y se usan frecuentemente para modelos de datos simples o para datos que cambian rápidamente, como una capa de caché en memoria.  Dado que ofrecen solo un conjunto limitado de operaciones, la complejidad se traslada a la capa de aplicación si se necesitan operaciones adicionales.

Un almacén clave-valor es la base para sistemas más complejos como un almacén de documentos y, en algunos casos, una base de datos de grafos.

##### Fuente(s) y lecturas adicionales: almacén clave-valor

* [Base de datos clave-valor](https://en.wikipedia.org/wiki/Key-value_database)
* [Desventajas de los almacenes clave-valor](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)
* [Arquitectura de Redis](http://qnimate.com/overview-of-redis-architecture/)
* [Arquitectura de Memcached](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)

#### Almacenamiento de documentos

> Abstracción: almacén clave-valor con documentos almacenados como valores

Un almacenamiento de documentos se centra en documentos (XML, JSON, binario, etc.), donde un documento almacena toda la información de un objeto dado. Los almacenes de documentos proporcionan APIs o un lenguaje de consulta para consultar basándose en la estructura interna del documento mismo. *Nota, muchos almacenes clave-valor incluyen características para trabajar con los metadatos de un valor, difuminando las líneas entre estos dos tipos de almacenamiento.*

Según la implementación subyacente, los documentos se organizan por colecciones, etiquetas, metadatos o directorios. Aunque los documentos pueden organizarse o agruparse juntos, los documentos pueden tener campos que son completamente diferentes entre sí.

Algunos almacenes de documentos como [MongoDB](https://www.mongodb.com/mongodb-architecture) y [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) también proporcionan un lenguaje similar a SQL para realizar consultas complejas. [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) soporta tanto clave-valor como documentos.

Los almacenes de documentos ofrecen alta flexibilidad y se utilizan frecuentemente para trabajar con datos que cambian ocasionalmente.

##### Fuente(s) y lectura adicional: almacenamiento de documentos

* [Base de datos orientada a documentos](https://es.wikipedia.org/wiki/Base_de_datos_orientada_a_documentos)
* [Arquitectura de MongoDB](https://www.mongodb.com/mongodb-architecture)
* [Arquitectura de CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Arquitectura de Elasticsearch](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)

#### Almacenamiento de columnas anchas

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Fuente: SQL & NoSQL, una breve historia</a></i>
</p>

> Abstracción: mapa anidado `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`

La unidad básica de datos de un almacenamiento de columnas anchas es una columna (par nombre/valor). Una columna puede agruparse en familias de columnas (análogas a una tabla SQL). Las familias de supercolumnas agrupan aún más familias de columnas. Puedes acceder a cada columna de forma independiente con una clave de fila, y las columnas con la misma clave forman una fila. Cada valor contiene una marca de tiempo para versionado y resolución de conflictos.

Google introdujo [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) como el primer almacenamiento de columnas anchas, que influyó en el proyecto open-source [HBase](https://www.edureka.co/blog/hbase-architecture/) usado frecuentemente en el ecosistema Hadoop, y [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) de Facebook. Almacenes como BigTable, HBase y Cassandra mantienen las claves en orden lexicográfico, permitiendo una recuperación eficiente de rangos selectivos de claves.

Los almacenes de columnas anchas ofrecen alta disponibilidad y alta escalabilidad. A menudo se utilizan para conjuntos de datos muy grandes.

##### Fuente(s) y lectura adicional: almacenamiento de columnas anchas

* [SQL & NoSQL, una breve historia](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)
* [Arquitectura de Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)
* [Arquitectura de HBase](https://www.edureka.co/blog/hbase-architecture/)
* [Arquitectura de Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)

#### Base de datos de grafos

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png">
  <br/>
  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Fuente: Base de datos de grafos</a></i>
</p>

> Abstracción: grafo

En una base de datos de grafos, cada nodo es un registro y cada arco es una relación entre dos nodos.  Las bases de datos de grafos están optimizadas para representar relaciones complejas con muchas claves foráneas o relaciones muchos a muchos.

Las bases de datos de grafos ofrecen un alto rendimiento para modelos de datos con relaciones complejas, como una red social.  Son relativamente nuevas y aún no se usan ampliamente; puede ser más difícil encontrar herramientas de desarrollo y recursos.  Muchos grafos solo pueden accederse con [APIs REST](#representational-state-transfer-rest).

##### Fuente(s) y lectura adicional: grafo

* [Base de datos de grafos](https://en.wikipedia.org/wiki/Graph_database)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)

#### Fuente(s) y lectura adicional: NoSQL

* [Explicación de la terminología BASE](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [Bases de datos NoSQL: una encuesta y guía para la decisión](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [Escalabilidad](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [Introducción a NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [Patrones NoSQL](http://horicky.blogspot.com/2009/11/nosql-patterns.html)

### SQL o NoSQL

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Fuente: Transición de RDBMS a NoSQL</a></i>
</p>

Razones para **SQL**:

* Datos estructurados
* Esquema estricto
* Datos relacionales
* Necesidad de uniones complejas
* Transacciones
* Patrones claros para escalado
* Más establecido: desarrolladores, comunidad, código, herramientas, etc.
* Las búsquedas por índice son muy rápidas

Razones para **NoSQL**:

* Datos semiestructurados
* Esquema dinámico o flexible
* Datos no relacionales
* No necesita uniones complejas
* Almacenar muchos TB (o PB) de datos
* Carga de trabajo muy intensiva en datos
* Muy alto rendimiento para IOPS

Datos de ejemplo bien adaptados para NoSQL:

* Ingesta rápida de datos de clickstream y registros
* Datos de tablas de clasificación o puntuación
* Datos temporales, como un carrito de compras
* Tablas frecuentemente accedidas ('calientes')
* Tablas de metadatos/búsqueda

##### Fuente(s) y lectura adicional: SQL o NoSQL

* [Escalando hasta tus primeros 10 millones de usuarios](https://www.youtube.com/watch?v=kKjm4ehYiMs)
* [Diferencias entre SQL y NoSQL](https://www.sitepoint.com/sql-vs-nosql-differences/)

## Caché

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Fuente: Patrones de diseño de sistemas escalables</a></i>
</p>

El almacenamiento en caché mejora los tiempos de carga de la página y puede reducir la carga en sus servidores y bases de datos. En este modelo, el despachador primero buscará si la solicitud se ha realizado antes e intentará encontrar el resultado previo para devolverlo, con el fin de ahorrar la ejecución real.

Las bases de datos a menudo se benefician de una distribución uniforme de lecturas y escrituras a través de sus particiones. Los elementos populares pueden sesgar la distribución, causando cuellos de botella. Colocar una caché delante de una base de datos puede ayudar a absorber cargas desiguales y picos de tráfico.

### Caché del cliente

Las cachés pueden estar ubicadas en el lado del cliente (SO o navegador), [lado del servidor](#reverse-proxy-web-server) o en una capa de caché distinta.

### Caché CDN

Las [CDNs](#content-delivery-network) se consideran un tipo de caché.

### Caché del servidor web

Los [proxy inversos](#reverse-proxy-web-server) y cachés como [Varnish](https://www.varnish-cache.org/) pueden servir contenido estático y dinámico directamente. Los servidores web también pueden almacenar en caché solicitudes, devolviendo respuestas sin tener que contactar con servidores de aplicaciones.

### Caché de base de datos

Su base de datos generalmente incluye algún nivel de caché en una configuración predeterminada, optimizada para un caso de uso genérico. Ajustar estas configuraciones para patrones de uso específicos puede mejorar aún más el rendimiento.

### Caché de aplicación

Las cachés en memoria como Memcached y Redis son almacenes clave-valor entre su aplicación y su almacenamiento de datos. Dado que los datos se mantienen en RAM, es mucho más rápido que las bases de datos típicas donde los datos se almacenan en disco. La RAM es más limitada que el disco, por lo que algoritmos de [invalidación de caché](https://es.wikipedia.org/wiki/Algoritmos_de_cach%C3%A9) como [el menos utilizado recientemente (LRU)](https://es.wikipedia.org/wiki/Pol%C3%ADticas_de_reemplazo_de_cach%C3%A9#El_menos_usado_recientemente_(LRU)) pueden ayudar a invalidar entradas 'frías' y mantener datos 'calientes' en RAM.

Redis tiene las siguientes características adicionales:

* Opción de persistencia
* Estructuras de datos integradas como conjuntos ordenados y listas

Hay múltiples niveles que puede almacenar en caché y que se dividen en dos categorías generales: **consultas de base de datos** y **objetos**:

* Nivel de fila
* Nivel de consulta
* Objetos serializables completamente formados
* HTML completamente renderizado

En general, debería tratar de evitar el almacenamiento en caché basado en archivos, ya que dificulta la clonación y el autoescalado.

### Caché a nivel de consulta de base de datos

Cada vez que consultas la base de datos, hashea la consulta como una clave y almacena el resultado en la caché. Este enfoque sufre problemas de expiración:

* Difícil eliminar un resultado en caché con consultas complejas
* Si un dato cambia, como una celda de tabla, necesitas eliminar todas las consultas en caché que podrían incluir la celda cambiada

### Caché a nivel de objeto

Ve tus datos como un objeto, similar a lo que haces con el código de tu aplicación. Haz que tu aplicación arme el conjunto de datos desde la base de datos en una instancia de clase o una(s) estructura(s) de datos:

* Elimina el objeto de la caché si sus datos subyacentes han cambiado
* Permite procesamiento asíncrono: los workers arman objetos consumiendo el último objeto en caché

Sugerencias de qué cachéar:

* Sesiones de usuario
* Páginas web completamente renderizadas
* Flujos de actividad
* Datos de grafo de usuario

### Cuándo actualizar la caché

Dado que solo puedes almacenar una cantidad limitada de datos en caché, deberás determinar qué estrategia de actualización de caché funciona mejor para tu caso de uso.

#### Cache-aside

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Fuente: De caché a grid de datos en memoria</a></i>
</p>

La aplicación es responsable de leer y escribir desde el almacenamiento. La caché no interactúa directamente con el almacenamiento. La aplicación hace lo siguiente:

* Busca la entrada en caché, resultando en un fallo de caché
* Carga la entrada desde la base de datos
* Añade la entrada a la caché
* Devuelve la entrada

```python
def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```

[Memcached](https://memcached.org/) generalmente se usa de esta manera.

Las lecturas posteriores de datos agregados a la caché son rápidas. Cache-aside también se conoce como carga perezosa. Solo se almacena en caché los datos solicitados, lo que evita llenar la caché con datos que no se solicitan.

##### Desventaja(s): cache-aside

* Cada fallo de caché resulta en tres viajes, lo que puede causar una demora notable.
* Los datos pueden volverse obsoletos si se actualizan en la base de datos. Este problema se mitiga configurando un tiempo de vida (TTL) que fuerza una actualización de la entrada de caché, o usando write-through.
* Cuando un nodo falla, es reemplazado por un nodo nuevo y vacío, aumentando la latencia.

#### Write-through

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fuente: Escalabilidad, disponibilidad, estabilidad, patrones</a></i>
</p>

La aplicación usa la caché como el almacén principal de datos, leyendo y escribiendo datos en ella, mientras que la caché es responsable de leer y escribir en la base de datos:

* La aplicación agrega/actualiza la entrada en la caché
* La caché escribe sincrónicamente la entrada en el almacén de datos
* Retorna

Código de la aplicación:

```python
set_user(12345, {"foo":"bar"})
```

Código de caché:

```python
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```

Write-through es una operación general lenta debido a la operación de escritura, pero las lecturas posteriores de datos recién escritos son rápidas. Los usuarios generalmente son más tolerantes a la latencia al actualizar datos que al leer datos. Los datos en la caché no están obsoletos.

##### Desventaja(s): write through

* Cuando se crea un nuevo nodo debido a una falla o escalado, el nuevo nodo no almacenará en caché las entradas hasta que la entrada se actualice en la base de datos. Cache-aside junto con write through puede mitigar este problema.
* La mayoría de los datos escritos podrían nunca ser leídos, lo que se puede minimizar con un TTL.

#### Write-behind (write-back)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fuente: Escalabilidad, disponibilidad, estabilidad, patrones</a></i>
</p>

En write-behind, la aplicación hace lo siguiente:

* Añadir/actualizar entrada en caché
* Escribir la entrada de forma asíncrona en el almacén de datos, mejorando el rendimiento de escritura

##### Desventaja(s): write-behind

* Podría haber pérdida de datos si la caché se cae antes de que sus contenidos lleguen al almacén de datos.
* Es más complejo implementar write-behind que implementar cache-aside o write-through.

#### Refresh-ahead

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Fuente: De caché a grid de datos en memoria</a></i>
</p>

Puede configurar la caché para actualizar automáticamente cualquier entrada de caché recientemente accedida antes de su expiración.

Refresh-ahead puede resultar en una latencia reducida frente a read-through si la caché puede predecir con precisión qué elementos probablemente se necesitarán en el futuro.

##### Desventaja(s): refresh-ahead

* No predecir con precisión qué elementos serán necesarios en el futuro puede resultar en un rendimiento reducido en comparación con no usar refresh-ahead.

### Desventaja(s): caché

* Es necesario mantener la consistencia entre las cachés y la fuente de la verdad, como la base de datos, mediante [invalidación de caché](https://es.wikipedia.org/wiki/Algoritmo_de_cach%C3%A9).
* La invalidación de caché es un problema difícil, existe una complejidad adicional asociada a cuándo actualizar la caché.
* Es necesario hacer cambios en la aplicación, como agregar Redis o memcached.

### Fuente(s) y lecturas adicionales

* [De caché a grid de datos en memoria](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [Patrones de diseño de sistemas escalables](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [Introducción a la arquitectura de sistemas para escala](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [Escalabilidad, disponibilidad, estabilidad, patrones](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Escalabilidad](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [Estrategias AWS ElastiCache](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)
* [Wikipedia](https://es.wikipedia.org/wiki/Cache_(inform%C3%A1tica))

## Asincronismo

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Fuente: Introducción a la arquitectura de sistemas para escala</a></i>
</p>

Los flujos de trabajo asíncronos ayudan a reducir los tiempos de respuesta para operaciones costosas que de otro modo se realizarían en línea. También pueden ayudar realizando trabajo que consume tiempo por adelantado, como la agregación periódica de datos.

### Colas de mensajes

Las colas de mensajes reciben, retienen y entregan mensajes. Si una operación es demasiado lenta para realizarse en línea, puede usar una cola de mensajes con el siguiente flujo de trabajo:

* Una aplicación publica un trabajo en la cola y luego notifica al usuario sobre el estado del trabajo
* Un trabajador recoge el trabajo de la cola, lo procesa y luego señala que el trabajo está completo

El usuario no queda bloqueado y el trabajo se procesa en segundo plano. Durante este tiempo, el cliente podría opcionalmente realizar una pequeña cantidad de procesamiento para que parezca que la tarea ha finalizado. Por ejemplo, si publicas un tweet, el tweet podría aparecer instantáneamente en tu línea de tiempo, pero podría tardar un poco antes de que tu tweet sea realmente entregado a todos tus seguidores.

**[Redis](https://redis.io/)** es útil como un broker de mensajes simple, pero los mensajes pueden perderse.

**[RabbitMQ](https://www.rabbitmq.com/)** es popular pero requiere que te adaptes al protocolo 'AMQP' y administres tus propios nodos.

**[Amazon SQS](https://aws.amazon.com/sqs/)** está alojado pero puede tener alta latencia y existe la posibilidad de que los mensajes se entreguen dos veces.

### Colas de tareas

Las colas de tareas reciben tareas y sus datos relacionados, las ejecutan y luego entregan sus resultados. Pueden soportar programación y pueden usarse para ejecutar trabajos computacionalmente intensivos en segundo plano.

**[Celery](https://docs.celeryproject.org/en/stable/)** tiene soporte para programación y principalmente tiene soporte para python.

### Presión de retorno

Si las colas comienzan a crecer significativamente, el tamaño de la cola puede ser mayor que la memoria, lo que resulta en fallos de caché, lecturas de disco y un rendimiento aún más lento. [La presión de retorno](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) puede ayudar limitando el tamaño de la cola, manteniendo así una alta tasa de rendimiento y buenos tiempos de respuesta para los trabajos ya en la cola. Una vez que la cola se llena, los clientes reciben un código de estado de servidor ocupado o HTTP 503 para intentar de nuevo más tarde. Los clientes pueden reintentar la solicitud en otro momento, quizás con [retroceso exponencial](https://en.wikipedia.org/wiki/Exponential_backoff).

### Desventaja(s): asincronía

* Casos de uso como cálculos económicos y flujos de trabajo en tiempo real podrían ser más adecuados para operaciones síncronas, ya que introducir colas puede añadir retrasos y complejidad.

### Fuente(s) y lectura adicional

* [Todo es un juego de números](https://www.youtube.com/watch?v=1KRYH75wgy4)
* [Aplicando presión de retorno cuando está sobrecargado](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [Ley de Little](https://en.wikipedia.org/wiki/Little%27s_law)
* [¿Cuál es la diferencia entre una cola de mensajes y una cola de tareas?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)

## Comunicación

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Fuente: modelo OSI de 7 capas</a></i>
</p>

### Protocolo de transferencia de hipertexto (HTTP)

HTTP es un método para codificar y transportar datos entre un cliente y un servidor. Es un protocolo de solicitud/respuesta: los clientes emiten solicitudes y los servidores emiten respuestas con contenido relevante e información de estado de finalización sobre la solicitud. HTTP es autónomo, permitiendo que solicitudes y respuestas fluyan a través de muchos routers y servidores intermedios que realizan balanceo de carga, almacenamiento en caché, cifrado y compresión.

Una solicitud HTTP básica consiste en un verbo (método) y un recurso (endpoint). A continuación se muestran verbos HTTP comunes:

| Verbo | Descripción | Idempotente* | Seguro | Cacheable |
|---|---|---|---|---|
| GET | Lee un recurso | Sí | Sí | Sí |
| POST | Crea un recurso o activa un proceso que maneja datos | No | No | Sí si la respuesta contiene información de frescura |
| PUT | Crea o reemplaza un recurso | Sí | No | No |
| PATCH | Actualiza parcialmente un recurso | No | No | Sí si la respuesta contiene información de frescura |
| DELETE | Elimina un recurso | Sí | No | No |

*Puede llamarse muchas veces sin resultados diferentes.

HTTP es un protocolo de capa de aplicación que se basa en protocolos de nivel inferior como **TCP** y **UDP**.

#### Fuente(s) y lectura adicional: HTTP

* [¿Qué es HTTP?](https://www.nginx.com/resources/glossary/http/)
* [Diferencia entre HTTP y TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [Diferencia entre PUT y PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)

### Protocolo de control de transmisión (TCP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Fuente: Cómo hacer un juego multijugador</a></i>
</p>

TCP es un protocolo orientado a conexión sobre una [red IP](https://es.wikipedia.org/wiki/Protocolo_de_Internet). La conexión se establece y termina usando un [handshake](https://es.wikipedia.org/wiki/Intercambio_de_señales). Todos los paquetes enviados están garantizados a llegar al destino en el orden original y sin corrupción mediante:

* Números de secuencia y [campos de checksum](https://es.wikipedia.org/wiki/Protocolo_de_control_de_transmisión#Cálculo_del_checksum) para cada paquete
* Paquetes de [reconocimiento](https://es.wikipedia.org/wiki/Reconocimiento_(redes_de_datos)) y retransmisión automática

Si el emisor no recibe una respuesta correcta, reenviará los paquetes. Si hay múltiples tiempos de espera, la conexión se cae. TCP también implementa [control de flujo](https://es.wikipedia.org/wiki/Control_de_flujo_(datos)) y [control de congestión](https://es.wikipedia.org/wiki/Congestión_de_red#Control_de_la_congestión). Estas garantías causan retrasos y generalmente resultan en una transmisión menos eficiente que UDP.

Para asegurar un alto rendimiento, los servidores web pueden mantener un gran número de conexiones TCP abiertas, lo que resulta en un alto uso de memoria. Puede ser costoso tener un gran número de conexiones abiertas entre hilos del servidor web y, por ejemplo, un servidor [memcached](https://memcached.org/). El [pooling de conexiones](https://es.wikipedia.org/wiki/Pool_de_conexiones) puede ayudar además de cambiar a UDP cuando sea aplicable.

TCP es útil para aplicaciones que requieren alta fiabilidad pero son menos críticas en tiempo. Algunos ejemplos incluyen servidores web, información de bases de datos, SMTP, FTP y SSH.

Usa TCP sobre UDP cuando:

* Necesites que todos los datos lleguen intactos
* Quieras hacer automáticamente una mejor estimación del uso del rendimiento de la red

### Protocolo de datagramas de usuario (UDP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Fuente: Cómo hacer un juego multijugador</a></i>
</p>

UDP es sin conexión. Los datagramas (análogos a paquetes) están garantizados solo a nivel de datagrama. Los datagramas pueden llegar a su destino fuera de orden o no llegar en absoluto. UDP no soporta control de congestión. Sin las garantías que soporta TCP, UDP es generalmente más eficiente.

UDP puede hacer broadcast, enviando datagramas a todos los dispositivos en la subred. Esto es útil con [DHCP](https://es.wikipedia.org/wiki/Protocolo_de_configuraci%C3%B3n_din%C3%A1mica_de_host) porque el cliente aún no ha recibido una dirección IP, lo que impide una manera para que TCP transmita sin la dirección IP.

UDP es menos confiable pero funciona bien en casos de uso en tiempo real como VoIP, videollamadas, streaming y juegos multijugador en tiempo real.

Usa UDP en lugar de TCP cuando:

* Necesitas la latencia más baja
* Los datos tardíos son peores que la pérdida de datos
* Quieres implementar tu propia corrección de errores

#### Fuente(s) y lectura adicional: TCP y UDP

* [Redes para programación de juegos](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)
* [Diferencias clave entre los protocolos TCP y UDP](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Diferencia entre TCP y UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Protocolo de control de transmisión](https://es.wikipedia.org/wiki/Protocolo_de_control_de_transmisi%C3%B3n)
* [Protocolo de datagramas de usuario](https://es.wikipedia.org/wiki/Protocolo_de_datagramas_de_usuario)
* [Escalando memcache en Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)

### Llamada a procedimiento remoto (RPC)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Fuente: Crack the system design interview</a></i>
</p>

En una RPC, un cliente hace que un procedimiento se ejecute en un espacio de direcciones diferente, usualmente un servidor remoto. El procedimiento está codificado como si fuera una llamada a procedimiento local, abstrayendo los detalles de cómo comunicarse con el servidor desde el programa cliente. Las llamadas remotas suelen ser más lentas y menos confiables que las llamadas locales, por lo que es útil distinguir las llamadas RPC de las llamadas locales. Los frameworks RPC populares incluyen [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/), y [Avro](https://avro.apache.org/docs/current/).

RPC es un protocolo de solicitud-respuesta:

* **Programa cliente** - Llama al procedimiento stub del cliente. Los parámetros se apilan en la pila como en una llamada a procedimiento local.
* **Procedimiento stub del cliente** - Empaqueta (marshal) el id del procedimiento y los argumentos en un mensaje de solicitud.
* **Módulo de comunicación del cliente** - El SO envía el mensaje desde el cliente al servidor.
* **Módulo de comunicación del servidor** - El SO pasa los paquetes entrantes al procedimiento stub del servidor.
* **Procedimiento stub del servidor** - Desempaqueta (unmarshal) los resultados, llama al procedimiento del servidor que coincide con el id del procedimiento y pasa los argumentos dados.
* La respuesta del servidor repite los pasos anteriores en orden inverso.

Llamadas RPC de ejemplo:

```
GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
```

RPC se centra en exponer comportamientos. Los RPC a menudo se utilizan por razones de rendimiento en comunicaciones internas, ya que puedes crear llamadas nativas a medida para ajustarlas mejor a tus casos de uso.

Elige una biblioteca nativa (también conocida como SDK) cuando:

* Conozcas tu plataforma objetivo.
* Quieras controlar cómo se accede a tu "lógica".
* Quieras controlar cómo se maneja el control de errores fuera de tu biblioteca.
* El rendimiento y la experiencia del usuario final sean tu principal preocupación.

Las APIs HTTP que siguen **REST** tienden a usarse más a menudo para APIs públicas.

#### Desventaja(s): RPC

* Los clientes RPC se vuelven fuertemente acoplados a la implementación del servicio.
* Se debe definir una nueva API para cada nueva operación o caso de uso.
* Puede ser difícil depurar RPC.
* Puede que no puedas aprovechar tecnologías existentes directamente. Por ejemplo, podría requerir esfuerzo adicional asegurar que [las llamadas RPC se almacenen en caché adecuadamente](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) en servidores de caché como [Squid](http://www.squid-cache.org/).

### Transferencia de estado representacional (REST)

REST es un estilo arquitectónico que impone un modelo cliente/servidor donde el cliente actúa sobre un conjunto de recursos gestionados por el servidor. El servidor proporciona una representación de recursos y acciones que pueden manipular o obtener una nueva representación de recursos. Toda la comunicación debe ser sin estado y cacheable.

Hay cuatro cualidades de una interfaz RESTful:

* **Identificar recursos (URI en HTTP)** - usar el mismo URI independientemente de la operación.
* **Cambiar con representaciones (Verbos en HTTP)** - usar verbos, encabezados y cuerpo.
* **Mensaje de error auto-descriptivo (respuesta de estado en HTTP)** - usar códigos de estado, no reinventar la rueda.
* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (interfaz HTML para HTTP)** - tu servicio web debe ser completamente accesible en un navegador.

Ejemplos de llamadas REST:

```
GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
```

REST se centra en exponer datos. Minimiza el acoplamiento entre cliente/servidor y se utiliza a menudo para APIs HTTP públicas. REST utiliza un método más genérico y uniforme para exponer recursos a través de URIs, [representación mediante encabezados](https://github.com/for-GET/know-your-http-well/blob/master/headers.md) y acciones a través de verbos como GET, POST, PUT, DELETE y PATCH. Al ser sin estado, REST es ideal para escalado horizontal y particionamiento.

#### Desventaja(s): REST

* Al estar REST centrado en exponer datos, puede no ser adecuado si los recursos no están organizados naturalmente o accedidos en una jerarquía simple. Por ejemplo, devolver todos los registros actualizados de la última hora que coincidan con un conjunto particular de eventos no se expresa fácilmente como una ruta. Con REST, es probable que se implemente con una combinación de ruta URI, parámetros de consulta y posiblemente el cuerpo de la solicitud.
* REST típicamente se basa en algunos verbos (GET, POST, PUT, DELETE y PATCH) que a veces no encajan en tu caso de uso. Por ejemplo, mover documentos expirados a la carpeta de archivo podría no encajar claramente dentro de estos verbos.
* Obtener recursos complicados con jerarquías anidadas requiere múltiples viajes de ida y vuelta entre cliente y servidor para renderizar vistas individuales, p. ej., obtener el contenido de una entrada de blog y los comentarios sobre esa entrada. Para aplicaciones móviles que operan en condiciones de red variables, estos múltiples viajes son altamente indeseables.
* Con el tiempo, se pueden añadir más campos a una respuesta de API y los clientes antiguos recibirán todos los nuevos campos de datos, incluso aquellos que no necesitan, lo que hace que el tamaño de la carga útil se incremente y provoque latencias mayores.

### Comparación de llamadas RPC y REST

| Operación | RPC | REST |
|---|---|---|
| Registro    | **POST** /signup | **POST** /persons |
| Renuncia    | **POST** /resign<br/>{<br/>"personid": "1234"<br/>} | **DELETE** /persons/1234 |
| Leer una persona | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |
| Leer lista de ítems de una persona | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |
| Añadir un ítem a la lista de una persona | **POST** /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | **POST** /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Actualizar un ítem    | **POST** /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | **PUT** /items/456<br/>{<br/>"key": "value"<br/>} |
| Eliminar un ítem | **POST** /removeItem<br/>{<br/>"itemid": "456"<br/>} | **DELETE** /items/456 |

<p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Fuente: ¿Realmente sabes por qué prefieres REST sobre RPC?</a></i>
</p>

#### Fuente(s) y lecturas adicionales: REST y RPC

* [¿Realmente sabes por qué prefieres REST sobre RPC?](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [¿Cuándo son más apropiados enfoques tipo RPC que REST?](http://programmers.stackexchange.com/a/181186)
* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [Desmitificando los mitos de RPC y REST](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)
* [¿Cuáles son las desventajas de usar REST?](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Supera la entrevista de diseño de sistemas](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Thrift](https://code.facebook.com/posts/1468950976659943/)
* [Por qué REST para uso interno y no RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)

## Seguridad

Esta sección podría usar algunas actualizaciones. ¡Considera [contribuir](#contributing)!

La seguridad es un tema amplio. A menos que tengas una experiencia considerable, un conocimiento en seguridad, o estés aplicando para un puesto que requiera conocimientos de seguridad, probablemente no necesites saber más que lo básico:

* Encripta en tránsito y en reposo.
* Sanitiza todas las entradas de usuario o cualquier parámetro de entrada expuesto al usuario para prevenir [XSS](https://es.wikipedia.org/wiki/Cross-site_scripting) y [inyección SQL](https://es.wikipedia.org/wiki/Inyecci%C3%B3n_SQL).
* Usa consultas parametrizadas para prevenir la inyección SQL.
* Usa el principio de [mínimo privilegio](https://es.wikipedia.org/wiki/Principio_de_m%C3%ADnimo_privilegio).

### Fuente(s) y lectura adicional

* [Lista de verificación de seguridad para API](https://github.com/shieldfy/API-Security-Checklist)
* [Guía de seguridad para desarrolladores](https://github.com/FallibleInc/security-guide-for-developers)
* [Top ten de OWASP](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)

## Apéndice

A veces se te pedirá hacer estimaciones 'rápidas'. Por ejemplo, podrías necesitar determinar cuánto tiempo tomará generar 100 miniaturas de imágenes desde el disco o cuánta memoria ocupará una estructura de datos. La **tabla de potencias de dos** y los **números de latencia que todo programador debería conocer** son referencias útiles.

### Tabla de potencias de dos

```
Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
```
#### Fuente(s) y lectura adicional

* [Potencias de dos](https://es.wikipedia.org/wiki/Potencia_de_dos)

### Números de latencia que todo programador debe conocer


```
Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
HDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
```
Métricas útiles basadas en los números anteriores:

* Lectura secuencial desde HDD a 30 MB/s
* Lectura secuencial desde Ethernet de 1 Gbps a 100 MB/s
* Lectura secuencial desde SSD a 1 GB/s
* Lectura secuencial desde memoria principal a 4 GB/s
* 6-7 viajes de ida y vuelta en todo el mundo por segundo
* 2,000 viajes de ida y vuelta por segundo dentro de un centro de datos

#### Números de latencia visualizados

![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)

#### Fuente(s) y lectura adicional

* [Números de latencia que todo programador debe conocer - 1](https://gist.github.com/jboner/2841832)
* [Números de latencia que todo programador debe conocer - 2](https://gist.github.com/hellerbarde/2843375)
* [Diseños, lecciones y consejos de la construcción de sistemas distribuidos grandes](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)
* [Consejos de ingeniería de software al construir sistemas distribuidos a gran escala](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)

### Preguntas adicionales para entrevistas de diseño de sistemas

> Preguntas comunes en entrevistas de diseño de sistemas, con enlaces a recursos sobre cómo resolver cada una.

| Pregunta | Referencia(s) |
|---|---|
| Diseñar un servicio de sincronización de archivos como Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| Diseñar un motor de búsqueda como Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |
| Diseñar un rastreador web escalable como Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |
| Diseñar Google docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |
| Diseñar un almacén clave-valor como Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| Diseñar un sistema de caché como Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Diseñar un sistema de recomendación como el de Amazon | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |
| Diseñar un sistema tinyurl como Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |
| Diseñar una app de chat como WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| Diseñar un sistema para compartir fotos como Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |
| Diseñar la función de noticias en Facebook | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |
| Diseñar la función de línea de tiempo en Facebook | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |
| Diseñar la función de chat en Facebook | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |

| Diseñar una función de búsqueda en grafo como la de Facebook | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |
| Diseñar una red de entrega de contenido como CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |
| Diseñar un sistema de temas de tendencia como el de Twitter | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |
| Diseñar un sistema de generación de ID aleatorio | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |
| Devolver las k solicitudes principales durante un intervalo de tiempo | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |
| Diseñar un sistema que sirva datos desde múltiples centros de datos | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |
| Diseñar un juego de cartas multijugador en línea | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |
| Diseñar un sistema de recolección de basura | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |
| Diseñar un limitador de tasa para API | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |
| Diseñar una bolsa de valores (como NASDAQ o Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Implementación en Golang](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Implementación en Go](http://bhomnick.net/building-a-simple-limit-order-in-go/) |
| Añadir una pregunta de diseño de sistema | [Contribuir](#contributing) |

### Arquitecturas del mundo real

> Artículos sobre cómo se diseñan los sistemas en el mundo real.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Fuente: Líneas de tiempo de Twitter a gran escala</a></i>
</p>

**No te centres en los detalles minuciosos de los siguientes artículos, en cambio:**

* Identifica principios compartidos, tecnologías comunes y patrones dentro de estos artículos
* Estudia qué problemas resuelve cada componente, dónde funciona, dónde no
* Revisa las lecciones aprendidas

|Tipo | Sistema | Referencia(s) |
|---|---|---|
| Procesamiento de datos | **MapReduce** - Procesamiento de datos distribuido de Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |
| Procesamiento de datos | **Spark** - Procesamiento de datos distribuido de Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |
| Procesamiento de datos | **Storm** - Procesamiento de datos distribuido de Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |
| | | |
| Almacenamiento de datos | **Bigtable** - Base de datos distribuida orientada a columnas de Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |
| Almacenamiento de datos | **HBase** - Implementación de código abierto de Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |
| Almacenamiento de datos | **Cassandra** - Base de datos distribuida orientada a columnas de Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)
| Almacenamiento de datos | **DynamoDB** - Base de datos orientada a documentos de Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |
| Almacenamiento de datos | **MongoDB** - Base de datos orientada a documentos | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |
| Almacenamiento de datos | **Spanner** - Base de datos distribuida globalmente de Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |
| Almacén de datos | **Memcached** - Sistema de caché distribuido en memoria | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Almacén de datos | **Redis** - Sistema de caché distribuido en memoria con persistencia y tipos de valores | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| | | |
| Sistema de archivos | **Google File System (GFS)** - Sistema de archivos distribuido | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |
| Sistema de archivos | **Hadoop File System (HDFS)** - Implementación de código abierto de GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |
| | | |
| Varios | **Chubby** - Servicio de bloqueo para sistemas distribuidos débilmente acoplados de Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |
| Varios | **Dapper** - Infraestructura para rastreo de sistemas distribuidos | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf) |
| Varios | **Kafka** - Cola de mensajes pub/sub de LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |
| Varios | **Zookeeper** - Infraestructura y servicios centralizados que permiten la sincronización | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |
| | Añadir una arquitectura | [Contribuir](#contributing) |

### Arquitecturas de empresas

| Empresa | Referencia(s) |
|---|---|
| Amazon | [Arquitectura de Amazon](http://highscalability.com/amazon-architecture) |
| Cinchcast | [Produciendo 1,500 horas de audio cada día](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |
| DataSift | [Minería de datos en tiempo real a 120,000 tweets por segundo](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |
| Dropbox | [Cómo hemos escalado Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| ESPN | [Operando a 100,000 duh nuh nuhs por segundo](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |
| Google | [Arquitectura de Google](http://highscalability.com/google-architecture) |
| Instagram | [14 millones de usuarios, terabytes de fotos](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Qué impulsa Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |
| Justin.tv | [Arquitectura de transmisión de video en vivo de Justin.Tv](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |
| Facebook | [Escalando memcached en Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Almacén de datos distribuido de Facebook para el grafo social](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Almacenamiento de fotos de Facebook](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Cómo Facebook transmite en vivo a 800,000 espectadores simultáneos](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |
| Flickr | [Arquitectura de Flickr](http://highscalability.com/flickr-architecture) |
| Mailbox | [De 0 a un millón de usuarios en 6 semanas](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |
| Netflix | [Una vista de 360 grados de toda la pila de Netflix](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: Qué sucede cuando presionas reproducir](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |
| Pinterest | [De 0 a decenas de miles de millones de vistas de página al mes](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 millones de visitantes, crecimiento de 10x, 12 empleados](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |
| Playfish | [50 millones de usuarios mensuales y creciendo](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |
| PlentyOfFish | [Arquitectura de PlentyOfFish](http://highscalability.com/plentyoffish-architecture) |
| Salesforce | [Cómo manejan 1.3 mil millones de transacciones por día](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |
| Stack Overflow | [Arquitectura de Stack Overflow](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |
| TripAdvisor | [40M visitantes, 200M vistas dinámicas de página, 30TB de datos](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |
| Tumblr | [15 mil millones de vistas de página al mes](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |
| Twitter | [Haciendo Twitter 10,000 por ciento más rápido](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Almacenando 250 millones de tweets al día usando MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M usuarios activos, 300K QPS, un firehose de 22 MB/s](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Líneas de tiempo a escala](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Datos grandes y pequeños en Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operaciones en Twitter: escalando más allá de 100 millones de usuarios](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[Cómo Twitter maneja 3,000 imágenes por segundo](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |
| Uber | [Cómo Uber escala su plataforma de mercado en tiempo real](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lecciones aprendidas al escalar Uber a 2000 ingenieros, 1000 servicios y 8000 repositorios Git](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |
| WhatsApp | [La arquitectura de WhatsApp que Facebook compró por 19 mil millones de dólares](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| YouTube | [Escalabilidad de YouTube](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[Arquitectura de YouTube](http://highscalability.com/youtube-architecture) |

### Blogs de ingeniería de empresas

> Arquitecturas para las empresas con las que estás entrevistando.
>
> Las preguntas que encuentres podrían ser del mismo dominio.

* [Ingeniería de Airbnb](http://nerds.airbnb.com/)
* [Desarrolladores de Atlassian](https://developer.atlassian.com/blog/)
* [Blog de AWS](https://aws.amazon.com/blogs/aws/)
* [Blog de Ingeniería de Bitly](http://word.bitly.com/)
* [Blogs de Box](https://blog.box.com/blog/category/engineering)
* [Blog de Desarrolladores de Cloudera](http://blog.cloudera.com/)
* [Blog Técnico de Dropbox](https://tech.dropbox.com/)
* [Ingeniería en Quora](https://www.quora.com/q/quoraengineering)
* [Blog Técnico de Ebay](http://www.ebaytechblog.com/)
* [Blog Técnico de Evernote](https://blog.evernote.com/tech/)
* [Etsy Código como Artesanía](http://codeascraft.com/)
* [Ingeniería de Facebook](https://www.facebook.com/Engineering)
* [Código de Flickr](http://code.flickr.net/)
* [Blog de Ingeniería de Foursquare](http://engineering.foursquare.com/)
* [Blog de Ingeniería de GitHub](https://github.blog/category/engineering)
* [Blog de Investigación de Google](http://googleresearch.blogspot.com/)
* [Blog de Ingeniería de Groupon](https://engineering.groupon.com/)
* [Blog de Ingeniería de Heroku](https://engineering.heroku.com/)
* [Blog de Ingeniería de Hubspot](http://product.hubspot.com/blog/topic/engineering)
* [Alta Escalabilidad](http://highscalability.com/)
* [Ingeniería de Instagram](http://instagram-engineering.tumblr.com/)
* [Blog de Software de Intel](https://software.intel.com/en-us/blogs/)
* [Blog Técnico de Jane Street](https://blogs.janestreet.com/category/ocaml/)
* [Ingeniería de LinkedIn](http://engineering.linkedin.com/blog)
* [Ingeniería de Microsoft](https://engineering.microsoft.com/)
* [Ingeniería Python de Microsoft](https://blogs.msdn.microsoft.com/pythonengineering/)
* [Blog Técnico de Netflix](http://techblog.netflix.com/)
* [Blog para Desarrolladores de Paypal](https://medium.com/paypal-engineering)
* [Blog de Ingeniería de Pinterest](https://medium.com/@Pinterest_Engineering)
* [Blog de Reddit](http://www.redditblog.com/)
* [Blog de Ingeniería de Salesforce](https://developer.salesforce.com/blogs/engineering/)
* [Blog de Ingeniería de Slack](https://slack.engineering/)
* [Laboratorios Spotify](https://labs.spotify.com/)
* [Blog de Ingeniería de Stripe](https://stripe.com/blog/engineering)
* [Blog de Ingeniería de Twilio](http://www.twilio.com/engineering)
* [Ingeniería de Twitter](https://blog.twitter.com/engineering/)
* [Blog de Ingeniería de Uber](http://eng.uber.com/)
* [Blog de Ingeniería de Yahoo](http://yahooeng.tumblr.com/)
* [Blog de Ingeniería de Yelp](http://engineeringblog.yelp.com/)
* [Blog de Ingeniería de Zynga](https://www.zynga.com/blogs/engineering)

#### Fuente(s) y lecturas adicionales

¿Quieres agregar un blog? Para evitar trabajo duplicado, considera añadir el blog de tu empresa al siguiente repositorio:

* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)

## En desarrollo

¿Interesado en agregar una sección o ayudar a completar una en progreso? ¡[Contribuye](#contributing)!

* Computación distribuida con MapReduce
* Hashing consistente
* Scatter gather
* [Contribuye](#contributing)

## Créditos

Los créditos y fuentes están proporcionados a lo largo de este repositorio.

Agradecimientos especiales a:

* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)
* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)
* [High scalability](http://highscalability.com/)
* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)
* [shashank88/system_design](https://github.com/shashank88/system_design)
* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)
* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
* [A distributed systems reading list](http://dancres.github.io/Pages/)
* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)

## Información de contacto

No dude en contactarme para discutir cualquier problema, pregunta o comentario.

Mi información de contacto se puede encontrar en mi [página de GitHub](https://github.com/donnemartin).

## Licencia

*Estoy proporcionando el código y los recursos en este repositorio bajo una licencia de código abierto. Debido a que este es mi repositorio personal, la licencia que recibe para mi código y recursos es de mi parte y no de mi empleador (Facebook).*

    Derechos de autor 2017 Donne Martin

    Licencia Internacional Creative Commons Atribución 4.0 (CC BY 4.0)

    http://creativecommons.org/licenses/by/4.0/


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-08-09

---