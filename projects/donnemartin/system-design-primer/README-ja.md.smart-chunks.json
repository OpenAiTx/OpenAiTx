[
  {
    "Id": 1,
    "Content": "*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*",
    "ContentSha": "NV5If+n4caPL9367nN6NPHEHX2NVMyxh97QjgslLVk8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "\n**Help [translate](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) this guide!**\n\n# The System Design Primer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png\">\n  <br/>\n</p>\n\n## Motivation\n\n> Learn how to design large-scale systems.\n>\n> Prep for the system design interview.\n\n### Learn how to design large-scale systems\n\nLearning how to design scalable systems will help you become a better engineer.\n\nSystem design is a broad topic.  There is a **vast amount of resources scattered throughout the web** on system design principles.\n\nThis repo is an **organized collection** of resources to help you learn how to build systems at scale.\n\n### Learn from the open source community\n\nThis is a continually updated, open source project.\n\n[Contributions](#contributing) are welcome!\n\n### Prep for the system design interview\n\nIn addition to coding interviews, system design is a **required component** of the **technical interview process** at many tech companies.\n\n**Practice common system design interview questions** and **compare** your results with **sample solutions**: discussions, code, and diagrams.\n\nAdditional topics for interview prep:\n\n* [Study guide](#study-guide)\n* [How to approach a system design interview question](#how-to-approach-a-system-design-interview-question)",
    "ContentSha": "AbJTT6alKgUjtCBRmG+Q5nAyd3D1OmTONWi5hXEC4sI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**このガイドの[翻訳](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md)にご協力ください！**\n\n# システム設計入門\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png\">\n  <br/>\n</p>\n\n## 動機\n\n> 大規模システムの設計方法を学ぶ。\n>\n> システム設計面接の準備をする。\n\n### 大規模システムの設計方法を学ぶ\n\nスケーラブルなシステムの設計方法を学ぶことは、より良いエンジニアになる助けとなります。\n\nシステム設計は広範なトピックです。システム設計の原則に関する**膨大な量のリソースがウェブ上に散在しています**。\n\nこのリポジトリは、スケールするシステムの構築方法を学ぶのに役立つ**体系的に整理されたリソースのコレクション**です。\n\n### オープンソースコミュニティから学ぶ\n\nこれは継続的に更新されるオープンソースプロジェクトです。\n\n[貢献](#contributing)を歓迎します！\n\n### システム設計面接の準備\n\nコーディング面接に加えて、多くの技術系企業の**技術面接プロセス**にはシステム設計が**必須の要素**となっています。\n\n**一般的なシステム設計面接の質問を練習し**、**議論、コード、図解を含むサンプル解答**と**比較**しましょう。\n\n面接準備のための追加トピック：\n\n* [学習ガイド](#study-guide)\n* [システム設計面接の質問へのアプローチ方法](#how-to-approach-a-system-design-interview-question)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 3,
    "Content": "* [System design interview questions, **with solutions**](#system-design-interview-questions-with-solutions)\n* [Object-oriented design interview questions, **with solutions**](#object-oriented-design-interview-questions-with-solutions)\n* [Additional system design interview questions](#additional-system-design-interview-questions)\n\n## Anki flashcards\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png\">\n  <br/>\n</p>\n\nThe provided [Anki flashcard decks](https://apps.ankiweb.net/) use spaced repetition to help you retain key system design concepts.\n\n* [System design deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)\n* [System design exercises deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)\n* [Object oriented design exercises deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)\n\nGreat for use while on-the-go.\n\n### Coding Resource: Interactive Coding Challenges\n\nLooking for resources to help you prep for the [**Coding Interview**](https://github.com/donnemartin/interactive-coding-challenges)?\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png\">\n  <br/>\n</p>\n\nCheck out the sister repo [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges), which contains an additional Anki deck:\n\n* [Coding deck](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)\n\n## Contributing\n\n> Learn from the community.\n\nFeel free to submit pull requests to help:\n\n* Fix errors\n* Improve sections",
    "ContentSha": "SXl/9sXgfkMzgSqqZA/bJ68vMrerBbNpRqT5TMAq1Hg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [システム設計面接質問、**解答付き**](#system-design-interview-questions-with-solutions)\n* [オブジェクト指向設計面接質問、**解答付き**](#object-oriented-design-interview-questions-with-solutions)\n* [追加のシステム設計面接質問](#additional-system-design-interview-questions)\n\n## Ankiフラッシュカード\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png\">\n  <br/>\n</p>\n\n提供されている[Ankiフラッシュカードデッキ](https://apps.ankiweb.net/)は、間隔反復を利用して主要なシステム設計の概念を記憶するのに役立ちます。\n\n* [システム設計デッキ](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)\n* [システム設計演習デッキ](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)\n* [オブジェクト指向設計演習デッキ](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)\n\n外出先での利用に最適です。\n\n### コーディングリソース: インタラクティブコーディングチャレンジ\n\n[**コーディング面接**](https://github.com/donnemartin/interactive-coding-challenges)の準備に役立つリソースをお探しですか？\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png\">\n  <br/>\n</p>\n\n姉妹リポジトリの[**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges)もぜひご覧ください。追加のAnkiデッキが含まれています：\n\n* [コーディングデッキ](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)\n\n## 貢献について\n\n> コミュニティから学びましょう。\n\n以下のためにプルリクエストを自由に送ってください：\n\n* 誤りの修正\n* セクションの改善",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 4,
    "Content": "* Add new sections\n* [Translate](https://github.com/donnemartin/system-design-primer/issues/28)\n\nContent that needs some polishing is placed [under development](#under-development).\n\nReview the [Contributing Guidelines](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).\n\n## Index of system design topics\n\n> Summaries of various system design topics, including pros and cons.  **Everything is a trade-off**.\n>\n> Each section contains links to more in-depth resources.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png\">\n  <br/>\n</p>\n\n* [System design topics: start here](#system-design-topics-start-here)\n    * [Step 1: Review the scalability video lecture](#step-1-review-the-scalability-video-lecture)\n    * [Step 2: Review the scalability article](#step-2-review-the-scalability-article)\n    * [Next steps](#next-steps)\n* [Performance vs scalability](#performance-vs-scalability)\n* [Latency vs throughput](#latency-vs-throughput)\n* [Availability vs consistency](#availability-vs-consistency)\n    * [CAP theorem](#cap-theorem)\n        * [CP - consistency and partition tolerance](#cp---consistency-and-partition-tolerance)\n        * [AP - availability and partition tolerance](#ap---availability-and-partition-tolerance)\n* [Consistency patterns](#consistency-patterns)\n    * [Weak consistency](#weak-consistency)\n    * [Eventual consistency](#eventual-consistency)\n    * [Strong consistency](#strong-consistency)\n* [Availability patterns](#availability-patterns)\n    * [Fail-over](#fail-over)\n    * [Replication](#replication)\n    * [Availability in numbers](#availability-in-numbers)\n* [Domain name system](#domain-name-system)\n* [Content delivery network](#content-delivery-network)\n    * [Push CDNs](#push-cdns)\n    * [Pull CDNs](#pull-cdns)",
    "ContentSha": "55nlChjOgBlS9Rz8E9JfxCDdOyXcovuwIdqXYGb4sqo=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 新しいセクションを追加\n* [翻訳](https://github.com/donnemartin/system-design-primer/issues/28)\n\n調整が必要なコンテンツは[開発中](#under-development)に置かれています。\n\n[貢献ガイドライン](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md)を確認してください。\n\n## システム設計トピックの索引\n\n> さまざまなシステム設計トピックの概要、利点と欠点を含む。 **すべてはトレードオフ**です。\n>\n> 各セクションには、より詳細なリソースへのリンクが含まれています。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png\">\n  <br/>\n</p>\n\n* [システム設計トピック：ここから始める](#system-design-topics-start-here)\n    * [ステップ1：スケーラビリティのビデオ講義を確認](#step-1-review-the-scalability-video-lecture)\n    * [ステップ2：スケーラビリティの記事を確認](#step-2-review-the-scalability-article)\n    * [次のステップ](#next-steps)\n* [パフォーマンス対スケーラビリティ](#performance-vs-scalability)\n* [レイテンシ対スループット](#latency-vs-throughput)\n* [可用性対整合性](#availability-vs-consistency)\n    * [CAP定理](#cap-theorem)\n        * [CP - 整合性と分割耐性](#cp---consistency-and-partition-tolerance)\n        * [AP - 可用性と分割耐性](#ap---availability-and-partition-tolerance)\n* [整合性パターン](#consistency-patterns)\n    * [弱い整合性](#weak-consistency)\n    * [最終的整合性](#eventual-consistency)\n    * [強い整合性](#strong-consistency)\n* [可用性パターン](#availability-patterns)\n    * [フェイルオーバー](#fail-over)\n    * [レプリケーション](#replication)\n    * [可用性の数値](#availability-in-numbers)\n* [ドメインネームシステム](#domain-name-system)\n* [コンテンツ配信ネットワーク](#content-delivery-network)\n    * [プッシュCDN](#push-cdns)\n    * [プルCDN](#pull-cdns)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 5,
    "Content": "* [Load balancer](#load-balancer)\n    * [Active-passive](#active-passive)\n    * [Active-active](#active-active)\n    * [Layer 4 load balancing](#layer-4-load-balancing)\n    * [Layer 7 load balancing](#layer-7-load-balancing)\n    * [Horizontal scaling](#horizontal-scaling)\n* [Reverse proxy (web server)](#reverse-proxy-web-server)\n    * [Load balancer vs reverse proxy](#load-balancer-vs-reverse-proxy)\n* [Application layer](#application-layer)\n    * [Microservices](#microservices)\n    * [Service discovery](#service-discovery)\n* [Database](#database)\n    * [Relational database management system (RDBMS)](#relational-database-management-system-rdbms)\n        * [Master-slave replication](#master-slave-replication)\n        * [Master-master replication](#master-master-replication)\n        * [Federation](#federation)\n        * [Sharding](#sharding)\n        * [Denormalization](#denormalization)\n        * [SQL tuning](#sql-tuning)\n    * [NoSQL](#nosql)\n        * [Key-value store](#key-value-store)\n        * [Document store](#document-store)\n        * [Wide column store](#wide-column-store)\n        * [Graph Database](#graph-database)\n    * [SQL or NoSQL](#sql-or-nosql)\n* [Cache](#cache)\n    * [Client caching](#client-caching)\n    * [CDN caching](#cdn-caching)\n    * [Web server caching](#web-server-caching)\n    * [Database caching](#database-caching)\n    * [Application caching](#application-caching)\n    * [Caching at the database query level](#caching-at-the-database-query-level)\n    * [Caching at the object level](#caching-at-the-object-level)\n    * [When to update the cache](#when-to-update-the-cache)\n        * [Cache-aside](#cache-aside)\n        * [Write-through](#write-through)\n        * [Write-behind (write-back)](#write-behind-write-back)\n        * [Refresh-ahead](#refresh-ahead)\n* [Asynchronism](#asynchronism)\n    * [Message queues](#message-queues)",
    "ContentSha": "asKFjZ3AfCGQPD58skhfkEeJZEI9zP/H+h/3PnvCFDY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [ロードバランサー](#load-balancer)\n    * [アクティブ-パッシブ](#active-passive)\n    * [アクティブ-アクティブ](#active-active)\n    * [レイヤー4ロードバランシング](#layer-4-load-balancing)\n    * [レイヤー7ロードバランシング](#layer-7-load-balancing)\n    * [水平スケーリング](#horizontal-scaling)\n* [リバースプロキシ（ウェブサーバー）](#reverse-proxy-web-server)\n    * [ロードバランサーとリバースプロキシの違い](#load-balancer-vs-reverse-proxy)\n* [アプリケーション層](#application-layer)\n    * [マイクロサービス](#microservices)\n    * [サービスディスカバリー](#service-discovery)\n* [データベース](#database)\n    * [リレーショナルデータベース管理システム（RDBMS）](#relational-database-management-system-rdbms)\n        * [マスター-スレーブレプリケーション](#master-slave-replication)\n        * [マスター-マスターレプリケーション](#master-master-replication)\n        * [フェデレーション](#federation)\n        * [シャーディング](#sharding)\n        * [非正規化](#denormalization)\n        * [SQLチューニング](#sql-tuning)\n    * [NoSQL](#nosql)\n        * [キー・バリューストア](#key-value-store)\n        * [ドキュメントストア](#document-store)\n        * [ワイドカラムストア](#wide-column-store)\n        * [グラフデータベース](#graph-database)\n    * [SQLまたはNoSQL](#sql-or-nosql)\n* [キャッシュ](#cache)\n    * [クライアントキャッシュ](#client-caching)\n    * [CDNキャッシュ](#cdn-caching)\n    * [ウェブサーバーキャッシュ](#web-server-caching)\n    * [データベースキャッシュ](#database-caching)\n    * [アプリケーションキャッシュ](#application-caching)\n    * [データベースクエリレベルでのキャッシュ](#caching-at-the-database-query-level)\n    * [オブジェクトレベルでのキャッシュ](#caching-at-the-object-level)\n    * [キャッシュ更新のタイミング](#when-to-update-the-cache)\n        * [キャッシュアサイド](#cache-aside)\n        * [ライトスルー](#write-through)\n        * [ライトビハインド（ライトバック）](#write-behind-write-back)\n        * [リフレッシュアヘッド](#refresh-ahead)\n* [非同期処理](#asynchronism)\n    * [メッセージキュー](#message-queues)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 6,
    "Content": "    * [Task queues](#task-queues)\n    * [Back pressure](#back-pressure)\n* [Communication](#communication)\n    * [Transmission control protocol (TCP)](#transmission-control-protocol-tcp)\n    * [User datagram protocol (UDP)](#user-datagram-protocol-udp)\n    * [Remote procedure call (RPC)](#remote-procedure-call-rpc)\n    * [Representational state transfer (REST)](#representational-state-transfer-rest)\n* [Security](#security)\n* [Appendix](#appendix)\n    * [Powers of two table](#powers-of-two-table)\n    * [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)\n    * [Additional system design interview questions](#additional-system-design-interview-questions)\n    * [Real world architectures](#real-world-architectures)\n    * [Company architectures](#company-architectures)\n    * [Company engineering blogs](#company-engineering-blogs)\n* [Under development](#under-development)\n* [Credits](#credits)\n* [Contact info](#contact-info)\n* [License](#license)\n\n## Study guide\n\n> Suggested topics to review based on your interview timeline (short, medium, long).\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)\n\n**Q: For interviews, do I need to know everything here?**\n\n**A: No, you don't need to know everything here to prepare for the interview**.\n\nWhat you are asked in an interview depends on variables such as:\n\n* How much experience you have\n* What your technical background is\n* What positions you are interviewing for\n* Which companies you are interviewing with\n* Luck\n\nMore experienced candidates are generally expected to know more about system design.  Architects or team leads might be expected to know more than individual contributors.  Top tech companies are likely to have one or more design interview rounds.\n",
    "ContentSha": "ATTNyUBhYGX23A6dK9YO6hNcpGiZGZByeStHZczOceg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "    * [タスクキュー](#task-queues)\n    * [バックプレッシャー](#back-pressure)\n* [通信](#communication)\n    * [トランスミッションコントロールプロトコル (TCP)](#transmission-control-protocol-tcp)\n    * [ユーザーデータグラムプロトコル (UDP)](#user-datagram-protocol-udp)\n    * [リモートプロシージャコール (RPC)](#remote-procedure-call-rpc)\n    * [表現状態転送 (REST)](#representational-state-transfer-rest)\n* [セキュリティ](#security)\n* [付録](#appendix)\n    * [2のべき乗表](#powers-of-two-table)\n    * [すべてのプログラマーが知るべきレイテンシ数値](#latency-numbers-every-programmer-should-know)\n    * [追加のシステム設計面接質問](#additional-system-design-interview-questions)\n    * [実際のアーキテクチャ](#real-world-architectures)\n    * [企業のアーキテクチャ](#company-architectures)\n    * [企業のエンジニアリングブログ](#company-engineering-blogs)\n* [開発中](#under-development)\n* [クレジット](#credits)\n* [連絡先情報](#contact-info)\n* [ライセンス](#license)\n\n## 学習ガイド\n\n> 面接のスケジュールに基づく推奨トピック（短期、中期、長期）。\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)\n\n**Q: 面接のためにここにあるすべてを知る必要がありますか？**\n\n**A: いいえ、面接準備のためにここにあるすべてを知る必要はありません**。\n\n面接で問われる内容は以下のような変数によって異なります：\n\n* あなたの経験の量\n* あなたの技術的な背景\n* 面接を受けるポジション\n* 面接を受ける企業\n* 運\n\n経験豊富な候補者は一般的にシステム設計についてより多く知っていることが期待されます。 アーキテクトやチームリーダーは個人貢献者よりも多く知っていることが期待されるかもしれません。 トップテック企業では一つ以上の設計面接ラウンドがある可能性が高いです。\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 7,
    "Content": "Start broad and go deeper in a few areas.  It helps to know a little about various key system design topics.  Adjust the following guide based on your timeline, experience, what positions you are interviewing for, and which companies you are interviewing with.\n\n* **Short timeline** - Aim for **breadth** with system design topics.  Practice by solving **some** interview questions.\n* **Medium timeline** - Aim for **breadth** and **some depth** with system design topics.  Practice by solving **many** interview questions.\n* **Long timeline** - Aim for **breadth** and **more depth** with system design topics.  Practice by solving **most** interview questions.\n\n| | Short | Medium | Long |\n|---|---|---|---|\n| Read through the [System design topics](#index-of-system-design-topics) to get a broad understanding of how systems work | :+1: | :+1: | :+1: |\n| Read through a few articles in the [Company engineering blogs](#company-engineering-blogs) for the companies you are interviewing with | :+1: | :+1: | :+1: |\n| Read through a few [Real world architectures](#real-world-architectures) | :+1: | :+1: | :+1: |\n| Review [How to approach a system design interview question](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |\n| Work through [System design interview questions with solutions](#system-design-interview-questions-with-solutions) | Some | Many | Most |\n| Work through [Object-oriented design interview questions with solutions](#object-oriented-design-interview-questions-with-solutions) | Some | Many | Most |\n| Review [Additional system design interview questions](#additional-system-design-interview-questions) | Some | Many | Most |\n\n## How to approach a system design interview question\n\n> How to tackle a system design interview question.\n\nThe system design interview is an **open-ended conversation**.  You are expected to lead it.\n\nYou can use the following steps to guide the discussion.  To help solidify this process, work through the [System design interview questions with solutions](#system-design-interview-questions-with-solutions) section using the following steps.\n\n### Step 1: Outline use cases, constraints, and assumptions\n\nGather requirements and scope the problem.  Ask questions to clarify use cases and constraints.  Discuss assumptions.\n\n* Who is going to use it?\n* How are they going to use it?\n* How many users are there?\n* What does the system do?\n* What are the inputs and outputs of the system?\n* How much data do we expect to handle?\n* How many requests per second do we expect?\n* What is the expected read to write ratio?\n\n### Step 2: Create a high level design\n\nOutline a high level design with all important components.",
    "ContentSha": "0rdWLVZbH/nPM3xkHGejRJHpsR4f8urb5LkuDcPAbZM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "幅広く学び、いくつかの分野で深掘りしましょう。システム設計の主要なトピックについて少し知っておくと役立ちます。以下のガイドは、あなたのスケジュール、経験、面接するポジションや企業に応じて調整してください。\n\n* **短期間** - システム設計トピックの**広範囲**を目指しましょう。**いくつか**の面接問題を解いて練習します。\n* **中期間** - システム設計トピックの**広範囲**と**一部の深掘り**を目指しましょう。**多くの**面接問題を解いて練習します。\n* **長期間** - システム設計トピックの**広範囲**と**より深い理解**を目指しましょう。**ほとんどの**面接問題を解いて練習します。\n\n| | 短期間 | 中期間 | 長期間 |\n|---|---|---|---|\n| [システム設計トピック](#index-of-system-design-topics)を読んでシステムの仕組みを広く理解する | :+1: | :+1: | :+1: |\n| 面接予定の企業の[会社のエンジニアリングブログ](#company-engineering-blogs)をいくつか読む | :+1: | :+1: | :+1: |\n| [実世界のアーキテクチャ](#real-world-architectures)をいくつか読む | :+1: | :+1: | :+1: |\n| [システム設計面接の質問への取り組み方](#how-to-approach-a-system-design-interview-question)を見直す | :+1: | :+1: | :+1: |\n| [システム設計面接質問と解答](#system-design-interview-questions-with-solutions)に取り組む | 一部 | 多く | ほとんど |\n| [オブジェクト指向設計面接質問と解答](#object-oriented-design-interview-questions-with-solutions)に取り組む | 一部 | 多く | ほとんど |\n| [追加のシステム設計面接質問](#additional-system-design-interview-questions)を見直す | 一部 | 多く | ほとんど |\n\n## システム設計面接質問への取り組み方\n\n> システム設計面接質問にどう取り組むか。\n\nシステム設計面接は**オープンエンドな対話**です。あなたが主導することが期待されます。\n\n以下のステップを使って議論を進めることができます。このプロセスを確実にするために、[システム設計面接質問と解答](#system-design-interview-questions-with-solutions)のセクションを以下のステップに従って取り組みましょう。\n\n### ステップ1: ユースケース、制約、仮定の概要を示す\n\n要件を集めて問題の範囲を定めます。ユースケースや制約を明確にするために質問し、仮定を議論します。\n\n* 誰が使うのか？\n* どのように使うのか？\n* ユーザー数は？\n* システムは何をするのか？\n* システムの入力と出力は何か？\n* どれくらいのデータを扱うことを想定しているか？\n* 1秒あたりのリクエスト数はどれくらいか？\n* 読み込みと書き込みの比率はどの程度か？\n\n### ステップ2: 高レベル設計を作成する\n\nすべての重要なコンポーネントを含む高レベル設計の概要を示します。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 8,
    "Content": "\n* Sketch the main components and connections\n* Justify your ideas\n\n### Step 3: Design core components\n\nDive into details for each core component.  For example, if you were asked to [design a url shortening service](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), discuss:\n\n* Generating and storing a hash of the full url\n    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) and [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n    * Hash collisions\n    * SQL or NoSQL\n    * Database schema\n* Translating a hashed url to the full url\n    * Database lookup\n* API and object-oriented design\n\n### Step 4: Scale the design\n\nIdentify and address bottlenecks, given the constraints.  For example, do you need the following to address scalability issues?\n\n* Load balancer\n* Horizontal scaling\n* Caching\n* Database sharding\n\nDiscuss potential solutions and trade-offs.  Everything is a trade-off.  Address bottlenecks using [principles of scalable system design](#index-of-system-design-topics).\n\n### Back-of-the-envelope calculations\n\nYou might be asked to do some estimates by hand.  Refer to the [Appendix](#appendix) for the following resources:\n\n* [Use back of the envelope calculations](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)\n* [Powers of two table](#powers-of-two-table)\n* [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)\n\n### Source(s) and further reading\n\nCheck out the following links to get a better idea of what to expect:\n",
    "ContentSha": "3x8iTXwR6ek+uAlSMupV1OgJsT8IwtVYxDBvXMFsB/g=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 主なコンポーネントと接続をスケッチする  \n* アイデアの正当性を説明する  \n\n### ステップ3: コアコンポーネントの設計  \n\n各コアコンポーネントの詳細に入り込む。たとえば、もし[URL短縮サービスを設計する](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)ように求められた場合、以下を議論する：  \n\n* フルURLのハッシュを生成し保存する  \n    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)と[Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)  \n    * ハッシュの衝突  \n    * SQLかNoSQLか  \n    * データベーススキーマ  \n* ハッシュ化されたURLをフルURLに変換する  \n    * データベース検索  \n* APIとオブジェクト指向設計  \n\n### ステップ4: 設計のスケールアップ  \n\n制約条件を踏まえてボトルネックを特定し対処する。たとえば、スケーラビリティの問題に対処するために以下が必要か？  \n\n* ロードバランサー  \n* 水平スケーリング  \n* キャッシュ  \n* データベースシャーディング  \n\n潜在的な解決策とトレードオフを議論する。すべてはトレードオフである。[スケーラブルなシステム設計の原則](#index-of-system-design-topics)を用いてボトルネックに対処する。  \n\n### おおまかな計算  \n\n手計算での見積もりを求められることがある。[付録](#appendix)の以下のリソースを参照せよ：  \n\n* [おおまかな計算の利用](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)  \n* [2の冪乗表](#powers-of-two-table)  \n* [すべてのプログラマが知るべきレイテンシ数値](#latency-numbers-every-programmer-should-know)  \n\n### 参考文献およびさらなる読書  \n\n以下のリンクを確認し、何を期待すべきかの理解を深めよう：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 9,
    "Content": "* [How to ace a systems design interview](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)\n* [The system design interview](http://www.hiredintech.com/system-design)\n* [Intro to Architecture and Systems Design Interviews](https://www.youtube.com/watch?v=ZgdS0EUmn70)\n* [System design template](https://leetcode.com/discuss/career/229177/My-System-Design-Template)\n\n## System design interview questions with solutions\n\n> Common system design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n| Question | |\n|---|---|\n| Design Pastebin.com (or Bit.ly) | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |\n| Design the Twitter timeline and search (or Facebook feed and search) | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |\n| Design a web crawler | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |\n| Design Mint.com | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |\n| Design the data structures for a social network | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |\n| Design a key-value store for a search engine | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |\n| Design Amazon's sales ranking by category feature | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |\n| Design a system that scales to millions of users on AWS | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |\n| Add a system design question | [Contribute](#contributing) |\n\n### Design Pastebin.com (or Bit.ly)\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)\n\n### Design the Twitter timeline and search (or Facebook feed and search)\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)\n\n### Design a web crawler\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)",
    "ContentSha": "AHgKOfvgyoP47Euk86jhd2olVjkmP2nZB6tXbpOIqic=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [システム設計面接を成功させる方法](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)\n* [システム設計面接](http://www.hiredintech.com/system-design)\n* [アーキテクチャとシステム設計面接の入門](https://www.youtube.com/watch?v=ZgdS0EUmn70)\n* [システム設計テンプレート](https://leetcode.com/discuss/career/229177/My-System-Design-Template)\n\n## システム設計面接の質問と解答例\n\n> 一般的なシステム設計面接の質問とサンプルディスカッション、コード、図解。\n>\n> 解答は `solutions/` フォルダ内の内容にリンク。\n\n| 質問 | |\n|---|---|\n| Pastebin.com（または Bit.ly）の設計 | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |\n| Twitterのタイムラインと検索の設計（またはFacebookのフィードと検索） | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |\n| ウェブクローラーの設計 | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |\n| Mint.comの設計 | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |\n| ソーシャルネットワークのデータ構造の設計 | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |\n| 検索エンジン用のキー・バリューストアの設計 | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |\n| Amazonのカテゴリー別売上ランキング機能の設計 | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |\n| AWSで数百万ユーザーにスケール可能なシステムの設計 | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |\n| システム設計の質問を追加する | [貢献する](#contributing) |\n\n### Pastebin.com（または Bit.ly）の設計\n\n[演習と解答を見る](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)\n\n### Twitterのタイムラインと検索の設計（またはFacebookのフィードと検索）\n\n[演習と解答を見る](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)\n\n### ウェブクローラーの設計\n\n[演習と解答を見る](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 10,
    "Content": "\n### Design Mint.com\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)\n\n### Design the data structures for a social network\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)\n\n### Design a key-value store for a search engine\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)\n\n### Design Amazon's sales ranking by category feature\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)\n\n### Design a system that scales to millions of users on AWS\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)\n\n## Object-oriented design interview questions with solutions\n\n> Common object-oriented design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n>**Note: This section is under development**\n\n| Question | |",
    "ContentSha": "o3sbdfQZN6cWPJee4lAmThiTo/ED2IUg9UbWh2T8Jr8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### Design Mint.com\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)\n\n### Design the data structures for a social network\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)\n\n### Design a key-value store for a search engine\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)\n\n### Design Amazon's sales ranking by category feature\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)\n\n### Design a system that scales to millions of users on AWS\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)\n\n## Object-oriented design interview questions with solutions\n\n> Common object-oriented design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n>**Note: This section is under development**\n\n| Question | |",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 11,
    "Content": "|---|---|\n| Design a hash map | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |\n| Design a least recently used cache | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |\n| Design a call center | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |\n| Design a deck of cards | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |\n| Design a parking lot | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |\n| Design a chat server | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |\n| Design a circular array | [Contribute](#contributing)  |\n| Add an object-oriented design question | [Contribute](#contributing) |\n\n## System design topics: start here\n\nNew to system design?\n\nFirst, you'll need a basic understanding of common principles, learning about what they are, how they are used, and their pros and cons.\n\n### Step 1: Review the scalability video lecture\n\n[Scalability Lecture at Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)\n\n* Topics covered:\n    * Vertical scaling\n    * Horizontal scaling\n    * Caching\n    * Load balancing\n    * Database replication\n    * Database partitioning\n\n### Step 2: Review the scalability article\n\n[Scalability](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)\n\n* Topics covered:\n    * [Clones](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n    * [Databases](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n    * [Caches](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n    * [Asynchronism](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)\n\n### Next steps\n",
    "ContentSha": "x8nrhrohPoZjm2NWw4mmB3mvJSUCp+CF0oOOqij1Y4E=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "|---|---|\n| ハッシュマップを設計する | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |\n| LRUキャッシュを設計する | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |\n| コールセンターを設計する | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |\n| トランプの山札を設計する | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |\n| 駐車場を設計する | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |\n| チャットサーバーを設計する | [解答](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |\n| 循環配列を設計する | [貢献する](#contributing)  |\n| オブジェクト指向設計の質問を追加する | [貢献する](#contributing) |\n\n## システム設計トピック：ここから始めよう\n\nシステム設計は初めてですか？\n\nまず、基本的な共通原則の理解が必要です。これらが何であるか、どのように使われるか、その利点と欠点について学びましょう。\n\n### ステップ1：スケーラビリティのビデオ講義を視聴する\n\n[ハーバードのスケーラビリティ講義](https://www.youtube.com/watch?v=-W9F__D3oY4)\n\n* カバーするトピック:\n    * 垂直スケーリング\n    * 水平スケーリング\n    * キャッシュ\n    * ロードバランシング\n    * データベースのレプリケーション\n    * データベースのパーティショニング\n\n### ステップ2：スケーラビリティの記事を読む\n\n[スケーラビリティ](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)\n\n* カバーするトピック:\n    * [クローン](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n    * [データベース](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n    * [キャッシュ](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n    * [非同期処理](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)\n\n### 次のステップ\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 12,
    "Content": "Next, we'll look at high-level trade-offs:\n\n* **Performance** vs **scalability**\n* **Latency** vs **throughput**\n* **Availability** vs **consistency**\n\nKeep in mind that **everything is a trade-off**.\n\nThen we'll dive into more specific topics such as DNS, CDNs, and load balancers.\n\n## Performance vs scalability\n\nA service is **scalable** if it results in increased **performance** in a manner proportional to resources added. Generally, increasing performance means serving more units of work, but it can also be to handle larger units of work, such as when datasets grow.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>\n\nAnother way to look at performance vs scalability:\n\n* If you have a **performance** problem, your system is slow for a single user.\n* If you have a **scalability** problem, your system is fast for a single user but slow under heavy load.\n\n### Source(s) and further reading\n\n* [A word on scalability](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n\n## Latency vs throughput\n\n**Latency** is the time to perform some action or to produce some result.\n\n**Throughput** is the number of such actions or results per unit of time.\n\nGenerally, you should aim for **maximal throughput** with **acceptable latency**.\n\n### Source(s) and further reading\n\n* [Understanding latency vs throughput](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)\n\n## Availability vs consistency\n\n### CAP theorem\n",
    "ContentSha": "3J96fMtAPtZfNniAS7/6wzXl1ty5ntM4Q00EOxpO0Ww=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "次に、高レベルのトレードオフについて見ていきます：\n\n* **パフォーマンス** vs **スケーラビリティ**\n* **レイテンシ** vs **スループット**\n* **可用性** vs **一貫性**\n\nすべては**トレードオフ**であることを念頭に置いてください。\n\nその後、DNS、CDN、ロードバランサーなど、より具体的なトピックに踏み込んでいきます。\n\n## パフォーマンス vs スケーラビリティ\n\nサービスが**スケーラブル**であるとは、追加したリソースに比例して**パフォーマンス**が向上する場合を指します。一般的に、パフォーマンスの向上とはより多くの作業単位を処理することを意味しますが、データセットが増大する場合のように、より大きな作業単位を扱うことも含まれます。<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>\n\nパフォーマンスとスケーラビリティの別の見方：\n\n* **パフォーマンス**の問題がある場合、単一ユーザーに対してシステムが遅い。\n* **スケーラビリティ**の問題がある場合、単一ユーザーには速いが、負荷が高いときに遅くなる。\n\n### 参考文献とさらなる読み物\n\n* [スケーラビリティについての一言](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)\n* [スケーラビリティ、可用性、安定性、パターン](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n\n## レイテンシ vs スループット\n\n**レイテンシ**は、ある操作を実行するか結果を出すまでの時間です。\n\n**スループット**は、単位時間あたりのそのような操作や結果の数です。\n\n一般的には、**許容可能なレイテンシ**で**最大スループット**を目指すべきです。\n\n### 参考文献とさらなる読み物\n\n* [レイテンシとスループットの理解](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)\n\n## 可用性 vs 一貫性\n\n### CAP定理\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 13,
    "Content": "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png\">\n  <br/>\n  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Source: CAP theorem revisited</a></i>\n</p>\n\nIn a distributed computer system, you can only support two of the following guarantees:\n\n* **Consistency** - Every read receives the most recent write or an error\n* **Availability** - Every request receives a response, without guarantee that it contains the most recent version of the information\n* **Partition Tolerance** - The system continues to operate despite arbitrary partitioning due to network failures\n\n*Networks aren't reliable, so you'll need to support partition tolerance.  You'll need to make a software tradeoff between consistency and availability.*\n\n#### CP - consistency and partition tolerance\n\nWaiting for a response from the partitioned node might result in a timeout error.  CP is a good choice if your business needs require atomic reads and writes.\n\n#### AP - availability and partition tolerance\n\nResponses return the most readily available version of the data available on any node, which might not be the latest.  Writes might take some time to propagate when the partition is resolved.\n\nAP is a good choice if the business needs to allow for [eventual consistency](#eventual-consistency) or when the system needs to continue working despite external errors.\n\n### Source(s) and further reading\n\n* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)\n* [A plain english introduction to CAP theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem)\n* [CAP FAQ](https://github.com/henryr/cap-faq)\n* [The CAP theorem](https://www.youtube.com/watch?v=k-Yaq8AHlFA)\n\n## Consistency patterns\n\nWith multiple copies of the same data, we are faced with options on how to synchronize them so clients have a consistent view of the data.  Recall the definition of consistency from the [CAP theorem](#cap-theorem) - Every read receives the most recent write or an error.\n\n### Weak consistency\n\nAfter a write, reads may or may not see it.  A best effort approach is taken.\n\nThis approach is seen in systems such as memcached.  Weak consistency works well in real time use cases such as VoIP, video chat, and realtime multiplayer games.  For example, if you are on a phone call and lose reception for a few seconds, when you regain connection you do not hear what was spoken during connection loss.",
    "ContentSha": "nlNKM8AB14RiMLs0dLLz8tVwgOHTXV/u3ObIx3G8az4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png\">\n  <br/>\n  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>出典: CAP定理再考</a></i>\n</p>\n\n分散コンピュータシステムでは、次の3つの保証のうち2つだけをサポートできます:\n\n* **一貫性（Consistency）** - すべての読み取りは最新の書き込みを受け取るか、エラーになる\n* **可用性（Availability）** - すべてのリクエストは応答を受け取るが、最新の情報が含まれている保証はない\n* **分割耐性（Partition Tolerance）** - ネットワーク障害による任意の分割があってもシステムは動作し続ける\n\n*ネットワークは信頼できないため、分割耐性をサポートする必要があります。ソフトウェア上のトレードオフとして、一貫性と可用性のどちらかを選択する必要があります。*\n\n#### CP - 一貫性と分割耐性\n\n分割されたノードからの応答を待つとタイムアウトエラーになる可能性があります。ビジネス上の要件が原子性のある読み書きを必要とする場合、CPは良い選択です。\n\n#### AP - 可用性と分割耐性\n\n応答は任意のノードで最も利用可能なバージョンのデータを返しますが、最新ではない場合があります。分割が解消されると書き込みの伝播に時間がかかることがあります。\n\nAPは[最終的な一貫性](#eventual-consistency)を許容する必要がある場合や、外部のエラーがあってもシステムを継続動作させる必要がある場合に適しています。\n\n### 出典とさらなる参考資料\n\n* [CAP定理再考](http://robertgreiner.com/2014/08/cap-theorem-revisited/)\n* [CAP定理のわかりやすい紹介](http://ksat.me/a-plain-english-introduction-to-cap-theorem)\n* [CAP FAQ](https://github.com/henryr/cap-faq)\n* [CAP定理](https://www.youtube.com/watch?v=k-Yaq8AHlFA)\n\n## 一貫性パターン\n\n同じデータの複数のコピーが存在する場合、クライアントが一貫したデータビューを持つようにそれらをどのように同期させるかの選択肢があります。[CAP定理](#cap-theorem)の一貫性の定義を思い出してください - すべての読み取りは最新の書き込みを受け取るか、エラーになる。\n\n### 弱い一貫性\n\n書き込み後に読み取りがそれを見える場合も見えない場合もあります。ベストエフォートのアプローチです。\n\nこのアプローチはmemcachedのようなシステムで見られます。弱い一貫性はVoIP、ビデオチャット、リアルタイムマルチプレイヤーゲームなどのリアルタイムユースケースでよく機能します。例えば、電話中に数秒間通信が途切れた場合、接続が回復してもその間に話された内容は聞こえません。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 14,
    "Content": "\n### Eventual consistency\n\nAfter a write, reads will eventually see it (typically within milliseconds).  Data is replicated asynchronously.\n\nThis approach is seen in systems such as DNS and email.  Eventual consistency works well in highly available systems.\n\n### Strong consistency\n\nAfter a write, reads will see it.  Data is replicated synchronously.\n\nThis approach is seen in file systems and RDBMSes.  Strong consistency works well in systems that need transactions.\n\n### Source(s) and further reading\n\n* [Transactions across data centers](http://snarfed.org/transactions_across_datacenters_io.html)\n\n## Availability patterns\n\nThere are two complementary patterns to support high availability: **fail-over** and **replication**.\n\n### Fail-over\n\n#### Active-passive\n\nWith active-passive fail-over, heartbeats are sent between the active and the passive server on standby.  If the heartbeat is interrupted, the passive server takes over the active's IP address and resumes service.\n\nThe length of downtime is determined by whether the passive server is already running in 'hot' standby or whether it needs to start up from 'cold' standby.  Only the active server handles traffic.\n\nActive-passive failover can also be referred to as master-slave failover.\n\n#### Active-active\n\nIn active-active, both servers are managing traffic, spreading the load between them.\n\nIf the servers are public-facing, the DNS would need to know about the public IPs of both servers.  If the servers are internal-facing, application logic would need to know about both servers.\n\nActive-active failover can also be referred to as master-master failover.\n\n### Disadvantage(s): failover",
    "ContentSha": "Gej6bybZnoGj5vLH+IOLm2NuKTHBE7Z2TA3eWaBaiak=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 最終的整合性\n\n書き込み後、読み取りは最終的にそれを参照します（通常は数ミリ秒以内）。データは非同期に複製されます。\n\nこのアプローチはDNSやメールのようなシステムで見られます。最終的整合性は高可用性システムでうまく機能します。\n\n### 強い整合性\n\n書き込み後、読み取りはそれを参照します。データは同期的に複製されます。\n\nこのアプローチはファイルシステムやRDBMSで見られます。強い整合性はトランザクションを必要とするシステムでうまく機能します。\n\n### 出典およびさらなる読み物\n\n* [データセンター間のトランザクション](http://snarfed.org/transactions_across_datacenters_io.html)\n\n## 可用性パターン\n\n高可用性をサポートするための相補的なパターンが二つあります：**フェイルオーバー**と**レプリケーション**。\n\n### フェイルオーバー\n\n#### アクティブ-パッシブ\n\nアクティブ-パッシブフェイルオーバーでは、アクティブサーバーと待機中のパッシブサーバー間でハートビートが送信されます。ハートビートが中断された場合、パッシブサーバーがアクティブのIPアドレスを引き継ぎサービスを再開します。\n\nダウンタイムの長さは、パッシブサーバーがすでに「ホット」スタンバイで稼働しているか、「コールド」スタンバイから起動する必要があるかで決まります。トラフィックを処理するのはアクティブサーバーのみです。\n\nアクティブ-パッシブフェイルオーバーはマスター-スレーブフェイルオーバーとも呼ばれます。\n\n#### アクティブ-アクティブ\n\nアクティブ-アクティブでは、両方のサーバーがトラフィックを管理し、負荷を分散しています。\n\nサーバーが公開向けの場合、DNSは両方のサーバーのパブリックIPを認識する必要があります。サーバーが内部向けの場合、アプリケーションロジックが両方のサーバーを認識する必要があります。\n\nアクティブ-アクティブフェイルオーバーはマスター-マスターフェイルオーバーとも呼ばれます。\n\n### 欠点：フェイルオーバー\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 15,
    "Content": "\n* Fail-over adds more hardware and additional complexity.\n* There is a potential for loss of data if the active system fails before any newly written data can be replicated to the passive.\n\n### Replication\n\n#### Master-slave and master-master\n\nThis topic is further discussed in the [Database](#database) section:\n\n* [Master-slave replication](#master-slave-replication)\n* [Master-master replication](#master-master-replication)\n\n### Availability in numbers\n\nAvailability is often quantified by uptime (or downtime) as a percentage of time the service is available.  Availability is generally measured in number of 9s--a service with 99.99% availability is described as having four 9s.\n\n#### 99.9% availability - three 9s\n\n| Duration            | Acceptable downtime|\n|---------------------|--------------------|\n| Downtime per year   | 8h 45min 57s       |\n| Downtime per month  | 43m 49.7s          |\n| Downtime per week   | 10m 4.8s           |\n| Downtime per day    | 1m 26.4s           |\n\n#### 99.99% availability - four 9s\n\n| Duration            | Acceptable downtime|\n|---------------------|--------------------|\n| Downtime per year   | 52min 35.7s        |\n| Downtime per month  | 4m 23s             |\n| Downtime per week   | 1m 5s              |\n| Downtime per day    | 8.6s               |\n\n#### Availability in parallel vs in sequence\n\nIf a service consists of multiple components prone to failure, the service's overall availability depends on whether the components are in sequence or in parallel.\n\n###### In sequence",
    "ContentSha": "7iHIUIb6fJkzxQcIKEVyv2l5jzfrJATtAgzkxfBD6fg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* フェイルオーバーは、より多くのハードウェアと追加の複雑さをもたらします。\n* アクティブシステムが、新たに書き込まれたデータがパッシブに複製される前に障害が発生した場合、データの損失の可能性があります。\n\n### 複製\n\n#### マスター・スレーブおよびマスター・マスター\n\nこのトピックは[データベース](#database)セクションでさらに詳しく説明されています：\n\n* [マスター・スレーブ複製](#master-slave-replication)\n* [マスター・マスター複製](#master-master-replication)\n\n### 可用性の数値\n\n可用性はしばしばサービスが利用可能な時間の割合としてアップタイム（またはダウンタイム）で定量化されます。可用性は一般的に「9の数」で測定され、99.99%の可用性を持つサービスは「4つの9」と表現されます。\n\n#### 99.9%の可用性 - 3つの9\n\n| 期間                | 許容ダウンタイム     |\n|---------------------|--------------------|\n| 年間ダウンタイム     | 8時間45分57秒       |\n| 月間ダウンタイム     | 43分49.7秒          |\n| 週間ダウンタイム     | 10分4.8秒           |\n| 1日あたりのダウンタイム | 1分26.4秒           |\n\n#### 99.99%の可用性 - 4つの9\n\n| 期間                | 許容ダウンタイム     |\n|---------------------|--------------------|\n| 年間ダウンタイム     | 52分35.7秒          |\n| 月間ダウンタイム     | 4分23秒             |\n| 週間ダウンタイム     | 1分5秒              |\n| 1日あたりのダウンタイム | 8.6秒               |\n\n#### 並列可用性と直列可用性\n\nサービスが障害を起こしやすい複数のコンポーネントで構成されている場合、サービス全体の可用性はコンポーネントが直列か並列かによって異なります。\n\n###### 直列の場合\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 16,
    "Content": "\nOverall availability decreases when two components with availability < 100% are in sequence:\n",
    "ContentSha": "MoWr3NjGedfagwyU1j0TqrIfLCsOUBLZEeMCD+o/O+Q=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "全体の可用性は、可用性が100%未満の2つのコンポーネントが直列に接続されている場合に低下します:\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 17,
    "Content": "```\nAvailability (Total) = Availability (Foo) * Availability (Bar)\n```",
    "ContentSha": "lB9bEqLhXuNZd7e3CBBSvV+eKTVRfJQnqnxct5vKoDI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nAvailability (Total) = Availability (Foo) * Availability (Bar)\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 18,
    "Content": "\nIf both `Foo` and `Bar` each had 99.9% availability, their total availability in sequence would be 99.8%.\n\n###### In parallel\n\nOverall availability increases when two components with availability < 100% are in parallel:\n",
    "ContentSha": "8idS6k4SI9XJ+uNRuiFmAXUVaamdekOMo2MnsD7SUdw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\nもし `Foo` と `Bar` の両方がそれぞれ99.9%の可用性を持っている場合、それらが直列に接続されると合計の可用性は99.8%になります。\n\n###### 並列の場合\n\n可用性が100%未満の2つのコンポーネントを並列に配置すると、全体の可用性は向上します：\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 19,
    "Content": "```\nAvailability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))\n```",
    "ContentSha": "MYI40NgkLqO1BQo3TOiX+3Zu0VfgykdTCZcU4oJjKTs=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nAvailability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 20,
    "Content": "\nIf both `Foo` and `Bar` each had 99.9% availability, their total availability in parallel would be 99.9999%.\n\n## Domain name system\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg\">\n  <br/>\n  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Source: DNS security presentation</a></i>\n</p>\n\nA Domain Name System (DNS) translates a domain name such as www.example.com to an IP address.\n\nDNS is hierarchical, with a few authoritative servers at the top level.  Your router or ISP provides information about which DNS server(s) to contact when doing a lookup.  Lower level DNS servers cache mappings, which could become stale due to DNS propagation delays.  DNS results can also be cached by your browser or OS for a certain period of time, determined by the [time to live (TTL)](https://en.wikipedia.org/wiki/Time_to_live).\n\n* **NS record (name server)** - Specifies the DNS servers for your domain/subdomain.\n* **MX record (mail exchange)** - Specifies the mail servers for accepting messages.\n* **A record (address)** - Points a name to an IP address.\n* **CNAME (canonical)** - Points a name to another name or `CNAME` (example.com to www.example.com) or to an `A` record.\n\nServices such as [CloudFlare](https://www.cloudflare.com/dns/) and [Route 53](https://aws.amazon.com/route53/) provide managed DNS services.  Some DNS services can route traffic through various methods:\n\n* [Weighted round robin](https://www.jscape.com/blog/load-balancing-algorithms)\n    * Prevent traffic from going to servers under maintenance\n    * Balance between varying cluster sizes\n    * A/B testing\n* [Latency-based](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)\n* [Geolocation-based](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)\n\n### Disadvantage(s): DNS\n\n* Accessing a DNS server introduces a slight delay, although mitigated by caching described above.\n* DNS server management could be complex and is generally managed by [governments, ISPs, and large companies](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).\n* DNS services have recently come under [DDoS attack](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), preventing users from accessing websites such as Twitter without knowing Twitter's IP address(es).\n\n### Source(s) and further reading\n\n* [DNS architecture](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)\n* [Wikipedia](https://en.wikipedia.org/wiki/Domain_Name_System)\n* [DNS articles](https://support.dnsimple.com/categories/dns/)",
    "ContentSha": "YhlbRAwaKJI7wcegCHvNOzGIOxkIHtEHSr0a7L+iJEc=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "もし `Foo` と `Bar` の両方がそれぞれ99.9%の可用性を持っている場合、並列での総可用性は99.9999%になります。\n\n## ドメインネームシステム\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg\">\n  <br/>\n  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>出典: DNSセキュリティプレゼンテーション</a></i>\n</p>\n\nドメインネームシステム（DNS）は、www.example.comのようなドメイン名をIPアドレスに変換します。\n\nDNSは階層構造を持ち、最上位にいくつかの権威サーバーがあります。ルーターやISPは、名前解決時にどのDNSサーバーに連絡すべきかの情報を提供します。下位のDNSサーバーはマッピングをキャッシュしますが、DNS伝播遅延により古くなることがあります。DNSの結果はブラウザやOSによっても一定期間キャッシュされ、その期間は[TTL（Time to Live）](https://en.wikipedia.org/wiki/Time_to_live)によって決まります。\n\n* **NSレコード（ネームサーバー）** - ドメイン／サブドメインのDNSサーバーを指定します。\n* **MXレコード（メール交換）** - メッセージ受信のためのメールサーバーを指定します。\n* **Aレコード（アドレス）** - 名前をIPアドレスに紐づけます。\n* **CNAME（カノニカル）** - 名前を別の名前や `CNAME`（例: example.com を www.example.com に）または `A`レコードに紐づけます。\n\n[CloudFlare](https://www.cloudflare.com/dns/)や[Route 53](https://aws.amazon.com/route53/)のようなサービスはマネージドDNSサービスを提供しています。一部のDNSサービスは以下のような様々な方法でトラフィックをルーティングできます：\n\n* [重み付きラウンドロビン](https://www.jscape.com/blog/load-balancing-algorithms)\n    * メンテナンス中のサーバーへのトラフィックを防ぐ\n    * 異なるクラスタサイズ間のバランス調整\n    * A/Bテスト\n* [レイテンシベース](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)\n* [地理位置ベース](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)\n\n### DNSの欠点\n\n* DNSサーバーにアクセスすることで若干の遅延が発生しますが、前述のキャッシュにより軽減されます。\n* DNSサーバーの管理は複雑であり、一般的に[政府、ISP、大企業](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729)によって管理されています。\n* 最近DNSサービスは[DDoS攻撃](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/)を受けており、ユーザーがTwitterなどのウェブサイトにアクセスする際にTwitterのIPアドレスを知らないとアクセスできない状況が発生しています。\n\n### 参考文献とさらなる情報\n\n* [DNSアーキテクチャ](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)\n* [Wikipedia](https://ja.wikipedia.org/wiki/ドメインネームシステム)\n* [DNS関連記事](https://support.dnsimple.com/categories/dns/)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 21,
    "Content": "\n## Content delivery network\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg\">\n  <br/>\n  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Source: Why use a CDN</a></i>\n</p>\n\nA content delivery network (CDN) is a globally distributed network of proxy servers, serving content from locations closer to the user.  Generally, static files such as HTML/CSS/JS, photos, and videos are served from CDN, although some CDNs such as Amazon's CloudFront support dynamic content.  The site's DNS resolution will tell clients which server to contact.\n\nServing content from CDNs can significantly improve performance in two ways:\n\n* Users receive content from data centers close to them\n* Your servers do not have to serve requests that the CDN fulfills\n\n### Push CDNs\n\nPush CDNs receive new content whenever changes occur on your server.  You take full responsibility for providing content, uploading directly to the CDN and rewriting URLs to point to the CDN.  You can configure when content expires and when it is updated.  Content is uploaded only when it is new or changed, minimizing traffic, but maximizing storage.\n\nSites with a small amount of traffic or sites with content that isn't often updated work well with push CDNs.  Content is placed on the CDNs once, instead of being re-pulled at regular intervals.\n\n### Pull CDNs\n\nPull CDNs grab new content from your server when the first user requests the content.  You leave the content on your server and rewrite URLs to point to the CDN.  This results in a slower request until the content is cached on the CDN.\n\nA [time-to-live (TTL)](https://en.wikipedia.org/wiki/Time_to_live) determines how long content is cached.  Pull CDNs minimize storage space on the CDN, but can create redundant traffic if files expire and are pulled before they have actually changed.\n\nSites with heavy traffic work well with pull CDNs, as traffic is spread out more evenly with only recently-requested content remaining on the CDN.\n\n### Disadvantage(s): CDN\n\n* CDN costs could be significant depending on traffic, although this should be weighed with additional costs you would incur not using a CDN.\n* Content might be stale if it is updated before the TTL expires it.\n* CDNs require changing URLs for static content to point to the CDN.\n\n### Source(s) and further reading\n\n* [Globally distributed content delivery](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)\n* [The differences between push and pull CDNs](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)",
    "ContentSha": "bGRlC+2cYKu2Zts6C6nMT6o/JLG5VQ9wuYmJZVvDRI0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "## コンテンツ配信ネットワーク\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg\">\n  <br/>\n  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>出典: なぜCDNを使うのか</a></i>\n</p>\n\nコンテンツ配信ネットワーク（CDN）は、ユーザーに近い場所からコンテンツを配信する、世界中に分散したプロキシサーバーのネットワークです。一般的に、HTML/CSS/JS、写真、動画などの静的ファイルはCDNから配信されますが、AmazonのCloudFrontのように動的コンテンツをサポートするCDNもあります。サイトのDNS解決はクライアントにどのサーバーに接続すべきかを伝えます。\n\nCDNからコンテンツを配信することで、次の2つの方法でパフォーマンスが大幅に向上します：\n\n* ユーザーは自分に近いデータセンターからコンテンツを受け取る\n* サーバーはCDNが対応するリクエストを処理する必要がなくなる\n\n### プッシュCDN\n\nプッシュCDNはサーバーで変更があるたびに新しいコンテンツを受け取ります。コンテンツ提供の全責任はあなたにあり、直接CDNにアップロードし、URLを書き換えてCDNを指すようにします。コンテンツの有効期限や更新タイミングを設定できます。コンテンツは新規または変更時のみアップロードされるため、トラフィックを最小限に抑えつつ、ストレージを最大限に活用します。\n\nトラフィックが少ないサイトや更新頻度の低いコンテンツのサイトではプッシュCDNが適しています。コンテンツは一度CDNに配置され、定期的に再取得されることはありません。\n\n### プルCDN\n\nプルCDNは最初のユーザーがコンテンツをリクエストした際にあなたのサーバーから新しいコンテンツを取得します。コンテンツはサーバー上に残し、URLを書き換えてCDNを指すようにします。そのため、コンテンツがCDNにキャッシュされるまではリクエストが遅くなります。\n\n[TTL（Time-to-Live）](https://ja.wikipedia.org/wiki/TTL)はコンテンツがキャッシュされる期間を決定します。プルCDNはCDN上のストレージ使用を最小限に抑えますが、ファイルの期限切れ後に実際には変更されていない場合でも再取得されることで冗長なトラフィックが発生する可能性があります。\n\nトラフィックが多いサイトではプルCDNが適しており、最近リクエストされたコンテンツのみがCDNに残り、トラフィックがより均等に分散されます。\n\n### デメリット：CDN\n\n* トラフィックによってはCDNコストが大きくなる可能性がありますが、CDNを使わなかった場合の追加コストと比較する必要があります。\n* TTLが切れる前に更新された場合、コンテンツが古いままになる可能性があります。\n* 静的コンテンツのURLをCDNを指すように変更する必要があります。\n\n### 出典および参考文献\n\n* [Globally distributed content delivery](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)\n* [プッシュCDNとプルCDNの違い](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 22,
    "Content": "* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)\n\n## Load balancer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>\n</p>\n\nLoad balancers distribute incoming client requests to computing resources such as application servers and databases.  In each case, the load balancer returns the response from the computing resource to the appropriate client.  Load balancers are effective at:\n\n* Preventing requests from going to unhealthy servers\n* Preventing overloading resources\n* Helping to eliminate a single point of failure\n\nLoad balancers can be implemented with hardware (expensive) or with software such as HAProxy.\n\nAdditional benefits include:\n\n* **SSL termination** - Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations\n    * Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server\n* **Session persistence** - Issue cookies and route a specific client's requests to same instance if the web apps do not keep track of sessions\n\nTo protect against failures, it's common to set up multiple load balancers, either in [active-passive](#active-passive) or [active-active](#active-active) mode.\n\nLoad balancers can route traffic based on various metrics, including:\n\n* Random\n* Least loaded\n* Session/cookies\n* [Round robin or weighted round robin](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)\n* [Layer 4](#layer-4-load-balancing)\n* [Layer 7](#layer-7-load-balancing)\n\n### Layer 4 load balancing\n\nLayer 4 load balancers look at info at the [transport layer](#communication) to decide how to distribute requests.  Generally, this involves the source, destination IP addresses, and ports in the header, but not the contents of the packet.  Layer 4 load balancers forward network packets to and from the upstream server, performing [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/).\n\n### Layer 7 load balancing",
    "ContentSha": "9cdxRHyBtl0u7vNUNZ/06ZZn+SBn6/L1EyLOFfGBVdU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)\n\n## ロードバランサー\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>出典: スケーラブルシステム設計パターン</a></i>\n</p>\n\nロードバランサーは、アプリケーションサーバーやデータベースなどのコンピューティングリソースに対するクライアントからのリクエストを分散します。 各ケースで、ロードバランサーはコンピューティングリソースからのレスポンスを適切なクライアントに返します。 ロードバランサーは以下に効果的です：\n\n* 不健康なサーバーへのリクエストを防ぐ\n* リソースの過負荷を防ぐ\n* 単一障害点の排除に役立つ\n\nロードバランサーはハードウェア（高価）やHAProxyのようなソフトウェアで実装可能です。\n\n追加の利点には以下があります：\n\n* **SSL終端** - 受信リクエストの復号化とサーバーレスポンスの暗号化を行い、バックエンドサーバーがこれらの高コストな処理を行わずに済むようにする\n    * 各サーバーに[X.509証明書](https://en.wikipedia.org/wiki/X.509)をインストールする必要がなくなる\n* **セッション持続性** - クッキーを発行し、ウェブアプリがセッションを追跡しない場合に特定クライアントのリクエストを同一インスタンスにルーティングする\n\n障害に備えて、ロードバランサーは[アクティブ-パッシブ](#active-passive)または[アクティブ-アクティブ](#active-active)モードで複数台構成することが一般的です。\n\nロードバランサーは以下のような様々な指標に基づいてトラフィックをルーティングできます：\n\n* ランダム\n* 最も負荷の低い\n* セッション／クッキー\n* [ラウンドロビンまたは加重ラウンドロビン](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)\n* [レイヤー4](#layer-4-load-balancing)\n* [レイヤー7](#layer-7-load-balancing)\n\n### レイヤー4ロードバランシング\n\nレイヤー4ロードバランサーはリクエスト分散のために[トランスポート層](#communication)の情報を参照します。 一般的には、ヘッダー内の送信元・宛先IPアドレスとポートを使いますが、パケットの内容は見ません。 レイヤー4ロードバランサーはアップストリームサーバーへのネットワークパケットを転送し、[ネットワークアドレス変換（NAT）](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)を行います。\n\n### レイヤー7ロードバランシング",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 23,
    "Content": "\nLayer 7 load balancers look at the [application layer](#communication) to decide how to distribute requests.  This can involve contents of the header, message, and cookies.  Layer 7 load balancers terminate network traffic, reads the message, makes a load-balancing decision, then opens a connection to the selected server.  For example, a layer 7 load balancer can direct video traffic to servers that host videos while directing more sensitive user billing traffic to security-hardened servers.\n\nAt the cost of flexibility, layer 4 load balancing requires less time and computing resources than Layer 7, although the performance impact can be minimal on modern commodity hardware.\n\n### Horizontal scaling\n\nLoad balancers can also help with horizontal scaling, improving performance and availability.  Scaling out using commodity machines is more cost efficient and results in higher availability than scaling up a single server on more expensive hardware, called **Vertical Scaling**.  It is also easier to hire for talent working on commodity hardware than it is for specialized enterprise systems.\n\n#### Disadvantage(s): horizontal scaling\n\n* Scaling horizontally introduces complexity and involves cloning servers\n    * Servers should be stateless: they should not contain any user-related data like sessions or profile pictures\n    * Sessions can be stored in a centralized data store such as a [database](#database) (SQL, NoSQL) or a persistent [cache](#cache) (Redis, Memcached)\n* Downstream servers such as caches and databases need to handle more simultaneous connections as upstream servers scale out\n\n### Disadvantage(s): load balancer\n\n* The load balancer can become a performance bottleneck if it does not have enough resources or if it is not configured properly.\n* Introducing a load balancer to help eliminate a single point of failure results in increased complexity.\n* A single load balancer is a single point of failure, configuring multiple load balancers further increases complexity.\n\n### Source(s) and further reading\n\n* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [Scalability](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n* [Wikipedia](https://en.wikipedia.org/wiki/Load_balancing_(computing))\n* [Layer 4 load balancing](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)\n* [Layer 7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)\n* [ELB listener config](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)\n\n## Reverse proxy (web server)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png\">\n  <br/>\n  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Source: Wikipedia</a></i>\n  <br/>\n</p>",
    "ContentSha": "d9PfMKhS5It6VuFSV5VdEgf336M0xQeGW1c7I8NDHiY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "レイヤー7のロードバランサーは、リクエストをどのように分配するかを決定するために[アプリケーション層](#communication)を参照します。これはヘッダー、メッセージ、クッキーの内容を含む場合があります。レイヤー7のロードバランサーはネットワークトラフィックを終端し、メッセージを読み込み、負荷分散の決定を行い、選択されたサーバーへの接続を開きます。例えば、レイヤー7のロードバランサーは動画トラフィックを動画をホストするサーバーに、より機密性の高いユーザー請求トラフィックをセキュリティ強化されたサーバーに振り分けることができます。\n\n柔軟性の代償として、レイヤー4のロードバランシングはレイヤー7よりも少ない時間と計算資源を必要としますが、最新の汎用ハードウェアではパフォーマンスへの影響は最小限です。\n\n### 水平スケーリング\n\nロードバランサーは水平スケーリングにも役立ち、パフォーマンスと可用性を向上させます。汎用マシンを使用してスケールアウトすることは、より高価なハードウェア上で単一のサーバーをスケールアップする（**垂直スケーリング**と呼ばれる）よりもコスト効率が高く、可用性も向上します。また、専門的な企業システムよりも汎用ハードウェアで働く人材を採用する方が容易です。\n\n#### 欠点：水平スケーリング\n\n* 水平スケーリングは複雑さを導入し、サーバーの複製を伴います\n    * サーバーはステートレスであるべきです：セッションやプロフィール画像などのユーザー関連データを含まないこと\n    * セッションは[データベース](#database)（SQL、NoSQL）や永続的な[キャッシュ](#cache)（Redis、Memcached）などの集中管理されたデータストアに保存できます\n* キャッシュやデータベースなどの下流サーバーは、上流サーバーのスケールアウトに伴い同時接続数の増加を処理する必要があります\n\n### 欠点：ロードバランサー\n\n* ロードバランサーが十分なリソースを持たない場合や適切に設定されていない場合、パフォーマンスのボトルネックになる可能性があります。\n* 単一障害点を排除するためにロードバランサーを導入すると、複雑さが増します。\n* 単一のロードバランサーは単一障害点であり、複数のロードバランサーを設定するとさらに複雑さが増します。\n\n### 参考文献およびさらなる読み物\n\n* [NGINXのアーキテクチャ](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxyアーキテクチャガイド](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [スケーラビリティ](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n* [ウィキペディア](https://en.wikipedia.org/wiki/Load_balancing_(computing))\n* [レイヤー4ロードバランシング](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)\n* [レイヤー7ロードバランシング](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)\n* [ELBリスナー設定](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)\n\n## リバースプロキシ（ウェブサーバー）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png\">\n  <br/>\n  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>出典: ウィキペディア</a></i>\n  <br/>\n</p>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 24,
    "Content": "\nA reverse proxy is a web server that centralizes internal services and provides unified interfaces to the public.  Requests from clients are forwarded to a server that can fulfill it before the reverse proxy returns the server's response to the client.\n\nAdditional benefits include:\n\n* **Increased security** - Hide information about backend servers, blacklist IPs, limit number of connections per client\n* **Increased scalability and flexibility** - Clients only see the reverse proxy's IP, allowing you to scale servers or change their configuration\n* **SSL termination** - Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations\n    * Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server\n* **Compression** - Compress server responses\n* **Caching** - Return the response for cached requests\n* **Static content** - Serve static content directly\n    * HTML/CSS/JS\n    * Photos\n    * Videos\n    * Etc\n\n### Load balancer vs reverse proxy\n\n* Deploying a load balancer is useful when you have multiple servers.  Often, load balancers  route traffic to a set of servers serving the same function.\n* Reverse proxies can be useful even with just one web server or application server, opening up the benefits described in the previous section.\n* Solutions such as NGINX and HAProxy can support both layer 7 reverse proxying and load balancing.\n\n### Disadvantage(s): reverse proxy\n\n* Introducing a reverse proxy results in increased complexity.\n* A single reverse proxy is a single point of failure, configuring multiple reverse proxies (ie a [failover](https://en.wikipedia.org/wiki/Failover)) further increases complexity.\n\n### Source(s) and further reading\n\n* [Reverse proxy vs load balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)\n* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)\n\n## Application layer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png\">\n  <br/>",
    "ContentSha": "mSXIlXJOirzgK7lcCGgaBsQWdB09fQQPiRxJI8Azkv4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "リバースプロキシは、内部サービスを集中管理し、一般向けに統一されたインターフェースを提供するウェブサーバーです。  \nクライアントからのリクエストは、それを満たすことができるサーバーに転送され、リバースプロキシはそのサーバーの応答をクライアントに返します。  \n\n追加の利点には以下が含まれます：  \n\n* **セキュリティの向上** - バックエンドサーバーの情報を隠し、IPをブラックリスト化し、クライアントごとの接続数を制限  \n* **スケーラビリティと柔軟性の向上** - クライアントはリバースプロキシのIPのみを認識し、サーバーのスケールや設定変更が可能  \n* **SSL終了処理** - 受信リクエストを復号し、サーバー応答を暗号化することで、バックエンドサーバーがこれらの高コストな処理を行わなくて済む  \n    * 各サーバーに[X.509証明書](https://en.wikipedia.org/wiki/X.509)をインストールする必要がなくなる  \n* **圧縮** - サーバー応答の圧縮  \n* **キャッシュ** - キャッシュされたリクエストに対して応答を返す  \n* **静的コンテンツ** - 静的コンテンツを直接配信  \n    * HTML/CSS/JS  \n    * 写真  \n    * 動画  \n    * その他  \n\n### ロードバランサーとリバースプロキシの違い  \n\n* 複数のサーバーがある場合、ロードバランサーの導入は有用です。多くの場合、ロードバランサーは同一機能を提供するサーバー群へトラフィックを振り分けます。  \n* リバースプロキシは、単一のウェブサーバーやアプリケーションサーバーでも有用であり、前述の利点を享受できます。  \n* NGINXやHAProxyなどのソリューションは、レイヤ7のリバースプロキシとロードバランシングの両方をサポートします。  \n\n### リバースプロキシの欠点  \n\n* リバースプロキシを導入すると複雑さが増します。  \n* 単一のリバースプロキシは単一障害点となり、複数のリバースプロキシ（例：[フェイルオーバー](https://en.wikipedia.org/wiki/Failover)）を設定するとさらに複雑になります。  \n\n### 参考文献とさらなる読み物  \n\n* [リバースプロキシ vs ロードバランサー](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)  \n* [NGINXのアーキテクチャ](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)  \n* [HAProxyアーキテクチャガイド](http://www.haproxy.org/download/1.2/doc/architecture.txt)  \n* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)  \n\n## アプリケーション層  \n\n<p align=\"center\">  \n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png\">  \n  <br/>",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 25,
    "Content": "  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>\n</p>\n\nSeparating out the web layer from the application layer (also known as platform layer) allows you to scale and configure both layers independently.  Adding a new API results in adding application servers without necessarily adding additional web servers.  The **single responsibility principle** advocates for small and autonomous services that work together.  Small teams with small services can plan more aggressively for rapid growth.\n\nWorkers in the application layer also help enable [asynchronism](#asynchronism).\n\n### Microservices\n\nRelated to this discussion are [microservices](https://en.wikipedia.org/wiki/Microservices), which can be described as a suite of independently deployable, small, modular services.  Each service runs a unique process and communicates through a well-defined, lightweight mechanism to serve a business goal. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>\n\nPinterest, for example, could have the following microservices: user profile, follower, feed, search, photo upload, etc.\n\n### Service Discovery\n\nSystems such as [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), and [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) can help services find each other by keeping track of registered names, addresses, and ports.  [Health checks](https://www.consul.io/intro/getting-started/checks.html) help verify service integrity and are often done using an [HTTP](#hypertext-transfer-protocol-http) endpoint.  Both Consul and Etcd have a built in [key-value store](#key-value-store) that can be useful for storing config values and other shared data.\n\n### Disadvantage(s): application layer\n\n* Adding an application layer with loosely coupled services requires a different approach from an architectural, operations, and process viewpoint (vs a monolithic system).\n* Microservices can add complexity in terms of deployments and operations.\n\n### Source(s) and further reading\n\n* [Intro to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale)\n* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Service oriented architecture](https://en.wikipedia.org/wiki/Service-oriented_architecture)\n* [Introduction to Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)\n* [Here's what you need to know about building microservices](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)\n\n## Database\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Source: Scaling up to your first 10 million users</a></i>\n</p>\n\n### Relational database management system (RDBMS)\n",
    "ContentSha": "4XnXpBum9tEdb1sG9FZ65dxvl1TxD2b55kzZSCwIQE8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>出典：システムをスケールさせるためのアーキテクチャ入門</a></i>\n</p>\n\nウェブ層をアプリケーション層（プラットフォーム層とも呼ばれる）から分離することで、両層を独立してスケールおよび構成できます。新しいAPIを追加する場合、必ずしも追加のウェブサーバーを増やすことなくアプリケーションサーバーを追加できます。**単一責任の原則**は、小さく自律的なサービスが連携して動作することを推奨します。小さなチームと小さなサービスは、急速な成長に対してより積極的な計画が可能です。\n\nアプリケーション層のワーカーは、[非同期処理](#asynchronism)の実現も支援します。\n\n### マイクロサービス\n\nこの議論に関連するのが[マイクロサービス](https://en.wikipedia.org/wiki/Microservices)であり、独立してデプロイ可能な小さくモジュール化されたサービス群として説明できます。各サービスは独自のプロセスを実行し、ビジネス目標を達成するために定義された軽量の通信手段を通じて連携します。<sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>\n\n例えばPinterestでは、ユーザープロファイル、フォロワー、フィード、検索、写真アップロードなどのマイクロサービスが存在する可能性があります。\n\n### サービスディスカバリ\n\n[Consul](https://www.consul.io/docs/index.html)、[Etcd](https://coreos.com/etcd/docs/latest)、および[Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)などのシステムは、登録された名前、アドレス、ポートを追跡することでサービス同士の検出を支援します。[ヘルスチェック](https://www.consul.io/intro/getting-started/checks.html)はサービスの健全性を検証し、多くの場合[HTTP](#hypertext-transfer-protocol-http)エンドポイントを使用して行われます。ConsulとEtcdは共に構成値やその他の共有データを保存するのに便利な組み込みの[key-valueストア](#key-value-store)を備えています。\n\n### 欠点：アプリケーション層\n\n* ゆるく結合されたサービスを持つアプリケーション層の追加は、モノリシックシステムとは異なるアーキテクチャ、運用、プロセスのアプローチを必要とします。\n* マイクロサービスはデプロイや運用の面で複雑さを増す可能性があります。\n\n### 出典および参考資料\n\n* [システムをスケールさせるためのアーキテクチャ入門](http://lethain.com/introduction-to-architecting-systems-for-scale)\n* [システム設計面接を攻略する](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [サービス指向アーキテクチャ](https://en.wikipedia.org/wiki/Service-oriented_architecture)\n* [Zookeeper入門](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)\n* [マイクロサービス構築に必要なこと](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)\n\n## データベース\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>出典：最初の1000万人ユーザーへのスケーリング</a></i>\n</p>\n\n### リレーショナルデータベース管理システム（RDBMS）\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 26,
    "Content": "A relational database like SQL is a collection of data items organized in tables.\n\n**ACID** is a set of properties of relational database [transactions](https://en.wikipedia.org/wiki/Database_transaction).\n\n* **Atomicity** - Each transaction is all or nothing\n* **Consistency** - Any transaction will bring the database from one valid state to another\n* **Isolation** - Executing transactions concurrently has the same results as if the transactions were executed serially\n* **Durability** - Once a transaction has been committed, it will remain so\n\nThere are many techniques to scale a relational database: **master-slave replication**, **master-master replication**, **federation**, **sharding**, **denormalization**, and **SQL tuning**.\n\n#### Master-slave replication\n\nThe master serves reads and writes, replicating writes to one or more slaves, which serve only reads.  Slaves can also replicate to additional slaves in a tree-like fashion.  If the master goes offline, the system can continue to operate in read-only mode until a slave is promoted to a master or a new master is provisioned.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### Disadvantage(s): master-slave replication\n\n* Additional logic is needed to promote a slave to a master.\n* See [Disadvantage(s): replication](#disadvantages-replication) for points related to **both** master-slave and master-master.\n\n#### Master-master replication\n\nBoth masters serve reads and writes and coordinate with each other on writes.  If either master goes down, the system can continue to operate with both reads and writes.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### Disadvantage(s): master-master replication\n\n* You'll need a load balancer or you'll need to make changes to your application logic to determine where to write.\n* Most master-master systems are either loosely consistent (violating ACID) or have increased write latency due to synchronization.",
    "ContentSha": "xbwODyHVavckLsfDMlRqRxmfdv3+erTT0ITmoKYGnqg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "リレーショナルデータベース（SQLのようなもの）は、テーブルに整理されたデータ項目の集合です。\n\n**ACID** はリレーショナルデータベースの[トランザクション](https://en.wikipedia.org/wiki/Database_transaction)の特性のセットです。\n\n* **Atomicity（原子性）** - 各トランザクションは全か無かである\n* **Consistency（一貫性）** - いかなるトランザクションもデータベースを有効な状態から別の有効な状態へと変える\n* **Isolation（独立性）** - トランザクションを同時に実行しても、直列に実行した場合と同じ結果になる\n* **Durability（永続性）** - 一度コミットされたトランザクションは保持され続ける\n\nリレーショナルデータベースをスケールさせる手法は多数あります：**マスター・スレーブレプリケーション**、**マスター・マスターレプリケーション**、**フェデレーション**、**シャーディング**、**非正規化**、および**SQLチューニング**。\n\n#### マスター・スレーブレプリケーション\n\nマスターは読み書きを提供し、書き込みを一つ以上のスレーブにレプリケートします。スレーブは読み込みのみを提供します。スレーブはさらに木構造のように別のスレーブにレプリケートすることもできます。マスターがオフラインになった場合、スレーブがマスターに昇格されるか新しいマスターが用意されるまで、システムは読み取り専用モードで動作を続けられます。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>出典: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### 欠点：マスター・スレーブレプリケーション\n\n* スレーブをマスターに昇格させるための追加のロジックが必要です。\n* **マスター・スレーブ** と **マスター・マスター** の両方に関係する点は [欠点：レプリケーション](#disadvantages-replication) を参照してください。\n\n#### マスター・マスターレプリケーション\n\n両方のマスターが読み書きを提供し、書き込みに関しては互いに調整します。どちらかのマスターがダウンしても、システムは読み書きの両方を継続して動作できます。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>出典: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### 欠点：マスター・マスターレプリケーション\n\n* ロードバランサーが必要になるか、書き込み先を決定するためにアプリケーションロジックを変更する必要があります。\n* ほとんどのマスター・マスターシステムは緩やかに整合性が保たれている（ACIDを破る）か、同期による書き込み遅延が増加します。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 27,
    "Content": "* Conflict resolution comes more into play as more write nodes are added and as latency increases.\n* See [Disadvantage(s): replication](#disadvantages-replication) for points related to **both** master-slave and master-master.\n\n##### Disadvantage(s): replication\n\n* There is a potential for loss of data if the master fails before any newly written data can be replicated to other nodes.\n* Writes are replayed to the read replicas.  If there are a lot of writes, the read replicas can get bogged down with replaying writes and can't do as many reads.\n* The more read slaves, the more you have to replicate, which leads to greater replication lag.\n* On some systems, writing to the master can spawn multiple threads to write in parallel, whereas read replicas only support writing sequentially with a single thread.\n* Replication adds more hardware and additional complexity.\n\n##### Source(s) and further reading: replication\n\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [Multi-master replication](https://en.wikipedia.org/wiki/Multi-master_replication)\n\n#### Federation\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Source: Scaling up to your first 10 million users</a></i>\n</p>\n\nFederation (or functional partitioning) splits up databases by function.  For example, instead of a single, monolithic database, you could have three databases: **forums**, **users**, and **products**, resulting in less read and write traffic to each database and therefore less replication lag.  Smaller databases result in more data that can fit in memory, which in turn results in more cache hits due to improved cache locality.  With no single central master serializing writes you can write in parallel, increasing throughput.\n\n##### Disadvantage(s): federation\n\n* Federation is not effective if your schema requires huge functions or tables.\n* You'll need to update your application logic to determine which database to read and write.\n* Joining data from two databases is more complex with a [server link](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).\n* Federation adds more hardware and additional complexity.\n\n##### Source(s) and further reading: federation\n\n* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n\n#### Sharding\n\n<p align=\"center\">",
    "ContentSha": "I/gTQQL3xkPYu5E5dWj4YTG/hfUu3BM7YFOD7HwCQH0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* コンフリクト解決は、書き込みノードが増え、レイテンシが増加するにつれてより重要になります。\n* マスター・スレーブおよびマスター・マスターの**両方**に関連するポイントについては、[欠点：レプリケーション](#disadvantages-replication)を参照してください。\n\n##### 欠点：レプリケーション\n\n* マスターが新たに書き込まれたデータを他のノードにレプリケートする前に障害が発生した場合、データが失われる可能性があります。\n* 書き込みはリードレプリカにリプレイされます。書き込みが多いと、リードレプリカは書き込みのリプレイで遅くなり、読み込み処理が減少します。\n* リードスレーブが多いほど、レプリケーションする量が増え、レプリケーション遅延が大きくなります。\n* 一部のシステムでは、マスターへの書き込みは複数のスレッドで並列に行われますが、リードレプリカは単一スレッドで順次書き込みのみサポートします。\n* レプリケーションはハードウェアの追加と複雑さを増加させます。\n\n##### 参考文献および詳細：レプリケーション\n\n* [スケーラビリティ、可用性、安定性、パターン](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [マルチマスター・レプリケーション](https://en.wikipedia.org/wiki/Multi-master_replication)\n\n#### フェデレーション\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>出典：初めての1000万人ユーザーへのスケーリング</a></i>\n</p>\n\nフェデレーション（または機能的パーティショニング）は、データベースを機能ごとに分割します。例えば、単一のモノリシックなデータベースの代わりに、**フォーラム**、**ユーザー**、**製品**の3つのデータベースを持つことで、各データベースへの読み書きトラフィックが減り、その結果レプリケーション遅延が少なくなります。小さいデータベースはメモリに収まるデータが増え、キャッシュの局所性が向上するためキャッシュヒット率が上がります。単一の中央マスターが書き込みを直列化しないため、並列に書き込むことができ、スループットが向上します。\n\n##### 欠点：フェデレーション\n\n* スキーマが巨大な関数やテーブルを必要とする場合、フェデレーションは効果的ではありません。\n* どのデータベースを読み書きするかを判断するためにアプリケーションロジックを更新する必要があります。\n* 2つのデータベースからのデータ結合は、[サーバーリンク](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers)を使うためより複雑です。\n* フェデレーションはハードウェアの追加と複雑さを増加させます。\n\n##### 参考文献および詳細：フェデレーション\n\n* [初めての1000万人ユーザーへのスケーリング](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n\n#### シャーディング\n\n<p align=\"center\">",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 28,
    "Content": "  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nSharding distributes data across different databases such that each database can only manage a subset of the data.  Taking a users database as an example, as the number of users increases, more shards are added to the cluster.\n\nSimilar to the advantages of [federation](#federation), sharding results in less read and write traffic, less replication, and more cache hits.  Index size is also reduced, which generally improves performance with faster queries.  If one shard goes down, the other shards are still operational, although you'll want to add some form of replication to avoid data loss.  Like federation, there is no single central master serializing writes, allowing you to write in parallel with increased throughput.\n\nCommon ways to shard a table of users is either through the user's last name initial or the user's geographic location.\n\n##### Disadvantage(s): sharding\n\n* You'll need to update your application logic to work with shards, which could result in complex SQL queries.\n* Data distribution can become lopsided in a shard.  For example, a set of power users on a shard could result in increased load to that shard compared to others.\n    * Rebalancing adds additional complexity.  A sharding function based on [consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) can reduce the amount of transferred data.\n* Joining data from multiple shards is more complex.\n* Sharding adds more hardware and additional complexity.\n\n##### Source(s) and further reading: sharding\n\n* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)\n* [Shard database architecture](https://en.wikipedia.org/wiki/Shard_(database_architecture))\n* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)\n\n#### Denormalization\n\nDenormalization attempts to improve read performance at the expense of some write performance.  Redundant copies of the data are written in multiple tables to avoid expensive joins.  Some RDBMS such as [PostgreSQL](https://en.wikipedia.org/wiki/PostgreSQL) and Oracle support [materialized views](https://en.wikipedia.org/wiki/Materialized_view) which handle the work of storing redundant information and keeping redundant copies consistent.\n\nOnce data becomes distributed with techniques such as [federation](#federation) and [sharding](#sharding), managing joins across data centers further increases complexity.  Denormalization might circumvent the need for such complex joins.\n\nIn most systems, reads can heavily outnumber writes 100:1 or even 1000:1.  A read resulting in a complex database join can be very expensive, spending a significant amount of time on disk operations.\n\n##### Disadvantage(s): denormalization\n\n* Data is duplicated.\n* Constraints can help redundant copies of information stay in sync, which increases complexity of the database design.\n* A denormalized database under heavy write load might perform worse than its normalized counterpart.\n\n###### Source(s) and further reading: denormalization",
    "ContentSha": "GzP1YEx8H74doj7cHlqPZNKSbHvkETAbRVSJw4T5QnY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>出典：スケーラビリティ、可用性、安定性、パターン</a></i>\n</p>\n\nシャーディングはデータを異なるデータベースに分散させ、各データベースがデータのサブセットのみを管理できるようにします。ユーザーデータベースを例に取ると、ユーザー数が増えるにつれて、クラスターにシャードが追加されます。\n\n[federation](#federation)の利点と同様に、シャーディングは読み書きトラフィックの減少、レプリケーションの減少、キャッシュヒットの増加をもたらします。インデックスサイズも減少し、一般的にクエリの高速化によってパフォーマンスが向上します。1つのシャードがダウンしても他のシャードは稼働し続けますが、データ損失を防ぐために何らかのレプリケーションを追加する必要があります。federationと同様に、書き込みを直列化する単一の中央マスターがないため、スループットを増加させて並列書き込みが可能です。\n\nユーザーテーブルをシャーディングする一般的な方法は、ユーザーの姓のイニシャルや地理的位置によるものです。\n\n##### 欠点：シャーディング\n\n* シャードに対応するためにアプリケーションロジックを更新する必要があり、複雑なSQLクエリになる可能性があります。\n* データの分布がシャード内で偏ることがあります。例えば、特定のシャードにパワーユーザーが集中すると、そのシャードの負荷が他より増加します。\n    * リバランスはさらなる複雑さを加えます。[一貫性ハッシュ](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)に基づくシャーディング関数は転送データ量を減らせます。\n* 複数シャードのデータを結合するのはより複雑です。\n* シャーディングはハードウェアと複雑さを増やします。\n\n##### 出典およびさらなる参考資料：シャーディング\n\n* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)\n* [Shard database architecture](https://en.wikipedia.org/wiki/Shard_(database_architecture))\n* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)\n\n#### 非正規化\n\n非正規化は書き込み性能を一部犠牲にして読み取り性能を向上させることを試みます。高価な結合を避けるために、冗長なデータコピーを複数のテーブルに書き込みます。[PostgreSQL](https://ja.wikipedia.org/wiki/PostgreSQL)やOracleなど一部のRDBMSは、冗長情報の保持とコピーの一貫性維持を処理する[マテリアライズドビュー](https://ja.wikipedia.org/wiki/マテリアライズドビュー)をサポートしています。\n\n[federation](#federation)や[sharding](#sharding)のような技術でデータが分散されると、データセンター間の結合管理はさらに複雑になります。非正規化はそのような複雑な結合の必要性を回避するかもしれません。\n\nほとんどのシステムでは、読み取りが書き込みを100:1または1000:1で大幅に上回ることがあります。複雑なデータベース結合を伴う読み取りは非常にコストがかかり、多くの時間をディスク操作に費やします。\n\n##### 欠点：非正規化\n\n* データが重複します。\n* 制約は冗長な情報コピーの同期を助けますが、データベース設計の複雑さを増します。\n* 非正規化データベースは書き込み負荷が高いと、正規化されたものより性能が悪化することがあります。\n\n###### 出典およびさらなる参考資料：非正規化",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 29,
    "Content": "\n* [Denormalization](https://en.wikipedia.org/wiki/Denormalization)\n\n#### SQL tuning\n\nSQL tuning is a broad topic and many [books](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) have been written as reference.\n\nIt's important to **benchmark** and **profile** to simulate and uncover bottlenecks.\n\n* **Benchmark** - Simulate high-load situations with tools such as [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).\n* **Profile** - Enable tools such as the [slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) to help track performance issues.\n\nBenchmarking and profiling might point you to the following optimizations.\n\n##### Tighten up the schema\n\n* MySQL dumps to disk in contiguous blocks for fast access.\n* Use `CHAR` instead of `VARCHAR` for fixed-length fields.\n    * `CHAR` effectively allows for fast, random access, whereas with `VARCHAR`, you must find the end of a string before moving onto the next one.\n* Use `TEXT` for large blocks of text such as blog posts.  `TEXT` also allows for boolean searches.  Using a `TEXT` field results in storing a pointer on disk that is used to locate the text block.\n* Use `INT` for larger numbers up to 2^32 or 4 billion.\n* Use `DECIMAL` for currency to avoid floating point representation errors.\n* Avoid storing large `BLOBS`, store the location of where to get the object instead.\n* `VARCHAR(255)` is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.\n* Set the `NOT NULL` constraint where applicable to [improve search performance](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).\n\n##### Use good indices\n\n* Columns that you are querying (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) could be faster with indices.\n* Indices are usually represented as self-balancing [B-tree](https://en.wikipedia.org/wiki/B-tree) that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time.\n* Placing an index can keep the data in memory, requiring more space.\n* Writes could also be slower since the index also needs to be updated.\n* When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices.\n\n##### Avoid expensive joins\n\n* [Denormalize](#denormalization) where performance demands it.\n\n##### Partition tables\n",
    "ContentSha": "RC5xUXwhghEuq573LDD6+Is8QYupI3Y4Dn+nKYuNP3o=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [非正規化](https://ja.wikipedia.org/wiki/非正規化)\n\n#### SQL チューニング\n\nSQL チューニングは広範なトピックであり、多くの[書籍](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning)が参考資料として書かれています。\n\n**ベンチマーク**および**プロファイリング**を行い、ボトルネックをシミュレートして発見することが重要です。\n\n* **ベンチマーク** - [ab](http://httpd.apache.org/docs/2.2/programs/ab.html)などのツールで高負荷状況をシミュレートします。\n* **プロファイル** - [スロークエリログ](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)などのツールを有効にしてパフォーマンス問題の追跡を支援します。\n\nベンチマークとプロファイリングによって、次の最適化が示唆されることがあります。\n\n##### スキーマを厳密にする\n\n* MySQLは高速アクセスのためにディスクに連続したブロックでダンプします。\n* 固定長フィールドには `CHAR` を使用します。\n    * `CHAR` は高速なランダムアクセスを可能にしますが、`VARCHAR` は次の文字列に移動する前に文字列の終端を見つける必要があります。\n* ブログ投稿などの大きなテキストブロックには `TEXT` を使います。`TEXT` はブール検索も可能です。`TEXT` フィールドを使用すると、テキストブロックを特定するためのポインタがディスクに保存されます。\n* 2^32（約40億）までの大きな数値には `INT` を使います。\n* 浮動小数点の表現誤差を避けるために通貨には `DECIMAL` を使います。\n* 大きな `BLOB` を保存するのは避け、代わりにオブジェクトの取得場所を保存します。\n* `VARCHAR(255)` は8ビット数でカウントできる最大の文字数であり、多くのRDBMSでバイトの使用を最大化します。\n* 適用可能な場合は `NOT NULL` 制約を設定して[検索性能を改善](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)します。\n\n##### 良いインデックスを使う\n\n* クエリで使用するカラム（`SELECT`、`GROUP BY`、`ORDER BY`、`JOIN`）はインデックスで高速化できます。\n* インデックスは通常、データをソートし、探索、順次アクセス、挿入、削除を対数時間で行う自己平衡型の[B木](https://ja.wikipedia.org/wiki/B木)として表されます。\n* インデックスを配置するとデータをメモリに保持でき、より多くのスペースを要します。\n* インデックスも更新する必要があるため、書き込みは遅くなることがあります。\n* 大量データのロード時はインデックスを無効化し、ロード後に再構築する方が速い場合があります。\n\n##### 高コストなジョインを避ける\n\n* パフォーマンスが求められる場合は[非正規化](#非正規化)を行います。\n\n##### テーブルをパーティション分割する\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 30,
    "Content": "* Break up a table by putting hot spots in a separate table to help keep it in memory.\n\n##### Tune the query cache\n\n* In some cases, the [query cache](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) could lead to [performance issues](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).\n\n##### Source(s) and further reading: SQL tuning\n\n* [Tips for optimizing MySQL queries](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)\n* [Is there a good reason i see VARCHAR(255) used so often?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)\n* [How do null values affect performance?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)\n* [Slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)\n\n### NoSQL\n\nNoSQL is a collection of data items represented in a **key-value store**, **document store**, **wide column store**, or a **graph database**.  Data is denormalized, and joins are generally done in the application code.  Most NoSQL stores lack true ACID transactions and favor [eventual consistency](#eventual-consistency).\n\n**BASE** is often used to describe the properties of NoSQL databases.  In comparison with the [CAP Theorem](#cap-theorem), BASE chooses availability over consistency.\n\n* **Basically available** - the system guarantees availability.\n* **Soft state** - the state of the system may change over time, even without input.\n* **Eventual consistency** - the system will become consistent over a period of time, given that the system doesn't receive input during that period.\n\nIn addition to choosing between [SQL or NoSQL](#sql-or-nosql), it is helpful to understand which type of NoSQL database best fits your use case(s).  We'll review **key-value stores**, **document stores**, **wide column stores**, and **graph databases** in the next section.\n\n#### Key-value store\n\n> Abstraction: hash table\n\nA key-value store generally allows for O(1) reads and writes and is often backed by memory or SSD.  Data stores can maintain keys in [lexicographic order](https://en.wikipedia.org/wiki/Lexicographical_order), allowing efficient retrieval of key ranges.  Key-value stores can allow for storing of metadata with a value.\n\nKey-value stores provide high performance and are often used for simple data models or for rapidly-changing data, such as an in-memory cache layer.  Since they offer only a limited set of operations, complexity is shifted to the application layer if additional operations are needed.\n\nA key-value store is the basis for more complex systems such as a document store, and in some cases, a graph database.\n\n##### Source(s) and further reading: key-value store\n\n* [Key-value database](https://en.wikipedia.org/wiki/Key-value_database)\n* [Disadvantages of key-value stores](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)\n* [Redis architecture](http://qnimate.com/overview-of-redis-architecture/)",
    "ContentSha": "+vnJh/M2dUlgEZ6CZbzhFf3VoeY7aJE4IGjH1bsbrm8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* ホットスポットを別のテーブルに分割してメモリに保持しやすくする。\n\n##### クエリキャッシュの調整\n\n* 場合によっては、[クエリキャッシュ](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html)が[パフォーマンスの問題](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/)を引き起こすことがある。\n\n##### 出典および参考文献：SQLチューニング\n\n* [MySQLクエリ最適化のためのヒント](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)\n* [なぜVARCHAR(255)が頻繁に使われるのか？](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)\n* [NULL値はパフォーマンスにどう影響するか？](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)\n* [スロークエリログ](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)\n\n### NoSQL\n\nNoSQLは**キー・バリュー・ストア**、**ドキュメントストア**、**ワイドカラムストア**、または**グラフデータベース**で表現されるデータ項目の集合である。 データは非正規化されており、結合は一般的にアプリケーションコード内で行われる。 多くのNoSQLストアは真のACIDトランザクションを欠き、[最終的整合性](#eventual-consistency)を重視する。\n\n**BASE**はNoSQLデータベースの特性を表すために使われることが多い。 [CAP定理](#cap-theorem)と比較すると、BASEは一貫性よりも可用性を優先する。\n\n* **基本的に利用可能** - システムは可用性を保証する。\n* **ソフトステート** - システムの状態は入力がなくても時間とともに変化する可能性がある。\n* **最終的整合性** - システムは一定期間入力がなければ整合性が取れる状態になる。\n\n[SQLかNoSQLか](#sql-or-nosql)の選択に加えて、どのタイプのNoSQLデータベースがユースケースに最適かを理解することが有用である。 次節では**キー・バリュー・ストア**、**ドキュメントストア**、**ワイドカラムストア**、**グラフデータベース**をレビューする。\n\n#### キー・バリュー・ストア\n\n> 抽象化：ハッシュテーブル\n\nキー・バリュー・ストアは一般的にO(1)の読み書きを可能にし、メモリまたはSSDでバックアップされることが多い。 データストアは[辞書式順序](https://en.wikipedia.org/wiki/Lexicographical_order)でキーを保持でき、キー範囲の効率的な取得を可能にする。 キー・バリュー・ストアは値にメタデータを格納することもできる。\n\nキー・バリュー・ストアは高いパフォーマンスを提供し、シンプルなデータモデルやインメモリキャッシュ層のような急速に変化するデータによく使われる。 限られた操作セットのみを提供するため、追加の操作が必要な場合は複雑さがアプリケーション層に移る。\n\nキー・バリュー・ストアはドキュメントストアや場合によってはグラフデータベースのようなより複雑なシステムの基礎となる。\n\n##### 出典および参考文献：キー・バリュー・ストア\n\n* [キー・バリュー・データベース](https://en.wikipedia.org/wiki/Key-value_database)\n* [キー・バリュー・ストアの欠点](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)\n* [Redisのアーキテクチャ](http://qnimate.com/overview-of-redis-architecture/)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 31,
    "Content": "* [Memcached architecture](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)\n\n#### Document store\n\n> Abstraction: key-value store with documents stored as values\n\nA document store is centered around documents (XML, JSON, binary, etc), where a document stores all information for a given object.  Document stores provide APIs or a query language to query based on the internal structure of the document itself.  *Note, many key-value stores include features for working with a value's metadata, blurring the lines between these two storage types.*\n\nBased on the underlying implementation, documents are organized by collections, tags, metadata, or directories.  Although documents can be organized or grouped together, documents may have fields that are completely different from each other.\n\nSome document stores like [MongoDB](https://www.mongodb.com/mongodb-architecture) and [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) also provide a SQL-like language to perform complex queries.  [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) supports both key-values and documents.\n\nDocument stores provide high flexibility and are often used for working with occasionally changing data.\n\n##### Source(s) and further reading: document store\n\n* [Document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database)\n* [MongoDB architecture](https://www.mongodb.com/mongodb-architecture)\n* [CouchDB architecture](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)\n* [Elasticsearch architecture](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)\n\n#### Wide column store\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png\">\n  <br/>\n  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Source: SQL & NoSQL, a brief history</a></i>\n</p>\n\n> Abstraction: nested map `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`\n\nA wide column store's basic unit of data is a column (name/value pair).  A column can be grouped in column families (analogous to a SQL table).  Super column families further group column families.  You can access each column independently with a row key, and columns with the same row key form a row.  Each value contains a timestamp for versioning and for conflict resolution.\n\nGoogle introduced [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) as the first wide column store, which influenced the open-source [HBase](https://www.edureka.co/blog/hbase-architecture/) often-used in the Hadoop ecosystem, and [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) from Facebook.  Stores such as BigTable, HBase, and Cassandra maintain keys in lexicographic order, allowing efficient retrieval of selective key ranges.\n\nWide column stores offer high availability and high scalability.  They are often used for very large data sets.\n\n##### Source(s) and further reading: wide column store\n\n* [SQL & NoSQL, a brief history](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)",
    "ContentSha": "qChjAGddKNc8A4k6Ydpi6HXYPt34LJFKDxqqAKCkrXw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Memcachedのアーキテクチャ](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)\n\n#### ドキュメントストア\n\n> 抽象化: ドキュメントを値として格納するキー・バリュー・ストア\n\nドキュメントストアはドキュメント（XML、JSON、バイナリなど）を中心に設計されており、ドキュメントは特定のオブジェクトに関するすべての情報を格納します。ドキュメントストアは、ドキュメント内部の構造に基づいてクエリを実行するためのAPIやクエリ言語を提供します。*注：多くのキー・バリュー・ストアは値のメタデータを扱う機能を含んでおり、これら二つのストレージタイプの境界を曖昧にしています。*\n\n基盤となる実装により、ドキュメントはコレクション、タグ、メタデータ、またはディレクトリによって組織化されます。ドキュメントはグループ化されることもありますが、ドキュメント同士が全く異なるフィールドを持つ場合もあります。\n\n[MongoDB](https://www.mongodb.com/mongodb-architecture)や[CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)のような一部のドキュメントストアは、複雑なクエリを実行するためのSQLに似た言語も提供しています。[DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf)はキー・バリューとドキュメントの両方をサポートしています。\n\nドキュメントストアは高い柔軟性を持ち、時折変更されるデータを扱う場合によく使われます。\n\n##### 参考文献およびさらなる学習: ドキュメントストア\n\n* [ドキュメント指向データベース](https://ja.wikipedia.org/wiki/%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E6%8C%87%E5%90%91%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9)\n* [MongoDBのアーキテクチャ](https://www.mongodb.com/mongodb-architecture)\n* [CouchDBのアーキテクチャ](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)\n* [Elasticsearchのアーキテクチャ](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)\n\n#### ワイドカラムストア\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png\">\n  <br/>\n  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>出典: SQL & NoSQL、簡単な歴史</a></i>\n</p>\n\n> 抽象化: ネストされたマップ `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`\n\nワイドカラムストアの基本データ単位はカラム（名前/値のペア）です。カラムはカラムファミリー（SQLのテーブルに類似）にグループ化されます。スーパーカラムファミリーはさらにカラムファミリーをグループ化します。行キーで各カラムに独立してアクセスでき、同じ行キーのカラムが行を形成します。各値にはバージョニングや競合解決のためのタイムスタンプが含まれます。\n\nGoogleは最初のワイドカラムストアとして[Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)を導入し、これがHadoopエコシステムでよく使われるオープンソースの[HBase](https://www.edureka.co/blog/hbase-architecture/)やFacebookの[Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)に影響を与えました。BigTable、HBase、Cassandraなどのストアはキーを辞書順で保持し、選択的なキー範囲の効率的な取得を可能にしています。\n\nワイドカラムストアは高い可用性と高いスケーラビリティを提供し、非常に大規模なデータセットによく使用されます。\n\n##### 参考文献およびさらなる学習: ワイドカラムストア\n\n* [SQL & NoSQL、簡単な歴史](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 32,
    "Content": "* [Bigtable architecture](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)\n* [HBase architecture](https://www.edureka.co/blog/hbase-architecture/)\n* [Cassandra architecture](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)\n\n#### Graph database\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png\">\n  <br/>\n  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Source: Graph database</a></i>\n</p>\n\n> Abstraction: graph\n\nIn a graph database, each node is a record and each arc is a relationship between two nodes.  Graph databases are optimized to represent complex relationships with many foreign keys or many-to-many relationships.\n\nGraphs databases offer high performance for data models with complex relationships, such as a social network.  They are relatively new and are not yet widely-used; it might be more difficult to find development tools and resources.  Many graphs can only be accessed with [REST APIs](#representational-state-transfer-rest).\n\n##### Source(s) and further reading: graph\n\n* [Graph database](https://en.wikipedia.org/wiki/Graph_database)\n* [Neo4j](https://neo4j.com/)\n* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)\n\n#### Source(s) and further reading: NoSQL\n\n* [Explanation of base terminology](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)\n* [NoSQL databases a survey and decision guidance](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)\n* [Scalability](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n* [Introduction to NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)\n* [NoSQL patterns](http://horicky.blogspot.com/2009/11/nosql-patterns.html)\n\n### SQL or NoSQL\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Source: Transitioning from RDBMS to NoSQL</a></i>\n</p>\n",
    "ContentSha": "yvB08chNWcvF9yiu0b/QLR53EBOeWK574rgWXfnGOXg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Bigtableアーキテクチャ](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)\n* [HBaseアーキテクチャ](https://www.edureka.co/blog/hbase-architecture/)\n* [Cassandraアーキテクチャ](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)\n\n#### グラフデータベース\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png\">\n  <br/>\n  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>出典：グラフデータベース</a></i>\n</p>\n\n> 抽象化：グラフ\n\nグラフデータベースでは、各ノードがレコードであり、各アークが2つのノード間の関係を表します。グラフデータベースは、多数の外部キーや多対多の関係を持つ複雑な関係を表現するように最適化されています。\n\nグラフデータベースは、ソーシャルネットワークのような複雑な関係を持つデータモデルに対して高いパフォーマンスを提供します。比較的新しい技術であり、まだ広く使われていないため、開発ツールやリソースを見つけるのが難しい場合があります。多くのグラフは[REST API](#representational-state-transfer-rest)でのみアクセス可能です。\n\n##### 出典および追加資料：グラフ\n\n* [グラフデータベース](https://en.wikipedia.org/wiki/Graph_database)\n* [Neo4j](https://neo4j.com/)\n* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)\n\n#### 出典および追加資料：NoSQL\n\n* [BASE用語の説明](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)\n* [NoSQLデータベースの調査と意思決定ガイダンス](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)\n* [スケーラビリティ](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n* [NoSQL入門](https://www.youtube.com/watch?v=qI_g07C_Q5I)\n* [NoSQLパターン](http://horicky.blogspot.com/2009/11/nosql-patterns.html)\n\n### SQLまたはNoSQL\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>出典：RDBMSからNoSQLへの移行</a></i>\n</p>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 33,
    "Content": "Reasons for **SQL**:\n\n* Structured data\n* Strict schema\n* Relational data\n* Need for complex joins\n* Transactions\n* Clear patterns for scaling\n* More established: developers, community, code, tools, etc\n* Lookups by index are very fast\n\nReasons for **NoSQL**:\n\n* Semi-structured data\n* Dynamic or flexible schema\n* Non-relational data\n* No need for complex joins\n* Store many TB (or PB) of data\n* Very data intensive workload\n* Very high throughput for IOPS\n\nSample data well-suited for NoSQL:\n\n* Rapid ingest of clickstream and log data\n* Leaderboard or scoring data\n* Temporary data, such as a shopping cart\n* Frequently accessed ('hot') tables\n* Metadata/lookup tables\n\n##### Source(s) and further reading: SQL or NoSQL\n\n* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n* [SQL vs NoSQL differences](https://www.sitepoint.com/sql-vs-nosql-differences/)\n\n## Cache\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>",
    "ContentSha": "s5JZtpzJOg6uZVhDykP9Uy+U/KEwjhNiySMSqZAIAwI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**SQL**を選ぶ理由:\n\n* 構造化データ\n* 厳密なスキーマ\n* リレーショナルデータ\n* 複雑な結合が必要\n* トランザクション\n* スケーリングのための明確なパターン\n* より確立されている：開発者、コミュニティ、コード、ツールなど\n* インデックスによるルックアップが非常に高速\n\n**NoSQL**を選ぶ理由:\n\n* 半構造化データ\n* 動的または柔軟なスキーマ\n* 非リレーショナルデータ\n* 複雑な結合が不要\n* 多数のTB（またはPB）のデータを保存\n* 非常にデータ集約型のワークロード\n* 非常に高いIOPSスループット\n\nNoSQLに適したサンプルデータ:\n\n* クリックストリームやログデータの迅速な取り込み\n* リーダーボードやスコアリングデータ\n* ショッピングカートのような一時データ\n* 頻繁にアクセスされる（「ホット」）テーブル\n* メタデータ／ルックアップテーブル\n\n##### 出典およびさらなる参考資料: SQLまたはNoSQL\n\n* [最初の1000万人ユーザーまでのスケーリング](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n* [SQLとNoSQLの違い](https://www.sitepoint.com/sql-vs-nosql-differences/)\n\n## キャッシュ\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>出典: スケーラブルなシステム設計パターン</a></i>",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 34,
    "Content": "</p>\n\nCaching improves page load times and can reduce the load on your servers and databases.  In this model, the dispatcher will first lookup if the request has been made before and try to find the previous result to return, in order to save the actual execution.\n\nDatabases often benefit from a uniform distribution of reads and writes across its partitions.  Popular items can skew the distribution, causing bottlenecks.  Putting a cache in front of a database can help absorb uneven loads and spikes in traffic.\n\n### Client caching\n\nCaches can be located on the client side (OS or browser), [server side](#reverse-proxy-web-server), or in a distinct cache layer.\n\n### CDN caching\n\n[CDNs](#content-delivery-network) are considered a type of cache.\n\n### Web server caching\n\n[Reverse proxies](#reverse-proxy-web-server) and caches such as [Varnish](https://www.varnish-cache.org/) can serve static and dynamic content directly.  Web servers can also cache requests, returning responses without having to contact application servers.\n\n### Database caching\n\nYour database usually includes some level of caching in a default configuration, optimized for a generic use case.  Tweaking these settings for specific usage patterns can further boost performance.\n\n### Application caching\n\nIn-memory caches such as Memcached and Redis are key-value stores between your application and your data storage.  Since the data is held in RAM, it is much faster than typical databases where data is stored on disk.  RAM is more limited than disk, so [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms) algorithms such as [least recently used (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)) can help invalidate 'cold' entries and keep 'hot' data in RAM.\n\nRedis has the following additional features:\n\n* Persistence option\n* Built-in data structures such as sorted sets and lists\n\nThere are multiple levels you can cache that fall into two general categories: **database queries** and **objects**:\n\n* Row level\n* Query-level\n* Fully-formed serializable objects\n* Fully-rendered HTML\n\nGenerally, you should try to avoid file-based caching, as it makes cloning and auto-scaling more difficult.\n",
    "ContentSha": "PfUbgKkIJf45vxersAv0t5I8be53ZYhiGpd5NAhmomo=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "</p>\n\nキャッシュはページの読み込み時間を改善し、サーバーやデータベースの負荷を軽減できます。このモデルでは、ディスパッチャーがまずリクエストが以前に行われたかどうかを確認し、実際の実行を省くために以前の結果を返そうとします。\n\nデータベースは通常、パーティション全体で読み書きが均等に分布することで恩恵を受けます。人気のあるアイテムは分布を偏らせ、ボトルネックを引き起こす可能性があります。データベースの前にキャッシュを置くことで、不均等な負荷やトラフィックの急増を吸収できます。\n\n### クライアントキャッシュ\n\nキャッシュはクライアント側（OSやブラウザ）、[サーバー側](#reverse-proxy-web-server)、または独立したキャッシュ層に配置できます。\n\n### CDNキャッシュ\n\n[CDN](#content-delivery-network)はキャッシュの一種と見なされます。\n\n### ウェブサーバーキャッシュ\n\n[リバースプロキシ](#reverse-proxy-web-server)や[Varnish](https://www.varnish-cache.org/)のようなキャッシュは静的および動的コンテンツを直接提供できます。ウェブサーバーもリクエストをキャッシュし、アプリケーションサーバーに連絡せずにレスポンスを返せます。\n\n### データベースキャッシュ\n\nデータベースは通常、デフォルト設定で何らかのキャッシュレベルを含み、汎用的なユースケースに最適化されています。特定の使用パターンに合わせてこれらの設定を調整すると、さらにパフォーマンスを向上させることができます。\n\n### アプリケーションキャッシュ\n\nMemcachedやRedisのようなインメモリキャッシュは、アプリケーションとデータストレージの間にあるキー・バリューストアです。データがRAMに保持されるため、通常ディスクに保存されるデータベースよりもはるかに高速です。RAMはディスクよりも容量が限られているため、[キャッシュ無効化](https://ja.wikipedia.org/wiki/キャッシュアルゴリズム)アルゴリズム（例えば[最も最近使われていない（LRU）](https://ja.wikipedia.org/wiki/キャッシュ置換アルゴリズム#最も最近使われていない_(LRU))）が「冷たい」エントリを無効化し、「熱い」データをRAMに保持するのに役立ちます。\n\nRedisには以下の追加機能があります：\n\n* 永続化オプション\n* ソート済みセットやリストなどの組み込みデータ構造\n\nキャッシュできるレベルは複数あり、大きく分けて**データベースクエリ**と**オブジェクト**の2種類があります：\n\n* 行レベル\n* クエリレベル\n* 完全に形成されたシリアライズ可能なオブジェクト\n* 完全にレンダリングされたHTML\n\n一般的に、ファイルベースのキャッシュはクローン作成やオートスケーリングを難しくするため避けるべきです。\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 35,
    "Content": "### Caching at the database query level\n\nWhenever you query the database, hash the query as a key and store the result to the cache.  This approach suffers from expiration issues:\n\n* Hard to delete a cached result with complex queries\n* If one piece of data changes such as a table cell, you need to delete all cached queries that might include the changed cell\n\n### Caching at the object level\n\nSee your data as an object, similar to what you do with your application code.  Have your application assemble the dataset from the database into a class instance or a data structure(s):\n\n* Remove the object from cache if its underlying data has changed\n* Allows for asynchronous processing: workers assemble objects by consuming the latest cached object\n\nSuggestions of what to cache:\n\n* User sessions\n* Fully rendered web pages\n* Activity streams\n* User graph data\n\n### When to update the cache\n\nSince you can only store a limited amount of data in cache, you'll need to determine which cache update strategy works best for your use case.\n\n#### Cache-aside\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>\n</p>\n\nThe application is responsible for reading and writing from storage.  The cache does not interact with storage directly.  The application does the following:\n\n* Look for entry in cache, resulting in a cache miss\n* Load entry from the database\n* Add entry to cache\n* Return entry\n",
    "ContentSha": "1LZ2C/EUSShYNdt1FP+/fZdVQMcH8WGFigSx+nEiAZI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### データベースクエリレベルでのキャッシュ\n\nデータベースをクエリするたびに、クエリをキーとしてハッシュ化し、その結果をキャッシュに保存します。この方法は有効期限の問題があります：\n\n* 複雑なクエリのキャッシュ結果を削除するのが難しい\n* テーブルのセルなど一部のデータが変更された場合、変更されたセルを含む可能性のあるすべてのキャッシュクエリを削除する必要がある\n\n### オブジェクトレベルでのキャッシュ\n\nデータをアプリケーションコードと同様にオブジェクトとして見なします。アプリケーションがデータベースからのデータセットをクラスインスタンスやデータ構造に組み立てます：\n\n* 基盤となるデータが変更された場合、オブジェクトをキャッシュから削除する\n* 非同期処理を可能にする：ワーカーは最新のキャッシュされたオブジェクトを利用してオブジェクトを組み立てる\n\nキャッシュすべきものの提案：\n\n* ユーザーセッション\n* 完全にレンダリングされたウェブページ\n* アクティビティストリーム\n* ユーザーグラフデータ\n\n### キャッシュを更新するタイミング\n\nキャッシュに保存できるデータ量は限られているため、ユースケースに最適なキャッシュ更新戦略を決定する必要があります。\n\n#### Cache-aside\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>出典: From cache to in-memory data grid</a></i>\n</p>\n\nアプリケーションがストレージからの読み書きを担当します。キャッシュはストレージと直接やり取りしません。アプリケーションの動作は以下の通りです：\n\n* キャッシュ内のエントリを探すが、キャッシュミスとなる\n* データベースからエントリを読み込む\n* エントリをキャッシュに追加する\n* エントリを返す\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 36,
    "Content": "```python\ndef get_user(self, user_id):\n    user = cache.get(\"user.{0}\", user_id)\n    if user is None:\n        user = db.query(\"SELECT * FROM users WHERE user_id = {0}\", user_id)\n        if user is not None:\n            key = \"user.{0}\".format(user_id)\n            cache.set(key, json.dumps(user))\n    return user\n```",
    "ContentSha": "oOOkxiaDDsfJgZibD4WyvNCLh494Kkw0zeQUjNF+dKA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\ndef get_user(self, user_id):\n    user = cache.get(\"user.{0}\", user_id)\n    if user is None:\n        user = db.query(\"SELECT * FROM users WHERE user_id = {0}\", user_id)\n        if user is not None:\n            key = \"user.{0}\".format(user_id)\n            cache.set(key, json.dumps(user))\n    return user\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 37,
    "Content": "\n[Memcached](https://memcached.org/) is generally used in this manner.\n\nSubsequent reads of data added to cache are fast.  Cache-aside is also referred to as lazy loading.  Only requested data is cached, which avoids filling up the cache with data that isn't requested.\n\n##### Disadvantage(s): cache-aside\n\n* Each cache miss results in three trips, which can cause a noticeable delay.\n* Data can become stale if it is updated in the database.  This issue is mitigated by setting a time-to-live (TTL) which forces an update of the cache entry, or by using write-through.\n* When a node fails, it is replaced by a new, empty node, increasing latency.\n\n#### Write-through\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nThe application uses the cache as the main data store, reading and writing data to it, while the cache is responsible for reading and writing to the database:\n\n* Application adds/updates entry in cache\n* Cache synchronously writes entry to data store\n* Return\n\nApplication code:\n",
    "ContentSha": "fTUxdhUP8C+msOuO6oFCQBKVESfJlBRIv+xTex+NRH4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "[Memcached](https://memcached.org/) は一般的にこのように使用されます。\n\nキャッシュに追加されたデータの後続の読み取りは高速です。Cache-asideはレイジーローディングとも呼ばれます。要求されたデータのみがキャッシュされ、要求されていないデータでキャッシュが埋まるのを防ぎます。\n\n##### 欠点: cache-aside\n\n* キャッシュミスごとに3回の往復が発生し、目に見える遅延を引き起こす可能性があります。\n* データベースで更新された場合、データが古くなる可能性があります。この問題は、キャッシュエントリの更新を強制するTTL（有効期限）を設定するか、ライトスルーを使用することで緩和されます。\n* ノードが故障した場合、新しい空のノードに置き換えられ、レイテンシが増加します。\n\n#### ライトスルー\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>出典: Scalability, availability, stability, patterns</a></i>\n</p>\n\nアプリケーションはキャッシュを主要なデータストアとして使用し、読み書きを行い、キャッシュはデータベースへの読み書きを担当します：\n\n* アプリケーションがキャッシュにエントリを追加/更新\n* キャッシュが同期的にデータストアにエントリを書き込み\n* 戻り値を返す\n\nアプリケーションコード：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 38,
    "Content": "```python\nset_user(12345, {\"foo\":\"bar\"})\n```",
    "ContentSha": "7tpMTtbDSdUbs+oC+Qf5dKLGCUAcRFUe6DfcgSYQP7c=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\nset_user(12345, {\"foo\":\"bar\"})\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 39,
    "Content": "\nCache code:\n",
    "ContentSha": "3TQIz863VWmVTS8NeQVBQ2s9apIl1JpwXxyAqo7YRXU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "キャッシュコード：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 40,
    "Content": "```python\ndef set_user(user_id, values):\n    user = db.query(\"UPDATE Users WHERE id = {0}\", user_id, values)\n    cache.set(user_id, user)\n```",
    "ContentSha": "2/SVlo2Tq+z8vN6s72UuRvXSio2ONq8aOqxj7V/g+MY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\ndef set_user(user_id, values):\n    user = db.query(\"UPDATE Users WHERE id = {0}\", user_id, values)\n    cache.set(user_id, user)\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 41,
    "Content": "\nWrite-through is a slow overall operation due to the write operation, but subsequent reads of just written data are fast.  Users are generally more tolerant of latency when updating data than reading data.  Data in the cache is not stale.\n\n##### Disadvantage(s): write through\n\n* When a new node is created due to failure or scaling, the new node will not cache entries until the entry is updated in the database.  Cache-aside in conjunction with write through can mitigate this issue.\n* Most data written might never be read, which can be minimized with a TTL.\n\n#### Write-behind (write-back)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nIn write-behind, the application does the following:\n\n* Add/update entry in cache\n* Asynchronously write entry to the data store, improving write performance\n\n##### Disadvantage(s): write-behind\n\n* There could be data loss if the cache goes down prior to its contents hitting the data store.\n* It is more complex to implement write-behind than it is to implement cache-aside or write-through.\n\n#### Refresh-ahead\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>\n</p>\n\nYou can configure the cache to automatically refresh any recently accessed cache entry prior to its expiration.\n\nRefresh-ahead can result in reduced latency vs read-through if the cache can accurately predict which items are likely to be needed in the future.\n\n##### Disadvantage(s): refresh-ahead\n",
    "ContentSha": "7f5A+XWrDoL377SvEQn7a+GkFngcY2VPIRUi5SDADy0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\nライトスルーは書き込み操作のため全体的に遅いですが、直後に書き込まれたデータの読み取りは高速です。ユーザーはデータの更新よりも読み取り時の遅延を一般的により許容します。キャッシュ内のデータは古くありません。\n\n##### デメリット：ライトスルー\n\n* 障害やスケーリングにより新しいノードが作成された場合、そのノードはデータベースでエントリが更新されるまでエントリをキャッシュしません。キャッシュアサイドとライトスルーを組み合わせることでこの問題を軽減できます。\n* 書き込まれたデータの多くは一度も読み取られない可能性があり、TTLでこれを最小化できます。\n\n#### ライトビハインド（ライトバック）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>出典：スケーラビリティ、可用性、安定性パターン</a></i>\n</p>\n\nライトビハインドでは、アプリケーションは以下を行います：\n\n* キャッシュにエントリを追加／更新\n* 非同期でデータストアにエントリを書き込み、書き込み性能を向上させる\n\n##### デメリット：ライトビハインド\n\n* キャッシュの内容がデータストアに反映される前にキャッシュがダウンするとデータ損失が発生する可能性があります。\n* ライトビハインドはキャッシュアサイドやライトスルーよりも実装が複雑です。\n\n#### リフレッシュアヘッド\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>出典：キャッシュからインメモリデータグリッドへ</a></i>\n</p>\n\nキャッシュは自動的に最近アクセスされたキャッシュエントリを期限切れ前にリフレッシュするよう設定できます。\n\nリフレッシュアヘッドは、キャッシュが将来必要とされる可能性のあるアイテムを正確に予測できれば、リードスルーよりもレイテンシを低減できます。\n\n##### デメリット：リフレッシュアヘッド\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 42,
    "Content": "* Not accurately predicting which items are likely to be needed in the future can result in reduced performance than without refresh-ahead.\n\n### Disadvantage(s): cache\n\n* Need to maintain consistency between caches and the source of truth such as the database through [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms).\n* Cache invalidation is a difficult problem, there is additional complexity associated with when to update the cache.\n* Need to make application changes such as adding Redis or memcached.\n\n### Source(s) and further reading\n\n* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)\n* [Scalable system design patterns](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)\n* [Introduction to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [Scalability](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n* [AWS ElastiCache strategies](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)\n* [Wikipedia](https://en.wikipedia.org/wiki/Cache_(computing))\n\n## Asynchronism\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png\">\n  <br/>\n  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>\n</p>\n\nAsynchronous workflows help reduce request times for expensive operations that would otherwise be performed in-line.  They can also help by doing time-consuming work in advance, such as periodic aggregation of data.\n\n### Message queues\n\nMessage queues receive, hold, and deliver messages.  If an operation is too slow to perform inline, you can use a message queue with the following workflow:\n\n* An application publishes a job to the queue, then notifies the user of job status\n* A worker picks up the job from the queue, processes it, then signals the job is complete\n\nThe user is not blocked and the job is processed in the background.  During this time, the client might optionally do a small amount of processing to make it seem like the task has completed.  For example, if posting a tweet, the tweet could be instantly posted to your timeline, but it could take some time before your tweet is actually delivered to all of your followers.\n\n**[Redis](https://redis.io/)** is useful as a simple message broker but messages can be lost.\n\n**[RabbitMQ](https://www.rabbitmq.com/)** is popular but requires you to adapt to the 'AMQP' protocol and manage your own nodes.",
    "ContentSha": "m5CQKaSxoSpqZLBi9DEuTpec6TQ1PuzDQenhKpH7SUw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 将来必要になる可能性が高いアイテムを正確に予測できないと、リフレッシュアヘッドなしの場合よりもパフォーマンスが低下することがある。\n\n### 欠点: キャッシュ\n\n* キャッシュとデータベースなどの真実のソースとの一貫性を[キャッシュ無効化](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%82%A2%E3%83%AB%E4%BB%A3%E6%9B%BF)を通じて維持する必要がある。\n* キャッシュ無効化は難しい問題であり、いつキャッシュを更新するかに関する追加の複雑さがある。\n* Redisやmemcachedの追加など、アプリケーションの変更が必要になる。\n\n### 参考文献およびさらなる読み物\n\n* [キャッシュからインメモリデータグリッドへ](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)\n* [スケーラブルシステム設計パターン](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)\n* [スケールのためのシステム設計入門](http://lethain.com/introduction-to-architecting-systems-for-scale/)\n* [スケーラビリティ、可用性、安定性のパターン](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [スケーラビリティ](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n* [AWS ElastiCache戦略](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)\n* [ウィキペディア](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0))\n\n## 非同期処理\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png\">\n  <br/>\n  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>出典: スケールのためのシステム設計入門</a></i>\n</p>\n\n非同期ワークフローは、インラインで実行すると高コストな操作のリクエスト時間を短縮するのに役立つ。また、定期的なデータ集約など、時間のかかる作業を事前に行うことにも役立つ。\n\n### メッセージキュー\n\nメッセージキューはメッセージの受信、保持、配信を行う。操作がインラインで行うには遅すぎる場合、以下のワークフローでメッセージキューを利用できる。\n\n* アプリケーションがジョブをキューに公開し、ユーザーにジョブの状態を通知する。\n* ワーカーがキューからジョブを取得して処理し、ジョブの完了を通知する。\n\nユーザーはブロックされず、ジョブはバックグラウンドで処理される。この間、クライアントはタスクが完了したかのように見せるために少量の処理を行うことがある。たとえば、ツイートを投稿する場合、ツイートは即座にタイムラインに表示されるが、実際にすべてのフォロワーに配信されるまでには時間がかかることがある。\n\n**[Redis](https://redis.io/)** はシンプルなメッセージブローカーとして有用だが、メッセージが失われる可能性がある。\n\n**[RabbitMQ](https://www.rabbitmq.com/)** は人気があるが、'AMQP'プロトコルに適応し、自分でノードを管理する必要がある。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 43,
    "Content": "\n**[Amazon SQS](https://aws.amazon.com/sqs/)** is hosted but can have high latency and has the possibility of messages being delivered twice.\n\n### Task queues\n\nTasks queues receive tasks and their related data, runs them, then delivers their results.  They can support scheduling and can be used to run computationally-intensive jobs in the background.\n\n**[Celery](https://docs.celeryproject.org/en/stable/)** has support for scheduling and primarily has python support.\n\n### Back pressure\n\nIf queues start to grow significantly, the queue size can become larger than memory, resulting in cache misses, disk reads, and even slower performance.  [Back pressure](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) can help by limiting the queue size, thereby maintaining a high throughput rate and good response times for jobs already in the queue.  Once the queue fills up, clients get a server busy or HTTP 503 status code to try again later.  Clients can retry the request at a later time, perhaps with [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff).\n\n### Disadvantage(s): asynchronism\n\n* Use cases such as inexpensive calculations and realtime workflows might be better suited for synchronous operations, as introducing queues can add delays and complexity.\n\n### Source(s) and further reading\n\n* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)\n* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)\n* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)\n* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)\n\n## Communication\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg\">\n  <br/>\n  <i><a href=http://www.escotal.com/osilayer.html>Source: OSI 7 layer model</a></i>\n</p>\n\n### Hypertext transfer protocol (HTTP)\n\nHTTP is a method for encoding and transporting data between a client and a server.  It is a request/response protocol: clients issue requests and servers issue responses with relevant content and completion status info about the request.  HTTP is self-contained, allowing requests and responses to flow through many intermediate routers and servers that perform load balancing, caching, encryption, and compression.\n\nA basic HTTP request consists of a verb (method) and a resource (endpoint).  Below are common HTTP verbs:\n\n| Verb | Description | Idempotent* | Safe | Cacheable |\n|---|---|---|---|---|",
    "ContentSha": "EQovDG9OkNb9dVypgpzwJggXSXWXdn7svWuM8fLZ6Es=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**[Amazon SQS](https://aws.amazon.com/sqs/)** はホスト型ですが、高遅延が発生する可能性があり、メッセージが二重に配信される可能性があります。\n\n### タスクキュー\n\nタスクキューはタスクと関連データを受け取り、それを実行し、結果を届けます。スケジューリングをサポートでき、計算負荷の高いジョブをバックグラウンドで実行するのに利用可能です。\n\n**[Celery](https://docs.celeryproject.org/en/stable/)** はスケジューリングをサポートし、主にPythonでのサポートがあります。\n\n### バックプレッシャー\n\nキューのサイズが大幅に増加すると、キューサイズがメモリ容量を超え、キャッシュミスやディスク読み込みが発生し、さらにパフォーマンスが低下します。[バックプレッシャー](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) はキューサイズを制限することで、スループット率を維持し、キュー内のジョブに対して良好な応答時間を保つのに役立ちます。キューが満杯になると、クライアントはサーバービジーやHTTP 503ステータスコードを受け取り、後で再試行を促されます。クライアントは後でリクエストを再試行でき、[指数バックオフ](https://en.wikipedia.org/wiki/Exponential_backoff)を用いることもあります。\n\n### デメリット：非同期性\n\n* 安価な計算やリアルタイムワークフローのようなユースケースには、キューを導入すると遅延や複雑さが増すため、同期処理の方が適している場合があります。\n\n### 出典および参考文献\n\n* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)\n* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)\n* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)\n* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)\n\n## 通信\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg\">\n  <br/>\n  <i><a href=http://www.escotal.com/osilayer.html>出典: OSI 7層モデル</a></i>\n</p>\n\n### ハイパーテキスト転送プロトコル（HTTP）\n\nHTTPはクライアントとサーバー間でデータをエンコードし転送する方法です。リクエスト/レスポンス型のプロトコルであり、クライアントはリクエストを発行し、サーバーは関連コンテンツとリクエストの完了状態情報を含むレスポンスを返します。HTTPは自己完結型であり、多くの中間ルーターやサーバーを経由してロードバランシング、キャッシュ、暗号化、圧縮を行いながらリクエストとレスポンスが流れます。\n\n基本的なHTTPリクエストは動詞（メソッド）とリソース（エンドポイント）で構成されます。以下は一般的なHTTP動詞です：\n\n| 動詞 | 説明 | 冪等* | 安全 | キャッシュ可能 |\n|---|---|---|---|---|\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 44,
    "Content": "| GET | Reads a resource | Yes | Yes | Yes |\n| POST | Creates a resource or trigger a process that handles data | No | No | Yes if response contains freshness info |\n| PUT | Creates or replace a resource | Yes | No | No |\n| PATCH | Partially updates a resource | No | No | Yes if response contains freshness info |\n| DELETE | Deletes a resource | Yes | No | No |\n\n*Can be called many times without different outcomes.\n\nHTTP is an application layer protocol relying on lower-level protocols such as **TCP** and **UDP**.\n\n#### Source(s) and further reading: HTTP\n\n* [What is HTTP?](https://www.nginx.com/resources/glossary/http/)\n* [Difference between HTTP and TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)\n* [Difference between PUT and PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)\n\n### Transmission control protocol (TCP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>\n</p>\n\nTCP is a connection-oriented protocol over an [IP network](https://en.wikipedia.org/wiki/Internet_Protocol).  Connection is established and terminated using a [handshake](https://en.wikipedia.org/wiki/Handshaking).  All packets sent are guaranteed to reach the destination in the original order and without corruption through:\n\n* Sequence numbers and [checksum fields](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) for each packet\n* [Acknowledgement](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) packets and automatic retransmission\n\nIf the sender does not receive a correct response, it will resend the packets.  If there are multiple timeouts, the connection is dropped.  TCP also implements [flow control](https://en.wikipedia.org/wiki/Flow_control_(data)) and [congestion control](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control).  These guarantees cause delays and generally result in less efficient transmission than UDP.\n\nTo ensure high throughput, web servers can keep a large number of TCP connections open, resulting in high memory usage.  It can be expensive to have a large number of open connections between web server threads and say, a [memcached](https://memcached.org/) server.  [Connection pooling](https://en.wikipedia.org/wiki/Connection_pool) can help in addition to switching to UDP where applicable.\n\nTCP is useful for applications that require high reliability but are less time critical.  Some examples include web servers, database info, SMTP, FTP, and SSH.\n\nUse TCP over UDP when:\n\n* You need all of the data to arrive intact\n* You want to automatically make a best estimate use of the network throughput\n",
    "ContentSha": "EP5TmrahE1oj6DWbBMp+YEc76iteUbB8TKDGw6d8MFY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| GET | リソースを読み取る | はい | はい | はい |\n| POST | リソースを作成するか、データを処理するプロセスをトリガーする | いいえ | いいえ | レスポンスに新鮮さ情報が含まれる場合ははい |\n| PUT | リソースを作成または置き換える | はい | いいえ | いいえ |\n| PATCH | リソースを部分的に更新する | いいえ | いいえ | レスポンスに新鮮さ情報が含まれる場合ははい |\n| DELETE | リソースを削除する | はい | いいえ | いいえ |\n\n* 結果が変わらない場合、何度でも呼び出せます。\n\nHTTPは、**TCP**や**UDP**などの下位プロトコルに依存するアプリケーション層プロトコルです。\n\n#### 出典およびさらなる読み物: HTTP\n\n* [HTTPとは？](https://www.nginx.com/resources/glossary/http/)\n* [HTTPとTCPの違い](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)\n* [PUTとPATCHの違い](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)\n\n### トランスミッションコントロールプロトコル（TCP）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>出典：マルチプレイヤーゲームの作り方</a></i>\n</p>\n\nTCPは[IPネットワーク](https://ja.wikipedia.org/wiki/インターネットプロトコル)上のコネクション指向プロトコルです。接続は[ハンドシェイク](https://ja.wikipedia.org/wiki/ハンドシェイク)を使って確立および終了されます。送信されるすべてのパケットは、次の方法で元の順序で破損なく宛先に届くことが保証されます：\n\n* 各パケットに対するシーケンス番号と[チェックサムフィールド](https://ja.wikipedia.org/wiki/トランスミッション制御プロトコル#チェックサム計算)\n* [確認応答](https://ja.wikipedia.org/wiki/確認応答)パケットと自動再送信\n\n送信者が正しい応答を受け取らない場合、パケットを再送します。タイムアウトが複数回発生すると接続は切断されます。TCPはまた、[フロー制御](https://ja.wikipedia.org/wiki/フロー制御)と[輻輳制御](https://ja.wikipedia.org/wiki/ネットワーク輻輳#輻輳制御)も実装しています。これらの保証は遅延を引き起こし、一般的にUDPより効率の悪い伝送となります。\n\n高スループットを確保するために、ウェブサーバーは多数のTCP接続を開いたままにでき、その結果メモリ使用量が増加します。ウェブサーバースレッドと例えば[memcached](https://memcached.org/)サーバー間で多数の開いた接続を持つことはコストがかかります。[コネクションプーリング](https://ja.wikipedia.org/wiki/コネクションプーリング)は、適用可能な場合はUDPへの切り替えに加えて役立ちます。\n\nTCPは高い信頼性が必要で時間的制約が比較的少ないアプリケーションに有用です。例としてウェブサーバー、データベース情報、SMTP、FTP、SSHなどがあります。\n\nUDPよりTCPを使う場合：\n\n* すべてのデータが完全に届く必要がある場合\n* ネットワークスループットの最善推定を自動的に行いたい場合\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 45,
    "Content": "### User datagram protocol (UDP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>\n</p>\n\nUDP is connectionless.  Datagrams (analogous to packets) are guaranteed only at the datagram level.  Datagrams might reach their destination out of order or not at all.  UDP does not support congestion control.  Without the guarantees that TCP support, UDP is generally more efficient.\n\nUDP can broadcast, sending datagrams to all devices on the subnet.  This is useful with [DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) because the client has not yet received an IP address, thus preventing a way for TCP to stream without the IP address.\n\nUDP is less reliable but works well in real time use cases such as VoIP, video chat, streaming, and realtime multiplayer games.\n\nUse UDP over TCP when:\n\n* You need the lowest latency\n* Late data is worse than loss of data\n* You want to implement your own error correction\n\n#### Source(s) and further reading: TCP and UDP\n\n* [Networking for game programming](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)\n* [Key differences between TCP and UDP protocols](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)\n* [Difference between TCP and UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)\n* [Transmission control protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)\n* [User datagram protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)\n* [Scaling memcache at Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)\n\n### Remote procedure call (RPC)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png\">\n  <br/>\n  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Source: Crack the system design interview</a></i>\n</p>\n\nIn an RPC, a client causes a procedure to execute on a different address space, usually a remote server.  The procedure is coded as if it were a local procedure call, abstracting away the details of how to communicate with the server from the client program.  Remote calls are usually slower and less reliable than local calls so it is helpful to distinguish RPC calls from local calls.  Popular RPC frameworks include [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/), and [Avro](https://avro.apache.org/docs/current/).\n\nRPC is a request-response protocol:",
    "ContentSha": "qWH5LAPvggn7k7ivyK8v6v8/pTXkZRoURbzBFakhSEM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### ユーザーデータグラムプロトコル（UDP）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>出典: マルチプレイヤーゲームの作り方</a></i>\n</p>\n\nUDPはコネクションレスです。データグラム（パケットに類似）はデータグラムレベルでのみ保証されます。データグラムは順序が入れ替わって届くことや、全く届かないこともあります。UDPは輻輳制御をサポートしません。TCPがサポートする保証がないため、UDPは一般的により効率的です。\n\nUDPはブロードキャストが可能で、サブネット上の全デバイスにデータグラムを送信します。これはクライアントがまだIPアドレスを受け取っていないため、TCPがIPアドレスなしでストリームを送る方法を妨げる[DHCP](https://ja.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol)で有用です。\n\nUDPは信頼性は低いですが、VoIP、ビデオチャット、ストリーミング、リアルタイムマルチプレイヤーゲームなどのリアルタイム用途に適しています。\n\nUDPをTCPの代わりに使うのは以下の場合です：\n\n* 最低の遅延が必要なとき\n* 遅延したデータはデータ損失より悪いとき\n* 独自の誤り訂正を実装したいとき\n\n#### 出典およびさらなる読み物: TCPとUDP\n\n* [ゲームプログラミングのためのネットワーキング](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)\n* [TCPとUDPプロトコルの主な違い](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)\n* [TCPとUDPの違い](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)\n* [伝送制御プロトコル](https://ja.wikipedia.org/wiki/Transmission_Control_Protocol)\n* [ユーザーデータグラムプロトコル](https://ja.wikipedia.org/wiki/User_Datagram_Protocol)\n* [Facebookのmemcacheスケーリング](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)\n\n### リモートプロシージャコール（RPC）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png\">\n  <br/>\n  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>出典: システム設計面接を攻略する</a></i>\n</p>\n\nRPCでは、クライアントが通常リモートサーバーの異なるアドレス空間でプロシージャを実行させます。プロシージャはローカルプロシージャコールのようにコード化されており、クライアントプログラムからサーバーとの通信方法の詳細を抽象化しています。リモートコールは通常ローカルコールより遅く信頼性が低いため、RPCコールとローカルコールを区別することが有用です。代表的なRPCフレームワークには[Protobuf](https://developers.google.com/protocol-buffers/)、[Thrift](https://thrift.apache.org/)、[Avro](https://avro.apache.org/docs/current/)があります。\n\nRPCはリクエスト-レスポンスプロトコルです：",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 46,
    "Content": "\n* **Client program** - Calls the client stub procedure.  The parameters are pushed onto the stack like a local procedure call.\n* **Client stub procedure** - Marshals (packs) procedure id and arguments into a request message.\n* **Client communication module** - OS sends the message from the client to the server.\n* **Server communication module** - OS passes the incoming packets to the server stub procedure.\n* **Server stub procedure** -  Unmarshalls the results, calls the server procedure matching the procedure id and passes the given arguments.\n* The server response repeats the steps above in reverse order.\n\nSample RPC calls:\n",
    "ContentSha": "5PmI2LbQPBewUn/2iz277V+TkEFWqKJeqfFmrsij1fA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n* **クライアントプログラム** - クライアントスタブ手続きを呼び出します。パラメータはローカル手続き呼び出しのようにスタックにプッシュされます。\n* **クライアントスタブ手続き** - 手続きIDと引数をリクエストメッセージにマーシャリング（パック）します。\n* **クライアント通信モジュール** - OSがクライアントからサーバへメッセージを送信します。\n* **サーバ通信モジュール** - OSが受信パケットをサーバスタブ手続きに渡します。\n* **サーバスタブ手続き** - 結果をアンマーシャルし、手続きIDに対応するサーバ手続きを呼び出し、引数を渡します。\n* サーバの応答は上記の手順を逆順で繰り返します。\n\nサンプルRPC呼び出し:\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 47,
    "Content": "```\nGET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  \"data\":\"anId\";\n  \"anotherdata\": \"another value\"\n}\n```",
    "ContentSha": "BYLxUnd5OWhXrWTwm++n0cxi7AnIAvtoL/RnYPfjXXk=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nGET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  \"data\":\"anId\";\n  \"anotherdata\": \"another value\"\n}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 48,
    "Content": "\nRPC is focused on exposing behaviors.  RPCs are often used for performance reasons with internal communications, as you can hand-craft native calls to better fit your use cases.\n\nChoose a native library (aka SDK) when:\n\n* You know your target platform.\n* You want to control how your \"logic\" is accessed.\n* You want to control how error control happens off your library.\n* Performance and end user experience is your primary concern.\n\nHTTP APIs following **REST** tend to be used more often for public APIs.\n\n#### Disadvantage(s): RPC\n\n* RPC clients become tightly coupled to the service implementation.\n* A new API must be defined for every new operation or use case.\n* It can be difficult to debug RPC.\n* You might not be able to leverage existing technologies out of the box.  For example, it might require additional effort to ensure [RPC calls are properly cached](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) on caching servers such as [Squid](http://www.squid-cache.org/).\n\n### Representational state transfer (REST)\n\nREST is an architectural style enforcing a client/server model where the client acts on a set of resources managed by the server.  The server provides a representation of resources and actions that can either manipulate or get a new representation of resources.  All communication must be stateless and cacheable.\n\nThere are four qualities of a RESTful interface:\n\n* **Identify resources (URI in HTTP)** - use the same URI regardless of any operation.\n* **Change with representations (Verbs in HTTP)** - use verbs, headers, and body.\n* **Self-descriptive error message (status response in HTTP)** - Use status codes, don't reinvent the wheel.\n* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML interface for HTTP)** - your web service should be fully accessible in a browser.\n\nSample REST calls:\n",
    "ContentSha": "Rt/8zO9jLRQq0DxNqYrouOd/1z3QvXPXQYsN4u7rca0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "RPCは動作の公開に焦点を当てています。RPCは内部通信でパフォーマンス上の理由からよく使用されます。ネイティブ呼び出しを手作業で作成してユースケースにより適合させることができるためです。\n\nネイティブライブラリ（別名SDK）を選択する場合：\n\n* 対象プラットフォームが明確である。\n* 「ロジック」へのアクセス方法を制御したい。\n* ライブラリ外でのエラー制御の方法を制御したい。\n* パフォーマンスとエンドユーザーの体験が最優先である。\n\n**REST**に従ったHTTP APIは、より一般的に公開APIで使われる傾向があります。\n\n#### 欠点：RPC\n\n* RPCクライアントはサービス実装に強く結合される。\n* 新しい操作やユースケースごとに新しいAPIを定義する必要がある。\n* RPCのデバッグは困難な場合がある。\n* 既存の技術をすぐに活用できないかもしれない。例えば、[RPC呼び出しがキャッシュサーバー（例：[Squid](http://www.squid-cache.org/)）で正しくキャッシュされるようにする](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)には追加の労力が必要なことがある。\n\n### 表現状態転送（REST）\n\nRESTはクライアント/サーバーモデルを強制するアーキテクチャスタイルで、クライアントはサーバーが管理するリソースの集合に対して動作します。サーバーはリソースの表現と、リソースを操作したり新しい表現を取得したりするためのアクションを提供します。全ての通信はステートレスでキャッシュ可能でなければなりません。\n\nRESTfulインターフェースには4つの特徴があります：\n\n* **リソースの識別（HTTPのURI）** - 操作に関わらず同じURIを使用する。\n* **表現による変更（HTTPの動詞）** - 動詞、ヘッダー、ボディを使用する。\n* **自己記述的なエラーメッセージ（HTTPのステータス応答）** - ステータスコードを使い、再発明しない。\n* **[HATEOAS](http://restcookbook.com/Basics/hateoas/)（HTTPのHTMLインターフェース）** - ウェブサービスはブラウザで完全にアクセス可能であるべき。\n\nRESTのサンプル呼び出し：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 49,
    "Content": "```\nGET /someresources/anId\n\nPUT /someresources/anId\n{\"anotherdata\": \"another value\"}\n```",
    "ContentSha": "LfYrdSaJCXPWw5FeIGqODwCXjq6vLSYullHQ6dtLt9M=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nGET /someresources/anId\n\nPUT /someresources/anId\n{\"anotherdata\": \"another value\"}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 50,
    "Content": "\nREST is focused on exposing data.  It minimizes the coupling between client/server and is often used for public HTTP APIs.  REST uses a more generic and uniform method of exposing resources through URIs, [representation through headers](https://github.com/for-GET/know-your-http-well/blob/master/headers.md), and actions through verbs such as GET, POST, PUT, DELETE, and PATCH.  Being stateless, REST is great for horizontal scaling and partitioning.\n\n#### Disadvantage(s): REST\n\n* With REST being focused on exposing data, it might not be a good fit if resources are not naturally organized or accessed in a simple hierarchy.  For example, returning all updated records from the past hour matching a particular set of events is not easily expressed as a path.  With REST, it is likely to be implemented with a combination of URI path, query parameters, and possibly the request body.\n* REST typically relies on a few verbs (GET, POST, PUT, DELETE, and PATCH) which sometimes doesn't fit your use case.  For example, moving expired documents to the archive folder might not cleanly fit within these verbs.\n* Fetching complicated resources with nested hierarchies requires multiple round trips between the client and server to render single views, e.g. fetching content of a blog entry and the comments on that entry. For mobile applications operating in variable network conditions, these multiple roundtrips are highly undesirable.\n* Over time, more fields might be added to an API response and older clients will receive all new data fields, even those that they do not need, as a result, it bloats the payload size and leads to larger latencies.\n\n### RPC and REST calls comparison\n\n| Operation | RPC | REST |\n|---|---|---|\n| Signup    | **POST** /signup | **POST** /persons |\n| Resign    | **POST** /resign<br/>{<br/>\"personid\": \"1234\"<br/>} | **DELETE** /persons/1234 |\n| Read a person | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |\n| Read a person’s items list | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |\n| Add an item to a person’s items | **POST** /addItemToUsersItemsList<br/>{<br/>\"personid\": \"1234\";<br/>\"itemid\": \"456\"<br/>} | **POST** /persons/1234/items<br/>{<br/>\"itemid\": \"456\"<br/>} |\n| Update an item    | **POST** /modifyItem<br/>{<br/>\"itemid\": \"456\";<br/>\"key\": \"value\"<br/>} | **PUT** /items/456<br/>{<br/>\"key\": \"value\"<br/>} |\n| Delete an item | **POST** /removeItem<br/>{<br/>\"itemid\": \"456\"<br/>} | **DELETE** /items/456 |\n\n<p align=\"center\">\n  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Source: Do you really know why you prefer REST over RPC</a></i>\n</p>\n\n#### Source(s) and further reading: REST and RPC\n\n* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)\n* [When are RPC-ish approaches more appropriate than REST?](http://programmers.stackexchange.com/a/181186)\n* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)\n* [Debunking the myths of RPC and REST](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)\n* [What are the drawbacks of using REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)\n* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Thrift](https://code.facebook.com/posts/1468950976659943/)\n* [Why REST for internal use and not RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)\n\n## Security\n\nThis section could use some updates.  Consider [contributing](#contributing)!",
    "ContentSha": "SY9oRc1IgrKNdRZI1YEjzyytSRn6DjylmnfEWHK6KsU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "RESTはデータの公開に焦点を当てています。クライアント/サーバー間の結合度を最小限に抑え、公共のHTTP APIでよく使用されます。RESTはURIを通じてリソースをより一般的かつ均一な方法で公開し、[ヘッダーによる表現](https://github.com/for-GET/know-your-http-well/blob/master/headers.md)やGET、POST、PUT、DELETE、PATCHなどの動詞によるアクションを使用します。ステートレスであるため、RESTは水平スケーリングやパーティショニングに適しています。\n\n#### 欠点: REST\n\n* RESTはデータ公開に焦点を当てているため、リソースが自然に単純な階層構造で整理またはアクセスされない場合には適さないことがあります。例えば、過去1時間に特定のイベントに一致するすべての更新レコードを返すことは、パスとして簡単に表現できません。RESTでは、URIパス、クエリパラメータ、および場合によってはリクエストボディの組み合わせで実装される可能性が高いです。\n* RESTは通常、いくつかの動詞（GET、POST、PUT、DELETE、PATCH）に依存しますが、これらが必ずしもユースケースに合わないことがあります。例えば、期限切れのドキュメントをアーカイブフォルダに移動する処理は、これらの動詞のどれにもきれいに収まらないかもしれません。\n* 入れ子構造を持つ複雑なリソースを取得するには、クライアントとサーバー間で複数回の往復が必要となり、単一ビューのレンダリングに時間がかかります。例えば、ブログエントリの内容とそのエントリに対するコメントを取得する場合です。変動するネットワーク環境で動作するモバイルアプリケーションでは、これらの複数の往復は非常に望ましくありません。\n* 時間が経つにつれてAPIレスポンスにより多くのフィールドが追加されることがあり、古いクライアントは必要のない新しいデータフィールドもすべて受け取ってしまいます。その結果、ペイロードサイズが膨れ上がり、レイテンシが大きくなります。\n\n### RPCとREST呼び出しの比較\n\n| 操作 | RPC | REST |\n|---|---|---|\n| サインアップ | **POST** /signup | **POST** /persons |\n| 退会 | **POST** /resign<br/>{<br/>\"personid\": \"1234\"<br/>} | **DELETE** /persons/1234 |\n| 人物情報取得 | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |\n| 人物のアイテムリスト取得 | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |\n| 人物のアイテムに追加 | **POST** /addItemToUsersItemsList<br/>{<br/>\"personid\": \"1234\";<br/>\"itemid\": \"456\"<br/>} | **POST** /persons/1234/items<br/>{<br/>\"itemid\": \"456\"<br/>} |\n| アイテム更新 | **POST** /modifyItem<br/>{<br/>\"itemid\": \"456\";<br/>\"key\": \"value\"<br/>} | **PUT** /items/456<br/>{<br/>\"key\": \"value\"<br/>} |\n| アイテム削除 | **POST** /removeItem<br/>{<br/>\"itemid\": \"456\"<br/>} | **DELETE** /items/456 |\n\n<p align=\"center\">\n  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>出典: RESTをRPCより好む理由を本当に知っていますか</a></i>\n</p>\n\n#### 出典およびさらなる参考資料: RESTとRPC\n\n* [RESTをRPCより好む理由を本当に知っていますか](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)\n* [RPC的アプローチがRESTより適切な場合とは？](http://programmers.stackexchange.com/a/181186)\n* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)\n* [RPCとRESTの神話を覆す](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)\n* [RESTの欠点とは？](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)\n* [システム設計面接を攻略する](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Thrift](https://code.facebook.com/posts/1468950976659943/)\n* [なぜ内部利用にはRESTでRPCではないのか](http://arstechnica.com/civis/viewtopic.php?t=1190508)\n\n## セキュリティ\n\nこのセクションは更新が必要です。[貢献](#contributing)をご検討ください！\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 51,
    "Content": "\nSecurity is a broad topic.  Unless you have considerable experience, a security background, or are applying for a position that requires knowledge of security, you probably won't need to know more than the basics:\n\n* Encrypt in transit and at rest.\n* Sanitize all user inputs or any input parameters exposed to user to prevent [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) and [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* Use parameterized queries to prevent SQL injection.\n* Use the principle of [least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege).\n\n### Source(s) and further reading\n\n* [API security checklist](https://github.com/shieldfy/API-Security-Checklist)\n* [Security guide for developers](https://github.com/FallibleInc/security-guide-for-developers)\n* [OWASP top ten](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)\n\n## Appendix\n\nYou'll sometimes be asked to do 'back-of-the-envelope' estimates.  For example, you might need to determine how long it will take to generate 100 image thumbnails from disk or how much memory a data structure will take.  The **Powers of two table** and **Latency numbers every programmer should know** are handy references.\n\n### Powers of two table\n",
    "ContentSha": "lttd9OX13KgyFAZReRo/UiwT2DoGI4tHaEGVoAH3mCA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "セキュリティは広範なテーマです。 かなりの経験やセキュリティの背景があるか、セキュリティ知識が必要な職に応募していない限り、おそらく基本的なこと以上を知る必要はありません:\n\n* 転送中および保存時に暗号化する。\n* [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting)や[SQLインジェクション](https://en.wikipedia.org/wiki/SQL_injection)を防ぐために、すべてのユーザー入力やユーザーに公開されている入力パラメータをサニタイズする。\n* SQLインジェクションを防ぐためにパラメータ化クエリを使用する。\n* [最小特権の原則](https://en.wikipedia.org/wiki/Principle_of_least_privilege)を利用する。\n\n### 参考資料およびさらなる読み物\n\n* [APIセキュリティチェックリスト](https://github.com/shieldfy/API-Security-Checklist)\n* [開発者向けセキュリティガイド](https://github.com/FallibleInc/security-guide-for-developers)\n* [OWASPトップテン](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)\n\n## 付録\n\n時折「ざっとした」見積もりを求められることがあります。 例えば、ディスクから100枚の画像サムネイルを生成するのにどれくらい時間がかかるか、またはデータ構造がどれほどのメモリを必要とするかを見積もる場合です。 **2のべき乗表** と **すべてのプログラマーが知っておくべきレイテンシ数値** は便利な参考資料です。\n\n### 2のべき乗表\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 52,
    "Content": "```\nPower           Exact Value         Approx Value        Bytes\n---------------------------------------------------------------\n7                             128\n8                             256\n10                           1024   1 thousand           1 KB\n16                         65,536                       64 KB\n20                      1,048,576   1 million            1 MB\n30                  1,073,741,824   1 billion            1 GB\n32                  4,294,967,296                        4 GB\n40              1,099,511,627,776   1 trillion           1 TB\n```",
    "ContentSha": "tY3s4yO7vTGsjW+GZNlakuBkrCR3FXNKe9N9AYlzPrU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nPower           Exact Value         Approx Value        Bytes\n---------------------------------------------------------------\n7                             128\n8                             256\n10                           1024   1 thousand           1 KB\n16                         65,536                       64 KB\n20                      1,048,576   1 million            1 MB\n30                  1,073,741,824   1 billion            1 GB\n32                  4,294,967,296                        4 GB\n40              1,099,511,627,776   1 trillion           1 TB\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 53,
    "Content": "\n#### Source(s) and further reading\n\n* [Powers of two](https://en.wikipedia.org/wiki/Power_of_two)\n\n### Latency numbers every programmer should know\n",
    "ContentSha": "ppBLjl4GPpTTuZuZkRCmUB3lr0F/LbyDBiLBdXbuDDw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n#### 参照元およびさらなる読書資料\n\n* [2のべき乗](https://en.wikipedia.org/wiki/Power_of_two)\n\n### すべてのプログラマーが知っておくべきレイテンシーの数値\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 54,
    "Content": "```\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy            10,000   ns       10 us\nSend 1 KB bytes over 1 Gbps network     10,000   ns       10 us\nRead 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nHDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD\nRead 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns\n```",
    "ContentSha": "Cxjssj59JwVoJhpDLS31tIAyvakR0WQUIHZP4hMVLy8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy            10,000   ns       10 us\nSend 1 KB bytes over 1 Gbps network     10,000   ns       10 us\nRead 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nHDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD\nRead 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 55,
    "Content": "\nHandy metrics based on numbers above:\n\n* Read sequentially from HDD at 30 MB/s\n* Read sequentially from 1 Gbps Ethernet at 100 MB/s\n* Read sequentially from SSD at 1 GB/s\n* Read sequentially from main memory at 4 GB/s\n* 6-7 world-wide round trips per second\n* 2,000 round trips per second within a data center\n\n#### Latency numbers visualized\n\n![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)\n\n#### Source(s) and further reading\n\n* [Latency numbers every programmer should know - 1](https://gist.github.com/jboner/2841832)\n* [Latency numbers every programmer should know - 2](https://gist.github.com/hellerbarde/2843375)\n* [Designs, lessons, and advice from building large distributed systems](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)\n* [Software Engineering Advice from Building Large-Scale Distributed Systems](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)\n\n### Additional system design interview questions\n\n> Common system design interview questions, with links to resources on how to solve each.\n\n| Question | Reference(s) |\n|---|---|\n| Design a file sync service like Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| Design a search engine like Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |\n| Design a scalable web crawler like Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |\n| Design Google docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |\n| Design a key-value store like Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| Design a cache system like Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Design a recommendation system like Amazon's | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |\n| Design a tinyurl system like Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |\n| Design a chat app like WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)\n| Design a picture sharing system like Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |\n| Design the Facebook news feed function | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |\n| Design the Facebook timeline function | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |\n| Design the Facebook chat function | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |",
    "ContentSha": "ufMEAJjeJvG/71zGm1ZrFnYShGruhPDGcpEQX8jnGIY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "上記の数値に基づく便利な指標：\n\n* HDDからの順次読み取り速度は30 MB/s\n* 1 Gbpsイーサネットからの順次読み取り速度は100 MB/s\n* SSDからの順次読み取り速度は1 GB/s\n* メインメモリからの順次読み取り速度は4 GB/s\n* 世界中で6〜7回の往復通信が1秒間に可能\n* データセンター内では1秒間に2,000回の往復通信が可能\n\n#### レイテンシー数値の可視化\n\n![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)\n\n#### 出典およびさらなる参考資料\n\n* [Latency numbers every programmer should know - 1](https://gist.github.com/jboner/2841832)\n* [Latency numbers every programmer should know - 2](https://gist.github.com/hellerbarde/2843375)\n* [大規模分散システム構築からの設計・教訓・アドバイス](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)\n* [大規模分散システム構築からのソフトウェア工学アドバイス](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)\n\n### 追加のシステム設計面接質問\n\n> 一般的なシステム設計の面接質問と、それぞれの解決方法へのリンク集。\n\n| 質問 | 参考リンク |\n|---|---|\n| Dropboxのようなファイル同期サービスを設計せよ | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| Googleのような検索エンジンを設計せよ | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |\n| Googleのようなスケーラブルなウェブクローラーを設計せよ | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |\n| Googleドキュメントを設計せよ | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |\n| Redisのようなキー・バリューストアを設計せよ | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| Memcachedのようなキャッシュシステムを設計せよ | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Amazonのようなレコメンデーションシステムを設計せよ | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |\n| BitlyのようなTinyURLシステムを設計せよ | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |\n| WhatsAppのようなチャットアプリを設計せよ | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)\n| Instagramのような写真共有システムを設計せよ | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |\n| Facebookのニュースフィード機能を設計せよ | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |\n| Facebookのタイムライン機能を設計せよ | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |\n| Facebookのチャット機能を設計せよ | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 56,
    "Content": "| Design a graph search function like Facebook's | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |\n| Design a content delivery network like CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |\n| Design a trending topic system like Twitter's | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |\n| Design a random ID generation system | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |\n| Return the top k requests during a time interval | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |\n| Design a system that serves data from multiple data centers | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |\n| Design an online multiplayer card game | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |\n| Design a garbage collection system | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |\n| Design an API rate limiter | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |\n| Design a Stock Exchange (like NASDAQ or Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |\n| Add a system design question | [Contribute](#contributing) |\n\n### Real world architectures\n\n> Articles on how real world systems are designed.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Source: Twitter timelines at scale</a></i>\n</p>\n\n**Don't focus on nitty gritty details for the following articles, instead:**\n\n* Identify shared principles, common technologies, and patterns within these articles\n* Study what problems are solved by each component, where it works, where it doesn't\n* Review the lessons learned\n\n|Type | System | Reference(s) |\n|---|---|---|\n| Data processing | **MapReduce** - Distributed data processing from Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |\n| Data processing | **Spark** - Distributed data processing from Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |\n| Data processing | **Storm** - Distributed data processing from Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |\n| | | |\n| Data store | **Bigtable** - Distributed column-oriented database from Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |\n| Data store | **HBase** - Open source implementation of Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |\n| Data store | **Cassandra** - Distributed column-oriented database from Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)\n| Data store | **DynamoDB** - Document-oriented database from Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |\n| Data store | **MongoDB** - Document-oriented database | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |\n| Data store | **Spanner** - Globally-distributed database from Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |",
    "ContentSha": "5hNQndfbSnlP1RLa/GyRt8pzzHWJN34J9g6lOThi724=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| Facebookのようなグラフ検索機能を設計する | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |\n| CloudFlareのようなコンテンツ配信ネットワークを設計する | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |\n| Twitterのようなトレンドトピックシステムを設計する | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |\n| ランダムID生成システムを設計する | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |\n| 一定時間内のトップkリクエストを返す | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |\n| 複数のデータセンターからデータを提供するシステムを設計する | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |\n| オンラインマルチプレイヤーカードゲームを設計する | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |\n| ガベージコレクションシステムを設計する | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |\n| APIレートリミッターを設計する | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |\n| 株式取引所（NASDAQやBinanceのような）を設計する | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |\n| システム設計の質問を追加する | [Contribute](#contributing) |\n\n### 実世界のアーキテクチャ\n\n> 実際のシステムがどのように設計されているかに関する記事。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>出典: 大規模Twitterタイムライン</a></i>\n</p>\n\n**以下の記事では細かい詳細にこだわらず、代わりに：**\n\n* これらの記事に共通する原則、一般的な技術、パターンを特定する\n* 各コンポーネントが解決する問題、機能する箇所、機能しない箇所を学ぶ\n* 得られた教訓を振り返る\n\n|種類 | システム | 参照 |\n|---|---|---|\n| データ処理 | **MapReduce** - Googleの分散データ処理 | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |\n| データ処理 | **Spark** - Databricksの分散データ処理 | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |\n| データ処理 | **Storm** - Twitterの分散データ処理 | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |\n| | | |\n| データストア | **Bigtable** - Googleの分散カラム指向データベース | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |\n| データストア | **HBase** - Bigtableのオープンソース実装 | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |\n| データストア | **Cassandra** - Facebookの分散カラム指向データベース | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666) |\n| データストア | **DynamoDB** - Amazonのドキュメント指向データベース | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |\n| データストア | **MongoDB** - ドキュメント指向データベース | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |\n| データストア | **Spanner** - Googleのグローバル分散データベース | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 57,
    "Content": "| Data store | **Memcached** - Distributed memory caching system | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Data store | **Redis** - Distributed memory caching system with persistence and value types | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| | | |\n| File system | **Google File System (GFS)** - Distributed file system | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |\n| File system | **Hadoop File System (HDFS)** - Open source implementation of GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |\n| | | |\n| Misc | **Chubby** - Lock service for loosely-coupled distributed systems from Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |\n| Misc | **Dapper** - Distributed systems tracing infrastructure | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)\n| Misc | **Kafka** - Pub/sub message queue from LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |\n| Misc | **Zookeeper** - Centralized infrastructure and services enabling synchronization | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |\n| | Add an architecture | [Contribute](#contributing) |\n\n### Company architectures\n\n| Company | Reference(s) |\n|---|---|\n| Amazon | [Amazon architecture](http://highscalability.com/amazon-architecture) |\n| Cinchcast | [Producing 1,500 hours of audio every day](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |\n| DataSift | [Realtime datamining At 120,000 tweets per second](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |\n| Dropbox | [How we've scaled Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| ESPN | [Operating At 100,000 duh nuh nuhs per second](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |\n| Google | [Google architecture](http://highscalability.com/google-architecture) |\n| Instagram | [14 million users, terabytes of photos](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[What powers Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |\n| Justin.tv | [Justin.Tv's live video broadcasting architecture](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |\n| Facebook | [Scaling memcached at Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebook’s distributed data store for the social graph](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook’s photo storage](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[How Facebook Live Streams To 800,000 Simultaneous Viewers](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |\n| Flickr | [Flickr architecture](http://highscalability.com/flickr-architecture) |\n| Mailbox | [From 0 to one million users in 6 weeks](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |\n| Netflix | [A 360 Degree View Of The Entire Netflix Stack](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: What Happens When You Press Play?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |\n| Pinterest | [From 0 To 10s of billions of page views a month](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 million visitors, 10x growth, 12 employees](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |\n| Playfish | [50 million monthly users and growing](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |\n| PlentyOfFish | [PlentyOfFish architecture](http://highscalability.com/plentyoffish-architecture) |\n| Salesforce | [How they handle 1.3 billion transactions a day](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |\n| Stack Overflow | [Stack Overflow architecture](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |\n| TripAdvisor | [40M visitors, 200M dynamic page views, 30TB data](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |\n| Tumblr | [15 billion page views a month](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |\n| Twitter | [Making Twitter 10000 percent faster](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Storing 250 million tweets a day using MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M active users, 300K QPS, a 22 MB/S firehose](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Timelines at scale](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Big and small data at Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operations at Twitter: scaling beyond 100 million users](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[How Twitter Handles 3,000 Images Per Second](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |\n| Uber | [How Uber scales their real-time market platform](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lessons Learned From Scaling Uber To 2000 Engineers, 1000 Services, And 8000 Git Repositories](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |\n| WhatsApp | [The WhatsApp architecture Facebook bought for $19 billion](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| YouTube | [YouTube scalability](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube architecture](http://highscalability.com/youtube-architecture) |\n",
    "ContentSha": "HJ43cGa2ts5Z1+EHjvCRBV9mq+PjUY5QXfwqLIs80oA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| データストア | **Memcached** - 分散メモリキャッシュシステム | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| データストア | **Redis** - 永続性と値タイプを備えた分散メモリキャッシュシステム | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| | | |\n| ファイルシステム | **Google File System (GFS)** - 分散ファイルシステム | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |\n| ファイルシステム | **Hadoop File System (HDFS)** - GFSのオープンソース実装 | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |\n| | | |\n| その他 | **Chubby** - Googleの疎結合分散システム用ロックサービス | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |\n| その他 | **Dapper** - 分散システムのトレーシングインフラストラクチャ | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf) |\n| その他 | **Kafka** - LinkedInのPub/Subメッセージキュー | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |\n| その他 | **Zookeeper** - 同期を可能にする集中型インフラとサービス | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |\n| | アーキテクチャを追加 | [Contribute](#contributing) |\n\n### 企業アーキテクチャ\n\n| 企業 | 参照 |\n|---|---|\n| Amazon | [Amazonアーキテクチャ](http://highscalability.com/amazon-architecture) |\n| Cinchcast | [毎日1,500時間のオーディオ制作](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |\n| DataSift | [毎秒120,000ツイートのリアルタイムデータマイニング](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |\n| Dropbox | [Dropboxのスケーリング方法](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| ESPN | [毎秒100,000回の操作](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |\n| Google | [Googleアーキテクチャ](http://highscalability.com/google-architecture) |\n| Instagram | [1400万人のユーザー、テラバイトの写真](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Instagramの動力源](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |\n| Justin.tv | [Justin.Tvのライブビデオ放送アーキテクチャ](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |\n| Facebook | [Facebookでのmemcachedのスケーリング](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebookのソーシャルグラフ用分散データストア](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebookの写真ストレージ](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Facebookが80万人の同時視聴者にライブ配信する方法](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |\n| Flickr | [Flickrアーキテクチャ](http://highscalability.com/flickr-architecture) |\n| Mailbox | [6週間で0から100万人のユーザーへ](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |\n| Netflix | [Netflixスタックの360度ビュー](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix：再生ボタンを押すと何が起こるか](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |\n| Pinterest | [月間数百億ページビューへのスケーリング](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[1800万人の訪問者、10倍の成長、従業員12名](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |\n| Playfish | [月間5,000万人のユーザー数と成長](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |\n| PlentyOfFish | [PlentyOfFishアーキテクチャ](http://highscalability.com/plentyoffish-architecture) |\n| Salesforce | [1日13億件のトランザクションを処理する方法](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |\n| Stack Overflow | [Stack Overflowアーキテクチャ](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |\n| TripAdvisor | [4,000万人の訪問者、2億の動的ページビュー、30TBのデータ](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |\n| Tumblr | [月間150億ページビュー](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |\n| Twitter | [Twitterを1万倍高速化](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[MySQLで1日2.5億ツイートを保存](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[1億5,000万人のアクティブユーザー、30万QPS、22MB/sのファイアホース](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[大規模なタイムライン](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Twitterのビッグ＆スモールデータ](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Twitterの運用：1億ユーザー超のスケーリング](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[Twitterが毎秒3,000枚の画像を処理する方法](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |\n| Uber | [Uberのリアルタイムマーケットプラットフォームのスケーリング方法](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Uberのスケーリング教訓：2000エンジニア、1000サービス、8000 Gitリポジトリ](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |\n| WhatsApp | [Facebookが190億ドルで買収したWhatsAppのアーキテクチャ](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| YouTube | [YouTubeのスケーラビリティ](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTubeアーキテクチャ](http://highscalability.com/youtube-architecture) |\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 58,
    "Content": "### Company engineering blogs\n\n> Architectures for companies you are interviewing with.\n>\n> Questions you encounter might be from the same domain.\n\n* [Airbnb Engineering](http://nerds.airbnb.com/)\n* [Atlassian Developers](https://developer.atlassian.com/blog/)\n* [AWS Blog](https://aws.amazon.com/blogs/aws/)\n* [Bitly Engineering Blog](http://word.bitly.com/)\n* [Box Blogs](https://blog.box.com/blog/category/engineering)\n* [Cloudera Developer Blog](http://blog.cloudera.com/)\n* [Dropbox Tech Blog](https://tech.dropbox.com/)\n* [Engineering at Quora](https://www.quora.com/q/quoraengineering)\n* [Ebay Tech Blog](http://www.ebaytechblog.com/)\n* [Evernote Tech Blog](https://blog.evernote.com/tech/)\n* [Etsy Code as Craft](http://codeascraft.com/)\n* [Facebook Engineering](https://www.facebook.com/Engineering)\n* [Flickr Code](http://code.flickr.net/)\n* [Foursquare Engineering Blog](http://engineering.foursquare.com/)\n* [GitHub Engineering Blog](https://github.blog/category/engineering)\n* [Google Research Blog](http://googleresearch.blogspot.com/)\n* [Groupon Engineering Blog](https://engineering.groupon.com/)\n* [Heroku Engineering Blog](https://engineering.heroku.com/)\n* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)\n* [High Scalability](http://highscalability.com/)\n* [Instagram Engineering](http://instagram-engineering.tumblr.com/)\n* [Intel Software Blog](https://software.intel.com/en-us/blogs/)\n* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)\n* [LinkedIn Engineering](http://engineering.linkedin.com/blog)\n* [Microsoft Engineering](https://engineering.microsoft.com/)\n* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)\n* [Netflix Tech Blog](http://techblog.netflix.com/)\n* [Paypal Developer Blog](https://medium.com/paypal-engineering)\n* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)\n* [Reddit Blog](http://www.redditblog.com/)\n* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)\n* [Slack Engineering Blog](https://slack.engineering/)\n* [Spotify Labs](https://labs.spotify.com/)\n* [Stripe Engineering Blog](https://stripe.com/blog/engineering)",
    "ContentSha": "K2HaPjFBuIAolMM1jFJHWyWd16kC4a7w+PNnWCMvsfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 企業のエンジニアリングブログ\n\n> 面接を受ける企業のアーキテクチャ。\n>\n> 出題される質問は同じドメインから来ることがあります。\n\n* [Airbnb エンジニアリング](http://nerds.airbnb.com/)\n* [Atlassian デベロッパー](https://developer.atlassian.com/blog/)\n* [AWS ブログ](https://aws.amazon.com/blogs/aws/)\n* [Bitly エンジニアリングブログ](http://word.bitly.com/)\n* [Box ブログ](https://blog.box.com/blog/category/engineering)\n* [Cloudera デベロッパーブログ](http://blog.cloudera.com/)\n* [Dropbox テックブログ](https://tech.dropbox.com/)\n* [Quora のエンジニアリング](https://www.quora.com/q/quoraengineering)\n* [Ebay テックブログ](http://www.ebaytechblog.com/)\n* [Evernote テックブログ](https://blog.evernote.com/tech/)\n* [Etsy Code as Craft](http://codeascraft.com/)\n* [Facebook エンジニアリング](https://www.facebook.com/Engineering)\n* [Flickr Code](http://code.flickr.net/)\n* [Foursquare エンジニアリングブログ](http://engineering.foursquare.com/)\n* [GitHub エンジニアリングブログ](https://github.blog/category/engineering)\n* [Google リサーチブログ](http://googleresearch.blogspot.com/)\n* [Groupon エンジニアリングブログ](https://engineering.groupon.com/)\n* [Heroku エンジニアリングブログ](https://engineering.heroku.com/)\n* [Hubspot エンジニアリングブログ](http://product.hubspot.com/blog/topic/engineering)\n* [High Scalability](http://highscalability.com/)\n* [Instagram エンジニアリング](http://instagram-engineering.tumblr.com/)\n* [Intel ソフトウェアブログ](https://software.intel.com/en-us/blogs/)\n* [Jane Street テックブログ](https://blogs.janestreet.com/category/ocaml/)\n* [LinkedIn エンジニアリング](http://engineering.linkedin.com/blog)\n* [Microsoft エンジニアリング](https://engineering.microsoft.com/)\n* [Microsoft Python エンジニアリング](https://blogs.msdn.microsoft.com/pythonengineering/)\n* [Netflix テックブログ](http://techblog.netflix.com/)\n* [Paypal デベロッパーブログ](https://medium.com/paypal-engineering)\n* [Pinterest エンジニアリングブログ](https://medium.com/@Pinterest_Engineering)\n* [Reddit ブログ](http://www.redditblog.com/)\n* [Salesforce エンジニアリングブログ](https://developer.salesforce.com/blogs/engineering/)\n* [Slack エンジニアリングブログ](https://slack.engineering/)\n* [Spotify ラボ](https://labs.spotify.com/)\n* [Stripe エンジニアリングブログ](https://stripe.com/blog/engineering)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 59,
    "Content": "* [Twilio Engineering Blog](http://www.twilio.com/engineering)\n* [Twitter Engineering](https://blog.twitter.com/engineering/)\n* [Uber Engineering Blog](http://eng.uber.com/)\n* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)\n* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)\n* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)\n\n#### Source(s) and further reading\n\nLooking to add a blog?  To avoid duplicating work, consider adding your company blog to the following repo:\n\n* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)\n\n## Under development\n\nInterested in adding a section or helping complete one in-progress?  [Contribute](#contributing)!\n\n* Distributed computing with MapReduce\n* Consistent hashing\n* Scatter gather\n* [Contribute](#contributing)\n\n## Credits\n\nCredits and sources are provided throughout this repo.\n\nSpecial thanks to:\n\n* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)\n* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)\n* [High scalability](http://highscalability.com/)\n* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)\n* [shashank88/system_design](https://github.com/shashank88/system_design)\n* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)\n* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)\n* [A distributed systems reading list](http://dancres.github.io/Pages/)\n* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n\n## Contact info\n",
    "ContentSha": "Ybn7ZSN9UGUEPKyqpiStfZWdM+FBaEvnQtoViA95ahg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Twilio エンジニアリングブログ](http://www.twilio.com/engineering)\n* [Twitter エンジニアリング](https://blog.twitter.com/engineering/)\n* [Uber エンジニアリングブログ](http://eng.uber.com/)\n* [Yahoo エンジニアリングブログ](http://yahooeng.tumblr.com/)\n* [Yelp エンジニアリングブログ](http://engineeringblog.yelp.com/)\n* [Zynga エンジニアリングブログ](https://www.zynga.com/blogs/engineering)\n\n#### 出典およびさらなる参考資料\n\nブログを追加したいですか？ 重複作業を避けるために、以下のリポジトリにあなたの会社のブログを追加することを検討してください：\n\n* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)\n\n## 開発中\n\nセクションを追加したり、進行中のものを完成させるのを手伝いたいですか？ [貢献する](#contributing)！\n\n* MapReduceを用いた分散コンピューティング\n* 一貫性のあるハッシュ\n* スキャッター・ギャザー\n* [貢献する](#contributing)\n\n## クレジット\n\nクレジットと出典はこのリポジトリ全体にわたって提供されています。\n\n特別な感謝：\n\n* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)\n* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)\n* [High scalability](http://highscalability.com/)\n* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)\n* [shashank88/system_design](https://github.com/shashank88/system_design)\n* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)\n* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)\n* [A distributed systems reading list](http://dancres.github.io/Pages/)\n* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n\n## 連絡先情報\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 60,
    "Content": "Feel free to contact me to discuss any issues, questions, or comments.\n\nMy contact info can be found on my [GitHub page](https://github.com/donnemartin).\n\n## License\n\n*I am providing code and resources in this repository to you under an open source license.  Because this is my personal repository, the license you receive to my code and resources is from me and not my employer (Facebook).*\n\n    Copyright 2017 Donne Martin\n\n    Creative Commons Attribution 4.0 International License (CC BY 4.0)\n\n    http://creativecommons.org/licenses/by/4.0/\n",
    "ContentSha": "pZfW5OoDeEHMjsOQIbYzifgEtKuSRxAcRTUdmpdKaBQ=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "ご質問やご意見、ご不明な点がございましたら、お気軽にご連絡ください。\n\n私の連絡先情報は[GitHubページ](https://github.com/donnemartin)に記載されています。\n\n## ライセンス\n\n*このリポジトリのコードおよびリソースはオープンソースライセンスのもとで提供しています。これは私個人のリポジトリであるため、コードおよびリソースに対するライセンスは私から直接提供されており、私の勤務先（Facebook）からではありません。*\n\n    著作権 2017 Donne Martin\n\n    クリエイティブ・コモンズ 表示 4.0 国際 ライセンス (CC BY 4.0)\n\n    http://creativecommons.org/licenses/by/4.0/\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  }
]