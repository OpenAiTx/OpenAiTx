[
  {
    "Id": 1,
    "Content": "*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*",
    "ContentSha": "NV5If+n4caPL9367nN6NPHEHX2NVMyxh97QjgslLVk8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "\n**Help [translate](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) this guide!**\n\n# The System Design Primer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png\">\n  <br/>\n</p>\n\n## Motivation\n\n> Learn how to design large-scale systems.\n>\n> Prep for the system design interview.\n\n### Learn how to design large-scale systems\n\nLearning how to design scalable systems will help you become a better engineer.\n\nSystem design is a broad topic.  There is a **vast amount of resources scattered throughout the web** on system design principles.\n\nThis repo is an **organized collection** of resources to help you learn how to build systems at scale.\n\n### Learn from the open source community\n\nThis is a continually updated, open source project.\n\n[Contributions](#contributing) are welcome!\n\n### Prep for the system design interview\n\nIn addition to coding interviews, system design is a **required component** of the **technical interview process** at many tech companies.\n\n**Practice common system design interview questions** and **compare** your results with **sample solutions**: discussions, code, and diagrams.\n\nAdditional topics for interview prep:\n\n* [Study guide](#study-guide)\n* [How to approach a system design interview question](#how-to-approach-a-system-design-interview-question)",
    "ContentSha": "AbJTT6alKgUjtCBRmG+Q5nAyd3D1OmTONWi5hXEC4sI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**이 가이드를 [번역](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md)하는 데 도움을 주세요!**\n\n# 시스템 설계 기초\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png\">\n  <br/>\n</p>\n\n## 동기\n\n> 대규모 시스템을 설계하는 방법을 배우세요.\n>\n> 시스템 설계 인터뷰 준비.\n\n### 대규모 시스템 설계 방법 배우기\n\n확장 가능한 시스템 설계 방법을 배우면 더 나은 엔지니어가 될 수 있습니다.\n\n시스템 설계는 광범위한 주제입니다. 시스템 설계 원칙에 관한 **방대한 양의 자료가 웹 곳곳에 흩어져 있습니다**.\n\n이 저장소는 대규모 시스템 구축 방법을 배우는 데 도움이 되는 **체계적으로 정리된 자료 모음**입니다.\n\n### 오픈 소스 커뮤니티에서 배우기\n\n이 프로젝트는 지속적으로 업데이트되는 오픈 소스 프로젝트입니다.\n\n[기여](#contributing)를 환영합니다!\n\n### 시스템 설계 인터뷰 준비\n\n코딩 인터뷰 외에도 시스템 설계는 많은 기술 회사의 **기술 인터뷰 과정**에서 **필수 구성 요소**입니다.\n\n**일반적인 시스템 설계 인터뷰 질문을 연습**하고 **토론, 코드, 다이어그램**으로 구성된 **샘플 솔루션과 비교**하세요.\n\n인터뷰 준비를 위한 추가 주제:\n\n* [학습 가이드](#study-guide)\n* [시스템 설계 인터뷰 질문 접근 방법](#how-to-approach-a-system-design-interview-question)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 3,
    "Content": "* [System design interview questions, **with solutions**](#system-design-interview-questions-with-solutions)\n* [Object-oriented design interview questions, **with solutions**](#object-oriented-design-interview-questions-with-solutions)\n* [Additional system design interview questions](#additional-system-design-interview-questions)\n\n## Anki flashcards\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png\">\n  <br/>\n</p>\n\nThe provided [Anki flashcard decks](https://apps.ankiweb.net/) use spaced repetition to help you retain key system design concepts.\n\n* [System design deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)\n* [System design exercises deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)\n* [Object oriented design exercises deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)\n\nGreat for use while on-the-go.\n\n### Coding Resource: Interactive Coding Challenges\n\nLooking for resources to help you prep for the [**Coding Interview**](https://github.com/donnemartin/interactive-coding-challenges)?\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png\">\n  <br/>\n</p>\n\nCheck out the sister repo [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges), which contains an additional Anki deck:\n\n* [Coding deck](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)\n\n## Contributing\n\n> Learn from the community.\n\nFeel free to submit pull requests to help:\n\n* Fix errors\n* Improve sections",
    "ContentSha": "SXl/9sXgfkMzgSqqZA/bJ68vMrerBbNpRqT5TMAq1Hg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [시스템 설계 인터뷰 질문, **해답 포함**](#system-design-interview-questions-with-solutions)\n* [객체지향 설계 인터뷰 질문, **해답 포함**](#object-oriented-design-interview-questions-with-solutions)\n* [추가 시스템 설계 인터뷰 질문](#additional-system-design-interview-questions)\n\n## Anki 플래시카드\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png\">\n  <br/>\n</p>\n\n제공된 [Anki 플래시카드 덱](https://apps.ankiweb.net/)은 간격 반복법을 이용해 핵심 시스템 설계 개념을 기억하는 데 도움을 줍니다.\n\n* [시스템 설계 덱](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)\n* [시스템 설계 연습 덱](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)\n* [객체지향 설계 연습 덱](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)\n\n외출 중에도 사용하기 좋습니다.\n\n### 코딩 자료: 인터랙티브 코딩 챌린지\n\n[**코딩 인터뷰**](https://github.com/donnemartin/interactive-coding-challenges) 준비에 도움이 될 자료를 찾고 있나요?\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png\">\n  <br/>\n</p>\n\n자매 저장소 [**인터랙티브 코딩 챌린지**](https://github.com/donnemartin/interactive-coding-challenges)에서 추가 Anki 덱을 확인해 보세요:\n\n* [코딩 덱](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)\n\n## 기여하기\n\n> 커뮤니티로부터 배우세요.\n\n다음 사항에 기여할 수 있는 풀 리퀘스트를 자유롭게 제출하세요:\n\n* 오류 수정\n* 섹션 개선",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 4,
    "Content": "* Add new sections\n* [Translate](https://github.com/donnemartin/system-design-primer/issues/28)\n\nContent that needs some polishing is placed [under development](#under-development).\n\nReview the [Contributing Guidelines](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).\n\n## Index of system design topics\n\n> Summaries of various system design topics, including pros and cons.  **Everything is a trade-off**.\n>\n> Each section contains links to more in-depth resources.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png\">\n  <br/>\n</p>\n\n* [System design topics: start here](#system-design-topics-start-here)\n    * [Step 1: Review the scalability video lecture](#step-1-review-the-scalability-video-lecture)\n    * [Step 2: Review the scalability article](#step-2-review-the-scalability-article)\n    * [Next steps](#next-steps)\n* [Performance vs scalability](#performance-vs-scalability)\n* [Latency vs throughput](#latency-vs-throughput)\n* [Availability vs consistency](#availability-vs-consistency)\n    * [CAP theorem](#cap-theorem)\n        * [CP - consistency and partition tolerance](#cp---consistency-and-partition-tolerance)\n        * [AP - availability and partition tolerance](#ap---availability-and-partition-tolerance)\n* [Consistency patterns](#consistency-patterns)\n    * [Weak consistency](#weak-consistency)\n    * [Eventual consistency](#eventual-consistency)\n    * [Strong consistency](#strong-consistency)\n* [Availability patterns](#availability-patterns)\n    * [Fail-over](#fail-over)\n    * [Replication](#replication)\n    * [Availability in numbers](#availability-in-numbers)\n* [Domain name system](#domain-name-system)\n* [Content delivery network](#content-delivery-network)\n    * [Push CDNs](#push-cdns)\n    * [Pull CDNs](#pull-cdns)",
    "ContentSha": "55nlChjOgBlS9Rz8E9JfxCDdOyXcovuwIdqXYGb4sqo=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 새 섹션 추가\n* [번역하기](https://github.com/donnemartin/system-design-primer/issues/28)\n\n수정이 필요한 내용은 [개발 중](#under-development)에 있습니다.\n\n[기여 지침](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md)을 검토하세요.\n\n## 시스템 설계 주제 색인\n\n> 장단점을 포함한 다양한 시스템 설계 주제 요약입니다. **모든 것은 트레이드오프입니다**.\n>\n> 각 섹션에는 더 심도 있는 자료로 연결되는 링크가 포함되어 있습니다.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png\">\n  <br/>\n</p>\n\n* [시스템 설계 주제: 여기서 시작하세요](#system-design-topics-start-here)\n    * [1단계: 확장성 비디오 강의 검토](#step-1-review-the-scalability-video-lecture)\n    * [2단계: 확장성 기사 검토](#step-2-review-the-scalability-article)\n    * [다음 단계](#next-steps)\n* [성능 대 확장성](#performance-vs-scalability)\n* [지연 시간 대 처리량](#latency-vs-throughput)\n* [가용성 대 일관성](#availability-vs-consistency)\n    * [CAP 정리](#cap-theorem)\n        * [CP - 일관성과 분할 허용](#cp---consistency-and-partition-tolerance)\n        * [AP - 가용성과 분할 허용](#ap---availability-and-partition-tolerance)\n* [일관성 패턴](#consistency-patterns)\n    * [약한 일관성](#weak-consistency)\n    * [최종 일관성](#eventual-consistency)\n    * [강한 일관성](#strong-consistency)\n* [가용성 패턴](#availability-patterns)\n    * [장애 조치](#fail-over)\n    * [복제](#replication)\n    * [숫자로 보는 가용성](#availability-in-numbers)\n* [도메인 이름 시스템](#domain-name-system)\n* [콘텐츠 전송 네트워크](#content-delivery-network)\n    * [푸시 CDN](#push-cdns)\n    * [풀 CDN](#pull-cdns)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 5,
    "Content": "* [Load balancer](#load-balancer)\n    * [Active-passive](#active-passive)\n    * [Active-active](#active-active)\n    * [Layer 4 load balancing](#layer-4-load-balancing)\n    * [Layer 7 load balancing](#layer-7-load-balancing)\n    * [Horizontal scaling](#horizontal-scaling)\n* [Reverse proxy (web server)](#reverse-proxy-web-server)\n    * [Load balancer vs reverse proxy](#load-balancer-vs-reverse-proxy)\n* [Application layer](#application-layer)\n    * [Microservices](#microservices)\n    * [Service discovery](#service-discovery)\n* [Database](#database)\n    * [Relational database management system (RDBMS)](#relational-database-management-system-rdbms)\n        * [Master-slave replication](#master-slave-replication)\n        * [Master-master replication](#master-master-replication)\n        * [Federation](#federation)\n        * [Sharding](#sharding)\n        * [Denormalization](#denormalization)\n        * [SQL tuning](#sql-tuning)\n    * [NoSQL](#nosql)\n        * [Key-value store](#key-value-store)\n        * [Document store](#document-store)\n        * [Wide column store](#wide-column-store)\n        * [Graph Database](#graph-database)\n    * [SQL or NoSQL](#sql-or-nosql)\n* [Cache](#cache)\n    * [Client caching](#client-caching)\n    * [CDN caching](#cdn-caching)\n    * [Web server caching](#web-server-caching)\n    * [Database caching](#database-caching)\n    * [Application caching](#application-caching)\n    * [Caching at the database query level](#caching-at-the-database-query-level)\n    * [Caching at the object level](#caching-at-the-object-level)\n    * [When to update the cache](#when-to-update-the-cache)\n        * [Cache-aside](#cache-aside)\n        * [Write-through](#write-through)\n        * [Write-behind (write-back)](#write-behind-write-back)\n        * [Refresh-ahead](#refresh-ahead)\n* [Asynchronism](#asynchronism)\n    * [Message queues](#message-queues)",
    "ContentSha": "asKFjZ3AfCGQPD58skhfkEeJZEI9zP/H+h/3PnvCFDY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [로드 밸런서](#load-balancer)\n    * [액티브-패시브](#active-passive)\n    * [액티브-액티브](#active-active)\n    * [레이어 4 로드 밸런싱](#layer-4-load-balancing)\n    * [레이어 7 로드 밸런싱](#layer-7-load-balancing)\n    * [수평 확장](#horizontal-scaling)\n* [리버스 프록시 (웹 서버)](#reverse-proxy-web-server)\n    * [로드 밸런서 vs 리버스 프록시](#load-balancer-vs-reverse-proxy)\n* [애플리케이션 계층](#application-layer)\n    * [마이크로서비스](#microservices)\n    * [서비스 디스커버리](#service-discovery)\n* [데이터베이스](#database)\n    * [관계형 데이터베이스 관리 시스템 (RDBMS)](#relational-database-management-system-rdbms)\n        * [마스터-슬레이브 복제](#master-slave-replication)\n        * [마스터-마스터 복제](#master-master-replication)\n        * [페더레이션](#federation)\n        * [샤딩](#sharding)\n        * [비정규화](#denormalization)\n        * [SQL 튜닝](#sql-tuning)\n    * [NoSQL](#nosql)\n        * [키-값 저장소](#key-value-store)\n        * [문서 저장소](#document-store)\n        * [와이드 컬럼 저장소](#wide-column-store)\n        * [그래프 데이터베이스](#graph-database)\n    * [SQL 또는 NoSQL](#sql-or-nosql)\n* [캐시](#cache)\n    * [클라이언트 캐싱](#client-caching)\n    * [CDN 캐싱](#cdn-caching)\n    * [웹 서버 캐싱](#web-server-caching)\n    * [데이터베이스 캐싱](#database-caching)\n    * [애플리케이션 캐싱](#application-caching)\n    * [데이터베이스 쿼리 레벨에서의 캐싱](#caching-at-the-database-query-level)\n    * [객체 레벨에서의 캐싱](#caching-at-the-object-level)\n    * [캐시 업데이트 시기](#when-to-update-the-cache)\n        * [캐시-어사이드](#cache-aside)\n        * [쓰기-스루](#write-through)\n        * [쓰기-비하인드 (쓰기-백)](#write-behind-write-back)\n        * [리프레시-어헤드](#refresh-ahead)\n* [비동기 처리](#asynchronism)\n    * [메시지 큐](#message-queues)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 6,
    "Content": "    * [Task queues](#task-queues)\n    * [Back pressure](#back-pressure)\n* [Communication](#communication)\n    * [Transmission control protocol (TCP)](#transmission-control-protocol-tcp)\n    * [User datagram protocol (UDP)](#user-datagram-protocol-udp)\n    * [Remote procedure call (RPC)](#remote-procedure-call-rpc)\n    * [Representational state transfer (REST)](#representational-state-transfer-rest)\n* [Security](#security)\n* [Appendix](#appendix)\n    * [Powers of two table](#powers-of-two-table)\n    * [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)\n    * [Additional system design interview questions](#additional-system-design-interview-questions)\n    * [Real world architectures](#real-world-architectures)\n    * [Company architectures](#company-architectures)\n    * [Company engineering blogs](#company-engineering-blogs)\n* [Under development](#under-development)\n* [Credits](#credits)\n* [Contact info](#contact-info)\n* [License](#license)\n\n## Study guide\n\n> Suggested topics to review based on your interview timeline (short, medium, long).\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)\n\n**Q: For interviews, do I need to know everything here?**\n\n**A: No, you don't need to know everything here to prepare for the interview**.\n\nWhat you are asked in an interview depends on variables such as:\n\n* How much experience you have\n* What your technical background is\n* What positions you are interviewing for\n* Which companies you are interviewing with\n* Luck\n\nMore experienced candidates are generally expected to know more about system design.  Architects or team leads might be expected to know more than individual contributors.  Top tech companies are likely to have one or more design interview rounds.\n",
    "ContentSha": "ATTNyUBhYGX23A6dK9YO6hNcpGiZGZByeStHZczOceg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "    * [작업 큐](#task-queues)\n    * [백프레셔](#back-pressure)\n* [통신](#communication)\n    * [전송 제어 프로토콜 (TCP)](#transmission-control-protocol-tcp)\n    * [사용자 데이터그램 프로토콜 (UDP)](#user-datagram-protocol-udp)\n    * [원격 프로시저 호출 (RPC)](#remote-procedure-call-rpc)\n    * [표현 상태 전송 (REST)](#representational-state-transfer-rest)\n* [보안](#security)\n* [부록](#appendix)\n    * [2의 거듭제곱 표](#powers-of-two-table)\n    * [모든 프로그래머가 알아야 할 지연 시간 숫자](#latency-numbers-every-programmer-should-know)\n    * [추가 시스템 설계 인터뷰 질문](#additional-system-design-interview-questions)\n    * [실제 아키텍처](#real-world-architectures)\n    * [회사 아키텍처](#company-architectures)\n    * [회사 엔지니어링 블로그](#company-engineering-blogs)\n* [개발 중](#under-development)\n* [크레딧](#credits)\n* [연락처 정보](#contact-info)\n* [라이선스](#license)\n\n## 학습 가이드\n\n> 인터뷰 일정(단기, 중기, 장기)을 기준으로 검토할 추천 주제입니다.\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)\n\n**Q: 인터뷰를 위해 여기 있는 모든 내용을 알아야 하나요?**\n\n**A: 아니요, 인터뷰 준비를 위해 여기 있는 모든 내용을 알 필요는 없습니다**.\n\n인터뷰에서 질문받는 내용은 다음과 같은 변수에 따라 달라집니다:\n\n* 경력 수준\n* 기술 배경\n* 지원하는 직무\n* 인터뷰하는 회사\n* 운\n\n경험이 많은 지원자는 일반적으로 시스템 설계에 대해 더 많이 알고 있을 것으로 기대됩니다. 아키텍트나 팀 리드는 개인 기여자보다 더 많이 알고 있어야 할 수도 있습니다. 주요 기술 회사는 하나 이상의 설계 인터뷰 라운드를 진행할 가능성이 높습니다.\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 7,
    "Content": "Start broad and go deeper in a few areas.  It helps to know a little about various key system design topics.  Adjust the following guide based on your timeline, experience, what positions you are interviewing for, and which companies you are interviewing with.\n\n* **Short timeline** - Aim for **breadth** with system design topics.  Practice by solving **some** interview questions.\n* **Medium timeline** - Aim for **breadth** and **some depth** with system design topics.  Practice by solving **many** interview questions.\n* **Long timeline** - Aim for **breadth** and **more depth** with system design topics.  Practice by solving **most** interview questions.\n\n| | Short | Medium | Long |\n|---|---|---|---|\n| Read through the [System design topics](#index-of-system-design-topics) to get a broad understanding of how systems work | :+1: | :+1: | :+1: |\n| Read through a few articles in the [Company engineering blogs](#company-engineering-blogs) for the companies you are interviewing with | :+1: | :+1: | :+1: |\n| Read through a few [Real world architectures](#real-world-architectures) | :+1: | :+1: | :+1: |\n| Review [How to approach a system design interview question](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |\n| Work through [System design interview questions with solutions](#system-design-interview-questions-with-solutions) | Some | Many | Most |\n| Work through [Object-oriented design interview questions with solutions](#object-oriented-design-interview-questions-with-solutions) | Some | Many | Most |\n| Review [Additional system design interview questions](#additional-system-design-interview-questions) | Some | Many | Most |\n\n## How to approach a system design interview question\n\n> How to tackle a system design interview question.\n\nThe system design interview is an **open-ended conversation**.  You are expected to lead it.\n\nYou can use the following steps to guide the discussion.  To help solidify this process, work through the [System design interview questions with solutions](#system-design-interview-questions-with-solutions) section using the following steps.\n\n### Step 1: Outline use cases, constraints, and assumptions\n\nGather requirements and scope the problem.  Ask questions to clarify use cases and constraints.  Discuss assumptions.\n\n* Who is going to use it?\n* How are they going to use it?\n* How many users are there?\n* What does the system do?\n* What are the inputs and outputs of the system?\n* How much data do we expect to handle?\n* How many requests per second do we expect?\n* What is the expected read to write ratio?\n\n### Step 2: Create a high level design\n\nOutline a high level design with all important components.",
    "ContentSha": "0rdWLVZbH/nPM3xkHGejRJHpsR4f8urb5LkuDcPAbZM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "넓게 시작해서 몇몇 영역에서 깊게 들어가세요. 다양한 핵심 시스템 설계 주제에 대해 조금 아는 것이 도움이 됩니다. 일정, 경험, 지원하는 포지션, 면접 보는 회사에 따라 다음 가이드를 조정하세요.\n\n* **짧은 일정** - 시스템 설계 주제의 **폭넓은 이해**를 목표로 하세요. **몇 개의** 면접 질문을 풀면서 연습하세요.\n* **중간 일정** - 시스템 설계 주제의 **폭넓은 이해와 일부 깊이**를 목표로 하세요. **많은** 면접 질문을 풀면서 연습하세요.\n* **긴 일정** - 시스템 설계 주제의 **폭넓은 이해와 더 깊은 이해**를 목표로 하세요. **대부분의** 면접 질문을 풀면서 연습하세요.\n\n| | 짧음 | 중간 | 김 |\n|---|---|---|---|\n| [시스템 설계 주제](#index-of-system-design-topics)를 읽고 시스템 작동 방식에 대한 폭넓은 이해 얻기 | :+1: | :+1: | :+1: |\n| 면접 보는 회사의 [회사 엔지니어링 블로그](#company-engineering-blogs)에서 몇 개의 글 읽기 | :+1: | :+1: | :+1: |\n| [실제 아키텍처](#real-world-architectures) 몇 개 읽기 | :+1: | :+1: | :+1: |\n| [시스템 설계 면접 질문 접근법](#how-to-approach-a-system-design-interview-question) 검토하기 | :+1: | :+1: | :+1: |\n| [시스템 설계 면접 질문과 해답](#system-design-interview-questions-with-solutions) 풀기 | 일부 | 다수 | 대부분 |\n| [객체지향 설계 면접 질문과 해답](#object-oriented-design-interview-questions-with-solutions) 풀기 | 일부 | 다수 | 대부분 |\n| [추가 시스템 설계 면접 질문](#additional-system-design-interview-questions) 검토하기 | 일부 | 다수 | 대부분 |\n\n## 시스템 설계 면접 질문에 접근하는 방법\n\n> 시스템 설계 면접 질문을 해결하는 방법.\n\n시스템 설계 면접은 **개방형 대화**입니다. 당신이 주도해야 합니다.\n\n다음 단계를 사용해 토론을 이끌 수 있습니다. 이 과정을 확실히 익히려면, [시스템 설계 면접 질문과 해답](#system-design-interview-questions-with-solutions) 섹션을 다음 단계를 따라 풀어보세요.\n\n### 1단계: 사용 사례, 제약 조건, 가정 개요 작성\n\n요구 사항을 수집하고 문제 범위를 설정하세요. 사용 사례와 제약 조건을 명확히 하기 위해 질문하세요. 가정을 논의하세요.\n\n* 누가 사용할 것인가?\n* 어떻게 사용할 것인가?\n* 사용자 수는 얼마인가?\n* 시스템이 하는 일은 무엇인가?\n* 시스템의 입력과 출력은 무엇인가?\n* 처리할 데이터 양은 얼마나 예상하는가?\n* 초당 요청 수는 얼마나 예상하는가?\n* 예상 읽기 대 쓰기 비율은 얼마인가?\n\n### 2단계: 상위 수준 설계 작성\n\n모든 주요 구성 요소를 포함한 상위 수준 설계 개요를 작성하세요.",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 8,
    "Content": "\n* Sketch the main components and connections\n* Justify your ideas\n\n### Step 3: Design core components\n\nDive into details for each core component.  For example, if you were asked to [design a url shortening service](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), discuss:\n\n* Generating and storing a hash of the full url\n    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) and [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n    * Hash collisions\n    * SQL or NoSQL\n    * Database schema\n* Translating a hashed url to the full url\n    * Database lookup\n* API and object-oriented design\n\n### Step 4: Scale the design\n\nIdentify and address bottlenecks, given the constraints.  For example, do you need the following to address scalability issues?\n\n* Load balancer\n* Horizontal scaling\n* Caching\n* Database sharding\n\nDiscuss potential solutions and trade-offs.  Everything is a trade-off.  Address bottlenecks using [principles of scalable system design](#index-of-system-design-topics).\n\n### Back-of-the-envelope calculations\n\nYou might be asked to do some estimates by hand.  Refer to the [Appendix](#appendix) for the following resources:\n\n* [Use back of the envelope calculations](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)\n* [Powers of two table](#powers-of-two-table)\n* [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)\n\n### Source(s) and further reading\n\nCheck out the following links to get a better idea of what to expect:\n",
    "ContentSha": "3x8iTXwR6ek+uAlSMupV1OgJsT8IwtVYxDBvXMFsB/g=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 주요 구성 요소 및 연결 스케치  \n* 아이디어에 대한 근거 제시  \n\n### 3단계: 핵심 구성 요소 설계  \n\n각 핵심 구성 요소에 대해 자세히 살펴보세요. 예를 들어, [URL 단축 서비스 설계](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)를 요청받았다면 다음을 논의하세요:  \n\n* 전체 URL의 해시 생성 및 저장  \n    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) 및 [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)  \n    * 해시 충돌  \n    * SQL 또는 NoSQL  \n    * 데이터베이스 스키마  \n* 해시된 URL을 전체 URL로 변환  \n    * 데이터베이스 조회  \n* API 및 객체 지향 설계  \n\n### 4단계: 설계 확장  \n\n제약 조건을 고려하여 병목 현상을 식별하고 해결하세요. 예를 들어, 확장성 문제를 해결하기 위해 다음이 필요한가요?  \n\n* 로드 밸런서  \n* 수평 확장  \n* 캐싱  \n* 데이터베이스 샤딩  \n\n잠재적 솔루션과 트레이드오프를 논의하세요. 모든 것은 트레이드오프입니다. [확장 가능한 시스템 설계 원칙](#index-of-system-design-topics)을 활용해 병목 현상을 해결하세요.  \n\n### 대략적 계산  \n\n손으로 일부 추정을 하라는 요청을 받을 수 있습니다. 다음 리소스를 참조하세요:  \n\n* [대략적 계산 활용](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)  \n* [2의 거듭제곱 표](#powers-of-two-table)  \n* [모든 프로그래머가 알아야 할 지연 시간 수치](#latency-numbers-every-programmer-should-know)  \n\n### 출처 및 추가 자료  \n\n다음 링크들을 확인하여 무엇을 기대할 수 있는지 더 잘 이해하세요:\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 9,
    "Content": "* [How to ace a systems design interview](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)\n* [The system design interview](http://www.hiredintech.com/system-design)\n* [Intro to Architecture and Systems Design Interviews](https://www.youtube.com/watch?v=ZgdS0EUmn70)\n* [System design template](https://leetcode.com/discuss/career/229177/My-System-Design-Template)\n\n## System design interview questions with solutions\n\n> Common system design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n| Question | |\n|---|---|\n| Design Pastebin.com (or Bit.ly) | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |\n| Design the Twitter timeline and search (or Facebook feed and search) | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |\n| Design a web crawler | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |\n| Design Mint.com | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |\n| Design the data structures for a social network | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |\n| Design a key-value store for a search engine | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |\n| Design Amazon's sales ranking by category feature | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |\n| Design a system that scales to millions of users on AWS | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |\n| Add a system design question | [Contribute](#contributing) |\n\n### Design Pastebin.com (or Bit.ly)\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)\n\n### Design the Twitter timeline and search (or Facebook feed and search)\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)\n\n### Design a web crawler\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)",
    "ContentSha": "AHgKOfvgyoP47Euk86jhd2olVjkmP2nZB6tXbpOIqic=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [시스템 설계 인터뷰를 성공적으로 치르는 방법](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)\n* [시스템 설계 인터뷰](http://www.hiredintech.com/system-design)\n* [아키텍처 및 시스템 설계 인터뷰 소개](https://www.youtube.com/watch?v=ZgdS0EUmn70)\n* [시스템 설계 템플릿](https://leetcode.com/discuss/career/229177/My-System-Design-Template)\n\n## 솔루션이 포함된 시스템 설계 인터뷰 질문\n\n> 일반적인 시스템 설계 인터뷰 질문과 예시 토론, 코드, 다이어그램.\n>\n> 솔루션은 `solutions/` 폴더 내의 내용과 연결되어 있습니다.\n\n| 질문 | |\n|---|---|\n| Pastebin.com (또는 Bit.ly) 설계하기 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |\n| 트위터 타임라인 및 검색 설계하기 (또는 페이스북 피드 및 검색) | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |\n| 웹 크롤러 설계하기 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |\n| Mint.com 설계하기 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |\n| 소셜 네트워크용 데이터 구조 설계하기 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |\n| 검색 엔진용 키-값 저장소 설계하기 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |\n| 아마존 카테고리별 판매 순위 기능 설계하기 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |\n| AWS에서 수백만 사용자로 확장 가능한 시스템 설계하기 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |\n| 시스템 설계 질문 추가하기 | [기여하기](#contributing) |\n\n### Pastebin.com (또는 Bit.ly) 설계하기\n\n[연습문제 및 솔루션 보기](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)\n\n### 트위터 타임라인 및 검색 설계하기 (또는 페이스북 피드 및 검색)\n\n[연습문제 및 솔루션 보기](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)\n\n### 웹 크롤러 설계하기\n\n[연습문제 및 솔루션 보기](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 10,
    "Content": "\n### Design Mint.com\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)\n\n### Design the data structures for a social network\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)\n\n### Design a key-value store for a search engine\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)\n\n### Design Amazon's sales ranking by category feature\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)\n\n### Design a system that scales to millions of users on AWS\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)\n\n## Object-oriented design interview questions with solutions\n\n> Common object-oriented design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n>**Note: This section is under development**\n\n| Question | |",
    "ContentSha": "o3sbdfQZN6cWPJee4lAmThiTo/ED2IUg9UbWh2T8Jr8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### Design Mint.com\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)\n\n### Design the data structures for a social network\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)\n\n### Design a key-value store for a search engine\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)\n\n### Design Amazon's sales ranking by category feature\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)\n\n### Design a system that scales to millions of users on AWS\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)\n\n## Object-oriented design interview questions with solutions\n\n> Common object-oriented design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n>**Note: This section is under development**\n\n| Question | |",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 11,
    "Content": "|---|---|\n| Design a hash map | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |\n| Design a least recently used cache | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |\n| Design a call center | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |\n| Design a deck of cards | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |\n| Design a parking lot | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |\n| Design a chat server | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |\n| Design a circular array | [Contribute](#contributing)  |\n| Add an object-oriented design question | [Contribute](#contributing) |\n\n## System design topics: start here\n\nNew to system design?\n\nFirst, you'll need a basic understanding of common principles, learning about what they are, how they are used, and their pros and cons.\n\n### Step 1: Review the scalability video lecture\n\n[Scalability Lecture at Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)\n\n* Topics covered:\n    * Vertical scaling\n    * Horizontal scaling\n    * Caching\n    * Load balancing\n    * Database replication\n    * Database partitioning\n\n### Step 2: Review the scalability article\n\n[Scalability](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)\n\n* Topics covered:\n    * [Clones](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n    * [Databases](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n    * [Caches](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n    * [Asynchronism](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)\n\n### Next steps\n",
    "ContentSha": "x8nrhrohPoZjm2NWw4mmB3mvJSUCp+CF0oOOqij1Y4E=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "|---|---|\n| 해시 맵 설계 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |\n| 최근에 가장 적게 사용된 캐시 설계 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |\n| 콜 센터 설계 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |\n| 카드 덱 설계 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |\n| 주차장 설계 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |\n| 채팅 서버 설계 | [솔루션](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |\n| 원형 배열 설계 | [기여하기](#contributing)  |\n| 객체지향 설계 질문 추가 | [기여하기](#contributing) |\n\n## 시스템 설계 주제: 여기서 시작하세요\n\n시스템 설계가 처음인가요?\n\n먼저, 일반적인 원리에 대한 기본 이해가 필요합니다. 그것들이 무엇인지, 어떻게 사용되는지, 그리고 장단점에 대해 배우세요.\n\n### 1단계: 확장성 비디오 강의 검토\n\n[하버드 확장성 강의](https://www.youtube.com/watch?v=-W9F__D3oY4)\n\n* 다루는 주제:\n    * 수직 확장\n    * 수평 확장\n    * 캐싱\n    * 부하 분산\n    * 데이터베이스 복제\n    * 데이터베이스 파티셔닝\n\n### 2단계: 확장성 기사 검토\n\n[확장성](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)\n\n* 다루는 주제:\n    * [클론](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n    * [데이터베이스](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n    * [캐시](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n    * [비동기성](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)\n\n### 다음 단계\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 12,
    "Content": "Next, we'll look at high-level trade-offs:\n\n* **Performance** vs **scalability**\n* **Latency** vs **throughput**\n* **Availability** vs **consistency**\n\nKeep in mind that **everything is a trade-off**.\n\nThen we'll dive into more specific topics such as DNS, CDNs, and load balancers.\n\n## Performance vs scalability\n\nA service is **scalable** if it results in increased **performance** in a manner proportional to resources added. Generally, increasing performance means serving more units of work, but it can also be to handle larger units of work, such as when datasets grow.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>\n\nAnother way to look at performance vs scalability:\n\n* If you have a **performance** problem, your system is slow for a single user.\n* If you have a **scalability** problem, your system is fast for a single user but slow under heavy load.\n\n### Source(s) and further reading\n\n* [A word on scalability](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n\n## Latency vs throughput\n\n**Latency** is the time to perform some action or to produce some result.\n\n**Throughput** is the number of such actions or results per unit of time.\n\nGenerally, you should aim for **maximal throughput** with **acceptable latency**.\n\n### Source(s) and further reading\n\n* [Understanding latency vs throughput](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)\n\n## Availability vs consistency\n\n### CAP theorem\n",
    "ContentSha": "3J96fMtAPtZfNniAS7/6wzXl1ty5ntM4Q00EOxpO0Ww=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "다음으로 고수준의 트레이드오프를 살펴보겠습니다:\n\n* **성능** 대 **확장성**\n* **지연 시간** 대 **처리량**\n* **가용성** 대 **일관성**\n\n모든 것은 **트레이드오프**라는 점을 명심하세요.\n\n그 다음에는 DNS, CDN, 로드 밸런서와 같은 더 구체적인 주제로 들어가겠습니다.\n\n## 성능 대 확장성\n\n서비스가 추가된 자원에 비례하여 **성능**이 증가한다면 그 서비스는 **확장 가능**하다고 합니다. 일반적으로 성능 증가란 더 많은 작업 단위를 처리하는 것을 의미하지만, 데이터셋이 커질 때처럼 더 큰 작업 단위를 처리하는 것도 포함됩니다.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>\n\n성능과 확장성을 바라보는 또 다른 관점:\n\n* **성능** 문제가 있다면, 단일 사용자에 대해 시스템이 느립니다.\n* **확장성** 문제가 있다면, 단일 사용자에 대해서는 시스템이 빠르지만, 부하가 많을 때 느립니다.\n\n### 출처 및 추가 읽기 자료\n\n* [확장성에 관한 한마디](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)\n* [확장성, 가용성, 안정성, 패턴](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n\n## 지연 시간 대 처리량\n\n**지연 시간**은 어떤 작업을 수행하거나 결과를 생성하는 데 걸리는 시간입니다.\n\n**처리량**은 단위 시간당 그러한 작업이나 결과의 수입니다.\n\n일반적으로 **허용 가능한 지연 시간**을 유지하면서 **최대 처리량**을 목표로 해야 합니다.\n\n### 출처 및 추가 읽기 자료\n\n* [지연 시간 대 처리량 이해하기](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)\n\n## 가용성 대 일관성\n\n### CAP 정리\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 13,
    "Content": "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png\">\n  <br/>\n  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Source: CAP theorem revisited</a></i>\n</p>\n\nIn a distributed computer system, you can only support two of the following guarantees:\n\n* **Consistency** - Every read receives the most recent write or an error\n* **Availability** - Every request receives a response, without guarantee that it contains the most recent version of the information\n* **Partition Tolerance** - The system continues to operate despite arbitrary partitioning due to network failures\n\n*Networks aren't reliable, so you'll need to support partition tolerance.  You'll need to make a software tradeoff between consistency and availability.*\n\n#### CP - consistency and partition tolerance\n\nWaiting for a response from the partitioned node might result in a timeout error.  CP is a good choice if your business needs require atomic reads and writes.\n\n#### AP - availability and partition tolerance\n\nResponses return the most readily available version of the data available on any node, which might not be the latest.  Writes might take some time to propagate when the partition is resolved.\n\nAP is a good choice if the business needs to allow for [eventual consistency](#eventual-consistency) or when the system needs to continue working despite external errors.\n\n### Source(s) and further reading\n\n* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)\n* [A plain english introduction to CAP theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem)\n* [CAP FAQ](https://github.com/henryr/cap-faq)\n* [The CAP theorem](https://www.youtube.com/watch?v=k-Yaq8AHlFA)\n\n## Consistency patterns\n\nWith multiple copies of the same data, we are faced with options on how to synchronize them so clients have a consistent view of the data.  Recall the definition of consistency from the [CAP theorem](#cap-theorem) - Every read receives the most recent write or an error.\n\n### Weak consistency\n\nAfter a write, reads may or may not see it.  A best effort approach is taken.\n\nThis approach is seen in systems such as memcached.  Weak consistency works well in real time use cases such as VoIP, video chat, and realtime multiplayer games.  For example, if you are on a phone call and lose reception for a few seconds, when you regain connection you do not hear what was spoken during connection loss.",
    "ContentSha": "nlNKM8AB14RiMLs0dLLz8tVwgOHTXV/u3ObIx3G8az4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png\">\n  <br/>\n  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>출처: CAP 정리 재검토</a></i>\n</p>\n\n분산 컴퓨터 시스템에서는 다음 보장 중 두 가지만 지원할 수 있습니다:\n\n* **일관성 (Consistency)** - 모든 읽기 요청이 가장 최근의 쓰기 작업을 받거나 오류를 반환함\n* **가용성 (Availability)** - 모든 요청이 응답을 받지만, 최신 버전의 정보를 포함한다는 보장은 없음\n* **분할 허용성 (Partition Tolerance)** - 네트워크 장애로 인한 임의의 분할에도 시스템이 계속 작동함\n\n*네트워크는 신뢰할 수 없으므로 분할 허용성을 지원해야 합니다. 일관성과 가용성 사이에서 소프트웨어 트레이드오프가 필요합니다.*\n\n#### CP - 일관성과 분할 허용성\n\n분할된 노드로부터 응답을 기다리면 타임아웃 오류가 발생할 수 있습니다. CP는 비즈니스 요구가 원자적 읽기와 쓰기를 필요로 할 때 좋은 선택입니다.\n\n#### AP - 가용성과 분할 허용성\n\n응답은 가장 쉽게 사용할 수 있는 노드의 데이터 버전을 반환하며, 최신 버전이 아닐 수 있습니다. 분할이 해제되면 쓰기가 전파되는 데 시간이 걸릴 수 있습니다.\n\nAP는 비즈니스가 [최종 일관성](#eventual-consistency)을 허용해야 하거나 시스템이 외부 오류에도 계속 작동해야 할 때 좋은 선택입니다.\n\n### 출처 및 추가 자료\n\n* [CAP 정리 재검토](http://robertgreiner.com/2014/08/cap-theorem-revisited/)\n* [CAP 정리에 대한 쉬운 영어 소개](http://ksat.me/a-plain-english-introduction-to-cap-theorem)\n* [CAP FAQ](https://github.com/henryr/cap-faq)\n* [CAP 정리](https://www.youtube.com/watch?v=k-Yaq8AHlFA)\n\n## 일관성 패턴\n\n같은 데이터의 여러 복사본이 있을 때, 클라이언트가 데이터에 대해 일관된 뷰를 갖도록 동기화하는 방법을 선택해야 합니다. [CAP 정리](#cap-theorem)에서 정의한 일관성은 모든 읽기가 가장 최근의 쓰기 작업을 받거나 오류를 반환하는 것을 의미합니다.\n\n### 약한 일관성\n\n쓰기 후 읽기가 해당 쓰기를 볼 수도 있고 보지 못할 수도 있습니다. 최선의 노력 방식이 사용됩니다.\n\n이 방식은 memcached와 같은 시스템에서 볼 수 있습니다. 약한 일관성은 VoIP, 비디오 채팅, 실시간 멀티플레이어 게임과 같은 실시간 사용 사례에 적합합니다. 예를 들어, 전화 통화 중 몇 초간 수신이 끊기면 연결이 복구되었을 때 그 사이에 오간 대화는 들리지 않습니다.",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 14,
    "Content": "\n### Eventual consistency\n\nAfter a write, reads will eventually see it (typically within milliseconds).  Data is replicated asynchronously.\n\nThis approach is seen in systems such as DNS and email.  Eventual consistency works well in highly available systems.\n\n### Strong consistency\n\nAfter a write, reads will see it.  Data is replicated synchronously.\n\nThis approach is seen in file systems and RDBMSes.  Strong consistency works well in systems that need transactions.\n\n### Source(s) and further reading\n\n* [Transactions across data centers](http://snarfed.org/transactions_across_datacenters_io.html)\n\n## Availability patterns\n\nThere are two complementary patterns to support high availability: **fail-over** and **replication**.\n\n### Fail-over\n\n#### Active-passive\n\nWith active-passive fail-over, heartbeats are sent between the active and the passive server on standby.  If the heartbeat is interrupted, the passive server takes over the active's IP address and resumes service.\n\nThe length of downtime is determined by whether the passive server is already running in 'hot' standby or whether it needs to start up from 'cold' standby.  Only the active server handles traffic.\n\nActive-passive failover can also be referred to as master-slave failover.\n\n#### Active-active\n\nIn active-active, both servers are managing traffic, spreading the load between them.\n\nIf the servers are public-facing, the DNS would need to know about the public IPs of both servers.  If the servers are internal-facing, application logic would need to know about both servers.\n\nActive-active failover can also be referred to as master-master failover.\n\n### Disadvantage(s): failover",
    "ContentSha": "Gej6bybZnoGj5vLH+IOLm2NuKTHBE7Z2TA3eWaBaiak=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 최종 일관성\n\n쓰기 작업 후, 읽기는 결국 이를 보게 됩니다(일반적으로 밀리초 내에). 데이터는 비동기적으로 복제됩니다.\n\n이 접근 방식은 DNS 및 이메일과 같은 시스템에서 볼 수 있습니다. 최종 일관성은 고가용성 시스템에서 잘 작동합니다.\n\n### 강력한 일관성\n\n쓰기 작업 후, 읽기는 이를 즉시 보게 됩니다. 데이터는 동기적으로 복제됩니다.\n\n이 접근 방식은 파일 시스템 및 RDBMS에서 볼 수 있습니다. 강력한 일관성은 트랜잭션이 필요한 시스템에서 잘 작동합니다.\n\n### 출처 및 추가 읽을거리\n\n* [데이터 센터 간 트랜잭션](http://snarfed.org/transactions_across_datacenters_io.html)\n\n## 가용성 패턴\n\n고가용성을 지원하는 두 가지 상호 보완적인 패턴이 있습니다: **페일오버**와 **복제**.\n\n### 페일오버\n\n#### 액티브-패시브\n\n액티브-패시브 페일오버에서는, 활성 서버와 대기 중인 수동 서버 간에 하트비트가 전송됩니다. 하트비트가 끊기면, 수동 서버가 활성 서버의 IP 주소를 인계받아 서비스를 재개합니다.\n\n다운타임 길이는 수동 서버가 이미 '핫' 대기 상태인지 아니면 '콜드' 대기 상태에서 시작해야 하는지에 따라 결정됩니다. 오직 활성 서버만 트래픽을 처리합니다.\n\n액티브-패시브 페일오버는 마스터-슬레이브 페일오버라고도 불릴 수 있습니다.\n\n#### 액티브-액티브\n\n액티브-액티브에서는 두 서버가 모두 트래픽을 관리하며 부하를 분산합니다.\n\n서버가 공개용이라면, DNS는 두 서버의 공용 IP를 알아야 합니다. 서버가 내부용이라면, 애플리케이션 로직이 두 서버를 알아야 합니다.\n\n액티브-액티브 페일오버는 마스터-마스터 페일오버라고도 불릴 수 있습니다.\n\n### 단점: 페일오버\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 15,
    "Content": "\n* Fail-over adds more hardware and additional complexity.\n* There is a potential for loss of data if the active system fails before any newly written data can be replicated to the passive.\n\n### Replication\n\n#### Master-slave and master-master\n\nThis topic is further discussed in the [Database](#database) section:\n\n* [Master-slave replication](#master-slave-replication)\n* [Master-master replication](#master-master-replication)\n\n### Availability in numbers\n\nAvailability is often quantified by uptime (or downtime) as a percentage of time the service is available.  Availability is generally measured in number of 9s--a service with 99.99% availability is described as having four 9s.\n\n#### 99.9% availability - three 9s\n\n| Duration            | Acceptable downtime|\n|---------------------|--------------------|\n| Downtime per year   | 8h 45min 57s       |\n| Downtime per month  | 43m 49.7s          |\n| Downtime per week   | 10m 4.8s           |\n| Downtime per day    | 1m 26.4s           |\n\n#### 99.99% availability - four 9s\n\n| Duration            | Acceptable downtime|\n|---------------------|--------------------|\n| Downtime per year   | 52min 35.7s        |\n| Downtime per month  | 4m 23s             |\n| Downtime per week   | 1m 5s              |\n| Downtime per day    | 8.6s               |\n\n#### Availability in parallel vs in sequence\n\nIf a service consists of multiple components prone to failure, the service's overall availability depends on whether the components are in sequence or in parallel.\n\n###### In sequence",
    "ContentSha": "7iHIUIb6fJkzxQcIKEVyv2l5jzfrJATtAgzkxfBD6fg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 장애 조치(fail-over)는 더 많은 하드웨어와 추가적인 복잡성을 더한다.\n* 활성 시스템이 새로 작성된 데이터를 수동 시스템으로 복제하기 전에 실패할 경우 데이터 손실 가능성이 있다.\n\n### 복제\n\n#### 마스터-슬레이브와 마스터-마스터\n\n이 주제는 [데이터베이스](#database) 섹션에서 더 자세히 다룬다:\n\n* [마스터-슬레이브 복제](#master-slave-replication)\n* [마스터-마스터 복제](#master-master-replication)\n\n### 가용성 수치\n\n가용성은 서비스가 사용 가능한 시간의 백분율로 가동 시간(또는 다운타임)으로 자주 정량화된다. 가용성은 일반적으로 9의 개수로 측정되며, 99.99% 가용성은 네 개의 9를 가진 것으로 표현된다.\n\n#### 99.9% 가용성 - 세 개의 9\n\n| 기간               | 허용 가능한 다운타임  |\n|--------------------|---------------------|\n| 연간 다운타임      | 8시간 45분 57초      |\n| 월간 다운타임      | 43분 49.7초          |\n| 주간 다운타임      | 10분 4.8초           |\n| 일간 다운타임      | 1분 26.4초           |\n\n#### 99.99% 가용성 - 네 개의 9\n\n| 기간               | 허용 가능한 다운타임  |\n|--------------------|---------------------|\n| 연간 다운타임      | 52분 35.7초          |\n| 월간 다운타임      | 4분 23초             |\n| 주간 다운타임      | 1분 5초              |\n| 일간 다운타임      | 8.6초                |\n\n#### 병렬 가용성 대 순차 가용성\n\n서비스가 고장에 취약한 여러 구성 요소로 이루어져 있다면, 서비스의 전체 가용성은 구성 요소들이 순차적(sequence)인지 병렬(parallel)인지에 따라 달라진다.\n\n###### 순차적 구성\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 16,
    "Content": "\nOverall availability decreases when two components with availability < 100% are in sequence:\n",
    "ContentSha": "MoWr3NjGedfagwyU1j0TqrIfLCsOUBLZEeMCD+o/O+Q=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "전체 가용성은 가용성이 100% 미만인 두 구성 요소가 순차적으로 연결될 때 감소합니다:\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 17,
    "Content": "```\nAvailability (Total) = Availability (Foo) * Availability (Bar)\n```",
    "ContentSha": "lB9bEqLhXuNZd7e3CBBSvV+eKTVRfJQnqnxct5vKoDI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nAvailability (Total) = Availability (Foo) * Availability (Bar)\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 18,
    "Content": "\nIf both `Foo` and `Bar` each had 99.9% availability, their total availability in sequence would be 99.8%.\n\n###### In parallel\n\nOverall availability increases when two components with availability < 100% are in parallel:\n",
    "ContentSha": "8idS6k4SI9XJ+uNRuiFmAXUVaamdekOMo2MnsD7SUdw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n만약 `Foo`와 `Bar`가 각각 99.9%의 가용성을 가진다면, 순차적으로 연결되었을 때 전체 가용성은 99.8%가 됩니다.\n\n###### 병렬로\n\n두 개의 가용성이 100% 미만인 구성 요소가 병렬로 연결되면 전체 가용성이 증가합니다:\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 19,
    "Content": "```\nAvailability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))\n```",
    "ContentSha": "MYI40NgkLqO1BQo3TOiX+3Zu0VfgykdTCZcU4oJjKTs=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nAvailability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 20,
    "Content": "\nIf both `Foo` and `Bar` each had 99.9% availability, their total availability in parallel would be 99.9999%.\n\n## Domain name system\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg\">\n  <br/>\n  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Source: DNS security presentation</a></i>\n</p>\n\nA Domain Name System (DNS) translates a domain name such as www.example.com to an IP address.\n\nDNS is hierarchical, with a few authoritative servers at the top level.  Your router or ISP provides information about which DNS server(s) to contact when doing a lookup.  Lower level DNS servers cache mappings, which could become stale due to DNS propagation delays.  DNS results can also be cached by your browser or OS for a certain period of time, determined by the [time to live (TTL)](https://en.wikipedia.org/wiki/Time_to_live).\n\n* **NS record (name server)** - Specifies the DNS servers for your domain/subdomain.\n* **MX record (mail exchange)** - Specifies the mail servers for accepting messages.\n* **A record (address)** - Points a name to an IP address.\n* **CNAME (canonical)** - Points a name to another name or `CNAME` (example.com to www.example.com) or to an `A` record.\n\nServices such as [CloudFlare](https://www.cloudflare.com/dns/) and [Route 53](https://aws.amazon.com/route53/) provide managed DNS services.  Some DNS services can route traffic through various methods:\n\n* [Weighted round robin](https://www.jscape.com/blog/load-balancing-algorithms)\n    * Prevent traffic from going to servers under maintenance\n    * Balance between varying cluster sizes\n    * A/B testing\n* [Latency-based](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)\n* [Geolocation-based](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)\n\n### Disadvantage(s): DNS\n\n* Accessing a DNS server introduces a slight delay, although mitigated by caching described above.\n* DNS server management could be complex and is generally managed by [governments, ISPs, and large companies](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).\n* DNS services have recently come under [DDoS attack](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), preventing users from accessing websites such as Twitter without knowing Twitter's IP address(es).\n\n### Source(s) and further reading\n\n* [DNS architecture](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)\n* [Wikipedia](https://en.wikipedia.org/wiki/Domain_Name_System)\n* [DNS articles](https://support.dnsimple.com/categories/dns/)",
    "ContentSha": "YhlbRAwaKJI7wcegCHvNOzGIOxkIHtEHSr0a7L+iJEc=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n만약 `Foo`와 `Bar`가 각각 99.9% 가용성을 가진다면, 병렬로 연결된 전체 가용성은 99.9999%가 됩니다.\n\n## 도메인 이름 시스템\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg\">\n  <br/>\n  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>출처: DNS 보안 프레젠테이션</a></i>\n</p>\n\n도메인 이름 시스템(DNS)은 www.example.com과 같은 도메인 이름을 IP 주소로 변환합니다.\n\nDNS는 계층적 구조이며, 최상위에는 몇 개의 권위 있는 서버가 있습니다. 라우터나 ISP는 조회 시 어떤 DNS 서버에 접속할지 정보를 제공합니다. 하위 DNS 서버들은 매핑 정보를 캐시하는데, 이는 DNS 전파 지연으로 인해 오래될 수 있습니다. DNS 결과는 브라우저나 OS에 의해 일정 기간 동안 캐시될 수 있으며, 이 기간은 [TTL(수명, time to live)](https://en.wikipedia.org/wiki/Time_to_live)에 의해 결정됩니다.\n\n* **NS 레코드 (네임 서버)** - 도메인/서브도메인에 대한 DNS 서버를 지정합니다.\n* **MX 레코드 (메일 교환)** - 메시지를 수신할 메일 서버를 지정합니다.\n* **A 레코드 (주소)** - 이름을 IP 주소에 연결합니다.\n* **CNAME (정식 이름)** - 이름을 다른 이름이나 `CNAME` (예: example.com을 www.example.com으로) 또는 `A` 레코드에 연결합니다.\n\n[CloudFlare](https://www.cloudflare.com/dns/)와 [Route 53](https://aws.amazon.com/route53/)과 같은 서비스는 관리형 DNS 서비스를 제공합니다. 일부 DNS 서비스는 다양한 방법으로 트래픽을 라우팅할 수 있습니다:\n\n* [가중 라운드 로빈](https://www.jscape.com/blog/load-balancing-algorithms)\n    * 유지보수 중인 서버로 트래픽이 가지 않도록 방지\n    * 다양한 클러스터 크기 간의 부하 균형 조절\n    * A/B 테스트\n* [지연 시간 기반](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)\n* [지리 위치 기반](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)\n\n### 단점: DNS\n\n* DNS 서버에 접근하는 것은 약간의 지연을 유발하지만, 위에서 설명한 캐싱으로 완화됩니다.\n* DNS 서버 관리는 복잡할 수 있으며 일반적으로 [정부, ISP, 대기업](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729)에서 관리합니다.\n* 최근 DNS 서비스는 [DDoS 공격](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/)을 받아, 사용자들이 Twitter의 IP 주소를 모르면 웹사이트에 접속하지 못하는 상황이 발생했습니다.\n\n### 출처 및 추가 읽을거리\n\n* [DNS 아키텍처](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)\n* [위키피디아](https://en.wikipedia.org/wiki/Domain_Name_System)\n* [DNS 관련 문서](https://support.dnsimple.com/categories/dns/)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 21,
    "Content": "\n## Content delivery network\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg\">\n  <br/>\n  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Source: Why use a CDN</a></i>\n</p>\n\nA content delivery network (CDN) is a globally distributed network of proxy servers, serving content from locations closer to the user.  Generally, static files such as HTML/CSS/JS, photos, and videos are served from CDN, although some CDNs such as Amazon's CloudFront support dynamic content.  The site's DNS resolution will tell clients which server to contact.\n\nServing content from CDNs can significantly improve performance in two ways:\n\n* Users receive content from data centers close to them\n* Your servers do not have to serve requests that the CDN fulfills\n\n### Push CDNs\n\nPush CDNs receive new content whenever changes occur on your server.  You take full responsibility for providing content, uploading directly to the CDN and rewriting URLs to point to the CDN.  You can configure when content expires and when it is updated.  Content is uploaded only when it is new or changed, minimizing traffic, but maximizing storage.\n\nSites with a small amount of traffic or sites with content that isn't often updated work well with push CDNs.  Content is placed on the CDNs once, instead of being re-pulled at regular intervals.\n\n### Pull CDNs\n\nPull CDNs grab new content from your server when the first user requests the content.  You leave the content on your server and rewrite URLs to point to the CDN.  This results in a slower request until the content is cached on the CDN.\n\nA [time-to-live (TTL)](https://en.wikipedia.org/wiki/Time_to_live) determines how long content is cached.  Pull CDNs minimize storage space on the CDN, but can create redundant traffic if files expire and are pulled before they have actually changed.\n\nSites with heavy traffic work well with pull CDNs, as traffic is spread out more evenly with only recently-requested content remaining on the CDN.\n\n### Disadvantage(s): CDN\n\n* CDN costs could be significant depending on traffic, although this should be weighed with additional costs you would incur not using a CDN.\n* Content might be stale if it is updated before the TTL expires it.\n* CDNs require changing URLs for static content to point to the CDN.\n\n### Source(s) and further reading\n\n* [Globally distributed content delivery](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)\n* [The differences between push and pull CDNs](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)",
    "ContentSha": "bGRlC+2cYKu2Zts6C6nMT6o/JLG5VQ9wuYmJZVvDRI0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "## 콘텐츠 전송 네트워크\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg\">\n  <br/>\n  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>출처: CDN을 사용하는 이유</a></i>\n</p>\n\n콘텐츠 전송 네트워크(CDN)는 전 세계에 분산된 프록시 서버 네트워크로, 사용자와 더 가까운 위치에서 콘텐츠를 제공합니다. 일반적으로 HTML/CSS/JS, 사진, 비디오와 같은 정적 파일이 CDN에서 제공되지만, Amazon의 CloudFront와 같은 일부 CDN은 동적 콘텐츠도 지원합니다. 사이트의 DNS 해석은 클라이언트가 어떤 서버에 접속할지 알려줍니다.\n\nCDN에서 콘텐츠를 제공하면 두 가지 방식으로 성능을 크게 향상시킬 수 있습니다:\n\n* 사용자는 자신과 가까운 데이터 센터에서 콘텐츠를 받습니다.\n* 귀하의 서버는 CDN이 처리하는 요청을 직접 처리할 필요가 없습니다.\n\n### 푸시 CDN\n\n푸시 CDN은 서버에서 변경이 발생할 때마다 새 콘텐츠를 받습니다. 콘텐츠 제공에 대한 전적인 책임을 지며, CDN에 직접 업로드하고 URL을 CDN을 가리키도록 재작성합니다. 콘텐츠 만료 시점과 업데이트 시점을 설정할 수 있습니다. 콘텐츠는 새롭거나 변경된 경우에만 업로드되어 트래픽을 최소화하고 저장 공간을 최대한 활용합니다.\n\n트래픽이 적거나 자주 업데이트되지 않는 콘텐츠를 가진 사이트는 푸시 CDN과 잘 맞습니다. 콘텐츠가 정기적으로 다시 가져오는 것이 아니라 한 번 CDN에 배치됩니다.\n\n### 풀 CDN\n\n풀 CDN은 첫 번째 사용자가 콘텐츠를 요청할 때 서버에서 새 콘텐츠를 가져옵니다. 콘텐츠는 서버에 남겨두고 URL을 CDN을 가리키도록 재작성합니다. 이로 인해 콘텐츠가 CDN에 캐시될 때까지 요청이 느려질 수 있습니다.\n\n[TTL(수명, Time-to-live)](https://en.wikipedia.org/wiki/Time_to_live)은 콘텐츠가 얼마나 오래 캐시되는지 결정합니다. 풀 CDN은 CDN에서 저장 공간을 최소화하지만, 파일이 변경되지 않았음에도 만료되어 다시 가져오는 경우 중복 트래픽이 발생할 수 있습니다.\n\n트래픽이 많은 사이트는 요청된 최신 콘텐츠만 CDN에 남아 트래픽이 더 고르게 분산되므로 풀 CDN과 잘 맞습니다.\n\n### 단점: CDN\n\n* 트래픽에 따라 CDN 비용이 상당할 수 있지만, CDN을 사용하지 않을 경우 발생할 추가 비용과 비교해야 합니다.\n* TTL 만료 전에 업데이트된 콘텐츠는 오래된 상태일 수 있습니다.\n* 정적 콘텐츠의 URL을 CDN을 가리키도록 변경해야 합니다.\n\n### 출처 및 추가 자료\n\n* [전 세계 분산 콘텐츠 전송](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)\n* [푸시 CDN과 풀 CDN의 차이점](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 22,
    "Content": "* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)\n\n## Load balancer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>\n</p>\n\nLoad balancers distribute incoming client requests to computing resources such as application servers and databases.  In each case, the load balancer returns the response from the computing resource to the appropriate client.  Load balancers are effective at:\n\n* Preventing requests from going to unhealthy servers\n* Preventing overloading resources\n* Helping to eliminate a single point of failure\n\nLoad balancers can be implemented with hardware (expensive) or with software such as HAProxy.\n\nAdditional benefits include:\n\n* **SSL termination** - Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations\n    * Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server\n* **Session persistence** - Issue cookies and route a specific client's requests to same instance if the web apps do not keep track of sessions\n\nTo protect against failures, it's common to set up multiple load balancers, either in [active-passive](#active-passive) or [active-active](#active-active) mode.\n\nLoad balancers can route traffic based on various metrics, including:\n\n* Random\n* Least loaded\n* Session/cookies\n* [Round robin or weighted round robin](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)\n* [Layer 4](#layer-4-load-balancing)\n* [Layer 7](#layer-7-load-balancing)\n\n### Layer 4 load balancing\n\nLayer 4 load balancers look at info at the [transport layer](#communication) to decide how to distribute requests.  Generally, this involves the source, destination IP addresses, and ports in the header, but not the contents of the packet.  Layer 4 load balancers forward network packets to and from the upstream server, performing [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/).\n\n### Layer 7 load balancing",
    "ContentSha": "9cdxRHyBtl0u7vNUNZ/06ZZn+SBn6/L1EyLOFfGBVdU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [위키피디아](https://en.wikipedia.org/wiki/Content_delivery_network)\n\n## 로드 밸런서\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>출처: 확장 가능한 시스템 설계 패턴</a></i>\n</p>\n\n로드 밸런서는 애플리케이션 서버 및 데이터베이스와 같은 컴퓨팅 자원에 들어오는 클라이언트 요청을 분배합니다. 각 경우에 로드 밸런서는 컴퓨팅 자원으로부터의 응답을 적절한 클라이언트에게 반환합니다. 로드 밸런서는 다음과 같은 점에서 효과적입니다:\n\n* 상태가 좋지 않은 서버로 요청이 가지 않도록 방지\n* 자원의 과부하 방지\n* 단일 장애점 제거에 도움\n\n로드 밸런서는 하드웨어(비용이 높음) 또는 HAProxy와 같은 소프트웨어로 구현할 수 있습니다.\n\n추가 이점은 다음과 같습니다:\n\n* **SSL 종료** - 들어오는 요청을 복호화하고 서버 응답을 암호화하여 백엔드 서버가 비용이 많이 드는 작업을 수행하지 않아도 됨\n    * 각 서버에 [X.509 인증서](https://en.wikipedia.org/wiki/X.509)를 설치할 필요 제거\n* **세션 지속성** - 쿠키를 발급하고 웹 앱이 세션을 추적하지 않는 경우 특정 클라이언트 요청을 동일 인스턴스로 라우팅\n\n장애를 방지하기 위해 여러 대의 로드 밸런서를 [액티브-패시브](#active-passive) 또는 [액티브-액티브](#active-active) 모드로 설정하는 것이 일반적입니다.\n\n로드 밸런서는 다음을 포함한 다양한 지표를 기반으로 트래픽을 라우팅할 수 있습니다:\n\n* 랜덤\n* 가장 적게 로드된 서버\n* 세션/쿠키\n* [라운드 로빈 또는 가중 라운드 로빈](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)\n* [레이어 4](#layer-4-load-balancing)\n* [레이어 7](#layer-7-load-balancing)\n\n### 레이어 4 로드 밸런싱\n\n레이어 4 로드 밸런서는 요청 분배를 결정하기 위해 [전송 계층](#communication)의 정보를 봅니다. 일반적으로 소스, 목적지 IP 주소와 헤더의 포트를 포함하지만 패킷 내용은 포함하지 않습니다. 레이어 4 로드 밸런서는 네트워크 패킷을 업스트림 서버로 포워딩하며, [네트워크 주소 변환 (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)을 수행합니다.\n\n### 레이어 7 로드 밸런싱",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 23,
    "Content": "\nLayer 7 load balancers look at the [application layer](#communication) to decide how to distribute requests.  This can involve contents of the header, message, and cookies.  Layer 7 load balancers terminate network traffic, reads the message, makes a load-balancing decision, then opens a connection to the selected server.  For example, a layer 7 load balancer can direct video traffic to servers that host videos while directing more sensitive user billing traffic to security-hardened servers.\n\nAt the cost of flexibility, layer 4 load balancing requires less time and computing resources than Layer 7, although the performance impact can be minimal on modern commodity hardware.\n\n### Horizontal scaling\n\nLoad balancers can also help with horizontal scaling, improving performance and availability.  Scaling out using commodity machines is more cost efficient and results in higher availability than scaling up a single server on more expensive hardware, called **Vertical Scaling**.  It is also easier to hire for talent working on commodity hardware than it is for specialized enterprise systems.\n\n#### Disadvantage(s): horizontal scaling\n\n* Scaling horizontally introduces complexity and involves cloning servers\n    * Servers should be stateless: they should not contain any user-related data like sessions or profile pictures\n    * Sessions can be stored in a centralized data store such as a [database](#database) (SQL, NoSQL) or a persistent [cache](#cache) (Redis, Memcached)\n* Downstream servers such as caches and databases need to handle more simultaneous connections as upstream servers scale out\n\n### Disadvantage(s): load balancer\n\n* The load balancer can become a performance bottleneck if it does not have enough resources or if it is not configured properly.\n* Introducing a load balancer to help eliminate a single point of failure results in increased complexity.\n* A single load balancer is a single point of failure, configuring multiple load balancers further increases complexity.\n\n### Source(s) and further reading\n\n* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [Scalability](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n* [Wikipedia](https://en.wikipedia.org/wiki/Load_balancing_(computing))\n* [Layer 4 load balancing](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)\n* [Layer 7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)\n* [ELB listener config](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)\n\n## Reverse proxy (web server)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png\">\n  <br/>\n  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Source: Wikipedia</a></i>\n  <br/>\n</p>",
    "ContentSha": "d9PfMKhS5It6VuFSV5VdEgf336M0xQeGW1c7I8NDHiY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "Layer 7 로드 밸런서는 요청을 어떻게 분배할지 결정하기 위해 [애플리케이션 계층](#communication)을 살펴봅니다.  이는 헤더, 메시지 및 쿠키의 내용을 포함할 수 있습니다.  Layer 7 로드 밸런서는 네트워크 트래픽을 종료하고, 메시지를 읽고, 로드 밸런싱 결정을 내린 후 선택된 서버에 연결을 엽니다.  예를 들어, Layer 7 로드 밸런서는 비디오 트래픽을 비디오를 호스팅하는 서버로, 더 민감한 사용자 청구 트래픽을 보안이 강화된 서버로 안내할 수 있습니다.\n\n유연성의 대가로, Layer 4 로드 밸런싱은 Layer 7보다 적은 시간과 컴퓨팅 자원을 필요로 하지만, 최신 일반 하드웨어에서는 성능 영향이 미미할 수 있습니다.\n\n### 수평 확장\n\n로드 밸런서는 수평 확장에도 도움을 주어 성능과 가용성을 향상시킵니다.  일반 하드웨어를 사용한 수평 확장은 더 비싼 하드웨어에서 단일 서버를 확장하는 **수직 확장**보다 비용 효율적이며 더 높은 가용성을 제공합니다.  또한 일반 하드웨어에서 일하는 인재를 고용하는 것이 전문 기업 시스템보다 더 쉽습니다.\n\n#### 단점: 수평 확장\n\n* 수평 확장은 복잡성을 도입하며 서버 복제를 포함합니다\n    * 서버는 상태 비저장(stateless)이어야 합니다: 세션이나 프로필 사진 같은 사용자 관련 데이터를 포함하지 않아야 합니다\n    * 세션은 중앙 집중식 데이터 저장소(예: [데이터베이스](#database)(SQL, NoSQL) 또는 영속적인 [캐시](#cache)(Redis, Memcached))에 저장할 수 있습니다\n* 캐시 및 데이터베이스와 같은 다운스트림 서버는 업스트림 서버가 확장됨에 따라 더 많은 동시 연결을 처리해야 합니다\n\n### 단점: 로드 밸런서\n\n* 로드 밸런서가 충분한 자원을 갖추지 못했거나 제대로 구성되지 않은 경우 성능 병목 현상이 발생할 수 있습니다.\n* 단일 실패 지점을 제거하기 위해 로드 밸런서를 도입하면 복잡성이 증가합니다.\n* 단일 로드 밸런서는 단일 실패 지점이며, 여러 로드 밸런서를 구성하면 복잡성이 더욱 증가합니다.\n\n### 출처 및 추가 읽기 자료\n\n* [NGINX 아키텍처](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy 아키텍처 가이드](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [확장성](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n* [위키피디아](https://en.wikipedia.org/wiki/Load_balancing_(computing))\n* [Layer 4 로드 밸런싱](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)\n* [Layer 7 로드 밸런싱](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)\n* [ELB 리스너 구성](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)\n\n## 리버스 프록시 (웹 서버)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png\">\n  <br/>\n  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>출처: 위키피디아</a></i>\n  <br/>\n</p>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 24,
    "Content": "\nA reverse proxy is a web server that centralizes internal services and provides unified interfaces to the public.  Requests from clients are forwarded to a server that can fulfill it before the reverse proxy returns the server's response to the client.\n\nAdditional benefits include:\n\n* **Increased security** - Hide information about backend servers, blacklist IPs, limit number of connections per client\n* **Increased scalability and flexibility** - Clients only see the reverse proxy's IP, allowing you to scale servers or change their configuration\n* **SSL termination** - Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations\n    * Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server\n* **Compression** - Compress server responses\n* **Caching** - Return the response for cached requests\n* **Static content** - Serve static content directly\n    * HTML/CSS/JS\n    * Photos\n    * Videos\n    * Etc\n\n### Load balancer vs reverse proxy\n\n* Deploying a load balancer is useful when you have multiple servers.  Often, load balancers  route traffic to a set of servers serving the same function.\n* Reverse proxies can be useful even with just one web server or application server, opening up the benefits described in the previous section.\n* Solutions such as NGINX and HAProxy can support both layer 7 reverse proxying and load balancing.\n\n### Disadvantage(s): reverse proxy\n\n* Introducing a reverse proxy results in increased complexity.\n* A single reverse proxy is a single point of failure, configuring multiple reverse proxies (ie a [failover](https://en.wikipedia.org/wiki/Failover)) further increases complexity.\n\n### Source(s) and further reading\n\n* [Reverse proxy vs load balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)\n* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)\n\n## Application layer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png\">\n  <br/>",
    "ContentSha": "mSXIlXJOirzgK7lcCGgaBsQWdB09fQQPiRxJI8Azkv4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "리버스 프록시는 내부 서비스를 중앙 집중화하고 대중에게 통합된 인터페이스를 제공하는 웹 서버입니다. 클라이언트의 요청은 리버스 프록시가 서버로 전달하여 서버가 요청을 처리한 후, 서버의 응답을 클라이언트에게 반환합니다.\n\n추가적인 이점은 다음과 같습니다:\n\n* **보안 강화** - 백엔드 서버에 대한 정보 숨기기, IP 차단, 클라이언트별 연결 수 제한\n* **확장성 및 유연성 향상** - 클라이언트는 리버스 프록시의 IP만 보므로 서버를 확장하거나 구성 변경 가능\n* **SSL 종료** - 들어오는 요청을 복호화하고 서버 응답을 암호화하여 백엔드 서버가 비용이 많이 드는 작업을 수행하지 않아도 됨\n    * 각 서버에 [X.509 인증서](https://ko.wikipedia.org/wiki/X.509) 설치 필요성 제거\n* **압축** - 서버 응답 압축\n* **캐싱** - 캐시된 요청에 대해 응답 반환\n* **정적 콘텐츠** - 정적 콘텐츠 직접 제공\n    * HTML/CSS/JS\n    * 사진\n    * 비디오\n    * 기타\n\n### 로드 밸런서 vs 리버스 프록시\n\n* 여러 서버가 있을 때 로드 밸런서를 배포하는 것이 유용합니다. 로드 밸런서는 종종 동일한 기능을 제공하는 서버 집합으로 트래픽을 라우팅합니다.\n* 리버스 프록시는 웹 서버나 애플리케이션 서버가 하나만 있어도 유용하며, 이전 섹션에서 설명한 이점을 제공합니다.\n* NGINX와 HAProxy 같은 솔루션은 레이어 7 리버스 프록시 및 로드 밸런싱을 모두 지원할 수 있습니다.\n\n### 단점: 리버스 프록시\n\n* 리버스 프록시 도입으로 복잡성이 증가합니다.\n* 단일 리버스 프록시는 단일 실패 지점이 되며, 여러 리버스 프록시를 구성하는 것(예: [페일오버](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%BC%EC%98%A4%EB%B2%84))은 복잡성을 더욱 증가시킵니다.\n\n### 출처 및 추가 읽을거리\n\n* [리버스 프록시 vs 로드 밸런서](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)\n* [NGINX 아키텍처](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy 아키텍처 가이드](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [위키피디아](https://ko.wikipedia.org/wiki/Reverse_proxy)\n\n## 애플리케이션 레이어\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png\">\n  <br/>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 25,
    "Content": "  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>\n</p>\n\nSeparating out the web layer from the application layer (also known as platform layer) allows you to scale and configure both layers independently.  Adding a new API results in adding application servers without necessarily adding additional web servers.  The **single responsibility principle** advocates for small and autonomous services that work together.  Small teams with small services can plan more aggressively for rapid growth.\n\nWorkers in the application layer also help enable [asynchronism](#asynchronism).\n\n### Microservices\n\nRelated to this discussion are [microservices](https://en.wikipedia.org/wiki/Microservices), which can be described as a suite of independently deployable, small, modular services.  Each service runs a unique process and communicates through a well-defined, lightweight mechanism to serve a business goal. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>\n\nPinterest, for example, could have the following microservices: user profile, follower, feed, search, photo upload, etc.\n\n### Service Discovery\n\nSystems such as [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), and [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) can help services find each other by keeping track of registered names, addresses, and ports.  [Health checks](https://www.consul.io/intro/getting-started/checks.html) help verify service integrity and are often done using an [HTTP](#hypertext-transfer-protocol-http) endpoint.  Both Consul and Etcd have a built in [key-value store](#key-value-store) that can be useful for storing config values and other shared data.\n\n### Disadvantage(s): application layer\n\n* Adding an application layer with loosely coupled services requires a different approach from an architectural, operations, and process viewpoint (vs a monolithic system).\n* Microservices can add complexity in terms of deployments and operations.\n\n### Source(s) and further reading\n\n* [Intro to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale)\n* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Service oriented architecture](https://en.wikipedia.org/wiki/Service-oriented_architecture)\n* [Introduction to Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)\n* [Here's what you need to know about building microservices](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)\n\n## Database\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Source: Scaling up to your first 10 million users</a></i>\n</p>\n\n### Relational database management system (RDBMS)\n",
    "ContentSha": "4XnXpBum9tEdb1sG9FZ65dxvl1TxD2b55kzZSCwIQE8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>출처: 대규모 시스템 설계 입문</a></i>\n</p>\n\n웹 계층을 애플리케이션 계층(플랫폼 계층이라고도 함)과 분리하면 두 계층을 독립적으로 확장하고 구성할 수 있습니다. 새로운 API를 추가하면 반드시 추가 웹 서버를 추가하지 않고도 애플리케이션 서버를 추가할 수 있습니다. **단일 책임 원칙**은 함께 작동하는 작고 자율적인 서비스를 권장합니다. 작은 팀이 작은 서비스를 관리하면 빠른 성장을 보다 적극적으로 계획할 수 있습니다.\n\n애플리케이션 계층의 워커는 또한 [비동기성](#asynchronism)을 가능하게 하는 데 도움을 줍니다.\n\n### 마이크로서비스\n\n이와 관련된 개념으로는 [마이크로서비스](https://en.wikipedia.org/wiki/Microservices)가 있으며, 이는 독립적으로 배포 가능한 작고 모듈화된 서비스 모음으로 설명할 수 있습니다. 각 서비스는 고유한 프로세스를 실행하고 잘 정의된 경량 메커니즘을 통해 통신하여 비즈니스 목표를 달성합니다. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>\n\n예를 들어 Pinterest는 사용자 프로필, 팔로워, 피드, 검색, 사진 업로드 등의 마이크로서비스를 가질 수 있습니다.\n\n### 서비스 디스커버리\n\n[Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)와 같은 시스템은 등록된 이름, 주소 및 포트를 추적하여 서비스들이 서로를 찾을 수 있도록 도와줍니다. [헬스 체크](https://www.consul.io/intro/getting-started/checks.html)는 서비스 무결성을 검증하는 데 도움을 주며 종종 [HTTP](#hypertext-transfer-protocol-http) 엔드포인트를 사용해 수행됩니다. Consul과 Etcd 모두 구성 값 및 기타 공유 데이터를 저장하는 데 유용한 내장 [키-값 저장소](#key-value-store)를 가지고 있습니다.\n\n### 단점: 애플리케이션 계층\n\n* 느슨하게 결합된 서비스로 애플리케이션 계층을 추가하면 아키텍처, 운영 및 프로세스 관점에서 다른 접근 방식이 필요합니다(모놀리식 시스템과 대비).\n* 마이크로서비스는 배포 및 운영 측면에서 복잡성을 더할 수 있습니다.\n\n### 출처 및 추가 읽기 자료\n\n* [대규모 시스템 설계 입문](http://lethain.com/introduction-to-architecting-systems-for-scale)\n* [시스템 설계 인터뷰 정복하기](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [서비스 지향 아키텍처](https://en.wikipedia.org/wiki/Service-oriented_architecture)\n* [Zookeeper 소개](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)\n* [마이크로서비스 구축에 대해 알아야 할 사항](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)\n\n## 데이터베이스\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>출처: 처음 1,000만 사용자까지 확장하기</a></i>\n</p>\n\n### 관계형 데이터베이스 관리 시스템 (RDBMS)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 26,
    "Content": "A relational database like SQL is a collection of data items organized in tables.\n\n**ACID** is a set of properties of relational database [transactions](https://en.wikipedia.org/wiki/Database_transaction).\n\n* **Atomicity** - Each transaction is all or nothing\n* **Consistency** - Any transaction will bring the database from one valid state to another\n* **Isolation** - Executing transactions concurrently has the same results as if the transactions were executed serially\n* **Durability** - Once a transaction has been committed, it will remain so\n\nThere are many techniques to scale a relational database: **master-slave replication**, **master-master replication**, **federation**, **sharding**, **denormalization**, and **SQL tuning**.\n\n#### Master-slave replication\n\nThe master serves reads and writes, replicating writes to one or more slaves, which serve only reads.  Slaves can also replicate to additional slaves in a tree-like fashion.  If the master goes offline, the system can continue to operate in read-only mode until a slave is promoted to a master or a new master is provisioned.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### Disadvantage(s): master-slave replication\n\n* Additional logic is needed to promote a slave to a master.\n* See [Disadvantage(s): replication](#disadvantages-replication) for points related to **both** master-slave and master-master.\n\n#### Master-master replication\n\nBoth masters serve reads and writes and coordinate with each other on writes.  If either master goes down, the system can continue to operate with both reads and writes.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### Disadvantage(s): master-master replication\n\n* You'll need a load balancer or you'll need to make changes to your application logic to determine where to write.\n* Most master-master systems are either loosely consistent (violating ACID) or have increased write latency due to synchronization.",
    "ContentSha": "xbwODyHVavckLsfDMlRqRxmfdv3+erTT0ITmoKYGnqg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "관계형 데이터베이스인 SQL은 테이블에 조직된 데이터 항목들의 모음입니다.\n\n**ACID**는 관계형 데이터베이스 [트랜잭션](https://en.wikipedia.org/wiki/Database_transaction)의 속성 집합입니다.\n\n* **원자성(Atomicity)** - 각 트랜잭션은 전부 수행되거나 전혀 수행되지 않아야 합니다.\n* **일관성(Consistency)** - 모든 트랜잭션은 데이터베이스를 한 유효한 상태에서 다른 유효한 상태로 전환합니다.\n* **격리성(Isolation)** - 트랜잭션을 동시에 실행해도 트랜잭션을 순차적으로 실행한 것과 동일한 결과를 가져옵니다.\n* **지속성(Durability)** - 트랜잭션이 커밋되면 그 상태가 유지됩니다.\n\n관계형 데이터베이스를 확장하는 여러 기법이 있습니다: **마스터-슬레이브 복제**, **마스터-마스터 복제**, **페더레이션**, **샤딩**, **비정규화**, 그리고 **SQL 튜닝**.\n\n#### 마스터-슬레이브 복제\n\n마스터는 읽기와 쓰기를 처리하며, 쓰기를 하나 이상의 슬레이브에게 복제합니다. 슬레이브는 읽기만 처리합니다. 슬레이브는 트리 형태로 추가 슬레이브에게도 복제할 수 있습니다. 마스터가 오프라인이 되면, 슬레이브가 마스터로 승격되거나 새 마스터가 준비될 때까지 시스템은 읽기 전용 모드로 계속 동작할 수 있습니다.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>출처: 확장성, 가용성, 안정성, 패턴</a></i>\n</p>\n\n##### 단점: 마스터-슬레이브 복제\n\n* 슬레이브를 마스터로 승격시키기 위한 추가 로직이 필요합니다.\n* 마스터-슬레이브와 마스터-마스터 모두에 관련된 사항은 [단점: 복제](#disadvantages-replication)를 참조하세요.\n\n#### 마스터-마스터 복제\n\n두 마스터 모두 읽기와 쓰기를 처리하며, 쓰기 작업에 대해 서로 조정합니다. 어느 한 쪽 마스터가 다운되더라도 시스템은 읽기와 쓰기를 계속 수행할 수 있습니다.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>출처: 확장성, 가용성, 안정성, 패턴</a></i>\n</p>\n\n##### 단점: 마스터-마스터 복제\n\n* 로드 밸런서가 필요하거나, 어디에 쓸지 결정하기 위해 애플리케이션 로직을 변경해야 합니다.\n* 대부분의 마스터-마스터 시스템은 느슨한 일관성(ACID 위반) 또는 동기화로 인한 쓰기 지연 증가 문제를 가집니다.",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 27,
    "Content": "* Conflict resolution comes more into play as more write nodes are added and as latency increases.\n* See [Disadvantage(s): replication](#disadvantages-replication) for points related to **both** master-slave and master-master.\n\n##### Disadvantage(s): replication\n\n* There is a potential for loss of data if the master fails before any newly written data can be replicated to other nodes.\n* Writes are replayed to the read replicas.  If there are a lot of writes, the read replicas can get bogged down with replaying writes and can't do as many reads.\n* The more read slaves, the more you have to replicate, which leads to greater replication lag.\n* On some systems, writing to the master can spawn multiple threads to write in parallel, whereas read replicas only support writing sequentially with a single thread.\n* Replication adds more hardware and additional complexity.\n\n##### Source(s) and further reading: replication\n\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [Multi-master replication](https://en.wikipedia.org/wiki/Multi-master_replication)\n\n#### Federation\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Source: Scaling up to your first 10 million users</a></i>\n</p>\n\nFederation (or functional partitioning) splits up databases by function.  For example, instead of a single, monolithic database, you could have three databases: **forums**, **users**, and **products**, resulting in less read and write traffic to each database and therefore less replication lag.  Smaller databases result in more data that can fit in memory, which in turn results in more cache hits due to improved cache locality.  With no single central master serializing writes you can write in parallel, increasing throughput.\n\n##### Disadvantage(s): federation\n\n* Federation is not effective if your schema requires huge functions or tables.\n* You'll need to update your application logic to determine which database to read and write.\n* Joining data from two databases is more complex with a [server link](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).\n* Federation adds more hardware and additional complexity.\n\n##### Source(s) and further reading: federation\n\n* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n\n#### Sharding\n\n<p align=\"center\">",
    "ContentSha": "I/gTQQL3xkPYu5E5dWj4YTG/hfUu3BM7YFOD7HwCQH0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 더 많은 쓰기 노드가 추가되고 지연 시간이 증가함에 따라 충돌 해결이 더 중요해집니다.\n* **마스터-슬레이브** 및 **마스터-마스터** 모두와 관련된 내용은 [단점: 복제](#disadvantages-replication)를 참조하세요.\n\n##### 단점: 복제\n\n* 마스터가 새로 쓴 데이터를 다른 노드에 복제하기 전에 실패하면 데이터 손실 가능성이 있습니다.\n* 쓰기 작업은 읽기 복제본에 재생됩니다. 쓰기가 많으면 읽기 복제본이 쓰기 재생에 부담을 느껴 읽기 성능이 저하될 수 있습니다.\n* 읽기 슬레이브가 많을수록 복제해야 할 양이 많아져 복제 지연이 커집니다.\n* 일부 시스템에서는 마스터에 쓰기 시 여러 스레드가 병렬로 쓰기를 수행하지만, 읽기 복제본은 단일 스레드로 순차적 쓰기만 지원합니다.\n* 복제는 더 많은 하드웨어와 추가적인 복잡성을 초래합니다.\n\n##### 출처 및 추가 읽을거리: 복제\n\n* [확장성, 가용성, 안정성, 패턴](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [멀티 마스터 복제](https://en.wikipedia.org/wiki/Multi-master_replication)\n\n#### 페더레이션\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>출처: 첫 1천만 사용자까지 확장하기</a></i>\n</p>\n\n페더레이션(또는 기능 분할)은 데이터베이스를 기능별로 분리합니다. 예를 들어, 단일 모놀리식 데이터베이스 대신에 **포럼**, **사용자**, **제품**이라는 세 개의 데이터베이스로 나누어 각 데이터베이스에 대한 읽기 및 쓰기 트래픽을 줄이고 복제 지연을 감소시킵니다. 작은 데이터베이스는 메모리에 더 많은 데이터를 적재할 수 있어 캐시 국소성이 향상되어 캐시 적중률이 높아집니다. 단일 중앙 마스터가 쓰기를 직렬화하지 않으므로 병렬로 쓸 수 있어 처리량이 증가합니다.\n\n##### 단점: 페더레이션\n\n* 스키마가 거대한 기능이나 테이블을 요구하는 경우 페더레이션은 효과적이지 않습니다.\n* 어느 데이터베이스를 읽고 쓸지 결정하기 위해 애플리케이션 로직을 업데이트해야 합니다.\n* 두 개의 데이터베이스에서 데이터를 조인하는 것은 [서버 링크](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers)를 사용해도 더 복잡합니다.\n* 페더레이션은 더 많은 하드웨어와 추가적인 복잡성을 초래합니다.\n\n##### 출처 및 추가 읽을거리: 페더레이션\n\n* [첫 1천만 사용자까지 확장하기](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n\n#### 샤딩\n\n<p align=\"center\">",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 28,
    "Content": "  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nSharding distributes data across different databases such that each database can only manage a subset of the data.  Taking a users database as an example, as the number of users increases, more shards are added to the cluster.\n\nSimilar to the advantages of [federation](#federation), sharding results in less read and write traffic, less replication, and more cache hits.  Index size is also reduced, which generally improves performance with faster queries.  If one shard goes down, the other shards are still operational, although you'll want to add some form of replication to avoid data loss.  Like federation, there is no single central master serializing writes, allowing you to write in parallel with increased throughput.\n\nCommon ways to shard a table of users is either through the user's last name initial or the user's geographic location.\n\n##### Disadvantage(s): sharding\n\n* You'll need to update your application logic to work with shards, which could result in complex SQL queries.\n* Data distribution can become lopsided in a shard.  For example, a set of power users on a shard could result in increased load to that shard compared to others.\n    * Rebalancing adds additional complexity.  A sharding function based on [consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) can reduce the amount of transferred data.\n* Joining data from multiple shards is more complex.\n* Sharding adds more hardware and additional complexity.\n\n##### Source(s) and further reading: sharding\n\n* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)\n* [Shard database architecture](https://en.wikipedia.org/wiki/Shard_(database_architecture))\n* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)\n\n#### Denormalization\n\nDenormalization attempts to improve read performance at the expense of some write performance.  Redundant copies of the data are written in multiple tables to avoid expensive joins.  Some RDBMS such as [PostgreSQL](https://en.wikipedia.org/wiki/PostgreSQL) and Oracle support [materialized views](https://en.wikipedia.org/wiki/Materialized_view) which handle the work of storing redundant information and keeping redundant copies consistent.\n\nOnce data becomes distributed with techniques such as [federation](#federation) and [sharding](#sharding), managing joins across data centers further increases complexity.  Denormalization might circumvent the need for such complex joins.\n\nIn most systems, reads can heavily outnumber writes 100:1 or even 1000:1.  A read resulting in a complex database join can be very expensive, spending a significant amount of time on disk operations.\n\n##### Disadvantage(s): denormalization\n\n* Data is duplicated.\n* Constraints can help redundant copies of information stay in sync, which increases complexity of the database design.\n* A denormalized database under heavy write load might perform worse than its normalized counterpart.\n\n###### Source(s) and further reading: denormalization",
    "ContentSha": "GzP1YEx8H74doj7cHlqPZNKSbHvkETAbRVSJw4T5QnY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>출처: 확장성, 가용성, 안정성, 패턴</a></i>\n</p>\n\n샤딩은 데이터를 서로 다른 데이터베이스에 분산시켜 각 데이터베이스가 데이터의 일부만 관리하도록 합니다. 사용자 데이터베이스를 예로 들면, 사용자가 증가함에 따라 클러스터에 더 많은 샤드가 추가됩니다.\n\n[federation](#federation)의 장점과 유사하게, 샤딩은 읽기 및 쓰기 트래픽 감소, 복제 감소, 캐시 적중률 증가를 가져옵니다. 인덱스 크기도 줄어들어 일반적으로 더 빠른 쿼리로 성능이 향상됩니다. 하나의 샤드가 다운되더라도 다른 샤드는 여전히 작동하지만, 데이터 손실을 방지하기 위해 복제 형태를 추가하는 것이 좋습니다. federation과 마찬가지로, 단일 중앙 마스터가 쓰기를 직렬화하지 않아 병렬로 쓰기가 가능하며 처리량이 증가합니다.\n\n사용자 테이블을 샤딩하는 일반적인 방법은 사용자의 성(last name) 이니셜이나 사용자의 지리적 위치를 기준으로 하는 것입니다.\n\n##### 단점: 샤딩\n\n* 샤드와 작동하도록 애플리케이션 로직을 업데이트해야 하며, 이는 복잡한 SQL 쿼리를 초래할 수 있습니다.\n* 데이터 분포가 샤드 내에서 불균형해질 수 있습니다. 예를 들어, 특정 샤드에 파워 유저 집단이 몰리면 해당 샤드에 부하가 증가할 수 있습니다.\n    * 리밸런싱은 추가적인 복잡성을 더합니다. [일관 해싱(consistent hashing)](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)을 기반으로 한 샤딩 함수는 전송되는 데이터 양을 줄일 수 있습니다.\n* 여러 샤드의 데이터를 조인하는 것이 더 복잡합니다.\n* 샤딩은 더 많은 하드웨어와 추가적인 복잡성을 수반합니다.\n\n##### 출처 및 추가 읽을거리: 샤딩\n\n* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)\n* [Shard database architecture](https://en.wikipedia.org/wiki/Shard_(database_architecture))\n* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)\n\n#### 비정규화\n\n비정규화는 일부 쓰기 성능을 희생하는 대신 읽기 성능을 향상시키려 시도합니다. 비용이 많이 드는 조인을 피하기 위해 여러 테이블에 중복된 데이터 복사본을 작성합니다. [PostgreSQL](https://en.wikipedia.org/wiki/PostgreSQL)과 Oracle 같은 일부 RDBMS는 중복 정보를 저장하고 중복 복사본을 일관되게 유지하는 작업을 처리하는 [물리화 뷰(materialized views)](https://en.wikipedia.org/wiki/Materialized_view)를 지원합니다.\n\n[federation](#federation)과 [sharding](#sharding) 같은 기술로 데이터가 분산되면 데이터 센터 간 조인 관리가 더욱 복잡해집니다. 비정규화는 이러한 복잡한 조인 필요성을 우회할 수 있습니다.\n\n대부분 시스템에서 읽기 작업이 쓰기 작업보다 100:1 또는 심지어 1000:1로 훨씬 많을 수 있습니다. 복잡한 데이터베이스 조인으로 인한 읽기는 매우 비용이 많이 들며 디스크 작업에 상당한 시간이 소요될 수 있습니다.\n\n##### 단점: 비정규화\n\n* 데이터가 중복됩니다.\n* 중복 정보의 동기화를 돕는 제약 조건은 데이터베이스 설계의 복잡성을 증가시킵니다.\n* 무거운 쓰기 부하가 걸린 비정규화 데이터베이스는 정규화된 데이터베이스보다 성능이 더 나쁠 수 있습니다.\n\n###### 출처 및 추가 읽을거리: 비정규화",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 29,
    "Content": "\n* [Denormalization](https://en.wikipedia.org/wiki/Denormalization)\n\n#### SQL tuning\n\nSQL tuning is a broad topic and many [books](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) have been written as reference.\n\nIt's important to **benchmark** and **profile** to simulate and uncover bottlenecks.\n\n* **Benchmark** - Simulate high-load situations with tools such as [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).\n* **Profile** - Enable tools such as the [slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) to help track performance issues.\n\nBenchmarking and profiling might point you to the following optimizations.\n\n##### Tighten up the schema\n\n* MySQL dumps to disk in contiguous blocks for fast access.\n* Use `CHAR` instead of `VARCHAR` for fixed-length fields.\n    * `CHAR` effectively allows for fast, random access, whereas with `VARCHAR`, you must find the end of a string before moving onto the next one.\n* Use `TEXT` for large blocks of text such as blog posts.  `TEXT` also allows for boolean searches.  Using a `TEXT` field results in storing a pointer on disk that is used to locate the text block.\n* Use `INT` for larger numbers up to 2^32 or 4 billion.\n* Use `DECIMAL` for currency to avoid floating point representation errors.\n* Avoid storing large `BLOBS`, store the location of where to get the object instead.\n* `VARCHAR(255)` is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.\n* Set the `NOT NULL` constraint where applicable to [improve search performance](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).\n\n##### Use good indices\n\n* Columns that you are querying (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) could be faster with indices.\n* Indices are usually represented as self-balancing [B-tree](https://en.wikipedia.org/wiki/B-tree) that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time.\n* Placing an index can keep the data in memory, requiring more space.\n* Writes could also be slower since the index also needs to be updated.\n* When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices.\n\n##### Avoid expensive joins\n\n* [Denormalize](#denormalization) where performance demands it.\n\n##### Partition tables\n",
    "ContentSha": "RC5xUXwhghEuq573LDD6+Is8QYupI3Y4Dn+nKYuNP3o=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [비정규화](https://en.wikipedia.org/wiki/Denormalization)\n\n#### SQL 튜닝\n\nSQL 튜닝은 광범위한 주제로 많은 [서적](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning)이 참고서로 출판되었습니다.\n\n병목 현상을 시뮬레이션하고 발견하기 위해 **벤치마크**와 **프로파일링**이 중요합니다.\n\n* **벤치마크** - [ab](http://httpd.apache.org/docs/2.2/programs/ab.html)와 같은 도구로 고부하 상황을 시뮬레이션합니다.\n* **프로파일링** - [슬로우 쿼리 로그](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)와 같은 도구를 활성화하여 성능 문제를 추적하는 데 도움을 줍니다.\n\n벤치마킹과 프로파일링을 통해 다음과 같은 최적화를 할 수 있습니다.\n\n##### 스키마를 강화하세요\n\n* MySQL은 빠른 접근을 위해 디스크에 연속된 블록으로 덤프합니다.\n* 고정 길이 필드에는 `VARCHAR` 대신 `CHAR`를 사용하세요.\n    * `CHAR`는 빠르고 임의 접근이 가능하지만, `VARCHAR`는 다음 문자열로 넘어가기 전에 문자열 끝을 찾아야 합니다.\n* 블로그 게시물 같은 큰 텍스트 블록에는 `TEXT`를 사용하세요. `TEXT`는 불리언 검색도 허용합니다. `TEXT` 필드를 사용하면 디스크에 텍스트 블록 위치를 찾는 포인터를 저장합니다.\n* 2^32 또는 40억까지 큰 숫자에는 `INT`를 사용하세요.\n* 부동 소수점 표현 오류를 피하기 위해 화폐에는 `DECIMAL`을 사용하세요.\n* 큰 `BLOB` 저장은 피하고 객체를 가져올 위치를 저장하세요.\n* `VARCHAR(255)`는 8비트 숫자로 셀 수 있는 최대 문자 수로, 일부 RDBMS에서 바이트 사용을 극대화합니다.\n* 적용 가능한 경우 `NOT NULL` 제약 조건을 설정하여 [검색 성능 향상](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)을 도모하세요.\n\n##### 좋은 인덱스 사용\n\n* 쿼리하는 열(`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`)에는 인덱스가 더 빠를 수 있습니다.\n* 인덱스는 데이터를 정렬 상태로 유지하고 로그 시간에 검색, 순차 접근, 삽입 및 삭제를 허용하는 자기 균형 [B-트리](https://en.wikipedia.org/wiki/B-tree)로 보통 구현됩니다.\n* 인덱스 배치는 데이터를 메모리에 유지할 수 있어 더 많은 공간이 필요합니다.\n* 인덱스도 업데이트되어야 하므로 쓰기 작업이 느려질 수 있습니다.\n* 대량 데이터를 로드할 때는 인덱스를 비활성화한 후 데이터를 로드하고 인덱스를 다시 구축하는 것이 더 빠를 수 있습니다.\n\n##### 비용이 많이 드는 조인 피하기\n\n* 성능이 필요할 때는 [비정규화](#denormalization)를 적용하세요.\n\n##### 테이블 파티셔닝\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 30,
    "Content": "* Break up a table by putting hot spots in a separate table to help keep it in memory.\n\n##### Tune the query cache\n\n* In some cases, the [query cache](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) could lead to [performance issues](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).\n\n##### Source(s) and further reading: SQL tuning\n\n* [Tips for optimizing MySQL queries](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)\n* [Is there a good reason i see VARCHAR(255) used so often?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)\n* [How do null values affect performance?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)\n* [Slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)\n\n### NoSQL\n\nNoSQL is a collection of data items represented in a **key-value store**, **document store**, **wide column store**, or a **graph database**.  Data is denormalized, and joins are generally done in the application code.  Most NoSQL stores lack true ACID transactions and favor [eventual consistency](#eventual-consistency).\n\n**BASE** is often used to describe the properties of NoSQL databases.  In comparison with the [CAP Theorem](#cap-theorem), BASE chooses availability over consistency.\n\n* **Basically available** - the system guarantees availability.\n* **Soft state** - the state of the system may change over time, even without input.\n* **Eventual consistency** - the system will become consistent over a period of time, given that the system doesn't receive input during that period.\n\nIn addition to choosing between [SQL or NoSQL](#sql-or-nosql), it is helpful to understand which type of NoSQL database best fits your use case(s).  We'll review **key-value stores**, **document stores**, **wide column stores**, and **graph databases** in the next section.\n\n#### Key-value store\n\n> Abstraction: hash table\n\nA key-value store generally allows for O(1) reads and writes and is often backed by memory or SSD.  Data stores can maintain keys in [lexicographic order](https://en.wikipedia.org/wiki/Lexicographical_order), allowing efficient retrieval of key ranges.  Key-value stores can allow for storing of metadata with a value.\n\nKey-value stores provide high performance and are often used for simple data models or for rapidly-changing data, such as an in-memory cache layer.  Since they offer only a limited set of operations, complexity is shifted to the application layer if additional operations are needed.\n\nA key-value store is the basis for more complex systems such as a document store, and in some cases, a graph database.\n\n##### Source(s) and further reading: key-value store\n\n* [Key-value database](https://en.wikipedia.org/wiki/Key-value_database)\n* [Disadvantages of key-value stores](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)\n* [Redis architecture](http://qnimate.com/overview-of-redis-architecture/)",
    "ContentSha": "+vnJh/M2dUlgEZ6CZbzhFf3VoeY7aJE4IGjH1bsbrm8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 핫스팟을 별도의 테이블로 분리하여 테이블을 나누면 메모리 유지에 도움이 됩니다.\n\n##### 쿼리 캐시 조정\n\n* 경우에 따라 [쿼리 캐시](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html)가 [성능 문제](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/)를 일으킬 수 있습니다.\n\n##### 출처 및 추가 읽기: SQL 튜닝\n\n* [MySQL 쿼리 최적화 팁](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)\n* [VARCHAR(255)가 자주 사용되는 합당한 이유가 있나요?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)\n* [NULL 값이 성능에 미치는 영향은?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)\n* [느린 쿼리 로그](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)\n\n### NoSQL\n\nNoSQL은 **키-값 저장소**, **문서 저장소**, **와이드 컬럼 저장소**, 또는 **그래프 데이터베이스**로 표현되는 데이터 항목들의 집합입니다. 데이터가 비정규화되어 있으며, 조인은 일반적으로 애플리케이션 코드에서 수행됩니다. 대부분의 NoSQL 저장소는 진정한 ACID 트랜잭션이 부족하며 [최종 일관성](#eventual-consistency)을 선호합니다.\n\n**BASE**는 종종 NoSQL 데이터베이스의 속성을 설명하는 데 사용됩니다. [CAP 정리](#cap-theorem)와 비교할 때, BASE는 일관성보다 가용성을 선택합니다.\n\n* **기본적으로 가용함** - 시스템은 가용성을 보장합니다.\n* **소프트 상태** - 입력이 없더라도 시스템 상태가 시간에 따라 변할 수 있습니다.\n* **최종 일관성** - 시스템이 일정 기간 동안 입력을 받지 않으면 그 기간 후에 일관성을 갖게 됩니다.\n\n[SQL 또는 NoSQL](#sql-or-nosql) 중 선택하는 것 외에도, 어떤 유형의 NoSQL 데이터베이스가 사용 사례에 가장 적합한지 이해하는 것이 도움이 됩니다. 다음 섹션에서 **키-값 저장소**, **문서 저장소**, **와이드 컬럼 저장소**, **그래프 데이터베이스**를 검토하겠습니다.\n\n#### 키-값 저장소\n\n> 추상화: 해시 테이블\n\n키-값 저장소는 일반적으로 O(1) 읽기 및 쓰기를 허용하며, 메모리 또는 SSD로 백업되는 경우가 많습니다. 데이터 저장소는 [사전식 순서](https://en.wikipedia.org/wiki/Lexicographical_order)로 키를 유지할 수 있어 키 범위의 효율적인 검색이 가능합니다. 키-값 저장소는 값과 함께 메타데이터 저장도 허용할 수 있습니다.\n\n키-값 저장소는 높은 성능을 제공하며 단순 데이터 모델이나 빠르게 변하는 데이터, 예를 들어 인메모리 캐시 계층에 자주 사용됩니다. 제한된 연산만 제공하기 때문에 추가 연산이 필요할 경우 복잡성이 애플리케이션 계층으로 전가됩니다.\n\n키-값 저장소는 문서 저장소나 경우에 따라 그래프 데이터베이스와 같은 더 복잡한 시스템의 기반입니다.\n\n##### 출처 및 추가 읽기: 키-값 저장소\n\n* [키-값 데이터베이스](https://en.wikipedia.org/wiki/Key-value_database)\n* [키-값 저장소의 단점](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)\n* [Redis 아키텍처](http://qnimate.com/overview-of-redis-architecture/)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 31,
    "Content": "* [Memcached architecture](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)\n\n#### Document store\n\n> Abstraction: key-value store with documents stored as values\n\nA document store is centered around documents (XML, JSON, binary, etc), where a document stores all information for a given object.  Document stores provide APIs or a query language to query based on the internal structure of the document itself.  *Note, many key-value stores include features for working with a value's metadata, blurring the lines between these two storage types.*\n\nBased on the underlying implementation, documents are organized by collections, tags, metadata, or directories.  Although documents can be organized or grouped together, documents may have fields that are completely different from each other.\n\nSome document stores like [MongoDB](https://www.mongodb.com/mongodb-architecture) and [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) also provide a SQL-like language to perform complex queries.  [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) supports both key-values and documents.\n\nDocument stores provide high flexibility and are often used for working with occasionally changing data.\n\n##### Source(s) and further reading: document store\n\n* [Document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database)\n* [MongoDB architecture](https://www.mongodb.com/mongodb-architecture)\n* [CouchDB architecture](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)\n* [Elasticsearch architecture](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)\n\n#### Wide column store\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png\">\n  <br/>\n  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Source: SQL & NoSQL, a brief history</a></i>\n</p>\n\n> Abstraction: nested map `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`\n\nA wide column store's basic unit of data is a column (name/value pair).  A column can be grouped in column families (analogous to a SQL table).  Super column families further group column families.  You can access each column independently with a row key, and columns with the same row key form a row.  Each value contains a timestamp for versioning and for conflict resolution.\n\nGoogle introduced [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) as the first wide column store, which influenced the open-source [HBase](https://www.edureka.co/blog/hbase-architecture/) often-used in the Hadoop ecosystem, and [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) from Facebook.  Stores such as BigTable, HBase, and Cassandra maintain keys in lexicographic order, allowing efficient retrieval of selective key ranges.\n\nWide column stores offer high availability and high scalability.  They are often used for very large data sets.\n\n##### Source(s) and further reading: wide column store\n\n* [SQL & NoSQL, a brief history](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)",
    "ContentSha": "qChjAGddKNc8A4k6Ydpi6HXYPt34LJFKDxqqAKCkrXw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Memcached 아키텍처](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)\n\n#### 문서 저장소\n\n> 추상화: 문서가 값으로 저장된 키-값 저장소\n\n문서 저장소는 문서(XML, JSON, 바이너리 등)를 중심으로 하며, 문서는 주어진 객체에 대한 모든 정보를 저장합니다. 문서 저장소는 문서 자체의 내부 구조를 기반으로 쿼리할 수 있는 API 또는 쿼리 언어를 제공합니다. *참고로, 많은 키-값 저장소는 값의 메타데이터를 다루는 기능을 포함하여 이 두 저장 유형의 경계를 모호하게 만듭니다.*\n\n기본 구현 방식에 따라 문서는 컬렉션, 태그, 메타데이터 또는 디렉터리로 조직됩니다. 문서들은 함께 조직되거나 그룹화될 수 있지만, 문서 간에 완전히 다른 필드를 가질 수도 있습니다.\n\n[MongoDB](https://www.mongodb.com/mongodb-architecture)와 [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)와 같은 일부 문서 저장소는 복잡한 쿼리를 수행하기 위해 SQL과 유사한 언어도 제공합니다. [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf)는 키-값과 문서 모두를 지원합니다.\n\n문서 저장소는 높은 유연성을 제공하며 가끔 변경되는 데이터 작업에 자주 사용됩니다.\n\n##### 출처 및 추가 읽을거리: 문서 저장소\n\n* [문서 지향 데이터베이스](https://en.wikipedia.org/wiki/Document-oriented_database)\n* [MongoDB 아키텍처](https://www.mongodb.com/mongodb-architecture)\n* [CouchDB 아키텍처](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)\n* [Elasticsearch 아키텍처](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)\n\n#### 와이드 컬럼 저장소\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png\">\n  <br/>\n  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>출처: SQL & NoSQL, 간단한 역사</a></i>\n</p>\n\n> 추상화: 중첩된 맵 `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`\n\n와이드 컬럼 저장소의 기본 데이터 단위는 컬럼(이름/값 쌍)입니다. 컬럼은 컬럼 패밀리( SQL 테이블에 상응)로 그룹화될 수 있습니다. 슈퍼 컬럼 패밀리는 컬럼 패밀리를 더 그룹화합니다. 각 컬럼은 행 키로 독립적으로 접근할 수 있고, 동일한 행 키를 가진 컬럼들이 행을 형성합니다. 각 값은 버전 관리 및 충돌 해결을 위한 타임스탬프를 포함합니다.\n\n구글은 최초의 와이드 컬럼 저장소인 [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)을 도입했으며, 이는 하둡 생태계에서 자주 사용되는 오픈소스 [HBase](https://www.edureka.co/blog/hbase-architecture/)와 페이스북의 [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)에 영향을 주었습니다. BigTable, HBase, Cassandra와 같은 저장소는 키를 사전식 순서로 유지하여 선택적 키 범위의 효율적 검색을 가능하게 합니다.\n\n와이드 컬럼 저장소는 높은 가용성과 높은 확장성을 제공합니다. 매우 큰 데이터 세트에 자주 사용됩니다.\n\n##### 출처 및 추가 읽을거리: 와이드 컬럼 저장소\n\n* [SQL & NoSQL, 간단한 역사](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 32,
    "Content": "* [Bigtable architecture](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)\n* [HBase architecture](https://www.edureka.co/blog/hbase-architecture/)\n* [Cassandra architecture](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)\n\n#### Graph database\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png\">\n  <br/>\n  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Source: Graph database</a></i>\n</p>\n\n> Abstraction: graph\n\nIn a graph database, each node is a record and each arc is a relationship between two nodes.  Graph databases are optimized to represent complex relationships with many foreign keys or many-to-many relationships.\n\nGraphs databases offer high performance for data models with complex relationships, such as a social network.  They are relatively new and are not yet widely-used; it might be more difficult to find development tools and resources.  Many graphs can only be accessed with [REST APIs](#representational-state-transfer-rest).\n\n##### Source(s) and further reading: graph\n\n* [Graph database](https://en.wikipedia.org/wiki/Graph_database)\n* [Neo4j](https://neo4j.com/)\n* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)\n\n#### Source(s) and further reading: NoSQL\n\n* [Explanation of base terminology](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)\n* [NoSQL databases a survey and decision guidance](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)\n* [Scalability](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n* [Introduction to NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)\n* [NoSQL patterns](http://horicky.blogspot.com/2009/11/nosql-patterns.html)\n\n### SQL or NoSQL\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Source: Transitioning from RDBMS to NoSQL</a></i>\n</p>\n",
    "ContentSha": "yvB08chNWcvF9yiu0b/QLR53EBOeWK574rgWXfnGOXg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [빅테이블 아키텍처](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)\n* [HBase 아키텍처](https://www.edureka.co/blog/hbase-architecture/)\n* [Cassandra 아키텍처](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)\n\n#### 그래프 데이터베이스\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png\">\n  <br/>\n  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>출처: 그래프 데이터베이스</a></i>\n</p>\n\n> 추상화: 그래프\n\n그래프 데이터베이스에서 각 노드는 레코드이고 각 호(arc)는 두 노드 간의 관계입니다. 그래프 데이터베이스는 많은 외래 키 또는 다대다 관계가 있는 복잡한 관계를 표현하는 데 최적화되어 있습니다.\n\n그래프 데이터베이스는 소셜 네트워크와 같은 복잡한 관계를 가진 데이터 모델에 대해 높은 성능을 제공합니다. 비교적 새롭고 아직 널리 사용되지 않았으며 개발 도구와 리소스를 찾기가 더 어려울 수 있습니다. 많은 그래프는 [REST API](#representational-state-transfer-rest)를 통해서만 접근할 수 있습니다.\n\n##### 출처 및 추가 읽을거리: 그래프\n\n* [그래프 데이터베이스](https://en.wikipedia.org/wiki/Graph_database)\n* [Neo4j](https://neo4j.com/)\n* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)\n\n#### 출처 및 추가 읽을거리: NoSQL\n\n* [BASE 용어 설명](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)\n* [NoSQL 데이터베이스 조사 및 결정 가이드](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)\n* [확장성](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n* [NoSQL 입문](https://www.youtube.com/watch?v=qI_g07C_Q5I)\n* [NoSQL 패턴](http://horicky.blogspot.com/2009/11/nosql-patterns.html)\n\n### SQL 또는 NoSQL\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>출처: RDBMS에서 NoSQL로의 전환</a></i>\n</p>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 33,
    "Content": "Reasons for **SQL**:\n\n* Structured data\n* Strict schema\n* Relational data\n* Need for complex joins\n* Transactions\n* Clear patterns for scaling\n* More established: developers, community, code, tools, etc\n* Lookups by index are very fast\n\nReasons for **NoSQL**:\n\n* Semi-structured data\n* Dynamic or flexible schema\n* Non-relational data\n* No need for complex joins\n* Store many TB (or PB) of data\n* Very data intensive workload\n* Very high throughput for IOPS\n\nSample data well-suited for NoSQL:\n\n* Rapid ingest of clickstream and log data\n* Leaderboard or scoring data\n* Temporary data, such as a shopping cart\n* Frequently accessed ('hot') tables\n* Metadata/lookup tables\n\n##### Source(s) and further reading: SQL or NoSQL\n\n* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n* [SQL vs NoSQL differences](https://www.sitepoint.com/sql-vs-nosql-differences/)\n\n## Cache\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>",
    "ContentSha": "s5JZtpzJOg6uZVhDykP9Uy+U/KEwjhNiySMSqZAIAwI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**SQL**의 이유:\n\n* 구조화된 데이터\n* 엄격한 스키마\n* 관계형 데이터\n* 복잡한 조인 필요\n* 트랜잭션\n* 명확한 확장 패턴\n* 더 확립됨: 개발자, 커뮤니티, 코드, 도구 등\n* 인덱스 조회가 매우 빠름\n\n**NoSQL**의 이유:\n\n* 반구조화된 데이터\n* 동적 또는 유연한 스키마\n* 비관계형 데이터\n* 복잡한 조인 불필요\n* 수 TB(또는 PB) 데이터 저장\n* 매우 데이터 집약적인 작업 부하\n* 매우 높은 IOPS 처리량\n\nNoSQL에 적합한 샘플 데이터:\n\n* 클릭스트림 및 로그 데이터의 빠른 수집\n* 리더보드 또는 점수 데이터\n* 쇼핑카트와 같은 임시 데이터\n* 자주 접근하는('핫') 테이블\n* 메타데이터/조회 테이블\n\n##### 출처 및 추가 읽을거리: SQL 또는 NoSQL\n\n* [처음 1,000만 사용자까지 확장하기](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n* [SQL과 NoSQL의 차이점](https://www.sitepoint.com/sql-vs-nosql-differences/)\n\n## 캐시\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>출처: 확장 가능한 시스템 설계 패턴</a></i>",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 34,
    "Content": "</p>\n\nCaching improves page load times and can reduce the load on your servers and databases.  In this model, the dispatcher will first lookup if the request has been made before and try to find the previous result to return, in order to save the actual execution.\n\nDatabases often benefit from a uniform distribution of reads and writes across its partitions.  Popular items can skew the distribution, causing bottlenecks.  Putting a cache in front of a database can help absorb uneven loads and spikes in traffic.\n\n### Client caching\n\nCaches can be located on the client side (OS or browser), [server side](#reverse-proxy-web-server), or in a distinct cache layer.\n\n### CDN caching\n\n[CDNs](#content-delivery-network) are considered a type of cache.\n\n### Web server caching\n\n[Reverse proxies](#reverse-proxy-web-server) and caches such as [Varnish](https://www.varnish-cache.org/) can serve static and dynamic content directly.  Web servers can also cache requests, returning responses without having to contact application servers.\n\n### Database caching\n\nYour database usually includes some level of caching in a default configuration, optimized for a generic use case.  Tweaking these settings for specific usage patterns can further boost performance.\n\n### Application caching\n\nIn-memory caches such as Memcached and Redis are key-value stores between your application and your data storage.  Since the data is held in RAM, it is much faster than typical databases where data is stored on disk.  RAM is more limited than disk, so [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms) algorithms such as [least recently used (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)) can help invalidate 'cold' entries and keep 'hot' data in RAM.\n\nRedis has the following additional features:\n\n* Persistence option\n* Built-in data structures such as sorted sets and lists\n\nThere are multiple levels you can cache that fall into two general categories: **database queries** and **objects**:\n\n* Row level\n* Query-level\n* Fully-formed serializable objects\n* Fully-rendered HTML\n\nGenerally, you should try to avoid file-based caching, as it makes cloning and auto-scaling more difficult.\n",
    "ContentSha": "PfUbgKkIJf45vxersAv0t5I8be53ZYhiGpd5NAhmomo=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "</p>\n\n캐싱은 페이지 로드 시간을 개선하고 서버 및 데이터베이스의 부하를 줄일 수 있습니다. 이 모델에서 디스패처는 먼저 요청이 이전에 이루어졌는지 확인하고, 이전 결과를 찾아 반환하여 실제 실행을 절약하려고 합니다.\n\n데이터베이스는 종종 파티션 전반에 걸쳐 읽기와 쓰기의 균일한 분포에서 이점을 얻습니다. 인기 있는 항목은 분포를 왜곡시켜 병목 현상을 초래할 수 있습니다. 데이터베이스 앞에 캐시를 두면 불균형한 부하와 트래픽 급증을 흡수하는 데 도움이 됩니다.\n\n### 클라이언트 캐싱\n\n캐시는 클라이언트 측(OS 또는 브라우저), [서버 측](#reverse-proxy-web-server) 또는 별도의 캐시 계층에 위치할 수 있습니다.\n\n### CDN 캐싱\n\n[CDN](#content-delivery-network)은 캐시의 한 종류로 간주됩니다.\n\n### 웹 서버 캐싱\n\n[리버스 프록시](#reverse-proxy-web-server) 및 [Varnish](https://www.varnish-cache.org/)와 같은 캐시는 정적 및 동적 콘텐츠를 직접 제공할 수 있습니다. 웹 서버는 요청을 캐시하여 애플리케이션 서버에 연락하지 않고도 응답을 반환할 수 있습니다.\n\n### 데이터베이스 캐싱\n\n데이터베이스는 일반적으로 기본 구성에서 어느 정도의 캐싱을 포함하며, 일반적인 사용 사례에 최적화되어 있습니다. 특정 사용 패턴에 맞게 이러한 설정을 조정하면 성능을 더욱 향상시킬 수 있습니다.\n\n### 애플리케이션 캐싱\n\nMemcached 및 Redis와 같은 메모리 내 캐시는 애플리케이션과 데이터 저장소 사이의 키-값 저장소입니다. 데이터가 RAM에 저장되기 때문에, 디스크에 데이터를 저장하는 일반 데이터베이스보다 훨씬 빠릅니다. RAM은 디스크보다 제한적이므로, [캐시 무효화](https://en.wikipedia.org/wiki/Cache_algorithms) 알고리즘인 [최소 최근 사용(LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)) 등이 '차가운' 항목을 무효화하고 '뜨거운' 데이터를 RAM에 유지하는 데 도움이 됩니다.\n\nRedis는 다음과 같은 추가 기능을 제공합니다:\n\n* 지속성 옵션\n* 정렬된 집합과 리스트 같은 내장 데이터 구조\n\n캐시할 수 있는 여러 수준이 있으며, 이는 일반적으로 두 가지 범주로 나뉩니다: **데이터베이스 쿼리**와 **객체**:\n\n* 행 수준\n* 쿼리 수준\n* 완전히 형성된 직렬화 가능한 객체\n* 완전히 렌더링된 HTML\n\n일반적으로 파일 기반 캐싱은 클로닝과 자동 확장을 어렵게 만들기 때문에 피하는 것이 좋습니다.\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 35,
    "Content": "### Caching at the database query level\n\nWhenever you query the database, hash the query as a key and store the result to the cache.  This approach suffers from expiration issues:\n\n* Hard to delete a cached result with complex queries\n* If one piece of data changes such as a table cell, you need to delete all cached queries that might include the changed cell\n\n### Caching at the object level\n\nSee your data as an object, similar to what you do with your application code.  Have your application assemble the dataset from the database into a class instance or a data structure(s):\n\n* Remove the object from cache if its underlying data has changed\n* Allows for asynchronous processing: workers assemble objects by consuming the latest cached object\n\nSuggestions of what to cache:\n\n* User sessions\n* Fully rendered web pages\n* Activity streams\n* User graph data\n\n### When to update the cache\n\nSince you can only store a limited amount of data in cache, you'll need to determine which cache update strategy works best for your use case.\n\n#### Cache-aside\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>\n</p>\n\nThe application is responsible for reading and writing from storage.  The cache does not interact with storage directly.  The application does the following:\n\n* Look for entry in cache, resulting in a cache miss\n* Load entry from the database\n* Add entry to cache\n* Return entry\n",
    "ContentSha": "1LZ2C/EUSShYNdt1FP+/fZdVQMcH8WGFigSx+nEiAZI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 데이터베이스 쿼리 레벨에서의 캐싱\n\n데이터베이스를 쿼리할 때마다 쿼리를 키로 해싱하고 결과를 캐시에 저장합니다. 이 접근법은 만료 문제를 겪습니다:\n\n* 복잡한 쿼리로 캐시된 결과를 삭제하기 어려움\n* 테이블 셀과 같은 데이터 한 조각이 변경되면, 변경된 셀을 포함할 수 있는 모든 캐시된 쿼리를 삭제해야 함\n\n### 객체 레벨에서의 캐싱\n\n데이터를 애플리케이션 코드에서 하는 것처럼 객체로 봅니다. 애플리케이션이 데이터베이스에서 데이터셋을 클래스 인스턴스나 데이터 구조로 조립하도록 합니다:\n\n* 기본 데이터가 변경되면 객체를 캐시에서 제거\n* 비동기 처리 가능: 작업자가 최신 캐시된 객체를 소비하여 객체를 조립함\n\n캐시할 항목 제안:\n\n* 사용자 세션\n* 완전히 렌더링된 웹 페이지\n* 활동 스트림\n* 사용자 그래프 데이터\n\n### 캐시를 언제 업데이트할지\n\n캐시에 저장할 수 있는 데이터가 제한적이므로, 어떤 캐시 업데이트 전략이 귀하의 사용 사례에 가장 적합한지 결정해야 합니다.\n\n#### 캐시-어사이드\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>출처: 캐시에서 인메모리 데이터 그리드로</a></i>\n</p>\n\n애플리케이션이 저장소에서 읽기 및 쓰기를 담당합니다. 캐시는 저장소와 직접 상호작용하지 않습니다. 애플리케이션은 다음을 수행합니다:\n\n* 캐시에서 항목을 찾으나 캐시 미스 발생\n* 데이터베이스에서 항목을 로드\n* 항목을 캐시에 추가\n* 항목을 반환\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 36,
    "Content": "```python\ndef get_user(self, user_id):\n    user = cache.get(\"user.{0}\", user_id)\n    if user is None:\n        user = db.query(\"SELECT * FROM users WHERE user_id = {0}\", user_id)\n        if user is not None:\n            key = \"user.{0}\".format(user_id)\n            cache.set(key, json.dumps(user))\n    return user\n```",
    "ContentSha": "oOOkxiaDDsfJgZibD4WyvNCLh494Kkw0zeQUjNF+dKA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\ndef get_user(self, user_id):\n    user = cache.get(\"user.{0}\", user_id)\n    if user is None:\n        user = db.query(\"SELECT * FROM users WHERE user_id = {0}\", user_id)\n        if user is not None:\n            key = \"user.{0}\".format(user_id)\n            cache.set(key, json.dumps(user))\n    return user\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 37,
    "Content": "\n[Memcached](https://memcached.org/) is generally used in this manner.\n\nSubsequent reads of data added to cache are fast.  Cache-aside is also referred to as lazy loading.  Only requested data is cached, which avoids filling up the cache with data that isn't requested.\n\n##### Disadvantage(s): cache-aside\n\n* Each cache miss results in three trips, which can cause a noticeable delay.\n* Data can become stale if it is updated in the database.  This issue is mitigated by setting a time-to-live (TTL) which forces an update of the cache entry, or by using write-through.\n* When a node fails, it is replaced by a new, empty node, increasing latency.\n\n#### Write-through\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nThe application uses the cache as the main data store, reading and writing data to it, while the cache is responsible for reading and writing to the database:\n\n* Application adds/updates entry in cache\n* Cache synchronously writes entry to data store\n* Return\n\nApplication code:\n",
    "ContentSha": "fTUxdhUP8C+msOuO6oFCQBKVESfJlBRIv+xTex+NRH4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "[Memcached](https://memcached.org/)는 일반적으로 다음과 같은 방식으로 사용됩니다.\n\n캐시에 추가된 데이터의 후속 읽기는 빠릅니다. 캐시 어사이드는 지연 로딩(lazy loading)이라고도 합니다. 요청된 데이터만 캐시에 저장되므로 요청되지 않은 데이터로 캐시가 가득 차는 것을 방지합니다.\n\n##### 단점: 캐시 어사이드\n\n* 각 캐시 미스는 세 번의 왕복을 발생시켜 눈에 띄는 지연을 초래할 수 있습니다.\n* 데이터가 데이터베이스에서 업데이트되면 오래된 데이터가 될 수 있습니다. 이 문제는 TTL(time-to-live)을 설정하여 캐시 항목의 업데이트를 강제하거나 쓰기 쓰루(write-through)를 사용하여 완화됩니다.\n* 노드가 실패하면 새롭고 빈 노드로 교체되어 지연 시간이 증가합니다.\n\n#### 쓰기 쓰루(write-through)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>출처: Scalability, availability, stability, patterns</a></i>\n</p>\n\n애플리케이션은 캐시를 주요 데이터 저장소로 사용하며, 캐시가 데이터베이스에 대해 읽기 및 쓰기를 담당하는 동안 데이터를 읽고 씁니다:\n\n* 애플리케이션이 캐시에 항목을 추가/업데이트합니다.\n* 캐시는 동기적으로 데이터 저장소에 항목을 씁니다.\n* 반환\n\n애플리케이션 코드:\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 38,
    "Content": "```python\nset_user(12345, {\"foo\":\"bar\"})\n```",
    "ContentSha": "7tpMTtbDSdUbs+oC+Qf5dKLGCUAcRFUe6DfcgSYQP7c=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\nset_user(12345, {\"foo\":\"bar\"})\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 39,
    "Content": "\nCache code:\n",
    "ContentSha": "3TQIz863VWmVTS8NeQVBQ2s9apIl1JpwXxyAqo7YRXU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "캐시 코드:\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 40,
    "Content": "```python\ndef set_user(user_id, values):\n    user = db.query(\"UPDATE Users WHERE id = {0}\", user_id, values)\n    cache.set(user_id, user)\n```",
    "ContentSha": "2/SVlo2Tq+z8vN6s72UuRvXSio2ONq8aOqxj7V/g+MY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\ndef set_user(user_id, values):\n    user = db.query(\"UPDATE Users WHERE id = {0}\", user_id, values)\n    cache.set(user_id, user)\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 41,
    "Content": "\nWrite-through is a slow overall operation due to the write operation, but subsequent reads of just written data are fast.  Users are generally more tolerant of latency when updating data than reading data.  Data in the cache is not stale.\n\n##### Disadvantage(s): write through\n\n* When a new node is created due to failure or scaling, the new node will not cache entries until the entry is updated in the database.  Cache-aside in conjunction with write through can mitigate this issue.\n* Most data written might never be read, which can be minimized with a TTL.\n\n#### Write-behind (write-back)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nIn write-behind, the application does the following:\n\n* Add/update entry in cache\n* Asynchronously write entry to the data store, improving write performance\n\n##### Disadvantage(s): write-behind\n\n* There could be data loss if the cache goes down prior to its contents hitting the data store.\n* It is more complex to implement write-behind than it is to implement cache-aside or write-through.\n\n#### Refresh-ahead\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>\n</p>\n\nYou can configure the cache to automatically refresh any recently accessed cache entry prior to its expiration.\n\nRefresh-ahead can result in reduced latency vs read-through if the cache can accurately predict which items are likely to be needed in the future.\n\n##### Disadvantage(s): refresh-ahead\n",
    "ContentSha": "7f5A+XWrDoL377SvEQn7a+GkFngcY2VPIRUi5SDADy0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "Write-through는 쓰기 작업으로 인해 전반적으로 느린 작업이지만, 방금 쓴 데이터에 대한 후속 읽기는 빠릅니다. 사용자는 일반적으로 데이터를 업데이트할 때보다 데이터를 읽을 때 지연에 더 민감합니다. 캐시의 데이터는 오래되지 않았습니다.\n\n##### 단점: write through\n\n* 장애나 확장으로 인해 새 노드가 생성되면, 데이터베이스에서 항목이 업데이트될 때까지 새 노드는 항목을 캐시하지 않습니다. write through와 함께 cache-aside를 사용하면 이 문제를 완화할 수 있습니다.\n* 대부분의 쓰여진 데이터는 읽히지 않을 수 있으며, 이는 TTL로 최소화할 수 있습니다.\n\n#### Write-behind (write-back)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>출처: 확장성, 가용성, 안정성, 패턴</a></i>\n</p>\n\nwrite-behind에서 애플리케이션은 다음을 수행합니다:\n\n* 캐시에 항목 추가/업데이트\n* 비동기적으로 항목을 데이터 저장소에 기록하여 쓰기 성능 향상\n\n##### 단점: write-behind\n\n* 캐시가 데이터 저장소에 내용이 기록되기 전에 다운되면 데이터 손실이 발생할 수 있습니다.\n* write-behind 구현은 cache-aside나 write-through 구현보다 더 복잡합니다.\n\n#### Refresh-ahead\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>출처: 캐시에서 인메모리 데이터 그리드로</a></i>\n</p>\n\n캐시가 만료되기 전에 최근에 액세스한 캐시 항목을 자동으로 갱신하도록 구성할 수 있습니다.\n\nRefresh-ahead는 캐시가 앞으로 필요할 가능성이 높은 항목을 정확히 예측할 수 있으면 read-through 대비 지연 시간을 줄일 수 있습니다.\n\n##### 단점: refresh-ahead\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 42,
    "Content": "* Not accurately predicting which items are likely to be needed in the future can result in reduced performance than without refresh-ahead.\n\n### Disadvantage(s): cache\n\n* Need to maintain consistency between caches and the source of truth such as the database through [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms).\n* Cache invalidation is a difficult problem, there is additional complexity associated with when to update the cache.\n* Need to make application changes such as adding Redis or memcached.\n\n### Source(s) and further reading\n\n* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)\n* [Scalable system design patterns](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)\n* [Introduction to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [Scalability](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n* [AWS ElastiCache strategies](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)\n* [Wikipedia](https://en.wikipedia.org/wiki/Cache_(computing))\n\n## Asynchronism\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png\">\n  <br/>\n  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>\n</p>\n\nAsynchronous workflows help reduce request times for expensive operations that would otherwise be performed in-line.  They can also help by doing time-consuming work in advance, such as periodic aggregation of data.\n\n### Message queues\n\nMessage queues receive, hold, and deliver messages.  If an operation is too slow to perform inline, you can use a message queue with the following workflow:\n\n* An application publishes a job to the queue, then notifies the user of job status\n* A worker picks up the job from the queue, processes it, then signals the job is complete\n\nThe user is not blocked and the job is processed in the background.  During this time, the client might optionally do a small amount of processing to make it seem like the task has completed.  For example, if posting a tweet, the tweet could be instantly posted to your timeline, but it could take some time before your tweet is actually delivered to all of your followers.\n\n**[Redis](https://redis.io/)** is useful as a simple message broker but messages can be lost.\n\n**[RabbitMQ](https://www.rabbitmq.com/)** is popular but requires you to adapt to the 'AMQP' protocol and manage your own nodes.",
    "ContentSha": "m5CQKaSxoSpqZLBi9DEuTpec6TQ1PuzDQenhKpH7SUw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 미래에 필요할 가능성이 높은 항목을 정확하게 예측하지 못하면 리프레시 어헤드 없이 사용하는 것보다 성능이 저하될 수 있습니다.\n\n### 단점: 캐시\n\n* 캐시와 데이터베이스와 같은 진실의 원천(source of truth) 간의 일관성을 [캐시 무효화](https://en.wikipedia.org/wiki/Cache_algorithms)를 통해 유지해야 합니다.\n* 캐시 무효화는 어려운 문제이며, 캐시를 언제 업데이트할지에 대한 추가적인 복잡성이 있습니다.\n* Redis나 memcached 추가와 같은 애플리케이션 변경이 필요합니다.\n\n### 출처 및 추가 읽을거리\n\n* [캐시에서 인메모리 데이터 그리드로](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)\n* [확장 가능한 시스템 설계 패턴](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)\n* [확장을 위한 시스템 설계 소개](http://lethain.com/introduction-to-architecting-systems-for-scale/)\n* [확장성, 가용성, 안정성, 패턴](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [확장성](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n* [AWS ElastiCache 전략](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)\n* [위키백과](https://en.wikipedia.org/wiki/Cache_(computing))\n\n## 비동기 처리\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png\">\n  <br/>\n  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>출처: 확장을 위한 시스템 설계 소개</a></i>\n</p>\n\n비동기 워크플로우는 인라인으로 수행하면 시간이 많이 걸리는 작업에 대한 요청 시간을 줄이는 데 도움이 됩니다. 또한 데이터의 주기적 집계와 같이 시간이 많이 걸리는 작업을 미리 수행하는 데도 도움이 됩니다.\n\n### 메시지 큐\n\n메시지 큐는 메시지를 수신, 보관, 전달합니다. 작업이 인라인으로 수행하기에 너무 느리면 다음과 같은 워크플로우로 메시지 큐를 사용할 수 있습니다:\n\n* 애플리케이션이 작업을 큐에 게시한 후 사용자에게 작업 상태를 알립니다.\n* 워커가 큐에서 작업을 가져와 처리한 후 작업이 완료되었음을 알립니다.\n\n사용자는 차단되지 않으며 작업은 백그라운드에서 처리됩니다. 이 동안 클라이언트는 작업이 완료된 것처럼 보이게 하기 위해 소량의 처리를 선택적으로 할 수 있습니다. 예를 들어, 트윗을 게시할 때 트윗은 즉시 타임라인에 게시되지만 실제로 모든 팔로워에게 전달되기까지 시간이 걸릴 수 있습니다.\n\n**[Redis](https://redis.io/)** 는 간단한 메시지 브로커로 유용하지만 메시지가 손실될 수 있습니다.\n\n**[RabbitMQ](https://www.rabbitmq.com/)** 는 인기가 있지만 'AMQP' 프로토콜에 적응하고 자체 노드를 관리해야 합니다.",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 43,
    "Content": "\n**[Amazon SQS](https://aws.amazon.com/sqs/)** is hosted but can have high latency and has the possibility of messages being delivered twice.\n\n### Task queues\n\nTasks queues receive tasks and their related data, runs them, then delivers their results.  They can support scheduling and can be used to run computationally-intensive jobs in the background.\n\n**[Celery](https://docs.celeryproject.org/en/stable/)** has support for scheduling and primarily has python support.\n\n### Back pressure\n\nIf queues start to grow significantly, the queue size can become larger than memory, resulting in cache misses, disk reads, and even slower performance.  [Back pressure](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) can help by limiting the queue size, thereby maintaining a high throughput rate and good response times for jobs already in the queue.  Once the queue fills up, clients get a server busy or HTTP 503 status code to try again later.  Clients can retry the request at a later time, perhaps with [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff).\n\n### Disadvantage(s): asynchronism\n\n* Use cases such as inexpensive calculations and realtime workflows might be better suited for synchronous operations, as introducing queues can add delays and complexity.\n\n### Source(s) and further reading\n\n* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)\n* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)\n* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)\n* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)\n\n## Communication\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg\">\n  <br/>\n  <i><a href=http://www.escotal.com/osilayer.html>Source: OSI 7 layer model</a></i>\n</p>\n\n### Hypertext transfer protocol (HTTP)\n\nHTTP is a method for encoding and transporting data between a client and a server.  It is a request/response protocol: clients issue requests and servers issue responses with relevant content and completion status info about the request.  HTTP is self-contained, allowing requests and responses to flow through many intermediate routers and servers that perform load balancing, caching, encryption, and compression.\n\nA basic HTTP request consists of a verb (method) and a resource (endpoint).  Below are common HTTP verbs:\n\n| Verb | Description | Idempotent* | Safe | Cacheable |\n|---|---|---|---|---|",
    "ContentSha": "EQovDG9OkNb9dVypgpzwJggXSXWXdn7svWuM8fLZ6Es=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**[Amazon SQS](https://aws.amazon.com/sqs/)**는 호스팅되는 서비스이지만 지연 시간이 높을 수 있으며 메시지가 두 번 전달될 가능성이 있습니다.\n\n### 작업 큐\n\n작업 큐는 작업과 관련 데이터를 받아 실행한 후 결과를 전달합니다. 스케줄링을 지원할 수 있으며, 백그라운드에서 계산 집약적인 작업을 실행하는 데 사용할 수 있습니다.\n\n**[Celery](https://docs.celeryproject.org/en/stable/)**는 스케줄링을 지원하며 주로 파이썬을 지원합니다.\n\n### 역압(Back pressure)\n\n큐가 크게 증가하기 시작하면 큐 크기가 메모리보다 커져 캐시 미스, 디스크 읽기 및 더 느린 성능이 발생할 수 있습니다. [역압](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)은 큐 크기를 제한하여 이미 큐에 있는 작업의 높은 처리량과 좋은 응답 시간을 유지하는 데 도움을 줄 수 있습니다. 큐가 가득 차면 클라이언트는 서버 바쁨 또는 HTTP 503 상태 코드를 받아 나중에 다시 시도합니다. 클라이언트는 나중에 요청을 재시도할 수 있으며, [지수 백오프](https://en.wikipedia.org/wiki/Exponential_backoff)를 사용할 수도 있습니다.\n\n### 단점: 비동기성\n\n* 저렴한 계산이나 실시간 워크플로우 같은 사용 사례는 큐 도입으로 인해 지연과 복잡성이 증가할 수 있으므로 동기식 작업에 더 적합할 수 있습니다.\n\n### 출처 및 추가 읽을거리\n\n* [모든 것은 숫자 게임이다](https://www.youtube.com/watch?v=1KRYH75wgy4)\n* [과부하 시 역압 적용하기](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)\n* [리틀의 법칙](https://en.wikipedia.org/wiki/Little%27s_law)\n* [메시지 큐와 작업 큐의 차이점은 무엇인가?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)\n\n## 통신\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg\">\n  <br/>\n  <i><a href=http://www.escotal.com/osilayer.html>출처: OSI 7 계층 모델</a></i>\n</p>\n\n### 하이퍼텍스트 전송 프로토콜(HTTP)\n\nHTTP는 클라이언트와 서버 간에 데이터를 인코딩하고 전송하는 방법입니다. 요청/응답 프로토콜로서, 클라이언트가 요청을 보내면 서버가 관련 콘텐츠와 요청 완료 상태 정보를 담은 응답을 보냅니다. HTTP는 자체 포함형으로, 요청과 응답이 부하 분산, 캐싱, 암호화, 압축을 수행하는 여러 중간 라우터와 서버를 통해 흐를 수 있습니다.\n\n기본 HTTP 요청은 동사(메서드)와 자원(엔드포인트)으로 구성됩니다. 아래는 일반적인 HTTP 동사입니다:\n\n| 동사 | 설명 | 멱등성* | 안전성 | 캐시 가능 |\n|---|---|---|---|---|\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 44,
    "Content": "| GET | Reads a resource | Yes | Yes | Yes |\n| POST | Creates a resource or trigger a process that handles data | No | No | Yes if response contains freshness info |\n| PUT | Creates or replace a resource | Yes | No | No |\n| PATCH | Partially updates a resource | No | No | Yes if response contains freshness info |\n| DELETE | Deletes a resource | Yes | No | No |\n\n*Can be called many times without different outcomes.\n\nHTTP is an application layer protocol relying on lower-level protocols such as **TCP** and **UDP**.\n\n#### Source(s) and further reading: HTTP\n\n* [What is HTTP?](https://www.nginx.com/resources/glossary/http/)\n* [Difference between HTTP and TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)\n* [Difference between PUT and PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)\n\n### Transmission control protocol (TCP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>\n</p>\n\nTCP is a connection-oriented protocol over an [IP network](https://en.wikipedia.org/wiki/Internet_Protocol).  Connection is established and terminated using a [handshake](https://en.wikipedia.org/wiki/Handshaking).  All packets sent are guaranteed to reach the destination in the original order and without corruption through:\n\n* Sequence numbers and [checksum fields](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) for each packet\n* [Acknowledgement](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) packets and automatic retransmission\n\nIf the sender does not receive a correct response, it will resend the packets.  If there are multiple timeouts, the connection is dropped.  TCP also implements [flow control](https://en.wikipedia.org/wiki/Flow_control_(data)) and [congestion control](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control).  These guarantees cause delays and generally result in less efficient transmission than UDP.\n\nTo ensure high throughput, web servers can keep a large number of TCP connections open, resulting in high memory usage.  It can be expensive to have a large number of open connections between web server threads and say, a [memcached](https://memcached.org/) server.  [Connection pooling](https://en.wikipedia.org/wiki/Connection_pool) can help in addition to switching to UDP where applicable.\n\nTCP is useful for applications that require high reliability but are less time critical.  Some examples include web servers, database info, SMTP, FTP, and SSH.\n\nUse TCP over UDP when:\n\n* You need all of the data to arrive intact\n* You want to automatically make a best estimate use of the network throughput\n",
    "ContentSha": "EP5TmrahE1oj6DWbBMp+YEc76iteUbB8TKDGw6d8MFY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| GET | 리소스를 읽음 | 예 | 예 | 예 |\n| POST | 리소스를 생성하거나 데이터를 처리하는 프로세스를 트리거함 | 아니오 | 아니오 | 응답에 최신 정보가 포함된 경우 예 |\n| PUT | 리소스를 생성하거나 교체함 | 예 | 아니오 | 아니오 |\n| PATCH | 리소스를 부분적으로 업데이트함 | 아니오 | 아니오 | 응답에 최신 정보가 포함된 경우 예 |\n| DELETE | 리소스를 삭제함 | 예 | 아니오 | 아니오 |\n\n*다른 결과 없이 여러 번 호출할 수 있음.\n\nHTTP는 **TCP** 및 **UDP**와 같은 하위 계층 프로토콜에 의존하는 애플리케이션 계층 프로토콜임.\n\n#### 출처 및 추가 읽을거리: HTTP\n\n* [HTTP란?](https://www.nginx.com/resources/glossary/http/)\n* [HTTP와 TCP의 차이점](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)\n* [PUT과 PATCH의 차이점](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)\n\n### 전송 제어 프로토콜 (TCP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>출처: 멀티플레이어 게임 만드는 법</a></i>\n</p>\n\nTCP는 [IP 네트워크](https://en.wikipedia.org/wiki/Internet_Protocol) 위의 연결 지향 프로토콜임. 연결은 [핸드셰이크](https://en.wikipedia.org/wiki/Handshaking)를 사용하여 설정되고 종료됨. 모든 전송된 패킷은 다음을 통해 원래 순서대로 손상 없이 목적지에 도달함이 보장됨:\n\n* 각 패킷에 대한 시퀀스 번호 및 [체크섬 필드](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation)\n* [승인 응답](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) 패킷 및 자동 재전송\n\n발신자가 올바른 응답을 받지 못하면 패킷을 재전송함. 여러 번 타임아웃이 발생하면 연결이 끊어짐. TCP는 또한 [흐름 제어](https://en.wikipedia.org/wiki/Flow_control_(data))와 [혼잡 제어](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control)를 구현함. 이러한 보장은 지연을 초래하며 일반적으로 UDP보다 전송 효율이 낮음.\n\n높은 처리량을 보장하기 위해 웹 서버는 많은 수의 TCP 연결을 유지할 수 있으며, 이는 높은 메모리 사용량을 초래함. 웹 서버 스레드와 예를 들어 [memcached](https://memcached.org/) 서버 간에 많은 수의 열린 연결을 유지하는 것은 비용이 많이 들 수 있음. [연결 풀링](https://en.wikipedia.org/wiki/Connection_pool)은 UDP로 전환하는 것과 더불어 도움이 될 수 있음.\n\nTCP는 높은 신뢰성이 필요하지만 시간에 덜 민감한 애플리케이션에 유용함. 예로는 웹 서버, 데이터베이스 정보, SMTP, FTP 및 SSH 등이 있음.\n\nUDP보다 TCP를 사용해야 하는 경우:\n\n* 모든 데이터가 온전하게 도착해야 할 때\n* 네트워크 처리량을 자동으로 최적 추정하여 사용하고자 할 때\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 45,
    "Content": "### User datagram protocol (UDP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>\n</p>\n\nUDP is connectionless.  Datagrams (analogous to packets) are guaranteed only at the datagram level.  Datagrams might reach their destination out of order or not at all.  UDP does not support congestion control.  Without the guarantees that TCP support, UDP is generally more efficient.\n\nUDP can broadcast, sending datagrams to all devices on the subnet.  This is useful with [DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) because the client has not yet received an IP address, thus preventing a way for TCP to stream without the IP address.\n\nUDP is less reliable but works well in real time use cases such as VoIP, video chat, streaming, and realtime multiplayer games.\n\nUse UDP over TCP when:\n\n* You need the lowest latency\n* Late data is worse than loss of data\n* You want to implement your own error correction\n\n#### Source(s) and further reading: TCP and UDP\n\n* [Networking for game programming](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)\n* [Key differences between TCP and UDP protocols](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)\n* [Difference between TCP and UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)\n* [Transmission control protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)\n* [User datagram protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)\n* [Scaling memcache at Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)\n\n### Remote procedure call (RPC)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png\">\n  <br/>\n  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Source: Crack the system design interview</a></i>\n</p>\n\nIn an RPC, a client causes a procedure to execute on a different address space, usually a remote server.  The procedure is coded as if it were a local procedure call, abstracting away the details of how to communicate with the server from the client program.  Remote calls are usually slower and less reliable than local calls so it is helpful to distinguish RPC calls from local calls.  Popular RPC frameworks include [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/), and [Avro](https://avro.apache.org/docs/current/).\n\nRPC is a request-response protocol:",
    "ContentSha": "qWH5LAPvggn7k7ivyK8v6v8/pTXkZRoURbzBFakhSEM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 사용자 데이터그램 프로토콜 (UDP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>출처: 멀티플레이어 게임 만드는 방법</a></i>\n</p>\n\nUDP는 연결 지향적이지 않습니다. 데이터그램(패킷에 해당)은 데이터그램 수준에서만 보장됩니다. 데이터그램은 순서가 뒤바뀌어 도착하거나 전혀 도착하지 않을 수 있습니다. UDP는 혼잡 제어를 지원하지 않습니다. TCP가 지원하는 보장 없이, UDP는 일반적으로 더 효율적입니다.\n\nUDP는 서브넷 내 모든 장치에 데이터그램을 브로드캐스트할 수 있습니다. 이는 클라이언트가 아직 IP 주소를 받지 않은 상태이므로 TCP가 IP 주소 없이 스트리밍할 수 없게 하는 DHCP에서 유용합니다.\n\nUDP는 신뢰성은 떨어지지만 VoIP, 영상 통화, 스트리밍, 실시간 멀티플레이어 게임과 같은 실시간 사용 사례에 적합합니다.\n\nTCP 대신 UDP를 사용해야 할 때:\n\n* 가장 낮은 지연 시간이 필요할 때\n* 늦은 데이터가 데이터 손실보다 나쁠 때\n* 자체 오류 수정 구현을 원할 때\n\n#### 출처 및 추가 읽기: TCP 및 UDP\n\n* [게임 프로그래밍을 위한 네트워킹](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)\n* [TCP와 UDP 프로토콜의 주요 차이점](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)\n* [TCP와 UDP의 차이](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)\n* [전송 제어 프로토콜](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)\n* [사용자 데이터그램 프로토콜](https://en.wikipedia.org/wiki/User_Datagram_Protocol)\n* [페이스북에서의 메모리캐시 확장](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)\n\n### 원격 프로시저 호출 (RPC)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png\">\n  <br/>\n  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>출처: 시스템 설계 인터뷰 공략</a></i>\n</p>\n\nRPC에서는 클라이언트가 다른 주소 공간, 보통 원격 서버에서 프로시저를 실행하도록 합니다. 프로시저는 로컬 프로시저 호출인 것처럼 코딩되어, 클라이언트 프로그램으로부터 서버와 통신하는 세부 사항을 추상화합니다. 원격 호출은 보통 로컬 호출보다 느리고 신뢰성이 떨어지므로 RPC 호출과 로컬 호출을 구분하는 것이 유용합니다. 널리 사용되는 RPC 프레임워크로는 [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/), [Avro](https://avro.apache.org/docs/current/)가 있습니다.\n\nRPC는 요청-응답 프로토콜입니다:",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 46,
    "Content": "\n* **Client program** - Calls the client stub procedure.  The parameters are pushed onto the stack like a local procedure call.\n* **Client stub procedure** - Marshals (packs) procedure id and arguments into a request message.\n* **Client communication module** - OS sends the message from the client to the server.\n* **Server communication module** - OS passes the incoming packets to the server stub procedure.\n* **Server stub procedure** -  Unmarshalls the results, calls the server procedure matching the procedure id and passes the given arguments.\n* The server response repeats the steps above in reverse order.\n\nSample RPC calls:\n",
    "ContentSha": "5PmI2LbQPBewUn/2iz277V+TkEFWqKJeqfFmrsij1fA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* **클라이언트 프로그램** - 클라이언트 스텁 프로시저를 호출합니다. 매개변수는 로컬 프로시저 호출처럼 스택에 푸시됩니다.\n* **클라이언트 스텁 프로시저** - 프로시저 ID와 인수를 요청 메시지로 마샬링(패킹)합니다.\n* **클라이언트 통신 모듈** - OS가 클라이언트에서 서버로 메시지를 전송합니다.\n* **서버 통신 모듈** - OS가 들어오는 패킷을 서버 스텁 프로시저로 전달합니다.\n* **서버 스텁 프로시저** - 결과를 언마샬링하고, 프로시저 ID에 맞는 서버 프로시저를 호출하며 주어진 인수를 전달합니다.\n* 서버 응답은 위 단계를 역순으로 반복합니다.\n\n샘플 RPC 호출:\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 47,
    "Content": "```\nGET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  \"data\":\"anId\";\n  \"anotherdata\": \"another value\"\n}\n```",
    "ContentSha": "BYLxUnd5OWhXrWTwm++n0cxi7AnIAvtoL/RnYPfjXXk=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nGET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  \"data\":\"anId\";\n  \"anotherdata\": \"another value\"\n}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 48,
    "Content": "\nRPC is focused on exposing behaviors.  RPCs are often used for performance reasons with internal communications, as you can hand-craft native calls to better fit your use cases.\n\nChoose a native library (aka SDK) when:\n\n* You know your target platform.\n* You want to control how your \"logic\" is accessed.\n* You want to control how error control happens off your library.\n* Performance and end user experience is your primary concern.\n\nHTTP APIs following **REST** tend to be used more often for public APIs.\n\n#### Disadvantage(s): RPC\n\n* RPC clients become tightly coupled to the service implementation.\n* A new API must be defined for every new operation or use case.\n* It can be difficult to debug RPC.\n* You might not be able to leverage existing technologies out of the box.  For example, it might require additional effort to ensure [RPC calls are properly cached](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) on caching servers such as [Squid](http://www.squid-cache.org/).\n\n### Representational state transfer (REST)\n\nREST is an architectural style enforcing a client/server model where the client acts on a set of resources managed by the server.  The server provides a representation of resources and actions that can either manipulate or get a new representation of resources.  All communication must be stateless and cacheable.\n\nThere are four qualities of a RESTful interface:\n\n* **Identify resources (URI in HTTP)** - use the same URI regardless of any operation.\n* **Change with representations (Verbs in HTTP)** - use verbs, headers, and body.\n* **Self-descriptive error message (status response in HTTP)** - Use status codes, don't reinvent the wheel.\n* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML interface for HTTP)** - your web service should be fully accessible in a browser.\n\nSample REST calls:\n",
    "ContentSha": "Rt/8zO9jLRQq0DxNqYrouOd/1z3QvXPXQYsN4u7rca0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "RPC는 동작을 노출하는 데 중점을 둡니다. RPC는 내부 통신에서 성능상의 이유로 자주 사용되며, 특정 사용 사례에 더 잘 맞도록 네이티브 호출을 수작업으로 작성할 수 있습니다.\n\n네이티브 라이브러리(즉, SDK)를 선택할 때:\n\n* 대상 플랫폼을 알고 있을 때.\n* \"로직\"에 대한 접근 방식을 제어하고 싶을 때.\n* 라이브러리 밖에서 오류 제어 방식을 제어하고 싶을 때.\n* 성능과 최종 사용자 경험이 주요 관심사일 때.\n\n**REST**를 따르는 HTTP API는 공개 API에 더 자주 사용되는 경향이 있습니다.\n\n#### 단점: RPC\n\n* RPC 클라이언트는 서비스 구현에 밀접하게 결합됩니다.\n* 새로운 작업이나 사용 사례마다 새로운 API를 정의해야 합니다.\n* RPC를 디버깅하기 어려울 수 있습니다.\n* 기존 기술을 바로 활용하지 못할 수 있습니다. 예를 들어, [RPC 호출이 적절히 캐시되는지](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) [Squid](http://www.squid-cache.org/) 같은 캐싱 서버에서 추가 노력이 필요할 수 있습니다.\n\n### 표현 상태 전송 (REST)\n\nREST는 클라이언트가 서버가 관리하는 자원 집합에 작용하는 클라이언트/서버 모델을 강제하는 아키텍처 스타일입니다. 서버는 자원과 자원을 조작하거나 새로운 자원 표현을 얻을 수 있는 동작의 표현을 제공합니다. 모든 통신은 무상태이며 캐시 가능해야 합니다.\n\nRESTful 인터페이스의 네 가지 특성:\n\n* **자원 식별(HTTP의 URI)** - 모든 작업에 대해 동일한 URI 사용.\n* **표현으로 변경(HTTP의 동사)** - 동사, 헤더, 본문 사용.\n* **자기 설명적 오류 메시지(HTTP의 상태 응답)** - 상태 코드를 사용하며, 새로운 방식 고안 금지.\n* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTTP용 HTML 인터페이스)** - 웹 서비스는 브라우저에서 완전히 접근 가능해야 함.\n\nREST 호출 샘플:\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 49,
    "Content": "```\nGET /someresources/anId\n\nPUT /someresources/anId\n{\"anotherdata\": \"another value\"}\n```",
    "ContentSha": "LfYrdSaJCXPWw5FeIGqODwCXjq6vLSYullHQ6dtLt9M=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nGET /someresources/anId\n\nPUT /someresources/anId\n{\"anotherdata\": \"another value\"}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 50,
    "Content": "\nREST is focused on exposing data.  It minimizes the coupling between client/server and is often used for public HTTP APIs.  REST uses a more generic and uniform method of exposing resources through URIs, [representation through headers](https://github.com/for-GET/know-your-http-well/blob/master/headers.md), and actions through verbs such as GET, POST, PUT, DELETE, and PATCH.  Being stateless, REST is great for horizontal scaling and partitioning.\n\n#### Disadvantage(s): REST\n\n* With REST being focused on exposing data, it might not be a good fit if resources are not naturally organized or accessed in a simple hierarchy.  For example, returning all updated records from the past hour matching a particular set of events is not easily expressed as a path.  With REST, it is likely to be implemented with a combination of URI path, query parameters, and possibly the request body.\n* REST typically relies on a few verbs (GET, POST, PUT, DELETE, and PATCH) which sometimes doesn't fit your use case.  For example, moving expired documents to the archive folder might not cleanly fit within these verbs.\n* Fetching complicated resources with nested hierarchies requires multiple round trips between the client and server to render single views, e.g. fetching content of a blog entry and the comments on that entry. For mobile applications operating in variable network conditions, these multiple roundtrips are highly undesirable.\n* Over time, more fields might be added to an API response and older clients will receive all new data fields, even those that they do not need, as a result, it bloats the payload size and leads to larger latencies.\n\n### RPC and REST calls comparison\n\n| Operation | RPC | REST |\n|---|---|---|\n| Signup    | **POST** /signup | **POST** /persons |\n| Resign    | **POST** /resign<br/>{<br/>\"personid\": \"1234\"<br/>} | **DELETE** /persons/1234 |\n| Read a person | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |\n| Read a person’s items list | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |\n| Add an item to a person’s items | **POST** /addItemToUsersItemsList<br/>{<br/>\"personid\": \"1234\";<br/>\"itemid\": \"456\"<br/>} | **POST** /persons/1234/items<br/>{<br/>\"itemid\": \"456\"<br/>} |\n| Update an item    | **POST** /modifyItem<br/>{<br/>\"itemid\": \"456\";<br/>\"key\": \"value\"<br/>} | **PUT** /items/456<br/>{<br/>\"key\": \"value\"<br/>} |\n| Delete an item | **POST** /removeItem<br/>{<br/>\"itemid\": \"456\"<br/>} | **DELETE** /items/456 |\n\n<p align=\"center\">\n  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Source: Do you really know why you prefer REST over RPC</a></i>\n</p>\n\n#### Source(s) and further reading: REST and RPC\n\n* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)\n* [When are RPC-ish approaches more appropriate than REST?](http://programmers.stackexchange.com/a/181186)\n* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)\n* [Debunking the myths of RPC and REST](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)\n* [What are the drawbacks of using REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)\n* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Thrift](https://code.facebook.com/posts/1468950976659943/)\n* [Why REST for internal use and not RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)\n\n## Security\n\nThis section could use some updates.  Consider [contributing](#contributing)!",
    "ContentSha": "SY9oRc1IgrKNdRZI1YEjzyytSRn6DjylmnfEWHK6KsU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "REST는 데이터를 노출하는 데 중점을 둡니다. 이는 클라이언트/서버 간의 결합도를 최소화하며, 공용 HTTP API에 자주 사용됩니다. REST는 URI를 통한 리소스 노출, [헤더를 통한 표현](https://github.com/for-GET/know-your-http-well/blob/master/headers.md), 그리고 GET, POST, PUT, DELETE, PATCH와 같은 동사를 통한 동작을 보다 일반적이고 일관된 방식으로 사용합니다. 상태 비저장이기 때문에 REST는 수평 확장 및 파티셔닝에 적합합니다.\n\n#### 단점: REST\n\n* REST는 데이터를 노출하는 데 중점을 두기 때문에, 리소스가 자연스럽게 조직되거나 간단한 계층 구조로 접근되지 않는 경우 적합하지 않을 수 있습니다. 예를 들어, 특정 이벤트 집합과 일치하는 지난 한 시간 동안 업데이트된 모든 기록을 반환하는 것은 경로로 쉽게 표현되지 않습니다. REST에서는 URI 경로, 쿼리 매개변수, 그리고 경우에 따라 요청 본문의 조합으로 구현될 가능성이 큽니다.\n* REST는 일반적으로 몇 가지 동사(GET, POST, PUT, DELETE, PATCH)에 의존하는데, 이는 때때로 사용 사례에 맞지 않을 수 있습니다. 예를 들어, 만료된 문서를 보관 폴더로 이동하는 작업은 이러한 동사에 깔끔하게 맞지 않을 수 있습니다.\n* 중첩된 계층 구조를 가진 복잡한 리소스를 가져오려면 클라이언트와 서버 간 여러 번 왕복해야 하며, 예를 들어 블로그 항목의 내용과 그 댓글을 가져올 때 단일 뷰를 렌더링하기 위해 여러 번 왕복이 필요합니다. 가변적인 네트워크 조건에서 작동하는 모바일 애플리케이션에는 이러한 다중 왕복이 매우 바람직하지 않습니다.\n* 시간이 지남에 따라 API 응답에 더 많은 필드가 추가될 수 있으며, 이전 클라이언트는 필요하지 않은 새로운 데이터 필드까지 모두 수신하게 되어, 페이로드 크기가 증가하고 지연 시간이 길어집니다.\n\n### RPC와 REST 호출 비교\n\n| 작업 | RPC | REST |\n|---|---|---|\n| 가입 | **POST** /signup | **POST** /persons |\n| 탈퇴 | **POST** /resign<br/>{<br/>\"personid\": \"1234\"<br/>} | **DELETE** /persons/1234 |\n| 사람 정보 읽기 | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |\n| 사람의 아이템 목록 읽기 | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |\n| 사람의 아이템에 추가 | **POST** /addItemToUsersItemsList<br/>{<br/>\"personid\": \"1234\";<br/>\"itemid\": \"456\"<br/>} | **POST** /persons/1234/items<br/>{<br/>\"itemid\": \"456\"<br/>} |\n| 아이템 업데이트 | **POST** /modifyItem<br/>{<br/>\"itemid\": \"456\";<br/>\"key\": \"value\"<br/>} | **PUT** /items/456<br/>{<br/>\"key\": \"value\"<br/>} |\n| 아이템 삭제 | **POST** /removeItem<br/>{<br/>\"itemid\": \"456\"<br/>} | **DELETE** /items/456 |\n\n<p align=\"center\">\n  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>출처: Do you really know why you prefer REST over RPC</a></i>\n</p>\n\n#### 출처 및 추가 읽을거리: REST 및 RPC\n\n* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)\n* [언제 RPC 방식이 REST보다 더 적합한가?](http://programmers.stackexchange.com/a/181186)\n* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)\n* [RPC와 REST의 신화 깨기](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)\n* [REST 사용의 단점은 무엇인가?](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)\n* [시스템 설계 인터뷰 깨기](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Thrift](https://code.facebook.com/posts/1468950976659943/)\n* [내부 사용에 REST가 RPC보다 나은 이유](http://arstechnica.com/civis/viewtopic.php?t=1190508)\n\n## 보안\n\n이 섹션은 업데이트가 필요합니다. [기여](#contributing)를 고려해 주세요!\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 51,
    "Content": "\nSecurity is a broad topic.  Unless you have considerable experience, a security background, or are applying for a position that requires knowledge of security, you probably won't need to know more than the basics:\n\n* Encrypt in transit and at rest.\n* Sanitize all user inputs or any input parameters exposed to user to prevent [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) and [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* Use parameterized queries to prevent SQL injection.\n* Use the principle of [least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege).\n\n### Source(s) and further reading\n\n* [API security checklist](https://github.com/shieldfy/API-Security-Checklist)\n* [Security guide for developers](https://github.com/FallibleInc/security-guide-for-developers)\n* [OWASP top ten](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)\n\n## Appendix\n\nYou'll sometimes be asked to do 'back-of-the-envelope' estimates.  For example, you might need to determine how long it will take to generate 100 image thumbnails from disk or how much memory a data structure will take.  The **Powers of two table** and **Latency numbers every programmer should know** are handy references.\n\n### Powers of two table\n",
    "ContentSha": "lttd9OX13KgyFAZReRo/UiwT2DoGI4tHaEGVoAH3mCA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "보안은 광범위한 주제입니다. 상당한 경험이나 보안 배경이 없거나 보안 지식을 요구하는 직위에 지원하지 않는 한, 기본 사항만 알아도 충분할 것입니다:\n\n* 전송 중 및 저장 중 데이터 암호화.\n* 모든 사용자 입력 또는 사용자에게 노출된 입력 매개변수를 정화하여 [XSS](https://ko.wikipedia.org/wiki/%ED%81%AC%EB%A1%9C%EC%8A%A4_%EC%8B%9C%ED%81%AC%EB%A7%81) 및 [SQL 인젝션](https://ko.wikipedia.org/wiki/SQL_%EC%9D%B8%EC%A0%9C%EC%85%98) 방지.\n* SQL 인젝션 방지를 위해 매개변수화된 쿼리 사용.\n* [최소 권한 원칙](https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%86%8C_%EA%B6%8C%ED%95%9C_%EC%9B%90%EC%B9%99) 적용.\n\n### 출처 및 추가 자료\n\n* [API 보안 체크리스트](https://github.com/shieldfy/API-Security-Checklist)\n* [개발자를 위한 보안 가이드](https://github.com/FallibleInc/security-guide-for-developers)\n* [OWASP 상위 10위](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)\n\n## 부록\n\n때때로 '간단한 계산' 추정을 요청받을 수 있습니다. 예를 들어, 디스크에서 100개의 이미지 썸네일을 생성하는 데 걸리는 시간이나 데이터 구조가 차지하는 메모리 양을 결정해야 할 수도 있습니다. **2의 거듭제곱 표**와 **모든 프로그래머가 알아야 할 지연 시간 수치**는 유용한 참고 자료입니다.\n\n### 2의 거듭제곱 표\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 52,
    "Content": "```\nPower           Exact Value         Approx Value        Bytes\n---------------------------------------------------------------\n7                             128\n8                             256\n10                           1024   1 thousand           1 KB\n16                         65,536                       64 KB\n20                      1,048,576   1 million            1 MB\n30                  1,073,741,824   1 billion            1 GB\n32                  4,294,967,296                        4 GB\n40              1,099,511,627,776   1 trillion           1 TB\n```",
    "ContentSha": "tY3s4yO7vTGsjW+GZNlakuBkrCR3FXNKe9N9AYlzPrU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nPower           Exact Value         Approx Value        Bytes\n---------------------------------------------------------------\n7                             128\n8                             256\n10                           1024   1 thousand           1 KB\n16                         65,536                       64 KB\n20                      1,048,576   1 million            1 MB\n30                  1,073,741,824   1 billion            1 GB\n32                  4,294,967,296                        4 GB\n40              1,099,511,627,776   1 trillion           1 TB\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 53,
    "Content": "\n#### Source(s) and further reading\n\n* [Powers of two](https://en.wikipedia.org/wiki/Power_of_two)\n\n### Latency numbers every programmer should know\n",
    "ContentSha": "ppBLjl4GPpTTuZuZkRCmUB3lr0F/LbyDBiLBdXbuDDw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "#### 출처 및 추가 참고 자료\n\n* [2의 거듭제곱](https://ko.wikipedia.org/wiki/2의_거듭제곱)\n\n### 모든 프로그래머가 알아야 할 지연 시간 수치들\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 54,
    "Content": "```\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy            10,000   ns       10 us\nSend 1 KB bytes over 1 Gbps network     10,000   ns       10 us\nRead 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nHDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD\nRead 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns\n```",
    "ContentSha": "Cxjssj59JwVoJhpDLS31tIAyvakR0WQUIHZP4hMVLy8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy            10,000   ns       10 us\nSend 1 KB bytes over 1 Gbps network     10,000   ns       10 us\nRead 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nHDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD\nRead 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 55,
    "Content": "\nHandy metrics based on numbers above:\n\n* Read sequentially from HDD at 30 MB/s\n* Read sequentially from 1 Gbps Ethernet at 100 MB/s\n* Read sequentially from SSD at 1 GB/s\n* Read sequentially from main memory at 4 GB/s\n* 6-7 world-wide round trips per second\n* 2,000 round trips per second within a data center\n\n#### Latency numbers visualized\n\n![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)\n\n#### Source(s) and further reading\n\n* [Latency numbers every programmer should know - 1](https://gist.github.com/jboner/2841832)\n* [Latency numbers every programmer should know - 2](https://gist.github.com/hellerbarde/2843375)\n* [Designs, lessons, and advice from building large distributed systems](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)\n* [Software Engineering Advice from Building Large-Scale Distributed Systems](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)\n\n### Additional system design interview questions\n\n> Common system design interview questions, with links to resources on how to solve each.\n\n| Question | Reference(s) |\n|---|---|\n| Design a file sync service like Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| Design a search engine like Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |\n| Design a scalable web crawler like Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |\n| Design Google docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |\n| Design a key-value store like Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| Design a cache system like Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Design a recommendation system like Amazon's | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |\n| Design a tinyurl system like Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |\n| Design a chat app like WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)\n| Design a picture sharing system like Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |\n| Design the Facebook news feed function | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |\n| Design the Facebook timeline function | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |\n| Design the Facebook chat function | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |",
    "ContentSha": "ufMEAJjeJvG/71zGm1ZrFnYShGruhPDGcpEQX8jnGIY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "위 숫자를 기준으로 한 유용한 지표:\n\n* HDD에서 순차적으로 읽기: 30 MB/s\n* 1 Gbps 이더넷에서 순차적으로 읽기: 100 MB/s\n* SSD에서 순차적으로 읽기: 1 GB/s\n* 메인 메모리에서 순차적으로 읽기: 4 GB/s\n* 전 세계 왕복 6-7회/초\n* 데이터 센터 내 왕복 2,000회/초\n\n#### 지연 시간 수치 시각화\n\n![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)\n\n#### 출처 및 추가 읽기 자료\n\n* [프로그래머라면 알아야 할 지연 시간 수치 - 1](https://gist.github.com/jboner/2841832)\n* [프로그래머라면 알아야 할 지연 시간 수치 - 2](https://gist.github.com/hellerbarde/2843375)\n* [대규모 분산 시스템 구축에서 얻은 설계, 교훈 및 조언](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)\n* [대규모 분산 시스템 구축에서 얻은 소프트웨어 공학 조언](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)\n\n### 추가 시스템 설계 인터뷰 질문\n\n> 일반적인 시스템 설계 인터뷰 질문과 각 질문 해결 방법에 대한 자료 링크.\n\n| 질문 | 참고자료 |\n|---|---|\n| Dropbox 같은 파일 동기화 서비스 설계 | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| Google 같은 검색 엔진 설계 | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |\n| Google 같은 확장 가능한 웹 크롤러 설계 | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |\n| Google Docs 설계 | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |\n| Redis 같은 키-값 저장소 설계 | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| Memcached 같은 캐시 시스템 설계 | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Amazon 같은 추천 시스템 설계 | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |\n| Bitly 같은 TinyURL 시스템 설계 | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |\n| WhatsApp 같은 채팅 앱 설계 | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| Instagram 같은 사진 공유 시스템 설계 | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |\n| Facebook 뉴스 피드 기능 설계 | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |\n| Facebook 타임라인 기능 설계 | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |\n| Facebook 채팅 기능 설계 | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 56,
    "Content": "| Design a graph search function like Facebook's | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |\n| Design a content delivery network like CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |\n| Design a trending topic system like Twitter's | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |\n| Design a random ID generation system | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |\n| Return the top k requests during a time interval | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |\n| Design a system that serves data from multiple data centers | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |\n| Design an online multiplayer card game | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |\n| Design a garbage collection system | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |\n| Design an API rate limiter | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |\n| Design a Stock Exchange (like NASDAQ or Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |\n| Add a system design question | [Contribute](#contributing) |\n\n### Real world architectures\n\n> Articles on how real world systems are designed.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Source: Twitter timelines at scale</a></i>\n</p>\n\n**Don't focus on nitty gritty details for the following articles, instead:**\n\n* Identify shared principles, common technologies, and patterns within these articles\n* Study what problems are solved by each component, where it works, where it doesn't\n* Review the lessons learned\n\n|Type | System | Reference(s) |\n|---|---|---|\n| Data processing | **MapReduce** - Distributed data processing from Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |\n| Data processing | **Spark** - Distributed data processing from Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |\n| Data processing | **Storm** - Distributed data processing from Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |\n| | | |\n| Data store | **Bigtable** - Distributed column-oriented database from Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |\n| Data store | **HBase** - Open source implementation of Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |\n| Data store | **Cassandra** - Distributed column-oriented database from Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)\n| Data store | **DynamoDB** - Document-oriented database from Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |\n| Data store | **MongoDB** - Document-oriented database | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |\n| Data store | **Spanner** - Globally-distributed database from Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |",
    "ContentSha": "5hNQndfbSnlP1RLa/GyRt8pzzHWJN34J9g6lOThi724=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| 페이스북과 같은 그래프 검색 기능 설계 | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |\n| 클라우드플레어와 같은 콘텐츠 전송 네트워크 설계 | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |\n| 트위터의 트렌딩 토픽 시스템 설계 | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |\n| 랜덤 ID 생성 시스템 설계 | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |\n| 특정 시간 구간 내 상위 k 요청 반환 | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |\n| 다중 데이터 센터에서 데이터를 제공하는 시스템 설계 | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |\n| 온라인 멀티플레이어 카드 게임 설계 | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |\n| 가비지 컬렉션 시스템 설계 | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |\n| API 속도 제한기 설계 | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |\n| 주식 거래소 설계 (NASDAQ 또는 Binance와 같은) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang 구현](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go 구현](http://bhomnick.net/building-a-simple-limit-order-in-go/) |\n| 시스템 설계 질문 추가 | [기여하기](#contributing) |\n\n### 실제 세계 아키텍처\n\n> 실제 시스템이 어떻게 설계되었는지에 관한 글들입니다.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>출처: 대규모 트위터 타임라인</a></i>\n</p>\n\n**다음 글들에서는 세부사항에 집중하지 말고, 대신에:**\n\n* 이 글들에서 공유되는 원칙, 공통 기술, 패턴을 파악하세요\n* 각 컴포넌트가 해결하는 문제, 작동하는 상황과 그렇지 않은 상황을 연구하세요\n* 배운 교훈들을 복습하세요\n\n|유형 | 시스템 | 참고 문헌 |\n|---|---|---|\n| 데이터 처리 | **MapReduce** - 구글의 분산 데이터 처리 | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |\n| 데이터 처리 | **Spark** - Databricks의 분산 데이터 처리 | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |\n| 데이터 처리 | **Storm** - 트위터의 분산 데이터 처리 | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |\n| | | |\n| 데이터 저장 | **Bigtable** - 구글의 분산 컬럼 지향 데이터베이스 | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |\n| 데이터 저장 | **HBase** - Bigtable의 오픈소스 구현체 | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |\n| 데이터 저장 | **Cassandra** - 페이스북의 분산 컬럼 지향 데이터베이스 | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)\n| 데이터 저장 | **DynamoDB** - 아마존의 문서 지향 데이터베이스 | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |\n| 데이터 저장 | **MongoDB** - 문서 지향 데이터베이스 | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |\n| 데이터 저장 | **Spanner** - 구글의 전 세계 분산 데이터베이스 | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 57,
    "Content": "| Data store | **Memcached** - Distributed memory caching system | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Data store | **Redis** - Distributed memory caching system with persistence and value types | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| | | |\n| File system | **Google File System (GFS)** - Distributed file system | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |\n| File system | **Hadoop File System (HDFS)** - Open source implementation of GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |\n| | | |\n| Misc | **Chubby** - Lock service for loosely-coupled distributed systems from Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |\n| Misc | **Dapper** - Distributed systems tracing infrastructure | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)\n| Misc | **Kafka** - Pub/sub message queue from LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |\n| Misc | **Zookeeper** - Centralized infrastructure and services enabling synchronization | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |\n| | Add an architecture | [Contribute](#contributing) |\n\n### Company architectures\n\n| Company | Reference(s) |\n|---|---|\n| Amazon | [Amazon architecture](http://highscalability.com/amazon-architecture) |\n| Cinchcast | [Producing 1,500 hours of audio every day](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |\n| DataSift | [Realtime datamining At 120,000 tweets per second](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |\n| Dropbox | [How we've scaled Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| ESPN | [Operating At 100,000 duh nuh nuhs per second](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |\n| Google | [Google architecture](http://highscalability.com/google-architecture) |\n| Instagram | [14 million users, terabytes of photos](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[What powers Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |\n| Justin.tv | [Justin.Tv's live video broadcasting architecture](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |\n| Facebook | [Scaling memcached at Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebook’s distributed data store for the social graph](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook’s photo storage](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[How Facebook Live Streams To 800,000 Simultaneous Viewers](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |\n| Flickr | [Flickr architecture](http://highscalability.com/flickr-architecture) |\n| Mailbox | [From 0 to one million users in 6 weeks](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |\n| Netflix | [A 360 Degree View Of The Entire Netflix Stack](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: What Happens When You Press Play?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |\n| Pinterest | [From 0 To 10s of billions of page views a month](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 million visitors, 10x growth, 12 employees](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |\n| Playfish | [50 million monthly users and growing](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |\n| PlentyOfFish | [PlentyOfFish architecture](http://highscalability.com/plentyoffish-architecture) |\n| Salesforce | [How they handle 1.3 billion transactions a day](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |\n| Stack Overflow | [Stack Overflow architecture](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |\n| TripAdvisor | [40M visitors, 200M dynamic page views, 30TB data](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |\n| Tumblr | [15 billion page views a month](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |\n| Twitter | [Making Twitter 10000 percent faster](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Storing 250 million tweets a day using MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M active users, 300K QPS, a 22 MB/S firehose](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Timelines at scale](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Big and small data at Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operations at Twitter: scaling beyond 100 million users](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[How Twitter Handles 3,000 Images Per Second](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |\n| Uber | [How Uber scales their real-time market platform](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lessons Learned From Scaling Uber To 2000 Engineers, 1000 Services, And 8000 Git Repositories](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |\n| WhatsApp | [The WhatsApp architecture Facebook bought for $19 billion](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| YouTube | [YouTube scalability](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube architecture](http://highscalability.com/youtube-architecture) |\n",
    "ContentSha": "HJ43cGa2ts5Z1+EHjvCRBV9mq+PjUY5QXfwqLIs80oA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| 데이터 저장소 | **Memcached** - 분산 메모리 캐싱 시스템 | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| 데이터 저장소 | **Redis** - 지속성 및 값 유형을 지원하는 분산 메모리 캐싱 시스템 | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| | | |\n| 파일 시스템 | **Google 파일 시스템 (GFS)** - 분산 파일 시스템 | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |\n| 파일 시스템 | **Hadoop 파일 시스템 (HDFS)** - GFS의 오픈 소스 구현 | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |\n| | | |\n| 기타 | **Chubby** - 구글의 느슨하게 결합된 분산 시스템을 위한 락 서비스 | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |\n| 기타 | **Dapper** - 분산 시스템 추적 인프라 | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf) |\n| 기타 | **Kafka** - LinkedIn의 Pub/sub 메시지 큐 | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |\n| 기타 | **Zookeeper** - 동기화를 가능하게 하는 중앙 집중식 인프라 및 서비스 | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |\n| | 아키텍처 추가 | [기여하기](#contributing) |\n\n### 기업 아키텍처\n\n| 기업 | 참고 자료 |\n|---|---|\n| Amazon | [Amazon 아키텍처](http://highscalability.com/amazon-architecture) |\n| Cinchcast | [매일 1,500시간의 오디오 생산](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |\n| DataSift | [초당 120,000 트윗의 실시간 데이터 마이닝](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |\n| Dropbox | [우리가 Dropbox를 확장한 방법](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| ESPN | [초당 100,000 duh nuh nuhs 운영](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |\n| Google | [Google 아키텍처](http://highscalability.com/google-architecture) |\n| Instagram | [1,400만 사용자, 수 테라바이트의 사진](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Instagram의 동력](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |\n| Justin.tv | [Justin.Tv의 라이브 비디오 방송 아키텍처](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |\n| Facebook | [Facebook에서의 memcached 확장](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebook의 소셜 그래프를 위한 분산 데이터 저장소](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook의 사진 저장소](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Facebook이 80만 동시 시청자에게 라이브 스트리밍 하는 방법](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |\n| Flickr | [Flickr 아키텍처](http://highscalability.com/flickr-architecture) |\n| Mailbox | [6주 만에 0에서 100만 사용자로](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |\n| Netflix | [Netflix 전체 스택 360도 보기](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: 재생 버튼을 눌렀을 때 무슨 일이 일어나는가?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |\n| Pinterest | [0에서 매월 수십억 페이지뷰까지](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[1,800만 방문자, 10배 성장, 12명 직원](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |\n| Playfish | [5천만 월간 사용자 및 성장 중](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |\n| PlentyOfFish | [PlentyOfFish 아키텍처](http://highscalability.com/plentyoffish-architecture) |\n| Salesforce | [하루 13억 건의 트랜잭션 처리 방법](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |\n| Stack Overflow | [Stack Overflow 아키텍처](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |\n| TripAdvisor | [4천만 방문자, 2억 동적 페이지뷰, 30TB 데이터](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |\n| Tumblr | [매월 150억 페이지뷰](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |\n| Twitter | [Twitter를 10000% 빠르게 만들기](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[MySQL을 사용해 하루 2억 5천만 트윗 저장하기](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[1억 5천만 활성 사용자, 30만 QPS, 22MB/s 파이어호스](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[대규모 타임라인](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Twitter의 대용량 및 소규모 데이터](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Twitter 운영: 1억 사용자 이상 확장](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[초당 3,000개 이미지 처리 방법](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |\n| Uber | [Uber의 실시간 시장 플랫폼 확장 방법](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[2000명 엔지니어, 1000개 서비스, 8000개 Git 저장소로 확장하며 배운 교훈](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |\n| WhatsApp | [Facebook이 190억 달러에 인수한 WhatsApp 아키텍처](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| YouTube | [YouTube 확장성](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube 아키텍처](http://highscalability.com/youtube-architecture) |\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 58,
    "Content": "### Company engineering blogs\n\n> Architectures for companies you are interviewing with.\n>\n> Questions you encounter might be from the same domain.\n\n* [Airbnb Engineering](http://nerds.airbnb.com/)\n* [Atlassian Developers](https://developer.atlassian.com/blog/)\n* [AWS Blog](https://aws.amazon.com/blogs/aws/)\n* [Bitly Engineering Blog](http://word.bitly.com/)\n* [Box Blogs](https://blog.box.com/blog/category/engineering)\n* [Cloudera Developer Blog](http://blog.cloudera.com/)\n* [Dropbox Tech Blog](https://tech.dropbox.com/)\n* [Engineering at Quora](https://www.quora.com/q/quoraengineering)\n* [Ebay Tech Blog](http://www.ebaytechblog.com/)\n* [Evernote Tech Blog](https://blog.evernote.com/tech/)\n* [Etsy Code as Craft](http://codeascraft.com/)\n* [Facebook Engineering](https://www.facebook.com/Engineering)\n* [Flickr Code](http://code.flickr.net/)\n* [Foursquare Engineering Blog](http://engineering.foursquare.com/)\n* [GitHub Engineering Blog](https://github.blog/category/engineering)\n* [Google Research Blog](http://googleresearch.blogspot.com/)\n* [Groupon Engineering Blog](https://engineering.groupon.com/)\n* [Heroku Engineering Blog](https://engineering.heroku.com/)\n* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)\n* [High Scalability](http://highscalability.com/)\n* [Instagram Engineering](http://instagram-engineering.tumblr.com/)\n* [Intel Software Blog](https://software.intel.com/en-us/blogs/)\n* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)\n* [LinkedIn Engineering](http://engineering.linkedin.com/blog)\n* [Microsoft Engineering](https://engineering.microsoft.com/)\n* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)\n* [Netflix Tech Blog](http://techblog.netflix.com/)\n* [Paypal Developer Blog](https://medium.com/paypal-engineering)\n* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)\n* [Reddit Blog](http://www.redditblog.com/)\n* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)\n* [Slack Engineering Blog](https://slack.engineering/)\n* [Spotify Labs](https://labs.spotify.com/)\n* [Stripe Engineering Blog](https://stripe.com/blog/engineering)",
    "ContentSha": "K2HaPjFBuIAolMM1jFJHWyWd16kC4a7w+PNnWCMvsfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 회사 엔지니어링 블로그\n\n> 면접을 보는 회사들의 아키텍처.\n>\n> 마주칠 수 있는 질문들이 같은 도메인에서 나올 수 있습니다.\n\n* [Airbnb 엔지니어링](http://nerds.airbnb.com/)\n* [Atlassian 개발자 블로그](https://developer.atlassian.com/blog/)\n* [AWS 블로그](https://aws.amazon.com/blogs/aws/)\n* [Bitly 엔지니어링 블로그](http://word.bitly.com/)\n* [Box 블로그](https://blog.box.com/blog/category/engineering)\n* [Cloudera 개발자 블로그](http://blog.cloudera.com/)\n* [Dropbox 기술 블로그](https://tech.dropbox.com/)\n* [Quora 엔지니어링](https://www.quora.com/q/quoraengineering)\n* [Ebay 기술 블로그](http://www.ebaytechblog.com/)\n* [Evernote 기술 블로그](https://blog.evernote.com/tech/)\n* [Etsy Code as Craft](http://codeascraft.com/)\n* [Facebook 엔지니어링](https://www.facebook.com/Engineering)\n* [Flickr 코드](http://code.flickr.net/)\n* [Foursquare 엔지니어링 블로그](http://engineering.foursquare.com/)\n* [GitHub 엔지니어링 블로그](https://github.blog/category/engineering)\n* [Google 연구 블로그](http://googleresearch.blogspot.com/)\n* [Groupon 엔지니어링 블로그](https://engineering.groupon.com/)\n* [Heroku 엔지니어링 블로그](https://engineering.heroku.com/)\n* [Hubspot 엔지니어링 블로그](http://product.hubspot.com/blog/topic/engineering)\n* [High Scalability](http://highscalability.com/)\n* [Instagram 엔지니어링](http://instagram-engineering.tumblr.com/)\n* [Intel 소프트웨어 블로그](https://software.intel.com/en-us/blogs/)\n* [Jane Street 기술 블로그](https://blogs.janestreet.com/category/ocaml/)\n* [LinkedIn 엔지니어링](http://engineering.linkedin.com/blog)\n* [Microsoft 엔지니어링](https://engineering.microsoft.com/)\n* [Microsoft Python 엔지니어링](https://blogs.msdn.microsoft.com/pythonengineering/)\n* [Netflix 기술 블로그](http://techblog.netflix.com/)\n* [Paypal 개발자 블로그](https://medium.com/paypal-engineering)\n* [Pinterest 엔지니어링 블로그](https://medium.com/@Pinterest_Engineering)\n* [Reddit 블로그](http://www.redditblog.com/)\n* [Salesforce 엔지니어링 블로그](https://developer.salesforce.com/blogs/engineering/)\n* [Slack 엔지니어링 블로그](https://slack.engineering/)\n* [Spotify Labs](https://labs.spotify.com/)\n* [Stripe 엔지니어링 블로그](https://stripe.com/blog/engineering)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 59,
    "Content": "* [Twilio Engineering Blog](http://www.twilio.com/engineering)\n* [Twitter Engineering](https://blog.twitter.com/engineering/)\n* [Uber Engineering Blog](http://eng.uber.com/)\n* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)\n* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)\n* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)\n\n#### Source(s) and further reading\n\nLooking to add a blog?  To avoid duplicating work, consider adding your company blog to the following repo:\n\n* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)\n\n## Under development\n\nInterested in adding a section or helping complete one in-progress?  [Contribute](#contributing)!\n\n* Distributed computing with MapReduce\n* Consistent hashing\n* Scatter gather\n* [Contribute](#contributing)\n\n## Credits\n\nCredits and sources are provided throughout this repo.\n\nSpecial thanks to:\n\n* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)\n* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)\n* [High scalability](http://highscalability.com/)\n* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)\n* [shashank88/system_design](https://github.com/shashank88/system_design)\n* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)\n* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)\n* [A distributed systems reading list](http://dancres.github.io/Pages/)\n* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n\n## Contact info\n",
    "ContentSha": "Ybn7ZSN9UGUEPKyqpiStfZWdM+FBaEvnQtoViA95ahg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [트윌리오 엔지니어링 블로그](http://www.twilio.com/engineering)\n* [트위터 엔지니어링](https://blog.twitter.com/engineering/)\n* [우버 엔지니어링 블로그](http://eng.uber.com/)\n* [야후 엔지니어링 블로그](http://yahooeng.tumblr.com/)\n* [옐프 엔지니어링 블로그](http://engineeringblog.yelp.com/)\n* [징가 엔지니어링 블로그](https://www.zynga.com/blogs/engineering)\n\n#### 출처 및 추가 읽을거리\n\n블로그를 추가하고 싶으신가요? 작업 중복을 피하기 위해 아래 저장소에 회사 블로그를 추가하는 것을 고려해 보세요:\n\n* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)\n\n## 개발 중\n\n섹션을 추가하거나 진행 중인 섹션 완성에 도움을 주고 싶으신가요? [기여하기](#contributing)!\n\n* MapReduce를 이용한 분산 컴퓨팅\n* 일관성 해싱\n* 스캐터 갤러\n* [기여하기](#contributing)\n\n## 감사의 글\n\n이 저장소 전반에 걸쳐 출처와 감사의 글이 제공됩니다.\n\n특별한 감사의 말씀을 전합니다:\n\n* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)\n* [코딩 인터뷰 완전 정복](https://www.amazon.com/dp/0984782850/)\n* [High scalability](http://highscalability.com/)\n* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)\n* [shashank88/system_design](https://github.com/shashank88/system_design)\n* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)\n* [시스템 디자인 치트 시트](https://gist.github.com/vasanthk/485d1c25737e8e72759f)\n* [분산 시스템 읽기 목록](http://dancres.github.io/Pages/)\n* [시스템 디자인 인터뷰 완전 정복](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n\n## 연락처 정보\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 60,
    "Content": "Feel free to contact me to discuss any issues, questions, or comments.\n\nMy contact info can be found on my [GitHub page](https://github.com/donnemartin).\n\n## License\n\n*I am providing code and resources in this repository to you under an open source license.  Because this is my personal repository, the license you receive to my code and resources is from me and not my employer (Facebook).*\n\n    Copyright 2017 Donne Martin\n\n    Creative Commons Attribution 4.0 International License (CC BY 4.0)\n\n    http://creativecommons.org/licenses/by/4.0/\n",
    "ContentSha": "pZfW5OoDeEHMjsOQIbYzifgEtKuSRxAcRTUdmpdKaBQ=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "문제, 질문 또는 의견이 있으시면 언제든지 저에게 연락해 주세요.\n\n제 연락처 정보는 제 [GitHub 페이지](https://github.com/donnemartin)에서 확인하실 수 있습니다.\n\n## 라이선스\n\n*이 저장소의 코드와 자료는 오픈 소스 라이선스 하에 제공됩니다. 이 저장소는 개인 저장소이므로, 코드와 자료에 대한 라이선스는 제 개인 자격으로 제공되며, 제 고용주(페이스북)와는 무관합니다.*\n\n    저작권 2017 Donne Martin\n\n    크리에이티브 커먼즈 저작자표시 4.0 국제 라이선스 (CC BY 4.0)\n\n    http://creativecommons.org/licenses/by/4.0/\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  }
]