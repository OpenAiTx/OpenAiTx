*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*

**Помогите [перевести](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) этот гид!**

# Системное проектирование: Основы

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png">
  <br/>
</p>

## Мотивация

> Научитесь проектировать крупномасштабные системы.
>
> Подготовьтесь к собеседованию по системному проектированию.

### Научитесь проектировать крупномасштабные системы

Изучение принципов масштабирования систем поможет вам стать лучшим инженером.

Системное проектирование — это обширная тема. **Огромное количество ресурсов разбросано по всему интернету** и посвящено принципам проектирования систем.

Этот репозиторий — **организованная коллекция** материалов, которые помогут вам научиться строить масштабируемые системы.

### Учитесь у сообщества open source

Это постоянно обновляемый проект с открытым исходным кодом.

[Вклад](#contributing) приветствуется!

### Подготовка к собеседованию по системному проектированию

В дополнение к собеседованиям по программированию системное проектирование является **обязательной частью** **технического интервью** во многих IT-компаниях.

**Тренируйтесь на популярных вопросах по системному проектированию** и **сравнивайте** свои решения с **примерами**: обсуждениями, кодом и схемами.

Дополнительные темы для подготовки к собеседованию:

* [Путеводитель по изучению](#study-guide)
* [Как решать вопросы по системному проектированию на собеседовании](#how-to-approach-a-system-design-interview-question)
* [Вопросы по системному дизайну для интервью, **с решениями**](#system-design-interview-questions-with-solutions)
* [Вопросы по объектно-ориентированному дизайну для интервью, **с решениями**](#object-oriented-design-interview-questions-with-solutions)
* [Дополнительные вопросы по системному дизайну для интервью](#additional-system-design-interview-questions)

## Anki карточки

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png">
  <br/>
</p>

Предоставленные [колоды карточек Anki](https://apps.ankiweb.net/) используют интервальное повторение для закрепления ключевых концепций системного дизайна.

* [Колода по системному дизайну](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)
* [Колода упражнений по системному дизайну](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)
* [Колода упражнений по объектно-ориентированному дизайну](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)

Отлично подходит для использования в дороге.

### Ресурс по программированию: Интерактивные задачи по программированию

Ищете ресурсы для подготовки к [**интервью по программированию**](https://github.com/donnemartin/interactive-coding-challenges)?

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png">
  <br/>
</p>

Ознакомьтесь с сестринским репозиторием [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges), который содержит дополнительную колоду Anki:

* [Колода по программированию](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)

## Участие

> Учитесь у сообщества.

Не стесняйтесь отправлять pull-запросы, чтобы помочь:

* Исправить ошибки
* Улучшить разделы
* Добавьте новые разделы
* [Перевести](https://github.com/donnemartin/system-design-primer/issues/28)

Контент, требующий доработки, размещён [в разработке](#under-development).

Ознакомьтесь с [Руководством по внесению изменений](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).

## Индекс тем по проектированию систем

> Краткие обзоры различных тем по проектированию систем, включая плюсы и минусы.  **Всё — компромисс**.
>
> Каждый раздел содержит ссылки на более подробные ресурсы.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png">
  <br/>
</p>

* [Темы по проектированию систем: начните здесь](#system-design-topics-start-here)
    * [Шаг 1: Просмотрите видео-лекцию о масштабируемости](#step-1-review-the-scalability-video-lecture)
    * [Шаг 2: Ознакомьтесь со статьёй о масштабируемости](#step-2-review-the-scalability-article)
    * [Следующие шаги](#next-steps)
* [Производительность vs масштабируемость](#performance-vs-scalability)
* [Задержка vs пропускная способность](#latency-vs-throughput)
* [Доступность vs согласованность](#availability-vs-consistency)
    * [Теорема CAP](#cap-theorem)
        * [CP — согласованность и устойчивость к разделению](#cp---consistency-and-partition-tolerance)
        * [AP — доступность и устойчивость к разделению](#ap---availability-and-partition-tolerance)
* [Паттерны согласованности](#consistency-patterns)
    * [Слабая согласованность](#weak-consistency)
    * [В конечном итоге согласованность](#eventual-consistency)
    * [Сильная согласованность](#strong-consistency)
* [Паттерны доступности](#availability-patterns)
    * [Автоматическое переключение](#fail-over)
    * [Репликация](#replication)
    * [Доступность в числах](#availability-in-numbers)
* [Система доменных имён](#domain-name-system)
* [Сеть доставки контента](#content-delivery-network)
    * [Push CDN](#push-cdns)
    * [Pull CDN](#pull-cdns)
* [Балансировщик нагрузки](#load-balancer)
    * [Активный-пассивный](#active-passive)
    * [Активный-активный](#active-active)
    * [Балансировка нагрузки на уровне 4](#layer-4-load-balancing)
    * [Балансировка нагрузки на уровне 7](#layer-7-load-balancing)
    * [Горизонтальное масштабирование](#horizontal-scaling)
* [Обратный прокси (веб-сервер)](#reverse-proxy-web-server)
    * [Балансировщик нагрузки vs обратный прокси](#load-balancer-vs-reverse-proxy)
* [Прикладной уровень](#application-layer)
    * [Микросервисы](#microservices)
    * [Обнаружение сервисов](#service-discovery)
* [База данных](#database)
    * [Система управления реляционными базами данных (СУБД)](#relational-database-management-system-rdbms)
        * [Репликация мастер-слейв](#master-slave-replication)
        * [Репликация мастер-мастер](#master-master-replication)
        * [Федерация](#federation)
        * [Шардинг](#sharding)
        * [Денормализация](#denormalization)
        * [Оптимизация SQL](#sql-tuning)
    * [NoSQL](#nosql)
        * [Ключ-значение хранилище](#key-value-store)
        * [Документное хранилище](#document-store)
        * [Широкостолбцовое хранилище](#wide-column-store)
        * [Графовая база данных](#graph-database)
    * [SQL или NoSQL](#sql-or-nosql)
* [Кэш](#cache)
    * [Кэширование на стороне клиента](#client-caching)
    * [Кэширование на CDN](#cdn-caching)
    * [Кэширование на веб-сервере](#web-server-caching)
    * [Кэширование базы данных](#database-caching)
    * [Кэширование на уровне приложения](#application-caching)
    * [Кэширование на уровне запросов к базе данных](#caching-at-the-database-query-level)
    * [Кэширование на уровне объектов](#caching-at-the-object-level)
    * [Когда обновлять кэш](#when-to-update-the-cache)
        * [Cache-aside (кэш в стороне)](#cache-aside)
        * [Write-through (прямое обновление)](#write-through)
        * [Write-behind (отложенная запись)](#write-behind-write-back)
        * [Refresh-ahead (опережающее обновление)](#refresh-ahead)
* [Асинхронность](#asynchronism)
    * [Очереди сообщений](#message-queues)
    * [Очереди задач](#task-queues)
    * [Обратное давление (Back pressure)](#back-pressure)
* [Связь](#communication)
    * [Протокол управления передачей (TCP)](#transmission-control-protocol-tcp)
    * [Протокол пользовательских дейтаграмм (UDP)](#user-datagram-protocol-udp)
    * [Удалённый вызов процедур (RPC)](#remote-procedure-call-rpc)
    * [Передача представления состояния (REST)](#representational-state-transfer-rest)
* [Безопасность](#security)
* [Приложение](#appendix)
    * [Таблица степеней двойки](#powers-of-two-table)
    * [Задержки, которые должен знать каждый программист](#latency-numbers-every-programmer-should-know)
    * [Дополнительные вопросы по проектированию систем для интервью](#additional-system-design-interview-questions)
    * [Архитектуры из реального мира](#real-world-architectures)
    * [Архитектуры компаний](#company-architectures)
    * [Инженерные блоги компаний](#company-engineering-blogs)
* [В разработке](#under-development)
* [Благодарности](#credits)
* [Контактная информация](#contact-info)
* [Лицензия](#license)

## Гайд по обучению

> Рекомендуемые темы для изучения в зависимости от вашего графика подготовки к интервью (короткий, средний, длинный).

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)

**Вопрос: Для интервью мне нужно знать всё, что здесь указано?**

**Ответ: Нет, вам не обязательно знать всё это для подготовки к интервью**.

Что вас спросят на интервью, зависит от таких факторов, как:

* Ваш опыт работы
* Ваш технический бэкграунд
* Должности, на которые вы проходите собеседование
* Компании, в которых вы проходите собеседование
* Удача

От более опытных кандидатов обычно ожидают большего знания в области проектирования систем.  Архитекторы или тимлиды могут быть обязаны знать больше, чем отдельные разработчики.  В ведущих IT-компаниях часто бывает один или несколько раундов интервью по проектированию.

Начните с общего обзора и углубляйтесь в некоторые области. Полезно знать хотя бы немного о различных ключевых темах проектирования систем. Корректируйте следующий гид исходя из вашего графика, опыта, позиций, на которые вы проходите собеседование, и компаний, в которых вы проходите собеседование.

* **Короткий срок** — ориентируйтесь на **широту** тем по проектированию систем. Практикуйтесь, решая **некоторые** вопросы из собеседований.
* **Средний срок** — ориентируйтесь на **широту** и **некоторую глубину** тем по проектированию систем. Практикуйтесь, решая **многие** вопросы из собеседований.
* **Длинный срок** — ориентируйтесь на **широту** и **большую глубину** тем по проектированию систем. Практикуйтесь, решая **большинство** вопросов из собеседований.

| | Короткий | Средний | Длинный |
|---|---|---|---|
| Прочитайте [Темы по проектированию систем](#index-of-system-design-topics), чтобы получить общее представление о работе систем | :+1: | :+1: | :+1: |
| Прочитайте несколько статей из [Инженерных блогов компаний](#company-engineering-blogs), в которых вы проходите собеседование | :+1: | :+1: | :+1: |
| Прочитайте несколько [Архитектур реального мира](#real-world-architectures) | :+1: | :+1: | :+1: |
| Ознакомьтесь с [Как подходить к вопросам по проектированию систем на собеседовании](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |
| Решайте [Вопросы по проектированию систем с решениями](#system-design-interview-questions-with-solutions) | Некоторые | Многие | Большинство |
| Решайте [Вопросы по объектно-ориентированному проектированию с решениями](#object-oriented-design-interview-questions-with-solutions) | Некоторые | Многие | Большинство |
| Ознакомьтесь с [Дополнительные вопросы по проектированию систем](#additional-system-design-interview-questions) | Некоторые | Многие | Большинство |

## Как подходить к вопросам по проектированию систем на собеседовании

> Как решать вопросы по проектированию систем на собеседовании.

Собеседование по проектированию систем — это **открытая беседа**. Ожидается, что вы будете ее вести.

Вы можете воспользоваться следующими шагами для ведения дискуссии. Для закрепления этого процесса проработайте раздел [Вопросы по проектированию систем с решениями](#system-design-interview-questions-with-solutions), используя эти шаги.

### Шаг 1: Определите варианты использования, ограничения и предположения

Соберите требования и определите рамки задачи. Задавайте вопросы для уточнения вариантов использования и ограничений. Обсуждайте предположения.

* Кто будет этим пользоваться?
* Как они будут этим пользоваться?
* Сколько пользователей будет?
* Что делает система?
* Каковы входные и выходные данные системы?
* Сколько данных мы ожидаем обработать?
* Сколько запросов в секунду мы ожидаем?
* Каково ожидаемое соотношение чтения к записи?

### Шаг 2: Создайте высокоуровневый дизайн

Опишите высокоуровневый дизайн с указанием всех важных компонентов.

* Нарисуйте основные компоненты и их соединения
* Обоснуйте свои идеи

### Шаг 3: Проектирование основных компонентов

Разберите детали каждого основного компонента. Например, если вам предложено [спроектировать сервис сокращения URL](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), обсудите:

* Генерация и хранение хэша полного URL
    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) и [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)
    * Коллизии хэшей
    * SQL или NoSQL
    * Схема базы данных
* Преобразование хэшированного URL обратно в полный URL
    * Поиск в базе данных
* API и объектно-ориентированное проектирование

### Шаг 4: Масштабирование архитектуры

Определите и устраните узкие места с учетом ограничений. Например, потребуется ли следующее для решения проблем масштабируемости?

* Балансировщик нагрузки
* Горизонтальное масштабирование
* Кэширование
* Шардирование базы данных

Обсудите возможные решения и компромиссы. Всё — это компромисс. Устраняйте узкие места, используя [принципы проектирования масштабируемых систем](#index-of-system-design-topics).

### Оценки «на коленке»

Вас могут попросить сделать некоторые оценки вручную. Обратитесь к [Приложению](#appendix) для следующих ресурсов:

* [Используйте оценки «на коленке»](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)
* [Таблица степеней двойки](#powers-of-two-table)
* [Числа задержек, которые должен знать каждый программист](#latency-numbers-every-programmer-should-know)

### Источники и дополнительная литература

Ознакомьтесь со следующими ссылками, чтобы лучше понять, чего ожидать:

* [Как пройти собеседование по системному дизайну](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)
* [Собеседование по системному дизайну](http://www.hiredintech.com/system-design)
* [Введение в архитектуру и собеседования по системному дизайну](https://www.youtube.com/watch?v=ZgdS0EUmn70)
* [Шаблон для системного дизайна](https://leetcode.com/discuss/career/229177/My-System-Design-Template)

## Вопросы по системному дизайну с решениями

> Типовые вопросы на собеседовании по системному дизайну с примерами обсуждений, кода и схем.
>
> Решения связаны с содержимым в папке `solutions/`.

| Вопрос | |
|---|---|
| Спроектируйте Pastebin.com (или Bit.ly) | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |
| Спроектируйте таймлайн и поиск в Twitter (или ленту и поиск в Facebook) | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |
| Спроектируйте веб-краулер | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |
| Спроектируйте Mint.com | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |
| Спроектируйте структуры данных для социальной сети | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |
| Спроектируйте key-value хранилище для поисковой системы | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |
| Спроектируйте функцию ранжирования продаж по категориям в Amazon | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |
| Спроектируйте систему, масштабируемую до миллионов пользователей на AWS | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |
| Добавьте вопрос по системному дизайну | [Внести вклад](#contributing) |

### Спроектируйте Pastebin.com (или Bit.ly)

[Просмотреть упражнение и решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)

### Спроектируйте таймлайн и поиск в Twitter (или ленту и поиск в Facebook)

[Просмотреть упражнение и решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)

### Спроектируйте веб-краулер

[Просмотреть упражнение и решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)

### Design Mint.com

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)

### Design the data structures for a social network

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)

### Design a key-value store for a search engine

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)

### Design Amazon's sales ranking by category feature

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)

### Design a system that scales to millions of users on AWS

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)

## Object-oriented design interview questions with solutions

> Common object-oriented design interview questions with sample discussions, code, and diagrams.
>
> Solutions linked to content in the `solutions/` folder.

>**Note: This section is under development**

| Question | |
|---|---|
| Спроектировать хеш-таблицу | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |
| Спроектировать кэш с удалением наименее используемых данных (LRU) | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |
| Спроектировать колл-центр | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |
| Спроектировать колоду карт | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |
| Спроектировать парковку | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |
| Спроектировать чат-сервер | [Решение](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |
| Спроектировать кольцевой массив | [Внести вклад](#contributing)  |
| Добавить вопрос по объектно-ориентированному проектированию | [Внести вклад](#contributing) |

## Темы системного проектирования: начните здесь

Впервые сталкиваетесь с системным проектированием?

Сначала вам нужно базовое понимание общих принципов: узнать, что это такое, как они применяются, их плюсы и минусы.

### Шаг 1: Посмотрите видеолекцию по масштабируемости

[Лекция по масштабируемости в Гарварде](https://www.youtube.com/watch?v=-W9F__D3oY4)

* Рассматриваемые темы:
    * Вертикальное масштабирование
    * Горизонтальное масштабирование
    * Кэширование
    * Балансировка нагрузки
    * Репликация баз данных
    * Партиционирование баз данных

### Шаг 2: Ознакомьтесь со статьей о масштабируемости

[Масштабируемость](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)

* Рассматриваемые темы:
    * [Клоны](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
    * [Базы данных](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
    * [Кэши](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
    * [Асинхронность](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)

### Следующие шаги

Далее мы рассмотрим компромиссы на высоком уровне:

* **Производительность** vs **масштабируемость**
* **Задержка** vs **пропускная способность**
* **Доступность** vs **согласованность**

Имейте в виду, что **всё — это компромисс**.

Затем мы углубимся в более конкретные темы, такие как DNS, CDN и балансировщики нагрузки.

## Производительность vs масштабируемость

Сервис считается **масштабируемым**, если увеличение ресурсов приводит к пропорциональному росту **производительности**. Обычно под увеличением производительности понимается возможность обслуживать больше единиц работы, но это также может означать обработку более крупных единиц работы, например, при росте объёмов данных.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>

Другой способ взглянуть на производительность и масштабируемость:

* Если у вас проблема с **производительностью**, ваша система медленно работает для одного пользователя.
* Если у вас проблема с **масштабируемостью**, ваша система быстро работает для одного пользователя, но медленно под высокой нагрузкой.

### Источники и дополнительное чтение

* [A word on scalability](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)
* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)

## Задержка vs пропускная способность

**Задержка** — это время, необходимое для выполнения действия или получения результата.

**Пропускная способность** — это количество таких действий или результатов в единицу времени.

Обычно следует стремиться к **максимальной пропускной способности** при **приемлемой задержке**.

### Источники и дополнительное чтение

* [Understanding latency vs throughput](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)

## Доступность vs согласованность

### Теорема CAP

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Источник: CAP theorem revisited</a></i>
</p>

В распределённой компьютерной системе можно поддерживать только две из следующих гарантий:

* **Согласованность** - Каждый запрос на чтение получает либо самое последнее записанное значение, либо ошибку
* **Доступность** - Каждый запрос получает ответ, но без гарантии, что ответ содержит самую свежую версию информации
* **Устойчивость к разделению** - Система продолжает работать, несмотря на произвольное разделение из-за сетевых сбоев

*Сети ненадежны, поэтому вам нужно поддерживать устойчивость к разделению. Необходимо сделать программный выбор между согласованностью и доступностью.*

#### CP - согласованность и устойчивость к разделению

Ожидание ответа от разделённого узла может привести к ошибке тайм-аута. CP — хороший выбор, если бизнес-требования требуют атомарных операций чтения и записи.

#### AP - доступность и устойчивость к разделению

Ответы возвращают наиболее доступную версию данных на любом узле, которая может быть не самой свежей. Записи могут распространяться с задержкой после восстановления разделения.

AP — хороший выбор, если бизнес допускает [постепенную согласованность](#eventual-consistency) или если системе требуется продолжать работу несмотря на внешние ошибки.

### Источники и дополнительная литература

* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)
* [Введение в CAP theorem на простом английском](http://ksat.me/a-plain-english-introduction-to-cap-theorem)
* [CAP FAQ](https://github.com/henryr/cap-faq)
* [Теорема CAP](https://www.youtube.com/watch?v=k-Yaq8AHlFA)

## Шаблоны согласованности

При наличии нескольких копий одних и тех же данных мы сталкиваемся с выбором способа их синхронизации, чтобы клиенты имели согласованный взгляд на данные. Напомним определение согласованности из [теоремы CAP](#cap-theorem) — Каждый запрос на чтение получает самое последнее записанное значение или ошибку.

### Слабая согласованность

После записи запросы на чтение могут как увидеть, так и не увидеть её. Применяется принцип наилучших усилий.

Этот подход используется в системах типа memcached. Слабая согласованность хорошо работает для случаев реального времени, таких как VoIP, видеочат и онлайн-игры в реальном времени. Например, если во время телефонного разговора вы на несколько секунд теряете связь, то, когда соединение восстанавливается, вы не услышите, что было сказано во время потери связи.

### Конечная согласованность

После записи данные будут видны при чтении со временем (обычно в течение миллисекунд). Данные реплицируются асинхронно.

Такой подход используется в системах, таких как DNS и электронная почта. Конечная согласованность хорошо работает в системах с высокой доступностью.

### Сильная согласованность

После записи данные будут видны при чтении. Данные реплицируются синхронно.

Такой подход используется в файловых системах и реляционных СУБД. Сильная согласованность хорошо подходит для систем, которым нужны транзакции.

### Источники и дополнительная литература

* [Транзакции между дата-центрами](http://snarfed.org/transactions_across_datacenters_io.html)

## Паттерны обеспечения доступности

Существует два взаимодополняющих паттерна для поддержки высокой доступности: **фейловер** и **репликация**.

### Фейловер

#### Активный-пассивный

При активном-пассивном фейловере между активным и пассивным сервером на резерве отправляются сигналы "heartbeat". Если сигнал прерывается, пассивный сервер принимает IP-адрес активного и продолжает обслуживание.

Длительность простоя определяется тем, запущен ли пассивный сервер уже в режиме "горячего" резерва, либо ему нужно стартовать из "холодного" резерва. Только активный сервер обрабатывает трафик.

Активно-пассивный фейловер также называют мастер-слейв фейловером.

#### Активный-активный

При активном-активном оба сервера обрабатывают трафик, распределяя нагрузку между собой.

Если серверы доступны из Интернета, DNS должен знать о публичных IP-адресах обоих серверов. Если серверы внутренние, логика приложения должна знать о них.

Активно-активный фейловер также называют мастер-мастер фейловером.

### Недостатки: фейловер

* Резервирование требует дополнительного оборудования и увеличивает сложность системы.
* Существует риск потери данных, если активная система выйдет из строя до того, как новые записанные данные будут реплицированы на пассивную.

### Репликация

#### Мастер-слейв и мастер-мастер

Эта тема более подробно рассматривается в разделе [База данных](#database):

* [Мастер-слейв репликация](#master-slave-replication)
* [Мастер-мастер репликация](#master-master-replication)

### Доступность в числах

Доступность часто выражается временем безотказной работы (или простоя) как процент времени, в течение которого сервис доступен. Обычно доступность измеряется количеством девяток -- сервис с 99,99% доступностью называют сервисом "четыре девятки".

#### 99,9% доступности — три девятки

| Период              | Допустимое время простоя|
|---------------------|------------------------|
| Простой в год       | 8ч 45мин 57с           |
| Простой в месяц     | 43мин 49,7с            |
| Простой в неделю    | 10мин 4,8с             |
| Простой в день      | 1мин 26,4с             |

#### 99,99% доступности — четыре девятки

| Период              | Допустимое время простоя|
|---------------------|------------------------|
| Простой в год       | 52мин 35,7с            |
| Простой в месяц     | 4мин 23с               |
| Простой в неделю    | 1мин 5с                |
| Простой в день      | 8,6с                   |

#### Доступность при параллельной и последовательной работе

Если сервис состоит из нескольких компонентов, подверженных сбоям, общая доступность сервиса зависит от того, работают ли компоненты последовательно или параллельно.

###### Последовательно

Общая доступность снижается, когда два компонента с доступностью < 100% идут последовательно:

```
Availability (Total) = Availability (Foo) * Availability (Bar)
```

Если и `Foo`, и `Bar` имеют доступность 99,9%, их общая доступность при последовательном соединении будет 99,8%.

###### В параллели

Общая доступность увеличивается, когда два компонента с доступностью < 100% работают параллельно:

```
Availability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))
```
Если и `Foo`, и `Bar` имеют доступность 99,9%, их общая доступность в параллельной работе будет 99,9999%.

## Система доменных имен

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Источник: Презентация по безопасности DNS</a></i>
</p>

Система доменных имен (DNS) переводит доменное имя, такое как www.example.com, в IP-адрес.

DNS иерархична, с несколькими авторитетными серверами на верхнем уровне. Ваш маршрутизатор или интернет-провайдер предоставляет информацию о том, с какими DNS-серверами связываться при поиске. DNS-серверы нижнего уровня кэшируют соответствия, которые могут устаревать из-за задержек распространения DNS. Результаты DNS также могут кэшироваться вашим браузером или ОС в течение определенного периода времени, определяемого [временем жизни (TTL)](https://en.wikipedia.org/wiki/Time_to_live).

* **NS-запись (сервер имен)** – Указывает DNS-серверы для вашего домена/поддомена.
* **MX-запись (почтовый обменник)** – Указывает почтовые серверы для приема сообщений.
* **A-запись (адрес)** – Привязывает имя к IP-адресу.
* **CNAME (каноническое имя)** – Привязывает имя к другому имени или `CNAME` (example.com к www.example.com) или к `A`-записи.

Сервисы, такие как [CloudFlare](https://www.cloudflare.com/dns/) и [Route 53](https://aws.amazon.com/route53/), предоставляют управляемые DNS-услуги. Некоторые DNS-сервисы могут маршрутизировать трафик различными способами:

* [Взвешенное круговое распределение](https://www.jscape.com/blog/load-balancing-algorithms)
    * Предотвращение направления трафика на серверы, находящиеся на обслуживании
    * Балансировка между кластерами разного размера
    * A/B тестирование
* [На основе задержки](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)
* [На основе геолокации](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)

### Недостатки: DNS

* Обращение к DNS-серверу вызывает небольшую задержку, которая, однако, смягчается описанным выше кэшированием.
* Управление DNS-серверами может быть сложным и обычно осуществляется [государствами, интернет-провайдерами и крупными компаниями](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).
* Недавно службы DNS подвергались [DDoS-атакам](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), что не позволяло пользователям заходить на сайты, такие как Twitter, без знания IP-адреса(-ов) Twitter.

### Источники и дополнительная литература

* [Архитектура DNS](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)
* [Википедия](https://en.wikipedia.org/wiki/Domain_Name_System)
* [Статьи о DNS](https://support.dnsimple.com/categories/dns/)


## Сеть доставки контента

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Источник: Почему использовать CDN</a></i>
</p>

Сеть доставки контента (CDN) — это глобально распределённая сеть прокси-серверов, обслуживающая контент из локаций, более близких к пользователю. Как правило, статические файлы, такие как HTML/CSS/JS, фотографии и видео, обслуживаются через CDN, хотя некоторые CDN, например CloudFront от Amazon, поддерживают динамический контент. Разрешение DNS сайта указывает клиентам, к какому серверу обращаться.

Обслуживание контента через CDN может значительно повысить производительность двумя способами:

* Пользователи получают контент из дата-центров, расположенных ближе к ним
* Ваши серверы не обслуживают запросы, которые выполняет CDN

### Push CDN

Push CDN получают новый контент всякий раз, когда на вашем сервере происходят изменения. Вы полностью отвечаете за предоставление контента, загружая его напрямую на CDN и переписывая URL на CDN. Вы можете настроить срок хранения контента и время его обновления. Контент загружается только когда он новый или изменён, минимизируя трафик, но увеличивая использование хранилища.

Сайты с небольшим количеством трафика или сайты с редко обновляемым контентом хорошо работают с Push CDN. Контент размещается на CDN один раз, вместо повторной загрузки через регулярные интервалы.

### Pull CDN

Pull CDN получают новый контент с вашего сервера, когда первый пользователь запрашивает этот контент. Вы оставляете контент на сервере и переписываете URL на CDN. Это приводит к более медленному запросу, пока контент не будет закэширован на CDN.

[Время жизни (TTL)](https://en.wikipedia.org/wiki/Time_to_live) определяет, как долго контент хранится в кеше. Pull CDN минимизируют занимаемое место на CDN, но могут создавать избыточный трафик, если файлы истекают и загружаются повторно до фактических изменений.

Сайты с высоким трафиком хорошо работают с Pull CDN, так как трафик распределяется равномернее, и только недавно запрошенный контент остаётся на CDN.

### Недостатки CDN

* Затраты на CDN могут быть значительными в зависимости от трафика, однако их следует сравнивать с дополнительными расходами при отказе от CDN.
* Контент может устареть, если он обновится до истечения TTL.
* Для использования CDN требуется изменение URL-адресов статического контента на адреса CDN.

### Источники и дополнительная литература

* [Глобально распределённая доставка контента](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)
* [Различия между Push и Pull CDN](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)
* [Википедия](https://en.wikipedia.org/wiki/Content_delivery_network)

## Балансировщик нагрузки

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Источник: Шаблоны проектирования масштабируемых систем</a></i>
</p>

Балансировщики нагрузки распределяют входящие клиентские запросы на вычислительные ресурсы, такие как серверы приложений и базы данных. В каждом случае балансировщик возвращает ответ вычислительного ресурса соответствующему клиенту. Балансировщики нагрузки эффективны для:

* Предотвращения отправки запросов на неработоспособные серверы
* Предотвращения перегрузки ресурсов
* Помощи в устранении единой точки отказа

Балансировщики нагрузки могут быть реализованы с помощью аппаратного обеспечения (дорого) или программно, например, с помощью HAProxy.

Дополнительные преимущества включают:

* **SSL-терминация** — Расшифровка входящих запросов и шифрование ответов сервера, чтобы серверы не выполняли эти потенциально дорогие операции
    * Устраняет необходимость установки [X.509 сертификатов](https://en.wikipedia.org/wiki/X.509) на каждом сервере
* **Сохранение сессии** — Выпуск cookie и маршрутизация запросов конкретного клиента к одной и той же инстанции, если веб-приложения не отслеживают сессии

Для защиты от отказов обычно настраивают несколько балансировщиков нагрузки в режиме [active-passive](#active-passive) или [active-active](#active-active).

Балансировщики нагрузки могут маршрутизировать трафик на основе различных метрик, включая:

* Случайный выбор
* Наименее загруженный
* Сессии/cookie
* [Кольцевой или взвешенный кольцевой алгоритм](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)
* [Уровень 4](#layer-4-load-balancing)
* [Уровень 7](#layer-7-load-balancing)

### Балансировка нагрузки на уровне 4

Балансировщики нагрузки уровня 4 анализируют информацию на [транспортном уровне](#communication) для принятия решения о распределении запросов. Обычно это включает исходные и целевые IP-адреса и порты в заголовке, но не содержимое пакета. Балансировщики уровня 4 пересылают сетевые пакеты на вышестоящий сервер и обратно, выполняя [сетевой адресный перевод (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/).

### Балансировка нагрузки на уровне 7
Балансировщики нагрузки уровня 7 анализируют [уровень приложения](#communication), чтобы решить, как распределять запросы. Это может включать содержимое заголовков, сообщений и cookies. Балансировщик нагрузки уровня 7 завершает сетевой трафик, читает сообщение, принимает решение о балансировке нагрузки, затем открывает соединение с выбранным сервером. Например, балансировщик уровня 7 может направлять видеотрафик на серверы с видео, а более чувствительный трафик, связанный с оплатой, — на защищённые серверы.

В ущерб гибкости балансировка нагрузки уровня 4 требует меньше времени и вычислительных ресурсов, чем уровень 7, хотя влияние на производительность может быть минимальным на современном массовом оборудовании.

### Горизонтальное масштабирование

Балансировщики нагрузки также помогают с горизонтальным масштабированием, повышая производительность и доступность. Масштабирование с использованием массовых машин более экономично и приводит к большей доступности, чем масштабирование одного сервера на более дорогом оборудовании, называемом **вертикальным масштабированием**. Также проще нанимать специалистов, работающих с массовым оборудованием, чем с специализированными корпоративными системами.

#### Недостатки: горизонтальное масштабирование

* Горизонтальное масштабирование увеличивает сложность и требует клонирования серверов
    * Сервера должны быть без состояния: не должны содержать пользовательские данные, такие как сессии или фотографии профиля
    * Сессии можно хранить в централизованном хранилище данных, таком как [база данных](#database) (SQL, NoSQL) или постоянный [кэш](#cache) (Redis, Memcached)
* Нижестоящие серверы, такие как кэши и базы данных, должны обрабатывать больше одновременных соединений по мере масштабирования верхних серверов

### Недостатки: балансировщик нагрузки

* Балансировщик нагрузки может стать узким местом по производительности, если у него недостаточно ресурсов или он неправильно настроен.
* Внедрение балансировщика нагрузки для устранения единой точки отказа увеличивает сложность.
* Один балансировщик нагрузки — это единая точка отказа, настройка нескольких балансировщиков дополнительно усложняет систему.

### Источники и дополнительная литература

* [Архитектура NGINX](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [Руководство по архитектуре HAProxy](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Масштабируемость](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
* [Википедия](https://en.wikipedia.org/wiki/Load_balancing_(computing))
* [Балансировка нагрузки уровня 4](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)
* [Балансировка нагрузки уровня 7](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)
* [Конфигурация ELB listener](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)

## Реверс-прокси (веб-сервер)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Источник: Википедия</a></i>
  <br/>
</p>

Реверсивный прокси — это веб-сервер, который централизует внутренние сервисы и предоставляет унифицированные интерфейсы для внешних пользователей. Запросы от клиентов перенаправляются на сервер, который может их обработать, после чего реверсивный прокси возвращает ответ сервера клиенту.

Дополнительные преимущества включают:

* **Повышенная безопасность** — скрытие информации о сервере бэкенда, черные списки IP, ограничение количества соединений на клиента
* **Повышенная масштабируемость и гибкость** — клиенты видят только IP-адрес реверсивного прокси, что позволяет масштабировать серверы или менять их конфигурацию
* **SSL-терминация** — дешифрование входящих запросов и шифрование ответов сервера, чтобы серверы бэкенда не выполняли эти ресурсоемкие операции
    * Устраняет необходимость установки [X.509 сертификатов](https://en.wikipedia.org/wiki/X.509) на каждом сервере
* **Сжатие** — сжатие ответов сервера
* **Кэширование** — возврат ответа для кэшированных запросов
* **Статический контент** — обслуживание статического контента напрямую
    * HTML/CSS/JS
    * Фотографии
    * Видео
    * и др.

### Балансировщик нагрузки vs реверсивный прокси

* Использование балансировщика нагрузки полезно, когда у вас несколько серверов. Часто балансировщики маршрутизируют трафик на набор серверов, выполняющих одну функцию.
* Реверсивные прокси могут быть полезны даже при наличии только одного веб-сервера или сервере приложений, открывая преимущества, описанные в предыдущем разделе.
* Решения такие, как NGINX и HAProxy, поддерживают как проксирование на уровне 7, так и балансировку нагрузки.

### Недостатки: реверсивный прокси

* Внедрение реверсивного прокси увеличивает сложность инфраструктуры.
* Один реверсивный прокси становится единой точкой отказа, а настройка нескольких прокси (например, [аварийное переключение](https://en.wikipedia.org/wiki/Failover)) еще больше усложняет систему.

### Источники и дополнительная литература

* [Reverse proxy vs load balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)
* [Архитектура NGINX](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [Руководство по архитектуре HAProxy](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)

## Прикладной уровень

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png">
  <br/>

  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Источник: Введение в архитектурирование систем для масштабирования</a></i>
</p>

Разделение веб-слоя и слоя приложения (также известного как платформенный слой) позволяет масштабировать и конфигурировать оба слоя независимо. Добавление нового API приводит к добавлению серверов приложений без необходимости увеличения количества веб-серверов. **Принцип единственной ответственности** призывает к созданию небольших и автономных сервисов, которые работают совместно. Маленькие команды с небольшими сервисами могут более агрессивно планировать быстрый рост.

Рабочие процессы в слое приложения также способствуют [асинхронности](#asynchronism).

### Микросервисы

К данной теме относятся [микросервисы](https://ru.wikipedia.org/wiki/Микросервисы), которые можно описать как набор автономно разворачиваемых, небольших, модульных сервисов. Каждый сервис запускает уникальный процесс и общается через хорошо определённый, легковесный механизм для достижения бизнес-цели. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>

Например, у Pinterest могут быть следующие микросервисы: профиль пользователя, подписчики, лента, поиск, загрузка фотографий и др.

### Обнаружение сервисов

Системы, такие как [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), и [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) помогают сервисам находить друг друга, отслеживая зарегистрированные имена, адреса и порты. [Проверки состояния](https://www.consul.io/intro/getting-started/checks.html) помогают убедиться в целостности сервиса и часто выполняются с помощью [HTTP](#hypertext-transfer-protocol-http) эндпоинта. И Consul, и Etcd имеют встроенное [хранилище ключ-значение](#key-value-store), полезное для хранения конфигураций и других общих данных.

### Недостатки: слой приложения

* Добавление слоя приложения с слабо связанными сервисами требует другого подхода с архитектурной, операционной и процессной точек зрения (в отличие от монолитной системы).
* Микросервисы могут усложнить процесс деплоя и эксплуатации.

### Источники и дополнительная литература

* [Введение в архитектурирование систем для масштабирования](http://lethain.com/introduction-to-architecting-systems-for-scale)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Сервис-ориентированная архитектура](https://ru.wikipedia.org/wiki/Сервис-ориентированная_архитектура)
* [Введение в Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)
* [Что нужно знать о построении микросервисов](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)

## База данных

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Источник: Масштабирование до первых 10 миллионов пользователей</a></i>
</p>

### Реляционная система управления базами данных (RDBMS)

Реляционная база данных, такая как SQL, представляет собой коллекцию элементов данных, организованных в таблицы.

**ACID** — это набор свойств [транзакций](https://en.wikipedia.org/wiki/Database_transaction) реляционной базы данных.

* **Атомарность** — каждая транзакция выполняется полностью или не выполняется вовсе
* **Согласованность** — любая транзакция переводит базу данных из одного корректного состояния в другое
* **Изолированность** — выполнение транзакций параллельно приводит к тем же результатам, что и последовательное выполнение
* **Долговечность** — после фиксации транзакции она остается сохраненной

Существует множество методов масштабирования реляционной базы данных: **мастер-слейв репликация**, **мастер-мастер репликация**, **федерация**, **шардинг**, **денормализация** и **SQL-оптимизация**.

#### Мастер-слейв репликация

Мастер обслуживает операции чтения и записи, реплицируя записи на одного или нескольких слейвов, которые обслуживают только чтение. Слейвы также могут реплицироваться на других слейвов в виде дерева. Если мастер выходит из строя, система может продолжать работать в режиме только для чтения до тех пор, пока слейв не будет повышен до мастера или не будет создан новый мастер.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Источник: Масштабируемость, доступность, стабильность, паттерны</a></i>
</p>

##### Недостаток(и): мастер-слейв репликация

* Требуется дополнительная логика для повышения слейва до мастера.
* См. [Недостаток(и): репликация](#disadvantages-replication) для пунктов, относящихся **к обеим** схемам мастер-слейв и мастер-мастер.

#### Мастер-мастер репликация

Оба мастера обслуживают операции чтения и записи и согласовывают между собой операции записи. Если один из мастеров выходит из строя, система может продолжать обслуживать как чтение, так и запись.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Источник: Масштабируемость, доступность, стабильность, паттерны</a></i>
</p>

##### Недостаток(и): мастер-мастер репликация

* Понадобится балансировщик нагрузки или потребуется внести изменения в логику приложения для определения места записи.
* Большинство мастер-мастер систем либо слабо согласованы (нарушая ACID), либо имеют увеличенную задержку записи из-за синхронизации.
* Разрешение конфликтов становится более актуальным по мере добавления большего количества узлов записи и увеличения задержки.
* См. [Недостатки: репликация](#disadvantages-replication) для моментов, относящихся к **мастер-слейв** и мастер-мастер.

##### Недостатки: репликация

* Существует вероятность потери данных, если мастер выйдет из строя до того, как вновь записанные данные будут реплицированы на другие узлы.
* Записи воспроизводятся на репликах для чтения. Если записей много, реплики для чтения могут быть перегружены воспроизведением записей и не смогут выполнять столько операций чтения.
* Чем больше реплик для чтения, тем больше требуется реплицировать, что приводит к увеличению задержки репликации.
* В некоторых системах запись на мастер может запускать несколько потоков для параллельной записи, тогда как реплики для чтения поддерживают только последовательную запись одним потоком.
* Репликация требует больше оборудования и увеличивает сложность.

##### Источники и дополнительная литература: репликация

* [Масштабируемость, доступность, стабильность, паттерны](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Мульти-мастер репликация](https://en.wikipedia.org/wiki/Multi-master_replication)

#### Федерация

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Источник: Масштабирование до первых 10 миллионов пользователей</a></i>
</p>

Федерация (или функциональное разделение) разделяет базы данных по функциям. Например, вместо одной монолитной базы данных можно иметь три базы: **форумы**, **пользователи** и **товары**, что приводит к меньшему количеству операций чтения и записи в каждой базе и, соответственно, меньшей задержке репликации. Меньшие базы позволяют большему объему данных помещаться в памяти, что увеличивает количество попаданий в кэш благодаря улучшенной локальности кэша. При отсутствии единого центрального мастера, сериализующего записи, вы можете писать параллельно, увеличивая пропускную способность.

##### Недостатки: федерация

* Федерация неэффективна, если ваша схема требует огромных функций или таблиц.
* Понадобится обновить логику приложения для определения, из какой базы читать и писать.
* Объединение данных из двух баз становится сложнее с использованием [server link](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).
* Федерация требует больше оборудования и увеличивает сложность.

##### Источники и дополнительная литература: федерация

* [Масштабирование до первых 10 миллионов пользователей](https://www.youtube.com/watch?v=kKjm4ehYiMs)

#### Шардинг

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Источник: Масштабируемость, доступность, стабильность, паттерны</a></i>
</p>

Шардинг распределяет данные между различными базами данных таким образом, что каждая база может управлять только частью данных. Например, если рассматривать базу данных пользователей, то с увеличением числа пользователей в кластер добавляются новые шарды.

Подобно преимуществам [федерации](#federation), шардинг приводит к меньшему количеству операций чтения и записи, меньшему количеству репликаций и большему количеству попаданий в кеш. Размер индекса также уменьшается, что обычно улучшает производительность и ускоряет запросы. Если один шард выходит из строя, остальные продолжают работать, хотя желательно добавить какую-либо форму репликации, чтобы избежать потери данных. Как и при федерации, отсутствует единый центральный мастер, сериализующий записи, что позволяет писать параллельно с увеличенной пропускной способностью.

Распространенные способы шардинга таблицы пользователей — по первой букве фамилии или по географическому расположению пользователя.

##### Недостатки: шардинг

* Необходимо обновлять логику приложения для работы с шардами, что может привести к сложным SQL-запросам.
* Распределение данных может оказаться неравномерным. Например, наличие группы активных пользователей на одном шарде может привести к повышенной нагрузке на этот шард по сравнению с другими.
    * Перебалансировка добавляет дополнительную сложность. Функция шардинга на основе [консистентного хеширования](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) может уменьшить объем передаваемых данных.
* Объединение данных из нескольких шардов становится более сложным.
* Шардинг требует больше аппаратных ресурсов и увеличивает сложность.

##### Источники и дополнительная литература: шардинг

* [Приход шарда](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)
* [Архитектура шардинга БД](https://ru.wikipedia.org/wiki/Шард_(архитектура_базы_данных))
* [Консистентное хеширование](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)

#### Денормализация

Денормализация пытается повысить производительность чтения за счет некоторого ухудшения производительности записи. Избыточные копии данных записываются в несколько таблиц, чтобы избежать затратных объединений. Некоторые СУБД, такие как [PostgreSQL](https://ru.wikipedia.org/wiki/PostgreSQL) и Oracle, поддерживают [материализованные представления](https://ru.wikipedia.org/wiki/Материализованное_представление), которые берут на себя задачу хранения избыточной информации и поддержания согласованности копий.

Когда данные распределяются с помощью таких техник, как [федерация](#federation) и [шардинг](#sharding), управление объединениями между дата-центрами становится еще сложнее. Денормализация может помочь избежать необходимости в таких сложных объединениях.

В большинстве систем количество чтений значительно превышает количество записей — в соотношении 100:1 или даже 1000:1. Операция чтения, приводящая к сложному объединению в базе данных, может быть очень затратной, тратя значительное время на операции с диском.

##### Недостатки: денормализация

* Данные дублируются.
* Ограничения могут помочь синхронизировать избыточные копии информации, что увеличивает сложность проектирования базы данных.
* Денормализованная база данных под высокой нагрузкой на запись может работать хуже, чем нормализованная.

###### Источники и дополнительная литература: денормализация

* [Денормализация](https://ru.wikipedia.org/wiki/Денормализация)

#### Настройка SQL

Настройка SQL — это обширная тема, и написано много [книг](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) в качестве справочников.

Важно проводить **бенчмаркинг** и **профилирование** для моделирования и выявления узких мест.

* **Бенчмаркинг** — моделируйте ситуации высокой нагрузки с помощью таких инструментов, как [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).
* **Профилирование** — используйте такие инструменты, как [журнал медленных запросов](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html), чтобы отслеживать проблемы с производительностью.

Бенчмаркинг и профилирование могут указать на следующие оптимизации.

##### Уточните схему

* MySQL записывает данные на диск в смежных блоках для быстрого доступа.
* Используйте `CHAR` вместо `VARCHAR` для полей фиксированной длины.
    * `CHAR` обеспечивает быстрый случайный доступ, тогда как с `VARCHAR` необходимо найти конец строки перед переходом к следующей.
* Используйте `TEXT` для больших блоков текста, таких как посты блога. `TEXT` также позволяет выполнять булевы поиски. Использование поля `TEXT` приводит к хранению указателя на диске, который используется для поиска текстового блока.
* Используйте `INT` для больших чисел до 2^32 или 4 миллиардов.
* Используйте `DECIMAL` для хранения валюты, чтобы избежать ошибок представления с плавающей точкой.
* Избегайте хранения больших `BLOB`, храните только местоположение объекта.
* `VARCHAR(255)` — это максимальное количество символов, которое можно посчитать в 8-битном числе, часто позволяя максимально использовать байт в некоторых СУБД.
* Устанавливайте ограничение `NOT NULL` там, где это возможно, чтобы [улучшить производительность поиска](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).

##### Используйте хорошие индексы

* Столбцы, по которым выполняются запросы (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`), могут работать быстрее с индексами.
* Индексы обычно реализованы как самобалансирующееся [B-дерево](https://ru.wikipedia.org/wiki/B-дерево), которое хранит данные в отсортированном виде и позволяет выполнять поиск, последовательный доступ, вставку и удаление за логарифмическое время.
* Размещение индекса может держать данные в памяти, что требует больше пространства.
* Запись может быть медленнее, так как индекс также нужно обновлять.
* При загрузке большого объема данных может быть быстрее отключить индексы, загрузить данные, а затем перестроить индексы.

##### Избегайте дорогих соединений

* [Денормализуйте](#denormalization), если этого требует производительность.

##### Разделяйте таблицы

* Разделите таблицу, поместив горячие точки в отдельную таблицу, чтобы облегчить её хранение в памяти.

##### Настройка кэша запросов

* В некоторых случаях [кэш запросов](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) может привести к [проблемам с производительностью](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).

##### Источники и дополнительная литература: оптимизация SQL

* [Советы по оптимизации MySQL-запросов](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)
* [Почему так часто используется VARCHAR(255)?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [Как значения NULL влияют на производительность?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Журнал медленных запросов](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)

### NoSQL

NoSQL — это набор элементов данных, представленных в виде **хранилища ключ-значение**, **документного хранилища**, **широкого столбцового хранилища** или **графовой базы данных**. Данные денормализованы, а соединения обычно выполняются в коде приложения. Большинство NoSQL-хранилищ не поддерживают настоящие транзакции ACID и предпочитают [конечную согласованность](#eventual-consistency).

**BASE** часто используется для описания свойств NoSQL-баз данных. В сравнении с [теоремой CAP](#cap-theorem), BASE выбирает доступность вместо согласованности.

* **В основном доступная** — система гарантирует доступность.
* **Мягкое состояние** — состояние системы может изменяться со временем, даже без внешнего воздействия.
* **Конечная согласованность** — система станет согласованной спустя некоторое время, если за этот период не поступит новых данных.

Помимо выбора между [SQL или NoSQL](#sql-or-nosql), полезно понять, какой тип NoSQL-базы данных лучше всего подходит для вашего кейса(-ов). В следующем разделе мы рассмотрим **хранилища ключ-значение**, **документные хранилища**, **широкие столбцовые хранилища** и **графовые базы данных**.

#### Хранилище ключ-значение

> Абстракция: хеш-таблица

Хранилище ключ-значение обычно обеспечивает операции чтения и записи за O(1) и часто работает на основе памяти или SSD. Хранилища могут поддерживать ключи в [лексикографическом порядке](https://en.wikipedia.org/wiki/Lexicographical_order), что позволяет эффективно извлекать диапазоны ключей. В хранилищах ключ-значение можно хранить метаданные вместе со значением.

Хранилища ключ-значение обеспечивают высокую производительность и часто используются для простых моделей данных или быстро изменяющихся данных, например, для слоя кэша в памяти. Поскольку они предлагают ограниченный набор операций, дополнительная сложность переносится на уровень приложения, если необходимы дополнительные операции.

Хранилище ключ-значение является основой для более сложных систем, таких как документные хранилища, а в некоторых случаях — графовые базы данных.

##### Источники и дополнительная литература: хранилище ключ-значение

* [База данных ключ-значение](https://en.wikipedia.org/wiki/Key-value_database)
* [Недостатки хранилищ ключ-значение](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)
* [Архитектура Redis](http://qnimate.com/overview-of-redis-architecture/)
* [Архитектура Memcached](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)

#### Документное хранилище

> Абстракция: хранилище ключ-значение, где документы сохраняются как значения

Документное хранилище строится вокруг документов (XML, JSON, бинарные файлы и др.), где документ хранит всю информацию об объекте. Документные хранилища предоставляют API или язык запросов для получения данных на основе внутренней структуры самого документа. *Заметьте, многие хранилища ключ-значение содержат функции для работы с метаданными значения, размывая границы между этими двумя типами хранения.*

В зависимости от реализации документы организованы по коллекциям, тегам, метаданным или директориям. Хотя документы могут быть сгруппированы, поля документов могут сильно отличаться друг от друга.

Некоторые документные хранилища, такие как [MongoDB](https://www.mongodb.com/mongodb-architecture) и [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/), также предоставляют язык запросов, похожий на SQL, для выполнения сложных запросов. [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) поддерживает работу как с ключ-значениями, так и с документами.

Документные хранилища обеспечивают высокую гибкость и часто используются для работы с редко изменяющимися данными.

##### Источники и дополнительная литература: документное хранилище

* [Документно-ориентированная база данных](https://en.wikipedia.org/wiki/Document-oriented_database)
* [Архитектура MongoDB](https://www.mongodb.com/mongodb-architecture)
* [Архитектура CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Архитектура Elasticsearch](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)

#### Хранилище широких столбцов

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Источник: SQL & NoSQL, краткая история</a></i>
</p>

> Абстракция: вложенная карта `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`

Базовой единицей данных в хранилище широких столбцов является столбец (пара имя/значение). Столбцы могут быть сгруппированы в семейства столбцов (аналог таблицы SQL). Суперсемейства столбцов объединяют семейства столбцов. Доступ к каждому столбцу осуществляется независимо по ключу строки, а столбцы с одинаковым ключом строки формируют строку. Каждое значение содержит временную метку для версионирования и разрешения конфликтов.

Google представила [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) как первое хранилище широких столбцов, которое повлияло на открытый проект [HBase](https://www.edureka.co/blog/hbase-architecture/), часто используемый в экосистеме Hadoop, и [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) от Facebook. Хранилища типа BigTable, HBase и Cassandra поддерживают ключи в лексикографическом порядке, что позволяет эффективно извлекать диапазоны ключей.

Хранилища широких столбцов обеспечивают высокую доступность и масштабируемость. Они часто применяются для работы с очень большими наборами данных.

##### Источники и дополнительная литература: хранилище широких столбцов

* [SQL & NoSQL, краткая история](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)
* [Архитектура Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)
* [Архитектура HBase](https://www.edureka.co/blog/hbase-architecture/)
* [Архитектура Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)

#### Графовые базы данных

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png">
  <br/>
  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Источник: Графовая база данных</a></i>
</p>

> Абстракция: граф

В графовой базе данных каждая вершина — это запись, а каждое ребро — это связь между двумя вершинами. Графовые базы данных оптимизированы для представления сложных отношений с множеством внешних ключей или отношений многие-ко-многим.

Графовые базы данных обеспечивают высокую производительность для моделей данных со сложными взаимосвязями, таких как социальные сети. Они относительно новые и пока не получили широкого распространения; может быть сложнее найти инструменты и ресурсы для разработки. Многие графы доступны только через [REST API](#representational-state-transfer-rest).

##### Источники и дополнительная литература: граф

* [Графовые базы данных](https://en.wikipedia.org/wiki/Graph_database)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)

#### Источники и дополнительная литература: NoSQL

* [Объяснение базовой терминологии](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [NoSQL базы данных: обзор и рекомендации по выбору](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [Масштабируемость](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [Введение в NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [NoSQL паттерны](http://horicky.blogspot.com/2009/11/nosql-patterns.html)

### SQL или NoSQL

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Источник: Переход от RDBMS к NoSQL</a></i>
</p>

Причины выбрать **SQL**:

* Структурированные данные
* Строгая схема
* Реляционные данные
* Необходимость сложных соединений
* Транзакции
* Четкие паттерны масштабирования
* Более устоявшаяся технология: разработчики, сообщество, код, инструменты и др.
* Поиск по индексу очень быстрый

Причины выбрать **NoSQL**:

* Полуструктурированные данные
* Динамическая или гибкая схема
* Нереляционные данные
* Нет необходимости в сложных соединениях
* Хранение многих ТБ (или ПБ) данных
* Очень интенсивная нагрузка на данные
* Очень высокая производительность по IOPS

Примеры данных, хорошо подходящих для NoSQL:

* Быстрый прием потоковых данных и логов
* Лидеры или данные по очкам
* Временные данные, такие как корзина покупок
* Часто запрашиваемые ("горячие") таблицы
* Таблицы метаданных/поиска

##### Источники и дополнительные материалы: SQL или NoSQL

* [Масштабирование до первых 10 миллионов пользователей](https://www.youtube.com/watch?v=kKjm4ehYiMs)
* [Различия между SQL и NoSQL](https://www.sitepoint.com/sql-vs-nosql-differences/)

## Кэш

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Источник: Шаблоны проектирования масштабируемых систем</a></i>
</p>

Кэширование улучшает время загрузки страниц и может снизить нагрузку на ваши серверы и базы данных. В этой модели диспетчер сначала проверяет, был ли сделан такой запрос ранее, и пытается найти предыдущий результат для возврата, чтобы избежать фактического выполнения.

Базы данных часто выигрывают от равномерного распределения чтений и записей по своим разделам. Популярные элементы могут искажать распределение, вызывая узкие места. Размещение кэша перед базой данных помогает сглаживать неравномерную нагрузку и всплески трафика.

### Кэширование на стороне клиента

Кэш может располагаться на стороне клиента (ОС или браузер), [на стороне сервера](#reverse-proxy-web-server) или в отдельном уровне кэширования.

### Кэширование CDN

[CDN](#content-delivery-network) считаются одним из видов кэша.

### Кэширование веб-сервера

[Обратные прокси](#reverse-proxy-web-server) и кэши, такие как [Varnish](https://www.varnish-cache.org/), могут обслуживать статический и динамический контент напрямую. Веб-серверы также могут кэшировать запросы, возвращая ответы без обращения к серверу приложений.

### Кэширование базы данных

Ваша база данных обычно включает некоторый уровень кэширования в стандартной конфигурации, оптимизированной для общего случая. Настройка этих параметров для конкретных сценариев использования может еще больше повысить производительность.

### Кэширование приложения

Кэши в оперативной памяти, такие как Memcached и Redis, являются хранилищами "ключ-значение" между вашим приложением и хранилищем данных. Поскольку данные хранятся в ОЗУ, они намного быстрее, чем в типичных базах данных, где данные записываются на диск. ОЗУ более ограничено, чем диск, поэтому алгоритмы [инвалидации кэша](https://en.wikipedia.org/wiki/Cache_algorithms), такие как [наименее недавно использованные (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)), помогают удалять "холодные" записи и держать "горячие" данные в ОЗУ.

У Redis есть следующие дополнительные возможности:

* Опция персистентности
* Встроенные структуры данных, такие как отсортированные множества и списки

Существует несколько уровней кэширования, которые делятся на две основные категории: **запросы к базе данных** и **объекты**:

* На уровне строки
* На уровне запроса
* Полностью сформированные сериализуемые объекты
* Полностью отрендеренный HTML

Как правило, следует избегать файлового кэширования, так как это усложняет клонирование и автоскейлинг.

### Кэширование на уровне запросов к базе данных

Всякий раз, когда вы выполняете запрос к базе данных, хэшируйте запрос как ключ и сохраняйте результат в кэше. Такой подход страдает от проблем с истечением срока действия:

* Сложно удалить закэшированный результат для сложных запросов
* Если одна часть данных изменяется, например ячейка таблицы, необходимо удалить все закэшированные запросы, которые могут содержать измененную ячейку

### Кэширование на уровне объекта

Рассматривайте ваши данные как объект, аналогично тому, как вы работаете с кодом приложения. Пусть приложение собирает набор данных из базы в экземпляр класса или структуру данных:

* Удалите объект из кэша, если его исходные данные изменились
* Позволяет асинхронную обработку: воркеры собирают объекты, используя последние закэшированные объекты

Что можно кэшировать:

* Сессии пользователей
* Полностью отрендеренные веб-страницы
* Потоки активности
* Данные графа пользователя

### Когда обновлять кэш

Поскольку вы можете хранить в кэше только ограниченное количество данных, необходимо определить стратегию обновления кэша, которая лучше всего подходит для вашего случая.

#### Cache-aside

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Источник: From cache to in-memory data grid</a></i>
</p>

Приложение отвечает за чтение и запись из хранилища. Кэш не взаимодействует с хранилищем напрямую. Приложение выполняет следующие действия:

* Поиск записи в кэше, приводящий к промаху по кэшу
* Загрузка записи из базы данных
* Добавление записи в кэш
* Возврат записи

```python
def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```

[Memcached](https://memcached.org/) обычно используется таким образом.

Последующие чтения данных, добавленных в кэш, происходят быстро. Cache-aside также называется ленивой загрузкой (lazy loading). В кэш помещаются только запрошенные данные, что предотвращает заполнение кэша неиспользуемыми данными.

##### Недостаток(и): cache-aside

* Каждый промах кэша приводит к трем обращениям, что может вызвать заметную задержку.
* Данные могут устаревать, если они были обновлены в базе данных. Эта проблема решается установкой времени жизни (TTL), которое принудительно обновляет запись в кэше, или использованием write-through.
* При отказе узла он заменяется новым, пустым узлом, что увеличивает задержку.

#### Write-through

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Источник: Масштабируемость, доступность, стабильность, паттерны</a></i>
</p>

Приложение использует кэш как основное хранилище данных, читая и записывая данные в него, при этом кэш отвечает за чтение и запись в базу данных:

* Приложение добавляет/обновляет запись в кэше
* Кэш синхронно записывает запись в хранилище данных
* Возврат

Код приложения:

```python
set_user(12345, {"foo":"bar"})
```

Код кэша:

```python
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```
Запись с немедленным сохранением (write-through) — это медленная операция из-за записи, но последующие чтения только что записанных данных выполняются быстро.  Пользователи обычно более терпимы к задержкам при обновлении данных, чем при чтении данных.  Данные в кэше не устаревшие.

##### Недостатки: запись с немедленным сохранением

* Когда создается новый узел из-за сбоя или масштабирования, новый узел не будет кэшировать записи до тех пор, пока запись не будет обновлена в базе данных.  Использование кэширования по запросу вместе с записью с немедленным сохранением может снизить этот недостаток.
* Большинство записанных данных могут никогда не быть считаны, что можно минимизировать с помощью TTL.

#### Запись с отложенным сохранением (write-behind, write-back)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Источник: Масштабируемость, доступность, стабильность, паттерны</a></i>
</p>

При записи с отложенным сохранением приложение выполняет следующие действия:

* Добавляет/обновляет запись в кэше
* Асинхронно записывает запись в хранилище данных, улучшая производительность записи

##### Недостатки: запись с отложенным сохранением

* Может произойти потеря данных, если кэш выйдет из строя до того, как его содержимое попадет в хранилище данных.
* Реализация записи с отложенным сохранением сложнее, чем реализация кэширования по запросу или записи с немедленным сохранением.

#### Предварительное обновление (refresh-ahead)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Источник: От кэша к распределенному хранилищу данных в памяти</a></i>
</p>

Можно настроить кэш так, чтобы он автоматически обновлял недавно запрошенные записи кэша до их истечения срока действия.

Предварительное обновление может привести к снижению задержки по сравнению с чтением через кэш, если кэш способен точно предсказать, какие элементы могут понадобиться в будущем.

##### Недостатки: предварительное обновление


* Неточной прогнозирование того, какие элементы могут понадобиться в будущем, может привести к снижению производительности по сравнению с отсутствием предварительного обновления.

### Недостаток(и): кэш

* Необходимо поддерживать согласованность между кэшами и источником истины, таким как база данных, через [инвалидацию кэша](https://en.wikipedia.org/wiki/Cache_algorithms).
* Инвалидация кэша — сложная задача, существует дополнительная сложность, связанная с определением момента обновления кэша.
* Требуется внесение изменений в приложение, например добавление Redis или memcached.

### Источники и дополнительная литература

* [От кэша к распределённой памяти](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [Шаблоны проектирования масштабируемых систем](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [Введение в архитектуру систем для масштабирования](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [Масштабируемость, доступность, стабильность, шаблоны](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Масштабируемость](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [Стратегии AWS ElastiCache](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)
* [Википедия](https://en.wikipedia.org/wiki/Cache_(computing))

## Асинхронность

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Источник: Введение в архитектуру систем для масштабирования</a></i>
</p>

Асинхронные процессы помогают сократить время ответа для ресурсоёмких операций, которые в противном случае выполнялись бы в реальном времени. Они также полезны для предварительного выполнения трудоёмких задач, например периодической агрегации данных.

### Очереди сообщений

Очереди сообщений принимают, хранят и доставляют сообщения. Если операция слишком медленная для выполнения в реальном времени, можно использовать очередь сообщений с следующим процессом:

* Приложение публикует задачу в очередь, затем уведомляет пользователя о статусе задачи
* Рабочий процесс извлекает задачу из очереди, обрабатывает её и сигнализирует о завершении

Пользователь не блокируется, а задача обрабатывается в фоновом режиме. В это время клиент может выполнять небольшую обработку, чтобы создать видимость завершения задачи. Например, при публикации твита, твит может мгновенно появиться на вашей ленте, но потребуется время, чтобы он был доставлен всем вашим подписчикам.

**[Redis](https://redis.io/)** полезен как простой брокер сообщений, но сообщения могут быть потеряны.

**[RabbitMQ](https://www.rabbitmq.com/)** популярен, но требует адаптации к протоколу 'AMQP' и самостоятельного управления узлами.

**[Amazon SQS](https://aws.amazon.com/sqs/)** размещается на сервере, но может иметь высокую задержку и возможность повторной доставки сообщений.

### Очереди задач

Очереди задач принимают задачи и связанные с ними данные, выполняют их, а затем доставляют результаты. Они поддерживают планирование и могут использоваться для выполнения ресурсоёмких задач в фоновом режиме.

**[Celery](https://docs.celeryproject.org/en/stable/)** поддерживает планирование и в основном работает с python.

### Обратное давление

Если очереди начинают значительно расти, их размер может превысить доступную память, что приведёт к промахам кэша, чтению с диска и ещё большему снижению производительности. [Обратное давление](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) помогает, ограничивая размер очереди, что позволяет поддерживать высокую пропускную способность и хорошее время отклика для уже находящихся в очереди задач. Когда очередь переполняется, клиентам возвращается статус "сервер занят" или HTTP 503 с предложением повторить попытку позже. Клиенты могут повторить запрос позднее, возможно, с использованием [экспоненциальной задержки](https://en.wikipedia.org/wiki/Exponential_backoff).

### Недостаток(и): асинхронность

* Для таких случаев, как недорогие вычисления и рабочие процессы в реальном времени, синхронные операции могут быть более подходящими, поскольку внедрение очередей увеличивает задержки и сложность.

### Источники и дополнительная литература

* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)
* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)
* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)

## Связь

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Источник: модель OSI 7 уровней</a></i>
</p>

### Протокол передачи гипертекста (HTTP)

HTTP — это способ кодирования и передачи данных между клиентом и сервером. Это протокол запрос/ответ: клиенты отправляют запросы, а серверы возвращают ответы с соответствующим содержимым и статусом завершения запроса. HTTP самодостаточен, позволяя передавать запросы и ответы через множество промежуточных маршрутизаторов и серверов, осуществляющих балансировку нагрузки, кэширование, шифрование и сжатие.

Базовый HTTP-запрос состоит из глагола (метода) и ресурса (конечной точки). Ниже приведены распространённые HTTP-глаголы:

| Глагол | Описание | Идемпотентность* | Безопасность | Кэшируемость |
|---|---|---|---|---|
| GET | Читает ресурс | Да | Да | Да |
| POST | Создает ресурс или запускает процесс обработки данных | Нет | Нет | Да, если ответ содержит информацию о свежести |
| PUT | Создает или заменяет ресурс | Да | Нет | Нет |
| PATCH | Частично обновляет ресурс | Нет | Нет | Да, если ответ содержит информацию о свежести |
| DELETE | Удаляет ресурс | Да | Нет | Нет |

*Может вызываться много раз без разных результатов.

HTTP — это протокол прикладного уровня, основанный на протоколах более низкого уровня, таких как **TCP** и **UDP**.

#### Источники и дополнительная литература: HTTP

* [Что такое HTTP?](https://www.nginx.com/resources/glossary/http/)
* [Различие между HTTP и TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [Различие между PUT и PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)

### Протокол управления передачей (TCP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Источник: Как создать многопользовательскую игру</a></i>
</p>

TCP — это ориентированный на соединение протокол поверх [IP-сети](https://en.wikipedia.org/wiki/Internet_Protocol). Соединение устанавливается и завершается с помощью [рукопожатия](https://en.wikipedia.org/wiki/Handshaking). Все отправленные пакеты гарантированно достигают назначения в исходном порядке и без повреждений благодаря:

* Номерам последовательности и [контрольным суммам](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) для каждого пакета
* Пакетам [подтверждения](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) и автоматической повторной передаче

Если отправитель не получает корректный ответ, он повторно отправляет пакеты. При множественных тайм-аутах соединение разрывается. TCP также реализует [управление потоком](https://en.wikipedia.org/wiki/Flow_control_(data)) и [управление перегрузкой](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control). Эти гарантии приводят к задержкам и обычно менее эффективной передаче данных по сравнению с UDP.

Для обеспечения высокой пропускной способности веб-серверы могут держать большое количество открытых TCP-соединений, что приводит к высокому расходу памяти. Держать много открытых соединений между потоками веб-сервера и, например, сервером [memcached](https://memcached.org/) может быть дорого. [Пул соединений](https://en.wikipedia.org/wiki/Connection_pool) может помочь, также стоит рассмотреть переход на UDP, где это возможно.

TCP полезен для приложений, которым требуется высокая надежность, но они менее критичны к времени. Примеры: веб-серверы, информация баз данных, SMTP, FTP и SSH.

Используйте TCP вместо UDP, когда:

* Вам нужно, чтобы все данные пришли без потерь
* Вы хотите автоматически оптимально использовать пропускную способность сети

### Протокол пользовательских дейтаграмм (UDP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Источник: Как сделать многопользовательскую игру</a></i>
</p>

UDP является протоколом без установления соединения. Дейтаграммы (аналогично пакетам) гарантируются только на уровне дейтаграмм. Дейтаграммы могут прибывать в пункт назначения не по порядку или не прибывать вообще. UDP не поддерживает управление перегрузкой. Без гарантий, которые предоставляет TCP, UDP, как правило, более эффективен.

UDP может осуществлять широковещательную передачу, отправляя дейтаграммы всем устройствам в подсети. Это полезно при [DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol), поскольку клиент еще не получил IP-адрес, что предотвращает возможность потоковой передачи по TCP без IP-адреса.

UDP менее надежен, но хорошо работает в случаях использования в реальном времени, таких как VoIP, видеочат, стриминг и многопользовательские игры в реальном времени.

Используйте UDP вместо TCP, когда:

* Вам нужна минимальная задержка
* Просроченные данные хуже, чем потеря данных
* Вы хотите реализовать собственную коррекцию ошибок

#### Источники и дополнительная литература: TCP и UDP

* [Сетевые технологии для программирования игр](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)
* [Ключевые различия между протоколами TCP и UDP](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Различие между TCP и UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Протокол управления передачей](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
* [Протокол пользовательских дейтаграмм](https://en.wikipedia.org/wiki/User_Datagram_Protocol)
* [Масштабирование memcache в Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)

### Удалённый вызов процедур (RPC)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Источник: Crack the system design interview</a></i>
</p>

В RPC клиент инициирует выполнение процедуры в другом адресном пространстве, обычно на удалённом сервере. Процедура кодируется так, как если бы это был локальный вызов процедуры, абстрагируя детали взаимодействия с сервером от клиентской программы. Удалённые вызовы обычно медленнее и менее надёжны, чем локальные, поэтому полезно различать вызовы RPC и локальные вызовы. Популярные фреймворки RPC включают [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/) и [Avro](https://avro.apache.org/docs/current/).

RPC — это протокол типа запрос-ответ:

* **Клиентская программа** - Вызывает процедуру клиентского заглушки. Параметры помещаются в стек, как при локальном вызове процедуры.
* **Процедура клиентского заглушки** - Сериализует (упаковывает) идентификатор процедуры и аргументы в сообщение запроса.
* **Модуль связи клиента** - ОС отправляет сообщение от клиента на сервер.
* **Модуль связи сервера** - ОС передает входящие пакеты процедуре серверского заглушки.
* **Процедура серверского заглушки** - Десериализует результаты, вызывает серверную процедуру, соответствующую идентификатору процедуры, и передает заданные аргументы.
* Ответ сервера повторяет вышеуказанные шаги в обратном порядке.

Примеры вызова RPC:

```
GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
```

RPC ориентирован на предоставление поведения. RPC часто используется для повышения производительности при внутренней коммуникации, поскольку вы можете вручную создавать нативные вызовы, чтобы лучше соответствовать вашим случаям использования.

Выберите нативную библиотеку (также известную как SDK), когда:

* Вы знаете свою целевую платформу.
* Вы хотите контролировать, как ваш "логика" доступна.
* Вы хотите контролировать обработку ошибок вне вашей библиотеки.
* Производительность и опыт конечного пользователя — ваш главный приоритет.

HTTP API, соответствующие **REST**, чаще используются для публичных API.

#### Недостатки: RPC

* RPC-клиенты становятся тесно связанными с реализацией сервиса.
* Для каждой новой операции или случая использования необходимо определять новый API.
* Отладка RPC может быть затруднена.
* Возможно, вы не сможете использовать существующие технологии из коробки. Например, может потребоваться дополнительная работа, чтобы [RPC-вызовы корректно кэшировались](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) на серверах кэширования, таких как [Squid](http://www.squid-cache.org/).

### Передача состояния представления (REST)

REST — это архитектурный стиль, реализующий модель клиент/сервер, где клиент работает с набором ресурсов, управляемых сервером. Сервер предоставляет представление ресурсов и действия, которые могут либо изменить, либо получить новое представление ресурсов. Вся коммуникация должна быть без состояния и кэшируемой.

У RESTful-интерфейса есть четыре качества:

* **Идентификация ресурсов (URI в HTTP)** — используйте один и тот же URI независимо от операции.
* **Изменение с представлениями (глаголы в HTTP)** — используйте глаголы, заголовки и тело.
* **Самоописывающее сообщение об ошибке (статус ответа в HTTP)** — используйте статус-коды, не изобретайте велосипед.
* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML-интерфейс для HTTP)** — ваш веб-сервис должен быть полностью доступен через браузер.

Примеры REST-запросов:

```
GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
```
REST ориентирован на предоставление данных. Он минимизирует связь между клиентом и сервером и часто используется для публичных HTTP API. REST использует более универсальный и единообразный способ предоставления ресурсов через URI, [представление через заголовки](https://github.com/for-GET/know-your-http-well/blob/master/headers.md) и действия через такие глаголы, как GET, POST, PUT, DELETE и PATCH. Будучи статeless, REST отлично подходит для горизонтального масштабирования и разбиения на части.

#### Недостатки: REST

* Поскольку REST ориентирован на предоставление данных, он может не подойти, если ресурсы не организованы или не доступны в простой иерархии. Например, возврат всех обновленных записей за последний час, соответствующих определенному набору событий, сложно выразить в виде пути. В REST это, скорее всего, реализуется с помощью комбинации пути URI, параметров запроса и, возможно, тела запроса.
* REST обычно опирается на несколько глаголов (GET, POST, PUT, DELETE и PATCH), которые иногда не соответствуют вашему случаю использования. Например, перемещение просроченных документов в архивную папку может не вписываться в эти глаголы.
* Получение сложных ресурсов с вложенными иерархиями требует нескольких обменов между клиентом и сервером для отображения одного представления, например, получение содержимого записи блога и комментариев к ней. Для мобильных приложений, работающих в переменных сетевых условиях, эти многократные обмены крайне нежелательны.
* Со временем в ответе API могут появляться новые поля, и старые клиенты будут получать все новые поля данных, даже те, которые им не нужны, что приводит к увеличению размера полезной нагрузки и большему времени задержки.

### Сравнение вызовов RPC и REST

| Операция | RPC | REST |
|---|---|---|
| Регистрация    | **POST** /signup | **POST** /persons |
| Увольнение    | **POST** /resign<br/>{<br/>"personid": "1234"<br/>} | **DELETE** /persons/1234 |
| Прочитать пользователя | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |
| Прочитать список предметов пользователя | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |
| Добавить предмет к списку пользователя | **POST** /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | **POST** /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Обновить предмет    | **POST** /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | **PUT** /items/456<br/>{<br/>"key": "value"<br/>} |
| Удалить предмет | **POST** /removeItem<br/>{<br/>"itemid": "456"<br/>} | **DELETE** /items/456 |

<p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Источник: Do you really know why you prefer REST over RPC</a></i>
</p>

#### Источники и дополнительная литература: REST и RPC

* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [Когда подходы, похожие на RPC, более уместны, чем REST?](http://programmers.stackexchange.com/a/181186)
* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [Развенчание мифов о RPC и REST](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)
* [Каковы недостатки использования REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Thrift](https://code.facebook.com/posts/1468950976659943/)
* [Почему REST для внутреннего использования, а не RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)

## Безопасность

Этот раздел нуждается в обновлении. Подумайте о [вкладе](#contributing)!


Безопасность — это обширная тема. Если у вас нет значительного опыта, образования в области безопасности или вы не претендуете на должность, требующую знаний в области безопасности, вам, вероятно, не потребуется знать больше, чем основы:

* Шифруйте данные при передаче и в состоянии покоя.
* Очищайте все пользовательские вводы или любые параметры, доступные пользователю, чтобы предотвратить [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) и [SQL-инъекции](https://en.wikipedia.org/wiki/SQL_injection).
* Используйте параметризованные запросы для предотвращения SQL-инъекций.
* Применяйте принцип [минимальных привилегий](https://en.wikipedia.org/wiki/Principle_of_least_privilege).

### Источники и дополнительная литература

* [Контрольный список безопасности API](https://github.com/shieldfy/API-Security-Checklist)
* [Руководство по безопасности для разработчиков](https://github.com/FallibleInc/security-guide-for-developers)
* [OWASP топ-10](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)

## Приложение

Иногда вас попросят сделать приблизительные оценки «на коленке». Например, вам может понадобиться определить, сколько времени потребуется для генерации 100 миниатюр изображений с диска или сколько памяти займет определённая структура данных. Таблицы **Степени двойки** и **Задержки, которые должен знать каждый программист** — полезные справочные материалы.

### Таблица степеней двойки

```
Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
```

#### Источники и дополнительная литература

* [Степени двойки](https://ru.wikipedia.org/wiki/Степень_двойки)

### Числа задержек, которые должен знать каждый программист

```
Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
HDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
```
Удобные метрики на основе приведённых выше чисел:

* Последовательное чтение с HDD на скорости 30 МБ/с
* Последовательное чтение по 1 Гбит/с Ethernet на скорости 100 МБ/с
* Последовательное чтение с SSD на скорости 1 ГБ/с
* Последовательное чтение из оперативной памяти на скорости 4 ГБ/с
* 6-7 круговых путешествий по всему миру в секунду
* 2 000 круговых путешествий в секунду внутри дата-центра

#### Визуализация чисел задержки

![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)

#### Источники и дополнительное чтение

* [Latency numbers every programmer should know - 1](https://gist.github.com/jboner/2841832)
* [Latency numbers every programmer should know - 2](https://gist.github.com/hellerbarde/2843375)
* [Designs, lessons, and advice from building large distributed systems](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)
* [Software Engineering Advice from Building Large-Scale Distributed Systems](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)

### Дополнительные вопросы для собеседования по системному дизайну

> Популярные вопросы на собеседовании по системному дизайну с ссылками на ресурсы по их решению.

| Вопрос | Ссылка(и) |
|---|---|
| Спроектировать сервис синхронизации файлов как Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| Спроектировать поисковую систему как Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |
| Спроектировать масштабируемого веб-краулера как Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |
| Спроектировать Google Docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |
| Спроектировать key-value хранилище как Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| Спроектировать систему кеширования как Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Спроектировать рекомендательную систему как у Amazon | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |
| Спроектировать систему tinyurl как Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |
| Спроектировать чат-приложение как WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)
| Спроектировать систему обмена фотографиями как Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |
| Спроектировать функцию новостной ленты Facebook | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |
| Спроектировать функцию хроники Facebook | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |
| Спроектировать функцию чата Facebook | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |

| Разработайте функцию поиска по графу, как у Facebook | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |
| Разработайте сеть доставки контента, как CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |
| Разработайте систему трендовых тем, как у Twitter | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov.wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |
| Разработайте систему генерации случайных идентификаторов | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |
| Возвращайте топ k запросов за интервал времени | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |
| Разработайте систему, обслуживающую данные из нескольких дата-центров | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |
| Разработайте онлайн-многопользовательскую карточную игру | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |
| Разработайте систему сборки мусора | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |
| Разработайте ограничитель частоты запросов API | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |
| Разработайте фондовую биржу (например, NASDAQ или Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |
| Добавьте вопрос по проектированию системы | [Contribute](#contributing) |

### Архитектуры из реального мира

> Статьи о том, как устроены реальные системы.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Источник: Масштабируемость таймлайнов Twitter</a></i>
</p>

**Не зацикливайтесь на мельчайших деталях из следующих статей, вместо этого:**

* Выделяйте общие принципы, технологии и паттерны, встречающиеся в этих статьях
* Изучайте, какие задачи решает каждый компонент, где он работает, а где нет
* Анализируйте полученные уроки

|Тип | Система | Ссылка(и) |
|---|---|---|
| Обработка данных | **MapReduce** — распределённая обработка данных от Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |
| Обработка данных | **Spark** — распределённая обработка данных от Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |
| Обработка данных | **Storm** — распределённая обработка данных от Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |
| | | |
| Хранилище данных | **Bigtable** — распределённая колонко-ориентированная БД от Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |
| Хранилище данных | **HBase** — open source реализация Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |
| Хранилище данных | **Cassandra** — распределённая колонко-ориентированная БД от Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)
| Хранилище данных | **DynamoDB** — документ-ориентированная БД от Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |
| Хранилище данных | **MongoDB** — документ-ориентированная база данных | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |
| Хранилище данных | **Spanner** — глобально-распределённая БД от Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |
| Хранилище данных | **Memcached** - Распределенная система кеширования в памяти | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Хранилище данных | **Redis** - Распределенная система кеширования в памяти с поддержкой персистентности и различных типов значений | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| | | |
| Файловая система | **Google File System (GFS)** - Распределенная файловая система | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |
| Файловая система | **Hadoop File System (HDFS)** - Открытая реализация GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |
| | | |
| Прочее | **Chubby** - Сервис блокировок для слабо связанных распределенных систем от Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |
| Прочее | **Dapper** - Инфраструктура трассировки распределенных систем | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)
| Прочее | **Kafka** - Очередь сообщений pub/sub от LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |
| Прочее | **Zookeeper** - Централизованная инфраструктура и сервисы для синхронизации | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |
| | Добавить архитектуру | [Внести вклад](#contributing) |

### Архитектуры компаний

| Компания | Ссылка(и) |
|---|---|
| Amazon | [Архитектура Amazon](http://highscalability.com/amazon-architecture) |
| Cinchcast | [Производство 1500 часов аудио в день](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |
| DataSift | [Анализ данных в реальном времени на 120 000 твитов в секунду](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |
| Dropbox | [Как мы масштабировали Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| ESPN | [Работа на 100 000 duh nuh nuhs в секунду](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |
| Google | [Архитектура Google](http://highscalability.com/google-architecture) |
| Instagram | [14 миллионов пользователей, терабайты фото](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Что обеспечивает работу Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |
| Justin.tv | [Архитектура потокового видео Justin.tv](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |
| Facebook | [Масштабирование memcached в Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: распределенное хранилище данных для социальной графа Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Хранение фотографий в Facebook](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Как Facebook транслирует Live для 800 000 одновременных зрителей](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |
| Flickr | [Архитектура Flickr](http://highscalability.com/flickr-architecture) |
| Mailbox | [С 0 до миллиона пользователей за 6 недель](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |
| Netflix | [360-градусный взгляд на стек Netflix](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: что происходит, когда вы нажимаете Play?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |
| Pinterest | [С 0 до десятков миллиардов просмотров страниц в месяц](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 миллионов посетителей, рост в 10 раз, 12 сотрудников](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |
| Playfish | [50 миллионов пользователей в месяц и рост](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |
| PlentyOfFish | [Архитектура PlentyOfFish](http://highscalability.com/plentyoffish-architecture) |
| Salesforce | [Как они обрабатывают 1,3 миллиарда транзакций в день](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |
| Stack Overflow | [Архитектура Stack Overflow](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |
| TripAdvisor | [40 млн посетителей, 200 млн динамических просмотров, 30 ТБ данных](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |
| Tumblr | [15 миллиардов просмотров страниц в месяц](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |
| Twitter | [Ускорение Twitter на 10000 процентов](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Хранение 250 миллионов твитов в день на MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150 млн активных пользователей, 300K QPS, поток 22 МБ/с](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Таймлайны в масштабе](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Большие и малые данные в Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Операции в Twitter: масштабирование за 100 миллионов пользователей](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[Как Twitter обрабатывает 3 000 изображений в секунду](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |
| Uber | [Как Uber масштабирует свою платформу реального времени](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Уроки масштабирования Uber до 2000 инженеров, 1000 сервисов и 8000 репозиториев](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |
| WhatsApp | [Архитектура WhatsApp, купленная Facebook за $19 миллиардов](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| YouTube | [Масштабируемость YouTube](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[Архитектура YouTube](http://highscalability.com/youtube-architecture) |

### Инженерные блоги компаний

> Архитектуры компаний, в которых вы проходите собеседование.
>
> Вопросы, с которыми вы сталкиваетесь, могут быть из той же области.

* [Airbnb Engineering](http://nerds.airbnb.com/)
* [Atlassian Developers](https://developer.atlassian.com/blog/)
* [AWS Blog](https://aws.amazon.com/blogs/aws/)
* [Bitly Engineering Blog](http://word.bitly.com/)
* [Box Blogs](https://blog.box.com/blog/category/engineering)
* [Cloudera Developer Blog](http://blog.cloudera.com/)
* [Dropbox Tech Blog](https://tech.dropbox.com/)
* [Engineering at Quora](https://www.quora.com/q/quoraengineering)
* [Ebay Tech Blog](http://www.ebaytechblog.com/)
* [Evernote Tech Blog](https://blog.evernote.com/tech/)
* [Etsy Code as Craft](http://codeascraft.com/)
* [Facebook Engineering](https://www.facebook.com/Engineering)
* [Flickr Code](http://code.flickr.net/)
* [Foursquare Engineering Blog](http://engineering.foursquare.com/)
* [GitHub Engineering Blog](https://github.blog/category/engineering)
* [Google Research Blog](http://googleresearch.blogspot.com/)
* [Groupon Engineering Blog](https://engineering.groupon.com/)
* [Heroku Engineering Blog](https://engineering.heroku.com/)
* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)
* [High Scalability](http://highscalability.com/)
* [Instagram Engineering](http://instagram-engineering.tumblr.com/)
* [Intel Software Blog](https://software.intel.com/en-us/blogs/)
* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)
* [LinkedIn Engineering](http://engineering.linkedin.com/blog)
* [Microsoft Engineering](https://engineering.microsoft.com/)
* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)
* [Netflix Tech Blog](http://techblog.netflix.com/)
* [Paypal Developer Blog](https://medium.com/paypal-engineering)
* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)
* [Reddit Blog](http://www.redditblog.com/)
* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)
* [Slack Engineering Blog](https://slack.engineering/)
* [Spotify Labs](https://labs.spotify.com/)
* [Stripe Engineering Blog](https://stripe.com/blog/engineering)
* [Twilio Engineering Blog](http://www.twilio.com/engineering)
* [Twitter Engineering](https://blog.twitter.com/engineering/)
* [Uber Engineering Blog](http://eng.uber.com/)
* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)
* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)
* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)

#### Источник(и) и дополнительная литература

Хотите добавить блог? Чтобы избежать дублирования работы, рассмотрите возможность добавления блога вашей компании в следующий репозиторий:

* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)

## В разработке

Хотите добавить раздел или помочь завершить текущий? [Внесите вклад](#contributing)!

* Распределённые вычисления с MapReduce
* Консистентное хеширование
* Scatter gather
* [Внесите вклад](#contributing)

## Благодарности

Благодарности и источники указаны по всему этому репозиторию.

Особая благодарность:

* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)
* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)
* [High scalability](http://highscalability.com/)
* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)
* [shashank88/system_design](https://github.com/shashank88/system_design)
* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)
* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
* [A distributed systems reading list](http://dancres.github.io/Pages/)
* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)

## Контактная информация

Не стесняйтесь обращаться ко мне для обсуждения любых проблем, вопросов или комментариев.

Мои контактные данные можно найти на моей [странице GitHub](https://github.com/donnemartin).

## Лицензия

*Я предоставляю код и ресурсы в этом репозитории вам по открытой лицензии. Поскольку это мой личный репозиторий, лицензию на мой код и ресурсы вы получаете от меня, а не от моего работодателя (Facebook).*

    Copyright 2017 Donne Martin

    Creative Commons Attribution 4.0 International License (CC BY 4.0)

    http://creativecommons.org/licenses/by/4.0/


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-08-09

---