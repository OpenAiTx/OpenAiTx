*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*

**Aiuta a [tradurre](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) questa guida!**

# The System Design Primer

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png">
  <br/>
</p>

## Motivazione

> Impara a progettare sistemi su larga scala.
>
> Preparati per il colloquio di system design.

### Impara a progettare sistemi su larga scala

Imparare a progettare sistemi scalabili ti aiuterà a diventare un ingegnere migliore.

La progettazione dei sistemi è un argomento ampio.  Ci sono **numerose risorse sparse sul web** riguardanti i principi di progettazione dei sistemi.

Questa repository è una **raccolta organizzata** di risorse per aiutarti a imparare come costruire sistemi su larga scala.

### Impara dalla comunità open source

Questo è un progetto open source continuamente aggiornato.

[Contributi](#contributing) sono benvenuti!

### Preparati per il colloquio di system design

Oltre ai colloqui di coding, il system design è una **componente obbligatoria** del **processo di colloquio tecnico** in molte aziende tecnologiche.

**Esercitati con le domande comuni dei colloqui di system design** e **confronta** i tuoi risultati con **soluzioni di esempio**: discussioni, codice e diagrammi.

Argomenti aggiuntivi per prepararti al colloquio:

* [Guida allo studio](#study-guide)
* [Come affrontare una domanda di colloquio di system design](#how-to-approach-a-system-design-interview-question)
* [Domande di colloquio sulla progettazione di sistemi, **con soluzioni**](#domande-di-colloquio-sulla-progettazione-di-sistemi-con-soluzioni)
* [Domande di colloquio sulla progettazione orientata agli oggetti, **con soluzioni**](#domande-di-colloquio-sulla-progettazione-orientata-agli-oggetti-con-soluzioni)
* [Domande aggiuntive di colloquio sulla progettazione di sistemi](#domande-aggiuntive-di-colloquio-sulla-progettazione-di-sistemi)

## Flashcard Anki

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png">
  <br/>
</p>

I [mazzi di flashcard Anki forniti](https://apps.ankiweb.net/) utilizzano la ripetizione dilazionata per aiutarti a memorizzare i concetti chiave di progettazione dei sistemi.

* [Mazzo progettazione di sistemi](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)
* [Mazzo esercizi di progettazione di sistemi](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)
* [Mazzo esercizi di progettazione orientata agli oggetti](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)

Ottimo per l'uso in mobilità.

### Risorsa di programmazione: Sfide di programmazione interattive

Cerchi risorse per prepararti al [**Colloquio di programmazione**](https://github.com/donnemartin/interactive-coding-challenges)?

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png">
  <br/>
</p>

Dai un'occhiata al repository gemello [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges), che contiene un ulteriore mazzo Anki:

* [Mazzo programmazione](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)

## Contribuire

> Impara dalla community.

Sentiti libero di inviare pull request per aiutare a:

* Correggere errori
* Migliorare le sezioni
* Aggiungi nuove sezioni
* [Traduci](https://github.com/donnemartin/system-design-primer/issues/28)

I contenuti che necessitano di revisione sono posti [in sviluppo](#under-development).

Consulta le [Linee guida per i contributi](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).

## Indice degli argomenti di system design

> Sommari di vari argomenti di system design, inclusi pro e contro.  **Tutto è un compromesso**.
>
> Ogni sezione contiene link a risorse più approfondite.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png">
  <br/>
</p>

* [Argomenti di system design: inizia qui](#system-design-topics-start-here)
    * [Passo 1: Guarda la lezione video sulla scalabilità](#step-1-review-the-scalability-video-lecture)
    * [Passo 2: Leggi l'articolo sulla scalabilità](#step-2-review-the-scalability-article)
    * [Prossimi passi](#next-steps)
* [Prestazioni vs scalabilità](#performance-vs-scalability)
* [Latenza vs throughput](#latency-vs-throughput)
* [Disponibilità vs consistenza](#availability-vs-consistency)
    * [Teorema CAP](#cap-theorem)
        * [CP - consistenza e tolleranza alle partizioni](#cp---consistency-and-partition-tolerance)
        * [AP - disponibilità e tolleranza alle partizioni](#ap---availability-and-partition-tolerance)
* [Pattern di consistenza](#consistency-patterns)
    * [Consistenza debole](#weak-consistency)
    * [Consistenza eventuale](#eventual-consistency)
    * [Consistenza forte](#strong-consistency)
* [Pattern di disponibilità](#availability-patterns)
    * [Fail-over](#fail-over)
    * [Replica](#replication)
    * [Disponibilità in numeri](#availability-in-numbers)
* [Domain name system](#domain-name-system)
* [Content delivery network](#content-delivery-network)
    * [Push CDN](#push-cdns)
    * [Pull CDN](#pull-cdns)
* [Bilanciatore di carico](#load-balancer)
    * [Attivo-passivo](#active-passive)
    * [Attivo-attivo](#active-active)
    * [Bilanciamento del carico Layer 4](#layer-4-load-balancing)
    * [Bilanciamento del carico Layer 7](#layer-7-load-balancing)
    * [Scalabilità orizzontale](#horizontal-scaling)
* [Proxy inverso (server web)](#reverse-proxy-web-server)
    * [Bilanciatore di carico vs proxy inverso](#load-balancer-vs-reverse-proxy)
* [Livello applicativo](#application-layer)
    * [Microservizi](#microservices)
    * [Service discovery](#service-discovery)
* [Database](#database)
    * [Sistema di gestione di database relazionali (RDBMS)](#relational-database-management-system-rdbms)
        * [Replica master-slave](#master-slave-replication)
        * [Replica master-master](#master-master-replication)
        * [Federazione](#federation)
        * [Sharding](#sharding)
        * [Denormalizzazione](#denormalization)
        * [Ottimizzazione SQL](#sql-tuning)
    * [NoSQL](#nosql)
        * [Archivio chiave-valore](#key-value-store)
        * [Archivio di documenti](#document-store)
        * [Archivio a colonne larghe](#wide-column-store)
        * [Database a grafo](#graph-database)
    * [SQL o NoSQL](#sql-or-nosql)
* [Cache](#cache)
    * [Caching lato client](#client-caching)
    * [Caching CDN](#cdn-caching)
    * [Caching del server web](#web-server-caching)
    * [Caching del database](#database-caching)
    * [Caching dell'applicazione](#application-caching)
    * [Caching a livello di query del database](#caching-at-the-database-query-level)
    * [Caching a livello di oggetto](#caching-at-the-object-level)
    * [Quando aggiornare la cache](#when-to-update-the-cache)
        * [Cache-aside](#cache-aside)
        * [Write-through](#write-through)
        * [Write-behind (write-back)](#write-behind-write-back)
        * [Refresh-ahead](#refresh-ahead)
* [Asincronismo](#asynchronism)
    * [Code di messaggi](#message-queues)
    * [Code di attività](#task-queues)
    * [Contenimento della pressione](#back-pressure)
* [Comunicazione](#communication)
    * [Transmission control protocol (TCP)](#transmission-control-protocol-tcp)
    * [User datagram protocol (UDP)](#user-datagram-protocol-udp)
    * [Remote procedure call (RPC)](#remote-procedure-call-rpc)
    * [Representational state transfer (REST)](#representational-state-transfer-rest)
* [Sicurezza](#security)
* [Appendice](#appendix)
    * [Tabella delle potenze di due](#powers-of-two-table)
    * [Numeri di latenza che ogni programmatore dovrebbe conoscere](#latency-numbers-every-programmer-should-know)
    * [Domande aggiuntive per colloqui di progettazione di sistemi](#additional-system-design-interview-questions)
    * [Architetture reali](#real-world-architectures)
    * [Architetture aziendali](#company-architectures)
    * [Blog ingegneristici aziendali](#company-engineering-blogs)
* [In fase di sviluppo](#under-development)
* [Crediti](#credits)
* [Informazioni di contatto](#contact-info)
* [Licenza](#license)

## Guida allo studio

> Argomenti suggeriti da rivedere in base alla tempistica del tuo colloquio (breve, media, lunga).

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)

**D: Per i colloqui, devo conoscere tutto ciò che è qui?**

**R: No, non è necessario conoscere tutto ciò che è qui per prepararsi al colloquio**.

Le domande che ti vengono poste in un colloquio dipendono da variabili come:

* Quanta esperienza hai
* Qual è il tuo background tecnico
* Per quali posizioni stai facendo il colloquio
* Con quali aziende stai facendo il colloquio
* Fortuna

Generalmente si prevede che i candidati più esperti conoscano di più sulla progettazione dei sistemi.  Gli architetti o i team lead potrebbero dover sapere più degli individual contributor.  Le migliori aziende tecnologiche potrebbero avere uno o più round di colloqui sulla progettazione.

Inizia in modo ampio e approfondisci in alcune aree. È utile conoscere almeno un po’ i vari temi chiave della progettazione dei sistemi. Adatta la guida seguente in base alla tua tempistica, esperienza, alle posizioni per cui stai facendo colloqui e alle aziende con cui ti stai candidando.

* **Tempistica breve** - Punta alla **ampiezza** sui temi di progettazione dei sistemi. Allenati risolvendo **alcune** domande di colloquio.
* **Tempistica media** - Punta alla **ampiezza** e **un po’ di profondità** sui temi di progettazione dei sistemi. Allenati risolvendo **molte** domande di colloquio.
* **Tempistica lunga** - Punta alla **ampiezza** e **maggiore profondità** sui temi di progettazione dei sistemi. Allenati risolvendo **la maggior parte** delle domande di colloquio.

| | Breve | Media | Lunga |
|---|---|---|---|
| Leggi i [Temi di progettazione dei sistemi](#index-of-system-design-topics) per ottenere una comprensione generale di come funzionano i sistemi | :+1: | :+1: | :+1: |
| Leggi alcuni articoli nei [Blog di ingegneria delle aziende](#company-engineering-blogs) delle aziende per cui ti candidi | :+1: | :+1: | :+1: |
| Leggi alcune [Architetture reali](#real-world-architectures) | :+1: | :+1: | :+1: |
| Rivedi [Come affrontare una domanda di colloquio di progettazione di sistemi](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |
| Lavora su [Domande di colloquio di progettazione di sistemi con soluzioni](#system-design-interview-questions-with-solutions) | Alcune | Molte | La maggior parte |
| Lavora su [Domande di colloquio di progettazione orientata agli oggetti con soluzioni](#object-oriented-design-interview-questions-with-solutions) | Alcune | Molte | La maggior parte |
| Rivedi [Domande aggiuntive di colloquio di progettazione di sistemi](#additional-system-design-interview-questions) | Alcune | Molte | La maggior parte |

## Come affrontare una domanda di colloquio di progettazione di sistemi

> Come gestire una domanda di colloquio sulla progettazione di sistemi.

Il colloquio di progettazione di sistemi è una **conversazione aperta**. Ci si aspetta che tu la conduca.

Puoi utilizzare i seguenti passaggi per guidare la discussione. Per aiutarti a consolidare questo processo, lavora sulle [Domande di colloquio di progettazione di sistemi con soluzioni](#system-design-interview-questions-with-solutions) seguendo i passaggi seguenti.

### Passaggio 1: Definisci casi d’uso, vincoli e assunzioni

Raccogli i requisiti e delimita il problema. Fai domande per chiarire i casi d’uso e i vincoli. Discuti le assunzioni.

* Chi lo userà?
* Come lo useranno?
* Quanti utenti ci sono?
* Cosa fa il sistema?
* Quali sono gli input e gli output del sistema?
* Quanti dati prevediamo di gestire?
* Quante richieste al secondo prevediamo?
* Qual è il rapporto previsto tra letture e scritture?

### Passaggio 2: Crea un design ad alto livello

Definisci un design ad alto livello con tutti i componenti importanti.

* Disegna i principali componenti e connessioni
* Giustifica le tue idee

### Step 3: Progettazione dei componenti principali

Approfondisci i dettagli di ciascun componente principale. Ad esempio, se ti venisse chiesto di [progettare un servizio di abbreviazione URL](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), discuti:

* Generazione e memorizzazione di un hash dell’URL completo
    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) e [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)
    * Collisioni di hash
    * SQL o NoSQL
    * Schema del database
* Traduzione di un URL hashato all’URL completo
    * Ricerca nel database
* API e progettazione orientata agli oggetti

### Step 4: Scala il design

Identifica e affronta i colli di bottiglia, dati i vincoli. Ad esempio, hai bisogno di quanto segue per affrontare problemi di scalabilità?

* Bilanciatore di carico
* Scalabilità orizzontale
* Caching
* Sharding del database

Discuti le possibili soluzioni e i compromessi. Tutto è un compromesso. Affronta i colli di bottiglia usando i [principi di progettazione scalabile dei sistemi](#index-of-system-design-topics).

### Calcoli approssimativi

Potresti essere invitato a fare alcune stime manuali. Consulta l’[Appendice](#appendix) per le seguenti risorse:

* [Usa calcoli approssimativi](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)
* [Tabella delle potenze di due](#powers-of-two-table)
* [Numeri di latenza che ogni programmatore dovrebbe conoscere](#latency-numbers-every-programmer-should-know)

### Fonte/i e ulteriori letture

Consulta i seguenti link per avere un’idea più chiara di cosa aspettarti:

* [Come superare un colloquio di progettazione di sistemi](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)
* [Il colloquio di progettazione di sistemi](http://www.hiredintech.com/system-design)
* [Introduzione all'architettura e ai colloqui di progettazione di sistemi](https://www.youtube.com/watch?v=ZgdS0EUmn70)
* [Template per la progettazione di sistemi](https://leetcode.com/discuss/career/229177/My-System-Design-Template)

## Domande di colloquio di progettazione di sistemi con soluzioni

> Domande comuni di colloquio di progettazione di sistemi con discussioni, codice e diagrammi di esempio.
>
> Soluzioni collegate ai contenuti nella cartella `solutions/`.

| Domanda | |
|---|---|
| Progettare Pastebin.com (o Bit.ly) | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |
| Progettare la timeline e la ricerca di Twitter (o feed e ricerca di Facebook) | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |
| Progettare un web crawler | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |
| Progettare Mint.com | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |
| Progettare le strutture dati per un social network | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |
| Progettare un archivio chiave-valore per un motore di ricerca | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |
| Progettare la funzione di ranking delle vendite per categoria di Amazon | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |
| Progettare un sistema che scala a milioni di utenti su AWS | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |
| Aggiungi una domanda di progettazione di sistemi | [Contribuisci](#contributing) |

### Progettare Pastebin.com (o Bit.ly)

[Visualizza esercizio e soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)

### Progettare la timeline e la ricerca di Twitter (o feed e ricerca di Facebook)

[Visualizza esercizio e soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)

### Progettare un web crawler

[Visualizza esercizio e soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)

### Design Mint.com

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)

### Design the data structures for a social network

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)

### Design a key-value store for a search engine

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)

### Design Amazon's sales ranking by category feature

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)

### Design a system that scales to millions of users on AWS

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)

## Object-oriented design interview questions with solutions

> Common object-oriented design interview questions with sample discussions, code, and diagrams.
>
> Solutions linked to content in the `solutions/` folder.

>**Note: This section is under development**

| Question | |
|---|---|
| Progetta una hash map | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |
| Progetta una cache least recently used | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |
| Progetta un call center | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |
| Progetta un mazzo di carte | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |
| Progetta un parcheggio | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |
| Progetta un server di chat | [Soluzione](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |
| Progetta un array circolare | [Contribuisci](#contributing)  |
| Aggiungi una domanda di progettazione orientata agli oggetti | [Contribuisci](#contributing) |

## Argomenti di system design: inizia qui

Nuovo alla progettazione di sistemi?

Per prima cosa, avrai bisogno di una comprensione di base dei principi comuni, imparando cosa sono, come vengono utilizzati e i loro pro e contro.

### Passo 1: Rivedi la video-lezione sulla scalabilità

[Lezione sulla Scalabilità ad Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)

* Argomenti trattati:
    * Scalabilità verticale
    * Scalabilità orizzontale
    * Caching
    * Bilanciamento del carico
    * Replica del database
    * Partizionamento del database

### Passo 2: Rivedi l'articolo sulla scalabilità

[Scalabilità](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)

* Argomenti trattati:
    * [Cloni](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
    * [Database](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
    * [Cache](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
    * [Asincronismo](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)

### Prossimi passi

Successivamente, esamineremo i compromessi di alto livello:

* **Prestazioni** vs **scalabilità**
* **Latenza** vs **throughput**
* **Disponibilità** vs **coerenza**

Ricorda che **tutto è un compromesso**.

Poi approfondiremo argomenti più specifici come DNS, CDN e bilanciatori di carico.

## Prestazioni vs scalabilità

Un servizio è **scalabile** se porta a un aumento delle **prestazioni** in modo proporzionale alle risorse aggiunte. In generale, aumentare le prestazioni significa servire più unità di lavoro, ma può anche significare gestire unità di lavoro più grandi, come quando i dataset crescono.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>

Un altro modo di vedere prestazioni vs scalabilità:

* Se hai un problema di **prestazioni**, il tuo sistema è lento per un singolo utente.
* Se hai un problema di **scalabilità**, il tuo sistema è veloce per un singolo utente ma lento sotto carico elevato.

### Fonte(i) e ulteriori letture

* [Una parola sulla scalabilità](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)
* [Scalabilità, disponibilità, stabilità, pattern](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)

## Latenza vs throughput

**Latenza** è il tempo necessario per eseguire un'azione o produrre un risultato.

**Throughput** è il numero di tali azioni o risultati per unità di tempo.

In generale, dovresti puntare a **massimizzare il throughput** con **latenza accettabile**.

### Fonte(i) e ulteriori letture

* [Comprendere latenza vs throughput](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)

## Disponibilità vs coerenza

### Teorema CAP

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Fonte: CAP theorem revisited</a></i>
</p>

In un sistema informatico distribuito, puoi supportare solo due delle seguenti garanzie:

* **Consistenza** - Ogni lettura riceve la scrittura più recente o un errore
* **Disponibilità** - Ogni richiesta riceve una risposta, senza garanzia che contenga la versione più recente dell'informazione
* **Tolleranza alle Partizioni** - Il sistema continua a funzionare nonostante partizioni arbitrarie dovute a guasti di rete

*Le reti non sono affidabili, quindi dovrai supportare la tolleranza alle partizioni.  Sarà necessario fare un compromesso software tra consistenza e disponibilità.*

#### CP - consistenza e tolleranza alle partizioni

Attendere una risposta dal nodo partizionato potrebbe causare un errore di timeout.  CP è una buona scelta se le esigenze aziendali richiedono letture e scritture atomiche.

#### AP - disponibilità e tolleranza alle partizioni

Le risposte restituiscono la versione più facilmente disponibile dei dati su qualsiasi nodo, che potrebbe non essere la più recente.  Le scritture potrebbero impiegare del tempo per propagarsi quando la partizione viene risolta.

AP è una buona scelta se le esigenze aziendali consentono [consistenza eventuale](#eventual-consistency) o quando il sistema deve continuare a funzionare nonostante errori esterni.

### Fonte/i e ulteriori letture

* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)
* [Una introduzione semplice al teorema CAP](http://ksat.me/a-plain-english-introduction-to-cap-theorem)
* [CAP FAQ](https://github.com/henryr/cap-faq)
* [Il teorema CAP](https://www.youtube.com/watch?v=k-Yaq8AHlFA)

## Pattern di consistenza

Con più copie degli stessi dati, ci troviamo di fronte a diverse opzioni su come sincronizzarle affinché i client abbiano una visione coerente dei dati.  Ricorda la definizione di consistenza dal [teorema CAP](#cap-theorem) - Ogni lettura riceve la scrittura più recente o un errore.

### Consistenza debole

Dopo una scrittura, le letture potrebbero vederla o meno.  Si adotta un approccio best effort.

Questo approccio si osserva in sistemi come memcached.  La consistenza debole funziona bene in casi d'uso in tempo reale come VoIP, video chat e giochi multiplayer in tempo reale.  Ad esempio, se sei al telefono e perdi la ricezione per alcuni secondi, quando riacquisti la connessione non senti ciò che è stato detto durante la perdita di connessione.

### Consistenza eventuale

Dopo una scrittura, le letture la vedranno eventualmente (tipicamente entro millisecondi). I dati sono replicati in modo asincrono.

Questo approccio si trova in sistemi come DNS ed email. La consistenza eventuale funziona bene nei sistemi altamente disponibili.

### Consistenza forte

Dopo una scrittura, le letture la vedranno. I dati sono replicati in modo sincrono.

Questo approccio si trova nei file system e nei RDBMS. La consistenza forte funziona bene nei sistemi che necessitano di transazioni.

### Fonte/i e ulteriori letture

* [Transazioni tra data center](http://snarfed.org/transactions_across_datacenters_io.html)

## Pattern di disponibilità

Ci sono due pattern complementari per supportare un’elevata disponibilità: **fail-over** e **replicazione**.

### Fail-over

#### Attivo-passivo

Con il fail-over attivo-passivo, vengono inviati heartbeat tra il server attivo e quello passivo in standby. Se l’heartbeat viene interrotto, il server passivo assume l’indirizzo IP dell’attivo e riprende il servizio.

La durata del downtime è determinata dal fatto che il server passivo sia già in standby “hot” o se debba avviarsi da standby “cold”. Solo il server attivo gestisce il traffico.

Il failover attivo-passivo può essere chiamato anche failover master-slave.

#### Attivo-attivo

Nell’attivo-attivo, entrambi i server gestiscono il traffico, distribuendo il carico tra loro.

Se i server sono pubblici, il DNS deve conoscere gli IP pubblici di entrambi i server. Se i server sono interni, la logica applicativa deve conoscere entrambi i server.

Il failover attivo-attivo può essere chiamato anche failover master-master.

### Svantaggio/i: failover

* Il fail-over aggiunge più hardware e ulteriore complessità.
* Esiste la possibilità di perdita di dati se il sistema attivo si guasta prima che i nuovi dati scritti possano essere replicati su quello passivo.

### Replicazione

#### Master-slave e master-master

Questo argomento è ulteriormente trattato nella sezione [Database](#database):

* [Replicazione master-slave](#master-slave-replication)
* [Replicazione master-master](#master-master-replication)

### Disponibilità in numeri

La disponibilità è spesso quantificata dal tempo di attività (o inattività) come percentuale del tempo in cui il servizio è disponibile. La disponibilità viene generalmente misurata in numero di 9--un servizio con il 99,99% di disponibilità viene descritto come avente quattro 9.

#### 99,9% di disponibilità - tre 9

| Durata              | Tempo di inattività accettabile|
|---------------------|-------------------------------|
| Inattività per anno | 8h 45min 57s                  |
| Inattività per mese | 43m 49,7s                     |
| Inattività per settimana | 10m 4,8s              |
| Inattività per giorno| 1m 26,4s                      |

#### 99,99% di disponibilità - quattro 9

| Durata              | Tempo di inattività accettabile|
|---------------------|-------------------------------|
| Inattività per anno | 52min 35,7s                   |
| Inattività per mese | 4m 23s                        |
| Inattività per settimana | 1m 5s                   |
| Inattività per giorno| 8,6s                          |

#### Disponibilità in parallelo vs in sequenza

Se un servizio è composto da più componenti soggetti a guasti, la disponibilità complessiva del servizio dipende dal fatto che i componenti siano in sequenza o in parallelo.

###### In sequenza

La disponibilità complessiva diminuisce quando due componenti con disponibilità < 100% sono in sequenza:

```
Availability (Total) = Availability (Foo) * Availability (Bar)
```

Se sia `Foo` che `Bar` avessero ciascuno una disponibilità del 99,9%, la loro disponibilità totale in sequenza sarebbe del 99,8%.

###### In parallelo

La disponibilità complessiva aumenta quando due componenti con disponibilità < 100% sono in parallelo:

```
Availability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))
```

Se sia `Foo` che `Bar` avessero ciascuno una disponibilità del 99,9%, la loro disponibilità totale in parallelo sarebbe del 99,9999%.

## Sistema dei nomi di dominio

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Fonte: Presentazione sulla sicurezza DNS</a></i>
</p>

Un Sistema dei Nomi di Dominio (DNS) traduce un nome di dominio come www.example.com in un indirizzo IP.

Il DNS è gerarchico, con pochi server autorevoli al livello superiore.  Il tuo router o ISP fornisce informazioni su quale(i) server DNS contattare durante una ricerca.  I server DNS di livello inferiore memorizzano nella cache le mappature, che potrebbero diventare obsolete a causa dei ritardi di propagazione DNS.  I risultati DNS possono essere memorizzati nella cache anche dal browser o dal sistema operativo per un certo periodo di tempo, determinato dal [time to live (TTL)](https://it.wikipedia.org/wiki/Time_to_live).

* **Record NS (name server)** - Specifica i server DNS per il tuo dominio/sottodominio.
* **Record MX (mail exchange)** - Specifica i server di posta per accettare i messaggi.
* **Record A (address)** - Punta un nome a un indirizzo IP.
* **CNAME (canonical)** - Punta un nome a un altro nome o `CNAME` (example.com a www.example.com) o a un record `A`.

Servizi come [CloudFlare](https://www.cloudflare.com/dns/) e [Route 53](https://aws.amazon.com/route53/) offrono servizi DNS gestiti.  Alcuni servizi DNS possono instradare il traffico tramite vari metodi:

* [Round robin pesato](https://www.jscape.com/blog/load-balancing-algorithms)
    * Impedire che il traffico vada ai server in manutenzione
    * Bilanciare tra dimensioni del cluster variabili
    * Test A/B
* [Basato sulla latenza](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)
* [Basato sulla geolocalizzazione](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)

### Svantaggio(i): DNS

* Accedere a un server DNS introduce un leggero ritardo, sebbene mitigato dalla cache descritta sopra.
* La gestione dei server DNS può essere complessa ed è generalmente gestita da [governi, ISP e grandi aziende](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).
* I servizi DNS sono stati recentemente oggetto di [attacchi DDoS](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), impedendo agli utenti di accedere a siti web come Twitter senza conoscere l'indirizzo/i IP di Twitter.

### Fonte(i) e ulteriori letture

* [Architettura DNS](https://technet.microsoft.com/it-it/library/dd197427(v=ws.10).aspx)
* [Wikipedia](https://it.wikipedia.org/wiki/Domain_Name_System)
* [Articoli DNS](https://support.dnsimple.com/categories/dns/)

## Content delivery network

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Fonte: Perché usare una CDN</a></i>
</p>

Una content delivery network (CDN) è una rete globale distribuita di server proxy, che fornisce contenuti da posizioni più vicine all'utente. Generalmente, file statici come HTML/CSS/JS, foto e video sono serviti da una CDN, anche se alcune CDN come CloudFront di Amazon supportano contenuti dinamici. La risoluzione DNS del sito indicherà ai client quale server contattare.

Fornire contenuti tramite CDN può migliorare significativamente le prestazioni in due modi:

* Gli utenti ricevono i contenuti da data center a loro vicini
* I tuoi server non devono servire le richieste che la CDN soddisfa

### Push CDN

Le push CDN ricevono nuovi contenuti ogni volta che si verificano cambiamenti sul tuo server. Sei completamente responsabile della fornitura dei contenuti, caricandoli direttamente sulla CDN e riscrivendo gli URL per puntare alla CDN. Puoi configurare quando i contenuti scadono e quando vengono aggiornati. I contenuti vengono caricati solo quando sono nuovi o modificati, minimizzando il traffico ma massimizzando lo storage.

I siti con poco traffico o con contenuti che non vengono aggiornati spesso funzionano bene con le push CDN. I contenuti vengono caricati sulle CDN una sola volta, invece di essere ripresi regolarmente.

### Pull CDN

Le pull CDN prelevano nuovi contenuti dal tuo server quando il primo utente li richiede. Lasci i contenuti sul tuo server e riscrivi gli URL per puntare alla CDN. Questo comporta una richiesta più lenta fino a quando il contenuto non viene memorizzato nella cache sulla CDN.

Un [time-to-live (TTL)](https://en.wikipedia.org/wiki/Time_to_live) determina per quanto tempo i contenuti vengono mantenuti in cache. Le pull CDN minimizzano lo spazio di archiviazione sulla CDN, ma possono creare traffico ridondante se i file scadono e vengono ripresi prima che siano effettivamente cambiati.

I siti con molto traffico funzionano bene con le pull CDN, poiché il traffico viene distribuito più uniformemente e solo i contenuti richiesti di recente rimangono sulla CDN.

### Svantaggio(i): CDN

* I costi della CDN possono essere significativi a seconda del traffico, anche se questo va valutato rispetto ai costi aggiuntivi che si sosterrebbero non usando una CDN.
* I contenuti potrebbero essere obsoleti se aggiornati prima che il TTL scada.
* Le CDN richiedono la modifica degli URL dei contenuti statici per puntare alla CDN.

### Fonte(i) e approfondimenti

* [Content delivery distribuito globalmente](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)
* [Le differenze tra push e pull CDN](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)
* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)

## Bilanciatore di carico

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Fonte: Scalable system design patterns</a></i>
</p>

I bilanciatori di carico distribuiscono le richieste dei client in arrivo alle risorse di calcolo come server applicativi e database. In ogni caso, il bilanciatore di carico restituisce la risposta dalla risorsa di calcolo al client appropriato. I bilanciatori di carico sono efficaci per:

* Impedire che le richieste vadano ai server non funzionanti
* Prevenire il sovraccarico delle risorse
* Aiutare ad eliminare un singolo punto di fallimento

I bilanciatori di carico possono essere implementati con hardware (costoso) o con software come HAProxy.

Ulteriori vantaggi includono:

* **Terminazione SSL** - Decifra le richieste in arrivo e cifra le risposte dei server in modo che i server backend non debbano eseguire queste operazioni potenzialmente costose
    * Elimina la necessità di installare i [certificati X.509](https://en.wikipedia.org/wiki/X.509) su ogni server
* **Persistenza della sessione** - Emette cookie e instrada le richieste di uno specifico client alla stessa istanza se le web app non tengono traccia delle sessioni

Per proteggersi dai guasti, è comune configurare più bilanciatori di carico, sia in modalità [attivo-passivo](#active-passive) che [attivo-attivo](#active-active).

I bilanciatori di carico possono instradare il traffico in base a vari parametri, tra cui:

* Casuale
* Meno carico
* Sessione/cookie
* [Round robin o round robin ponderato](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)
* [Layer 4](#layer-4-load-balancing)
* [Layer 7](#layer-7-load-balancing)

### Bilanciamento del carico Layer 4

I bilanciatori di carico Layer 4 osservano le informazioni al [livello di trasporto](#communication) per decidere come distribuire le richieste. Generalmente, questo implica gli indirizzi IP di origine e destinazione e le porte nell’intestazione, ma non il contenuto del pacchetto. I bilanciatori di carico Layer 4 inoltrano i pacchetti di rete da e verso il server upstream, effettuando il [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/).

### Bilanciamento del carico Layer 7
I bilanciatori di carico Layer 7 esaminano il [livello applicativo](#communication) per decidere come distribuire le richieste. Questo può coinvolgere il contenuto dell’header, del messaggio e dei cookie. I bilanciatori di carico Layer 7 terminano il traffico di rete, leggono il messaggio, prendono una decisione di bilanciamento del carico, quindi aprono una connessione al server selezionato. Ad esempio, un bilanciatore di carico Layer 7 può indirizzare il traffico video ai server che ospitano i video mentre indirizza il traffico di fatturazione utente più sensibile a server rinforzati per la sicurezza.

Al costo della flessibilità, il bilanciamento del carico Layer 4 richiede meno tempo e risorse di calcolo rispetto al Layer 7, anche se l’impatto sulle prestazioni può essere minimo sull’hardware moderno di tipo commerciale.

### Scalabilità orizzontale

I bilanciatori di carico possono anche aiutare con la scalabilità orizzontale, migliorando prestazioni e disponibilità. L’ampliamento tramite macchine commerciali è più conveniente e garantisce una maggiore disponibilità rispetto all’ampliamento di un singolo server su hardware più costoso, chiamato **Scalabilità Verticale**. È anche più facile assumere personale che lavori su hardware commerciale rispetto a sistemi aziendali specializzati.

#### Svantaggio(i): scalabilità orizzontale

* La scalabilità orizzontale introduce complessità e implica la clonazione dei server
    * I server dovrebbero essere stateless: non dovrebbero contenere dati utente come sessioni o foto profilo
    * Le sessioni possono essere archiviate in un archivio dati centralizzato come un [database](#database) (SQL, NoSQL) o una [cache](#cache) persistente (Redis, Memcached)
* I server downstream come cache e database devono gestire più connessioni simultanee man mano che i server upstream si espandono

### Svantaggio(i): bilanciatore di carico

* Il bilanciatore di carico può diventare un collo di bottiglia nelle prestazioni se non dispone di risorse sufficienti o se non è configurato correttamente.
* L’introduzione di un bilanciatore di carico per eliminare un singolo punto di errore comporta una complessità maggiore.
* Un singolo bilanciatore di carico è un punto di errore singolo; la configurazione di più bilanciatori di carico aumenta ulteriormente la complessità.

### Fonte(i) e approfondimenti

* [Architettura NGINX](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [Guida all’architettura HAProxy](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Scalabilità](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
* [Wikipedia](https://en.wikipedia.org/wiki/Load_balancing_(computing))
* [Bilanciamento del carico Layer 4](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)
* [Bilanciamento del carico Layer 7](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)
* [Config listener ELB](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)

## Reverse proxy (server web)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Fonte: Wikipedia</a></i>
  <br/>
</p>

Un reverse proxy è un server web che centralizza i servizi interni e fornisce interfacce unificate al pubblico. Le richieste dei client vengono inoltrate a un server che può soddisfarle, prima che il reverse proxy restituisca la risposta del server al client.

Ulteriori vantaggi includono:

* **Maggiore sicurezza** - Nasconde le informazioni sui server backend, mette in blacklist gli IP, limita il numero di connessioni per client
* **Maggiore scalabilità e flessibilità** - I client vedono solo l'IP del reverse proxy, consentendo di scalare i server o modificarne la configurazione
* **Terminazione SSL** - Decripta le richieste in entrata e cripta le risposte del server così i server backend non devono eseguire queste operazioni potenzialmente costose
    * Elimina la necessità di installare [certificati X.509](https://it.wikipedia.org/wiki/X.509) su ogni server
* **Compressione** - Comprime le risposte del server
* **Caching** - Restituisce la risposta per richieste già memorizzate in cache
* **Contenuti statici** - Serve direttamente contenuti statici
    * HTML/CSS/JS
    * Foto
    * Video
    * Etc

### Bilanciatore di carico vs reverse proxy

* Implementare un bilanciatore di carico è utile quando si hanno più server. Spesso, i bilanciatori di carico instradano il traffico a un gruppo di server che svolgono la stessa funzione.
* I reverse proxy possono essere utili anche con un solo server web o application server, offrendo i vantaggi descritti nella sezione precedente.
* Soluzioni come NGINX e HAProxy possono supportare sia il reverse proxy di livello 7 sia il bilanciamento del carico.

### Svantaggio(i): reverse proxy

* L'introduzione di un reverse proxy comporta una maggiore complessità.
* Un singolo reverse proxy rappresenta un single point of failure, configurare più reverse proxy (ad esempio un [failover](https://it.wikipedia.org/wiki/Failover)) aumenta ulteriormente la complessità.

### Fonte(i) e ulteriori letture

* [Reverse proxy vs bilanciatore di carico](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)
* [Architettura NGINX](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [Guida all'architettura di HAProxy](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Wikipedia](https://it.wikipedia.org/wiki/Reverse_proxy)

## Livello applicazione

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png">
  <br/>

  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Fonte: Introduzione all'architettura di sistemi scalabili</a></i>
</p>

Separare il livello web dal livello applicativo (noto anche come livello piattaforma) permette di scalare e configurare entrambi i livelli in modo indipendente. Aggiungere una nuova API comporta l'aggiunta di server applicativi senza necessariamente aggiungere ulteriori server web. Il **principio della singola responsabilità** sostiene servizi piccoli e autonomi che collaborano tra loro. Piccoli team con piccoli servizi possono pianificare più aggressivamente una crescita rapida.

I worker nel livello applicativo aiutano anche ad abilitare [l'asincronismo](#asynchronism).

### Microservizi

Riguardo questa discussione ci sono i [microservizi](https://it.wikipedia.org/wiki/Microservizi), che possono essere descritti come un insieme di servizi piccoli, modulari e distribuibili in modo indipendente. Ogni servizio esegue un processo unico e comunica tramite un meccanismo ben definito e leggero per raggiungere un obiettivo aziendale. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>

Pinterest, ad esempio, potrebbe avere i seguenti microservizi: profilo utente, follower, feed, ricerca, caricamento foto, ecc.

### Service Discovery

Sistemi come [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), e [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) aiutano i servizi a trovarsi tra loro tenendo traccia di nomi registrati, indirizzi e porte. I [controlli di integrità](https://www.consul.io/intro/getting-started/checks.html) aiutano a verificare l'integrità del servizio e sono spesso eseguiti tramite un endpoint [HTTP](#hypertext-transfer-protocol-http). Sia Consul che Etcd hanno un [key-value store](#key-value-store) integrato che può essere utile per memorizzare valori di configurazione e altri dati condivisi.

### Svantaggi: livello applicativo

* Aggiungere un livello applicativo con servizi disaccoppiati richiede un approccio diverso dal punto di vista architetturale, operativo e dei processi (rispetto a un sistema monolitico).
* I microservizi possono aggiungere complessità in termini di deployment e operazioni.

### Fonte(e) e approfondimenti

* [Introduzione all'architettura di sistemi scalabili](http://lethain.com/introduction-to-architecting-systems-for-scale)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Architettura orientata ai servizi](https://it.wikipedia.org/wiki/Architettura_orientata_ai_servizi)
* [Introduzione a Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)
* [Cosa sapere per costruire microservizi](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)

## Database

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Fonte: Scalare fino ai tuoi primi 10 milioni di utenti</a></i>
</p>

### Sistema di gestione di database relazionali (RDBMS)

Un database relazionale come SQL è una raccolta di elementi di dati organizzati in tabelle.

**ACID** è un insieme di proprietà delle [transazioni](https://en.wikipedia.org/wiki/Database_transaction) dei database relazionali.

* **Atomicità** - Ogni transazione è tutto o niente
* **Coerenza** - Qualsiasi transazione porterà il database da uno stato valido a un altro
* **Isolamento** - L'esecuzione concorrente delle transazioni produce gli stessi risultati che se fossero eseguite in serie
* **Durabilità** - Una volta che una transazione è stata confermata, rimarrà tale

Esistono molte tecniche per scalare un database relazionale: **replicazione master-slave**, **replicazione master-master**, **federazione**, **sharding**, **denormalizzazione** e **ottimizzazione SQL**.

#### Replicazione master-slave

Il master gestisce le letture e le scritture, replicando le scritture su uno o più slave, che gestiscono solo le letture. Gli slave possono anche replicare su altri slave in modo gerarchico. Se il master va offline, il sistema può continuare a funzionare in modalità sola lettura fino a quando uno slave viene promosso a master o viene predisposto un nuovo master.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fonte: Scalabilità, disponibilità, stabilità, pattern</a></i>
</p>

##### Svantaggio/i: replicazione master-slave

* È necessaria logica aggiuntiva per promuovere uno slave a master.
* Vedi [Svantaggio/i: replicazione](#disadvantages-replication) per i punti relativi **sia** a master-slave che master-master.

#### Replicazione master-master

Entrambi i master gestiscono letture e scritture e si coordinano tra loro sulle scritture. Se uno dei master si guasta, il sistema può continuare a funzionare sia per le letture che per le scritture.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fonte: Scalabilità, disponibilità, stabilità, pattern</a></i>
</p>

##### Svantaggio/i: replicazione master-master

* Sarà necessario un bilanciatore di carico oppure dovrai modificare la logica dell'applicazione per determinare dove scrivere.
* La maggior parte dei sistemi master-master sono o debolmente consistenti (violando ACID) oppure presentano una maggiore latenza di scrittura dovuta alla sincronizzazione.
* La risoluzione dei conflitti diventa più rilevante man mano che si aggiungono più nodi di scrittura e che la latenza aumenta.
* Vedi [Svantaggio(i): replica](#disadvantages-replication) per punti relativi **sia** a master-slave che a master-master.

##### Svantaggio(i): replica

* Esiste il potenziale di perdita di dati se il master fallisce prima che i nuovi dati scritti possano essere replicati sugli altri nodi.
* Le scritture vengono riprodotte sulle repliche di lettura. Se ci sono molte scritture, le repliche di lettura possono essere rallentate dal replay delle scritture e non riescono a gestire altrettante letture.
* Più slave di lettura ci sono, più dati bisogna replicare, il che porta a un maggiore ritardo di replica.
* Su alcuni sistemi, la scrittura sul master può generare più thread per scrivere in parallelo, mentre le repliche di lettura supportano solo la scrittura sequenziale con un singolo thread.
* La replica aggiunge più hardware e ulteriore complessità.

##### Fonte(i) e ulteriori letture: replica

* [Scalabilità, disponibilità, stabilità, pattern](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Replica multi-master](https://en.wikipedia.org/wiki/Multi-master_replication)

#### Federazione

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Fonte: Scaling up to your first 10 million users</a></i>
</p>

La federazione (o partizionamento funzionale) suddivide i database in base alla funzione. Ad esempio, invece di un singolo database monolitico, si potrebbero avere tre database: **forum**, **utenti** e **prodotti**, con conseguente minore traffico di lettura e scrittura per ogni database e quindi minore ritardo di replica. Database più piccoli permettono di memorizzare più dati in memoria, il che si traduce in più hit della cache grazie a una migliore località della cache. Non avendo un unico master centrale che serializza le scritture, è possibile scrivere in parallelo, aumentando il throughput.

##### Svantaggio(i): federazione

* La federazione non è efficace se lo schema richiede funzioni o tabelle molto grandi.
* Sarà necessario aggiornare la logica dell'applicazione per determinare quale database leggere e scrivere.
* Unire dati da due database è più complesso con un [collegamento server](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).
* La federazione aggiunge più hardware e ulteriore complessità.

##### Fonte(i) e ulteriori letture: federazione

* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)

#### Sharding

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fonte: Scalability, availability, stability, patterns</a></i>
</p>

Lo sharding distribuisce i dati tra diversi database in modo che ciascun database possa gestire solo un sottoinsieme dei dati. Prendendo come esempio un database utenti, man mano che il numero di utenti aumenta, si aggiungono altri shard al cluster.

Simile ai vantaggi della [federazione](#federation), lo sharding comporta meno traffico di lettura e scrittura, meno replicazione e più cache hit. Anche la dimensione dell'indice si riduce, migliorando generalmente le prestazioni con query più veloci. Se uno shard si guasta, gli altri shard continuano a funzionare, anche se è consigliabile aggiungere una forma di replica per evitare la perdita di dati. Come la federazione, non esiste un unico master centrale che serializza le scritture, permettendo di scrivere in parallelo con maggiore throughput.

I modi comuni per shardare una tabella di utenti sono tramite l'iniziale del cognome dell'utente o la posizione geografica dell'utente.

##### Svantaggi: sharding

* Sarà necessario aggiornare la logica dell'applicazione per lavorare con gli shard, il che può comportare query SQL complesse.
* La distribuzione dei dati può diventare squilibrata in uno shard. Ad esempio, un gruppo di power user su uno shard potrebbe causare un carico maggiore su quello shard rispetto agli altri.
    * Il riequilibrio aggiunge ulteriore complessità. Una funzione di sharding basata su [consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) può ridurre la quantità di dati trasferiti.
* Unire dati da più shard è più complesso.
* Lo sharding aggiunge più hardware e maggiore complessità.

##### Fonte(e) e ulteriori letture: sharding

* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)
* [Shard database architecture](https://it.wikipedia.org/wiki/Shard_(database_architecture))
* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)

#### Denormalizzazione

La denormalizzazione cerca di migliorare le prestazioni di lettura a scapito di quelle di scrittura. Copie ridondanti dei dati vengono scritte in più tabelle per evitare join costosi. Alcuni RDBMS come [PostgreSQL](https://it.wikipedia.org/wiki/PostgreSQL) e Oracle supportano le [materialized views](https://it.wikipedia.org/wiki/Materialized_view) che gestiscono il lavoro di memorizzazione delle informazioni ridondanti e mantengono le copie ridondanti coerenti.

Quando i dati vengono distribuiti con tecniche come [federazione](#federation) e [sharding](#sharding), la gestione dei join tra data center aumenta ulteriormente la complessità. La denormalizzazione può evitare la necessità di join così complessi.

Nella maggior parte dei sistemi, le letture possono superare di gran lunga le scritture, anche 100:1 o 1000:1. Una lettura che comporta un join complesso nel database può essere molto costosa, spendendo una notevole quantità di tempo in operazioni su disco.

##### Svantaggi: denormalizzazione

* I dati sono duplicati.
* I vincoli possono aiutare le copie ridondanti dell'informazione a rimanere sincronizzate, aumentando la complessità della progettazione del database.
* Un database denormalizzato sotto carico di scrittura intenso potrebbe avere prestazioni peggiori rispetto a uno normalizzato.

###### Fonte(e) e ulteriori letture: denormalizzazione

* [Denormalizzazione](https://it.wikipedia.org/wiki/Denormalizzazione)

#### Ottimizzazione SQL

L'ottimizzazione SQL è un argomento ampio e molti [libri](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) sono stati scritti come riferimento.

È importante **misurare** e **profilare** per simulare e individuare i colli di bottiglia.

* **Misurazione** - Simula situazioni di alto carico con strumenti come [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).
* **Profilazione** - Abilita strumenti come il [registro delle query lente](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) per aiutare a tracciare problemi di performance.

Le misurazioni e la profilazione potrebbero indirizzarti verso le seguenti ottimizzazioni.

##### Ottimizza lo schema

* MySQL esporta su disco in blocchi contigui per accesso veloce.
* Usa `CHAR` invece di `VARCHAR` per campi a lunghezza fissa.
    * `CHAR` permette un accesso casuale veloce, mentre con `VARCHAR` bisogna trovare la fine della stringa prima di passare alla successiva.
* Usa `TEXT` per grandi blocchi di testo come post di blog. `TEXT` consente anche ricerche booleane. Usando un campo `TEXT` si memorizza un puntatore su disco che viene usato per trovare il blocco di testo.
* Usa `INT` per numeri grandi fino a 2^32 o 4 miliardi.
* Usa `DECIMAL` per le valute per evitare errori di rappresentazione dei numeri in virgola mobile.
* Evita di memorizzare grandi `BLOB`, salva invece la posizione dove reperire l'oggetto.
* `VARCHAR(255)` è il numero massimo di caratteri che può essere conteggiato in un numero a 8 bit, spesso ottimizzando l'uso di un byte in alcuni RDBMS.
* Imposta il vincolo `NOT NULL` dove applicabile per [migliorare le prestazioni di ricerca](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).

##### Usa buoni indici

* Le colonne che interroghi (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) possono essere più veloci con indici.
* Gli indici sono solitamente rappresentati come [B-tree](https://it.wikipedia.org/wiki/B-tree) autobilancianti che mantengono i dati ordinati e consentono ricerche, accesso sequenziale, inserimenti e cancellazioni in tempo logaritmico.
* Posizionare un indice può mantenere i dati in memoria, richiedendo più spazio.
* Le scritture possono essere più lente poiché anche l'indice deve essere aggiornato.
* Quando si caricano grandi quantità di dati, potrebbe essere più veloce disabilitare gli indici, caricare i dati e poi ricostruire gli indici.

##### Evita join costosi

* [Denormalizza](#denormalizzazione) dove le prestazioni lo richiedono.

##### Partiziona le tabelle

* Suddividi una tabella inserendo i punti caldi in una tabella separata per aiutare a mantenerla in memoria.

##### Ottimizza la cache delle query

* In alcuni casi, la [cache delle query](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) potrebbe causare [problemi di prestazioni](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).

##### Fonte(i) e ulteriori letture: ottimizzazione SQL

* [Suggerimenti per ottimizzare le query MySQL](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)
* [C'è una buona ragione per cui vedo spesso VARCHAR(255)?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [Come influenzano le prestazioni i valori null?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)

### NoSQL

NoSQL è una collezione di elementi dati rappresentati in un **key-value store**, **document store**, **wide column store** o un **graph database**. I dati sono denormalizzati, e le join generalmente vengono effettuate nel codice dell'applicazione. La maggior parte degli archivi NoSQL non offre vere transazioni ACID e privilegia la [consistenza eventuale](#eventual-consistency).

**BASE** viene spesso utilizzato per descrivere le proprietà dei database NoSQL. In confronto al [Teorema CAP](#cap-theorem), BASE sceglie la disponibilità rispetto alla consistenza.

* **Fondamentalmente disponibile** - il sistema garantisce la disponibilità.
* **Stato morbido** - lo stato del sistema può cambiare nel tempo, anche senza input.
* **Consistenza eventuale** - il sistema diventerà consistente nel tempo, purché non riceva input durante quel periodo.

Oltre a scegliere tra [SQL o NoSQL](#sql-or-nosql), è utile capire quale tipo di database NoSQL si adatta meglio ai tuoi casi d'uso. Esamineremo **key-value store**, **document store**, **wide column store** e **graph database** nella prossima sezione.

#### Key-value store

> Astrazione: tabella hash

Un key-value store generalmente consente letture e scritture O(1) ed è spesso supportato da memoria o SSD. Gli archivi dati possono mantenere le chiavi in [ordine lessicografico](https://en.wikipedia.org/wiki/Lexicographical_order), permettendo il recupero efficiente di intervalli di chiavi. I key-value store possono consentire la memorizzazione di metadati insieme a un valore.

I key-value store offrono alte prestazioni e sono spesso utilizzati per modelli dati semplici o per dati che cambiano rapidamente, come uno strato di cache in memoria. Poiché offrono solo un set limitato di operazioni, la complessità viene spostata al livello applicativo se sono necessarie operazioni aggiuntive.

Un key-value store è la base per sistemi più complessi come un document store, e in alcuni casi, un graph database.

##### Fonte(i) e ulteriori letture: key-value store

* [Database key-value](https://en.wikipedia.org/wiki/Key-value_database)
* [Svantaggi dei key-value store](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)
* [Architettura di Redis](http://qnimate.com/overview-of-redis-architecture/)
* [Architettura di Memcached](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)

#### Document store

> Astrazione: archivio chiave-valore con documenti memorizzati come valori

Un document store è incentrato sui documenti (XML, JSON, binari, ecc.), dove un documento memorizza tutte le informazioni relative a un determinato oggetto. I document store forniscono API o un linguaggio di query per interrogare sulla base della struttura interna del documento stesso. *Nota, molti archivi chiave-valore includono funzionalità per lavorare con i metadati di un valore, sfumando la distinzione tra questi due tipi di archiviazione.*

In base all'implementazione sottostante, i documenti sono organizzati in collezioni, tag, metadati o directory. Anche se i documenti possono essere organizzati o raggruppati insieme, i documenti possono avere campi completamente diversi tra loro.

Alcuni document store come [MongoDB](https://www.mongodb.com/mongodb-architecture) e [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) offrono anche un linguaggio simile a SQL per effettuare query complesse. [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) supporta sia chiave-valore che documenti.

I document store offrono grande flessibilità e sono spesso utilizzati per lavorare con dati che cambiano occasionalmente.

##### Fonte(e) e ulteriori letture: document store

* [Database orientato ai documenti](https://en.wikipedia.org/wiki/Document-oriented_database)
* [Architettura MongoDB](https://www.mongodb.com/mongodb-architecture)
* [Architettura CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Architettura Elasticsearch](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)

#### Wide column store

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Fonte: SQL & NoSQL, una breve storia</a></i>
</p>

> Astrazione: mappa annidata `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`

L'unità base di dati di un wide column store è una colonna (coppia nome/valore). Una colonna può essere raggruppata in famiglie di colonne (analogo a una tabella SQL). Le super column families raggruppano ulteriormente le famiglie di colonne. Puoi accedere a ciascuna colonna indipendentemente tramite una chiave di riga, e le colonne con la stessa chiave di riga formano una riga. Ogni valore contiene un timestamp per la versioning e la risoluzione dei conflitti.

Google ha introdotto [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) come primo wide column store, che ha influenzato l'open-source [HBase](https://www.edureka.co/blog/hbase-architecture/) spesso usato nell'ecosistema Hadoop, e [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) di Facebook. Archivi come BigTable, HBase e Cassandra mantengono le chiavi in ordine lessicografico, consentendo un recupero efficiente di intervalli selettivi di chiavi.

I wide column store offrono alta disponibilità e grande scalabilità. Sono spesso utilizzati per set di dati molto grandi.

##### Fonte(e) e ulteriori letture: wide column store

* [SQL & NoSQL, una breve storia](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)
* [Architettura Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)
* [Architettura HBase](https://www.edureka.co/blog/hbase-architecture/)
* [Architettura Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)

#### Database a grafo

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png">
  <br/>
  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Fonte: Database a grafo</a></i>
</p>

> Astrazione: grafo

In un database a grafo, ogni nodo è un record e ogni arco è una relazione tra due nodi. I database a grafo sono ottimizzati per rappresentare relazioni complesse con molte chiavi esterne o relazioni molti-a-molti.

I database a grafo offrono prestazioni elevate per modelli di dati con relazioni complesse, come una rete sociale. Sono relativamente nuovi e non sono ancora ampiamente utilizzati; potrebbe essere più difficile trovare strumenti di sviluppo e risorse. Molti grafi possono essere accessibili solo tramite [REST API](#representational-state-transfer-rest).

##### Fonte/i e ulteriori letture: grafo

* [Database a grafo](https://en.wikipedia.org/wiki/Graph_database)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)

#### Fonte/i e ulteriori letture: NoSQL

* [Spiegazione della terminologia base](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [Database NoSQL: panoramica e guida alle decisioni](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [Scalabilità](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [Introduzione ai NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [Pattern NoSQL](http://horicky.blogspot.com/2009/11/nosql-patterns.html)

### SQL o NoSQL

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Fonte: Transizione da RDBMS a NoSQL</a></i>
</p>

Motivi per **SQL**:

* Dati strutturati
* Schema rigoroso
* Dati relazionali
* Necessità di join complessi
* Transazioni
* Schemi chiari per lo scaling
* Più consolidato: sviluppatori, comunità, codice, strumenti, ecc.
* Le ricerche tramite indice sono molto veloci

Motivi per **NoSQL**:

* Dati semi-strutturati
* Schema dinamico o flessibile
* Dati non relazionali
* Nessuna necessità di join complessi
* Memorizzazione di molti TB (o PB) di dati
* Carico di lavoro molto intensivo sui dati
* Altissimo throughput per IOPS

Esempi di dati adatti a NoSQL:

* Ingestione rapida di dati clickstream e log
* Dati di classifiche o punteggi
* Dati temporanei, come un carrello della spesa
* Tabelle frequentemente accessibili ('hot')
* Tabelle di metadati/lookup

##### Fonte(e) e ulteriori letture: SQL o NoSQL

* [Scalare fino ai primi 10 milioni di utenti](https://www.youtube.com/watch?v=kKjm4ehYiMs)
* [Differenze tra SQL e NoSQL](https://www.sitepoint.com/sql-vs-nosql-differences/)

## Cache

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Fonte: Scalable system design patterns</a></i>
</p>

La cache migliora i tempi di caricamento della pagina e può ridurre il carico sui server e sui database. In questo modello, il dispatcher controllerà prima se la richiesta è già stata effettuata e cercherà di trovare il risultato precedente da restituire, al fine di evitare l'esecuzione effettiva.

I database spesso beneficiano di una distribuzione uniforme di letture e scritture tra le sue partizioni. Gli elementi popolari possono alterare la distribuzione, causando colli di bottiglia. Mettere una cache davanti a un database può aiutare ad assorbire carichi irregolari e picchi di traffico.

### Cache lato client

Le cache possono essere posizionate lato client (OS o browser), [lato server](#reverse-proxy-web-server), o in un livello di cache distinto.

### Cache CDN

Le [CDN](#content-delivery-network) sono considerate un tipo di cache.

### Cache del web server

[Reverse proxy](#reverse-proxy-web-server) e cache come [Varnish](https://www.varnish-cache.org/) possono servire direttamente contenuti statici e dinamici. I web server possono anche memorizzare le richieste in cache, restituendo risposte senza dover contattare i server applicativi.

### Cache del database

Il tuo database di solito include un certo livello di cache nella configurazione predefinita, ottimizzata per un uso generico. Modificare queste impostazioni per specifici modelli di utilizzo può aumentare ulteriormente le prestazioni.

### Cache applicativa

Le cache in memoria come Memcached e Redis sono archivi chiave-valore tra la tua applicazione e il tuo storage dati. Poiché i dati sono tenuti in RAM, sono molto più veloci rispetto ai database tipici dove i dati sono su disco. La RAM è più limitata del disco, quindi algoritmi di [invalidazione della cache](https://it.wikipedia.org/wiki/Algoritmi_di_cache) come [least recently used (LRU)](https://it.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)) possono aiutare a invalidare le voci "fredde" e mantenere i dati "caldi" in RAM.

Redis offre le seguenti funzionalità aggiuntive:

* Opzione di persistenza
* Strutture dati integrate come insiemi ordinati e liste

Esistono diversi livelli che puoi cacheare, che rientrano in due categorie generali: **query di database** e **oggetti**:

* Livello riga
* Livello query
* Oggetti serializzabili completi
* HTML completamente renderizzato

Generalmente, è meglio evitare la cache basata su file, poiché rende più difficile la clonazione e l'auto-scalabilità.

### Caching a livello di query del database

Ogni volta che interroghi il database, usa l'hash della query come chiave e memorizza il risultato nella cache. Questo approccio presenta problemi di scadenza:

* Difficile eliminare un risultato memorizzato in cache con query complesse
* Se una parte dei dati cambia, come una cella di tabella, devi eliminare tutte le query memorizzate in cache che potrebbero includere la cella modificata

### Caching a livello di oggetto

Vedi i tuoi dati come oggetti, simile a come fai con il codice della tua applicazione. Fai sì che la tua applicazione assembli il set di dati dal database in un'istanza di classe o in una/e struttura/e dati:

* Rimuovi l'oggetto dalla cache se i suoi dati sottostanti sono cambiati
* Permette l'elaborazione asincrona: i worker assemblano oggetti consumando l'ultimo oggetto memorizzato in cache

Suggerimenti su cosa memorizzare in cache:

* Sessioni utente
* Pagine web completamente renderizzate
* Stream di attività
* Dati del grafo utente

### Quando aggiornare la cache

Poiché puoi memorizzare solo una quantità limitata di dati in cache, dovrai determinare quale strategia di aggiornamento della cache funziona meglio per il tuo caso d'uso.

#### Cache-aside

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Fonte: From cache to in-memory data grid</a></i>
</p>

L'applicazione è responsabile della lettura e scrittura dallo storage. La cache non interagisce direttamente con lo storage. L'applicazione esegue le seguenti operazioni:

* Cerca una voce in cache, ottenendo un cache miss
* Carica la voce dal database
* Aggiunge la voce alla cache
* Restituisce la voce

```python
def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```

[Memcached](https://memcached.org/) viene generalmente utilizzato in questo modo.

Le letture successive dei dati aggiunti alla cache sono veloci. Il cache-aside è anche chiamato lazy loading. Solo i dati richiesti vengono memorizzati nella cache, evitando di riempire la cache con dati che non vengono richiesti.

##### Svantaggio/i: cache-aside

* Ogni mancanza nella cache comporta tre passaggi, il che può causare un ritardo evidente.
* I dati possono diventare obsoleti se vengono aggiornati nel database. Questo problema viene mitigato impostando un time-to-live (TTL) che forza l’aggiornamento della voce in cache, oppure utilizzando il write-through.
* Quando un nodo fallisce, viene sostituito da un nodo nuovo e vuoto, aumentando la latenza.

#### Write-through

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fonte: Scalability, availability, stability, patterns</a></i>
</p>

L’applicazione utilizza la cache come principale archivio dati, leggendo e scrivendo dati su di essa, mentre la cache si occupa di leggere e scrivere sul database:

* L’applicazione aggiunge/aggiorna la voce nella cache
* La cache scrive sincronicamente la voce nell’archivio dati
* Ritorno

Codice dell’applicazione:

```python
set_user(12345, {"foo":"bar"})
```

Codice cache:

```python
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```
La modalità write-through è generalmente un'operazione lenta a causa della scrittura, ma le letture successive dei dati appena scritti sono rapide. Gli utenti di solito sono più tolleranti alla latenza durante l'aggiornamento dei dati rispetto alla lettura dei dati. I dati nella cache non sono obsoleti.

##### Svantaggio/i: write-through

* Quando viene creato un nuovo nodo a seguito di un guasto o di uno scaling, il nuovo nodo non memorizzerà le voci in cache finché la voce non verrà aggiornata nel database. Cache-aside insieme a write-through può mitigare questo problema.
* La maggior parte dei dati scritti potrebbe non essere mai letta, cosa che può essere minimizzata con un TTL.

#### Write-behind (write-back)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Fonte: Scalability, availability, stability, patterns</a></i>
</p>

Nel write-behind, l'applicazione esegue le seguenti operazioni:

* Aggiunge/aggiorna la voce nella cache
* Scrive la voce nel data store in modo asincrono, migliorando le prestazioni di scrittura

##### Svantaggio/i: write-behind

* Potrebbe esserci perdita di dati se la cache si interrompe prima che il suo contenuto venga scritto nel data store.
* Implementare il write-behind è più complesso rispetto a cache-aside o write-through.

#### Refresh-ahead

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Fonte: From cache to in-memory data grid</a></i>
</p>

È possibile configurare la cache affinché aggiorni automaticamente qualsiasi voce della cache recentemente acceduta prima della sua scadenza.

Il refresh-ahead può comportare una latenza ridotta rispetto al read-through se la cache riesce a prevedere accuratamente quali elementi saranno necessari in futuro.

##### Svantaggio/i: refresh-ahead


* Non prevedere accuratamente quali elementi potrebbero essere necessari in futuro può comportare prestazioni inferiori rispetto all'assenza di refresh-ahead.

### Svantaggio(i): cache

* È necessario mantenere la coerenza tra le cache e la fonte di verità come il database tramite [invalidazione della cache](https://en.wikipedia.org/wiki/Cache_algorithms).
* L'invalidazione della cache è un problema difficile, vi è una complessità aggiuntiva relativa a quando aggiornare la cache.
* È necessario apportare modifiche all'applicazione come l'aggiunta di Redis o memcached.

### Fonte(i) e letture aggiuntive

* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [Scalable system design patterns](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [Introduction to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Scalability](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [AWS ElastiCache strategies](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)
* [Wikipedia](https://en.wikipedia.org/wiki/Cache_(computing))

## Asincronismo

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Fonte: Introduzione all’architettura di sistemi scalabili</a></i>
</p>

I flussi di lavoro asincroni aiutano a ridurre i tempi di richiesta per operazioni costose che altrimenti verrebbero eseguite in linea. Possono anche aiutare effettuando in anticipo lavori che richiedono tempo, come l'aggregazione periodica dei dati.

### Code di messaggi

Le code di messaggi ricevono, trattengono e consegnano messaggi. Se un'operazione è troppo lenta per essere eseguita in linea, è possibile utilizzare una coda di messaggi con il seguente flusso:

* Un'applicazione pubblica un lavoro nella coda, quindi notifica all'utente lo stato del lavoro
* Un worker preleva il lavoro dalla coda, lo elabora e segnala il completamento

L'utente non viene bloccato e il lavoro viene elaborato in background. Durante questo periodo, il client può opzionalmente eseguire una piccola quantità di elaborazione per far sembrare che il compito sia stato completato. Ad esempio, se si pubblica un tweet, il tweet potrebbe essere immediatamente pubblicato sulla propria timeline, ma potrebbe volerci del tempo prima che il tweet venga effettivamente consegnato a tutti i propri follower.

**[Redis](https://redis.io/)** è utile come semplice message broker, ma i messaggi possono andare persi.

**[RabbitMQ](https://www.rabbitmq.com/)** è popolare, ma richiede di adattarsi al protocollo 'AMQP' e di gestire i propri nodi.

**[Amazon SQS](https://aws.amazon.com/sqs/)** è ospitato ma può avere alta latenza e la possibilità che i messaggi vengano consegnati due volte.

### Code di attività

Le code di attività ricevono le attività e i relativi dati, le eseguono e poi ne consegnano i risultati. Possono supportare la pianificazione e vengono utilizzate per eseguire lavori computazionalmente intensivi in background.

**[Celery](https://docs.celeryproject.org/en/stable/)** supporta la pianificazione ed è principalmente compatibile con python.

### Pressione inversa (Back pressure)

Se le code iniziano a crescere significativamente, la dimensione della coda può superare la memoria, causando cache miss, letture da disco e prestazioni ancora più lente. La [pressione inversa](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) può aiutare limitando la dimensione della coda, mantenendo così un alto tasso di throughput e buoni tempi di risposta per i lavori già in coda. Una volta che la coda è piena, i client ricevono un messaggio di server occupato o lo status code HTTP 503 per riprovare più tardi. I client possono ripetere la richiesta successivamente, magari con [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff).

### Svantaggio(i): asincronismo

* Casi d'uso come calcoli poco costosi e flussi di lavoro in tempo reale potrebbero essere più adatti per operazioni sincrone, poiché l'introduzione di code può aggiungere ritardi e complessità.

### Fonte(e) e ulteriori letture

* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)
* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)
* [Qual è la differenza tra una message queue e una task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)

## Comunicazione

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Fonte: modello OSI a 7 livelli</a></i>
</p>

### Hypertext transfer protocol (HTTP)

HTTP è un metodo per codificare e trasportare dati tra un client e un server. È un protocollo request/response: i client inviano richieste e i server rispondono con contenuti rilevanti e informazioni sullo stato di completamento della richiesta. HTTP è autonomo, consentendo che richieste e risposte fluiscano attraverso router e server intermedi che eseguono bilanciamento del carico, caching, crittografia e compressione.

Una richiesta HTTP di base consiste in un verbo (metodo) e una risorsa (endpoint). Di seguito sono riportati i verbi HTTP più comuni:

| Verbo | Descrizione | Idempotente* | Sicuro | Caching |
|---|---|---|---|---|
| GET | Legge una risorsa | Sì | Sì | Sì |
| POST | Crea una risorsa o avvia un processo che gestisce dati | No | No | Sì se la risposta contiene info sulla freschezza |
| PUT | Crea o sostituisce una risorsa | Sì | No | No |
| PATCH | Aggiorna parzialmente una risorsa | No | No | Sì se la risposta contiene info sulla freschezza |
| DELETE | Elimina una risorsa | Sì | No | No |

*Può essere chiamato molte volte senza risultati diversi.

HTTP è un protocollo di livello applicazione che si basa su protocolli di livello inferiore come **TCP** e **UDP**.

#### Fonte(e) e ulteriori letture: HTTP

* [Cos'è HTTP?](https://www.nginx.com/resources/glossary/http/)
* [Differenza tra HTTP e TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [Differenza tra PUT e PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)

### Transmission control protocol (TCP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Fonte: Come realizzare un gioco multiplayer</a></i>
</p>

TCP è un protocollo orientato alla connessione su una [rete IP](https://en.wikipedia.org/wiki/Internet_Protocol). La connessione viene stabilita e terminata tramite una [stretta di mano](https://en.wikipedia.org/wiki/Handshaking). Tutti i pacchetti inviati sono garantiti di raggiungere la destinazione nell'ordine originale e senza corruzione tramite:

* Numeri di sequenza e [campi checksum](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) per ogni pacchetto
* Pacchetti di [acknowledgement](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) e ritrasmissione automatica

Se il mittente non riceve una risposta corretta, ritrasmette i pacchetti. Se ci sono più timeout, la connessione viene chiusa. TCP implementa anche il [controllo di flusso](https://en.wikipedia.org/wiki/Flow_control_(data)) e il [controllo della congestione](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control). Queste garanzie causano ritardi e generalmente portano a una trasmissione meno efficiente rispetto a UDP.

Per garantire un'elevata velocità di trasmissione, i server web possono mantenere aperte molte connessioni TCP, con conseguente elevato utilizzo di memoria. Può essere costoso avere molte connessioni aperte tra i thread del server web e, ad esempio, un server [memcached](https://memcached.org/). Il [connection pooling](https://en.wikipedia.org/wiki/Connection_pool) può aiutare oltre alla commutazione su UDP dove applicabile.

TCP è utile per applicazioni che richiedono alta affidabilità ma sono meno critiche in termini di tempo. Alcuni esempi includono server web, info di database, SMTP, FTP e SSH.

Usa TCP invece di UDP quando:

* Hai bisogno che tutti i dati arrivino integri
* Vuoi stimare automaticamente il miglior utilizzo della larghezza di banda di rete

### Protocollo User Datagram (UDP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Fonte: How to make a multiplayer game</a></i>
</p>

UDP è senza connessione. I datagrammi (analoghi ai pacchetti) sono garantiti solo a livello di datagramma. I datagrammi possono arrivare a destinazione fuori ordine o non arrivare affatto. UDP non supporta il controllo della congestione. Senza le garanzie offerte da TCP, UDP è generalmente più efficiente.

UDP può trasmettere in broadcast, inviando datagrammi a tutti i dispositivi sulla sottorete. Questo è utile con [DHCP](https://it.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) perché il client non ha ancora ricevuto un indirizzo IP, impedendo così a TCP di trasmettere senza l’indirizzo IP.

UDP è meno affidabile, ma funziona bene in casi d’uso in tempo reale come VoIP, videochat, streaming e giochi multiplayer in tempo reale.

Usa UDP invece di TCP quando:

* Hai bisogno della latenza più bassa
* I dati in ritardo sono peggiori della perdita di dati
* Vuoi implementare la tua correzione degli errori

#### Fonte(i) e letture aggiuntive: TCP e UDP

* [Networking per la programmazione di giochi](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)
* [Differenze chiave tra i protocolli TCP e UDP](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Differenza tra TCP e UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Transmission control protocol](https://it.wikipedia.org/wiki/Transmission_Control_Protocol)
* [User datagram protocol](https://it.wikipedia.org/wiki/User_Datagram_Protocol)
* [Scaling memcache at Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)

### Remote procedure call (RPC)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Fonte: Crack the system design interview</a></i>
</p>

In una RPC, un client fa eseguire una procedura su uno spazio di indirizzi diverso, di solito un server remoto. La procedura è scritta come se fosse una chiamata locale, astrarre i dettagli di come comunicare con il server dal programma client. Le chiamate remote sono solitamente più lente e meno affidabili delle chiamate locali, quindi è utile distinguere tra chiamate RPC e chiamate locali. Framework RPC popolari includono [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/), e [Avro](https://avro.apache.org/docs/current/).

RPC è un protocollo richiesta-risposta:

* **Programma client** - Chiama la procedura stub del client. I parametri vengono inseriti nello stack come in una chiamata di procedura locale.
* **Procedura stub del client** - Marsha (impacchetta) l'id della procedura e gli argomenti in un messaggio di richiesta.
* **Modulo di comunicazione del client** - Il sistema operativo invia il messaggio dal client al server.
* **Modulo di comunicazione del server** - Il sistema operativo passa i pacchetti in arrivo alla procedura stub del server.
* **Procedura stub del server** - Demarsha i risultati, chiama la procedura del server corrispondente all'id della procedura e passa gli argomenti forniti.
* La risposta del server ripete i passaggi sopra descritti in ordine inverso.

Esempi di chiamate RPC:

```
GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
```

RPC si concentra sull'esposizione dei comportamenti. Gli RPC vengono spesso utilizzati per motivi di prestazioni nelle comunicazioni interne, poiché è possibile creare chiamate native su misura per adattarsi meglio ai propri casi d'uso.

Scegli una libreria nativa (nota anche come SDK) quando:

* Conosci la tua piattaforma di destinazione.
* Vuoi controllare come viene acceduta la tua "logica".
* Vuoi controllare come avviene la gestione degli errori al di fuori della tua libreria.
* Le prestazioni e l'esperienza dell'utente finale sono la tua principale preoccupazione.

Le API HTTP che seguono **REST** tendono ad essere utilizzate più frequentemente per le API pubbliche.

#### Svantaggio/i: RPC

* I client RPC diventano strettamente accoppiati all'implementazione del servizio.
* Deve essere definita una nuova API per ogni nuova operazione o caso d'uso.
* Può essere difficile eseguire il debug degli RPC.
* Potresti non essere in grado di sfruttare tecnologie esistenti immediatamente. Ad esempio, potrebbe essere necessario uno sforzo aggiuntivo per garantire che [le chiamate RPC siano correttamente memorizzate nella cache](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) su server di caching come [Squid](http://www.squid-cache.org/).

### Trasferimento di stato rappresentazionale (REST)

REST è uno stile architetturale che applica un modello client/server in cui il client agisce su un insieme di risorse gestite dal server. Il server fornisce una rappresentazione delle risorse e azioni che possono manipolare o ottenere una nuova rappresentazione delle risorse. Tutta la comunicazione deve essere senza stato e cacheabile.

Ci sono quattro qualità di un'interfaccia RESTful:

* **Identificare le risorse (URI in HTTP)** - utilizzare lo stesso URI indipendentemente dall'operazione.
* **Cambiare con le rappresentazioni (Verbi in HTTP)** - usare verbi, header e body.
* **Messaggio di errore auto-descrittivo (risposta di stato in HTTP)** - utilizzare i codici di stato, non reinventare la ruota.
* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (interfaccia HTML per HTTP)** - il tuo servizio web dovrebbe essere completamente accessibile tramite browser.

Esempi di chiamate REST:

```
GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
```

REST è focalizzato sull’esposizione dei dati. Minimizza il coupling tra client/server ed è spesso utilizzato per API HTTP pubbliche. REST utilizza un metodo più generico e uniforme per esporre le risorse tramite URI, [rappresentazione tramite header](https://github.com/for-GET/know-your-http-well/blob/master/headers.md) e azioni tramite verbi come GET, POST, PUT, DELETE e PATCH. Essendo stateless, REST è ottimo per lo scaling orizzontale e il partizionamento.

#### Svantaggio(i): REST

* Poiché REST è focalizzato sull’esposizione dei dati, potrebbe non essere adatto se le risorse non sono naturalmente organizzate o accessibili in una gerarchia semplice. Ad esempio, restituire tutti i record aggiornati nell’ultima ora che corrispondono a un particolare insieme di eventi non è facilmente esprimibile come un percorso. Con REST, è probabile che venga implementato con una combinazione di percorso URI, parametri di query e possibilmente il corpo della richiesta.
* REST tipicamente si basa su pochi verbi (GET, POST, PUT, DELETE e PATCH) che a volte non si adattano al tuo caso d’uso. Ad esempio, spostare documenti scaduti nella cartella archivio potrebbe non rientrare perfettamente in questi verbi.
* Recuperare risorse complesse con gerarchie annidate richiede più round trip tra client e server per rendere singole viste, ad es. recuperare il contenuto di una voce di blog e i commenti su quella voce. Per applicazioni mobili che operano in condizioni di rete variabili, questi roundtrip multipli sono altamente indesiderabili.
* Nel tempo, potrebbero essere aggiunti più campi alla risposta di un’API e i client più vecchi riceveranno tutti i nuovi campi dati, anche quelli di cui non hanno bisogno; di conseguenza, il payload si gonfia e comporta latenze maggiori.

### Confronto tra chiamate RPC e REST

| Operazione | RPC | REST |
|---|---|---|
| Registrazione | **POST** /signup | **POST** /persons |
| Dimissioni | **POST** /resign<br/>{<br/>"personid": "1234"<br/>} | **DELETE** /persons/1234 |
| Leggi una persona | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |
| Leggi la lista oggetti di una persona | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |
| Aggiungi un oggetto alla lista di una persona | **POST** /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | **POST** /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Aggiorna un oggetto | **POST** /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | **PUT** /items/456<br/>{<br/>"key": "value"<br/>} |
| Elimina un oggetto | **POST** /removeItem<br/>{<br/>"itemid": "456"<br/>} | **DELETE** /items/456 |

<p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Fonte: Do you really know why you prefer REST over RPC</a></i>
</p>

#### Fonte/i e ulteriori letture: REST e RPC

* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [Quando gli approcci RPC sono più appropriati rispetto a REST?](http://programmers.stackexchange.com/a/181186)
* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [Sfatare i miti di RPC e REST](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)
* [Quali sono gli svantaggi dell’utilizzo di REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Thrift](https://code.facebook.com/posts/1468950976659943/)
* [Perché REST per uso interno e non RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)

## Sicurezza

Questa sezione potrebbe necessitare di aggiornamenti. Prendi in considerazione di [contribuire](#contributing)!

La sicurezza è un argomento ampio. A meno che tu non abbia una notevole esperienza, un background in sicurezza, o stia facendo domanda per una posizione che richiede conoscenze di sicurezza, probabilmente non avrai bisogno di sapere più delle basi:

* Crittografa i dati in transito e a riposo.
* Sanifica tutti gli input dell'utente o qualsiasi parametro di input esposto all'utente per prevenire [XSS](https://it.wikipedia.org/wiki/Cross-site_scripting) e [iniezione SQL](https://it.wikipedia.org/wiki/SQL_injection).
* Usa query parametrizzate per prevenire l'iniezione SQL.
* Usa il principio del [privilegio minimo](https://it.wikipedia.org/wiki/Principio_del_privilegio_minimo).

### Fonte(e) e ulteriori letture

* [Checklist di sicurezza API](https://github.com/shieldfy/API-Security-Checklist)
* [Guida alla sicurezza per sviluppatori](https://github.com/FallibleInc/security-guide-for-developers)
* [OWASP top ten](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)

## Appendice

A volte ti verrà chiesto di fare stime "a spanne". Ad esempio, potresti dover determinare quanto tempo ci vorrà per generare 100 miniature di immagini da disco o quanta memoria occuperà una struttura dati. La **tabella delle potenze di due** e i **numeri di latenza che ogni programmatore dovrebbe conoscere** sono riferimenti utili.

### Tabella delle potenze di due

```
Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
```

#### Fonte(e) e ulteriori letture

* [Potenze di due](https://it.wikipedia.org/wiki/Potenza_di_due)

### Numeri di latenza che ogni programmatore dovrebbe conoscere

```
Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
HDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
```
Metriche utili basate sui numeri sopra:

* Lettura sequenziale da HDD a 30 MB/s
* Lettura sequenziale da Ethernet 1 Gbps a 100 MB/s
* Lettura sequenziale da SSD a 1 GB/s
* Lettura sequenziale dalla memoria principale a 4 GB/s
* 6-7 viaggi di andata e ritorno in tutto il mondo al secondo
* 2.000 viaggi di andata e ritorno al secondo all'interno di un data center

#### Numeri di latenza visualizzati

![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)

#### Fonte/i e letture aggiuntive

* [Numeri di latenza che ogni programmatore dovrebbe conoscere - 1](https://gist.github.com/jboner/2841832)
* [Numeri di latenza che ogni programmatore dovrebbe conoscere - 2](https://gist.github.com/hellerbarde/2843375)
* [Progetti, lezioni e consigli dalla realizzazione di grandi sistemi distribuiti](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)
* [Consigli di ingegneria del software dalla costruzione di sistemi distribuiti su larga scala](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)

### Ulteriori domande per colloqui di progettazione di sistemi

> Domande comuni dei colloqui di progettazione di sistemi, con link a risorse su come risolverle.

| Domanda | Riferimento/i |
|---|---|
| Progetta un servizio di sincronizzazione file come Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| Progetta un motore di ricerca come Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |
| Progetta un web crawler scalabile come Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |
| Progetta Google docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |
| Progetta un key-value store come Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| Progetta un sistema di cache come Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Progetta un sistema di raccomandazione come quello di Amazon | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |
| Progetta un sistema tinyurl come Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |
| Progetta un'app di chat come WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)
| Progetta un sistema di condivisione immagini come Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |
| Progetta la funzione news feed di Facebook | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |
| Progetta la funzione timeline di Facebook | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |
| Progetta la funzione chat di Facebook | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |

| Progetta una funzione di ricerca su grafi come quella di Facebook | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |
| Progetta una content delivery network come CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |
| Progetta un sistema di argomenti di tendenza come quello di Twitter | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |
| Progetta un sistema di generazione di ID casuali | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |
| Restituisci le top k richieste durante un intervallo di tempo | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |
| Progetta un sistema che serve dati da più data center | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |
| Progetta un gioco di carte multiplayer online | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |
| Progetta un sistema di garbage collection | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |
| Progetta un sistema di limitazione delle API | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |
| Progetta una Borsa Valori (come NASDAQ o Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |
| Aggiungi una domanda di system design | [Contribuisci](#contributing) |

### Architetture del mondo reale

> Articoli su come sono progettati i sistemi nel mondo reale.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Fonte: Twitter timelines at scale</a></i>
</p>

**Non concentrarti sui dettagli minuziosi per i seguenti articoli, invece:**

* Identifica principi condivisi, tecnologie comuni e pattern all'interno di questi articoli
* Studia quali problemi vengono risolti da ciascun componente, dove funziona e dove no
* Rivedi le lezioni apprese

|Tipo | Sistema | Riferimento/i |
|---|---|---|
| Data processing | **MapReduce** - Elaborazione dati distribuita di Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |
| Data processing | **Spark** - Elaborazione dati distribuita di Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |
| Data processing | **Storm** - Elaborazione dati distribuita di Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |
| | | |
| Data store | **Bigtable** - Database distribuito orientato alle colonne di Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |
| Data store | **HBase** - Implementazione open source di Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |
| Data store | **Cassandra** - Database distribuito orientato alle colonne di Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)
| Data store | **DynamoDB** - Database orientato ai documenti di Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |
| Data store | **MongoDB** - Database orientato ai documenti | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |
| Data store | **Spanner** - Database distribuito globalmente di Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |
| Data store | **Memcached** - Sistema di caching della memoria distribuito | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Data store | **Redis** - Sistema di caching della memoria distribuito con persistenza e tipi di valore | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| | | |
| File system | **Google File System (GFS)** - File system distribuito | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |
| File system | **Hadoop File System (HDFS)** - Implementazione open source di GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |
| | | |
| Misc | **Chubby** - Servizio di lock per sistemi distribuiti loosely-coupled di Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |
| Misc | **Dapper** - Infrastruttura di tracciamento per sistemi distribuiti | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)
| Misc | **Kafka** - Coda di messaggi pub/sub di LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |
| Misc | **Zookeeper** - Infrastruttura centralizzata e servizi per l'abilitazione della sincronizzazione | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |
| | Aggiungi un'architettura | [Contribuisci](#contributing) |

### Architetture aziendali

| Azienda | Riferimento/i |
|---|---|
| Amazon | [Architettura Amazon](http://highscalability.com/amazon-architecture) |
| Cinchcast | [Produzione di 1.500 ore di audio ogni giorno](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |
| DataSift | [Datamining in tempo reale a 120.000 tweet al secondo](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |
| Dropbox | [Come abbiamo scalato Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| ESPN | [Operatività a 100.000 duh nuh nuhs al secondo](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |
| Google | [Architettura Google](http://highscalability.com/google-architecture) |
| Instagram | [14 milioni di utenti, terabyte di foto](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Cosa alimenta Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |
| Justin.tv | [Architettura di trasmissione video live di Justin.Tv](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |
| Facebook | [Scalare memcached su Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Data store distribuito di Facebook per il social graph](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Lo storage delle foto su Facebook](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Come Facebook Live trasmette a 800.000 spettatori simultanei](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |
| Flickr | [Architettura Flickr](http://highscalability.com/flickr-architecture) |
| Mailbox | [Da 0 a un milione di utenti in 6 settimane](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |
| Netflix | [Vista a 360 gradi dell'intero stack Netflix](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: cosa succede quando premi Play?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |
| Pinterest | [Da 0 a decine di miliardi di pageview al mese](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 milioni di visitatori, crescita 10x, 12 dipendenti](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |
| Playfish | [50 milioni di utenti mensili e in crescita](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |
| PlentyOfFish | [Architettura PlentyOfFish](http://highscalability.com/plentyoffish-architecture) |
| Salesforce | [Come gestiscono 1,3 miliardi di transazioni al giorno](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |
| Stack Overflow | [Architettura Stack Overflow](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |
| TripAdvisor | [40M visitatori, 200M pageview dinamiche, 30TB dati](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |
| Tumblr | [15 miliardi di pageview al mese](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |
| Twitter | [Rendere Twitter il 10000 percento più veloce](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Memorizzare 250 milioni di tweet al giorno usando MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M utenti attivi, 300K QPS, un firehose da 22 MB/S](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Timeline su larga scala](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Big e small data su Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operazioni su Twitter: scaling oltre 100 milioni di utenti](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[Come Twitter gestisce 3.000 immagini al secondo](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |
| Uber | [Come Uber scala la propria piattaforma di mercato in tempo reale](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lezioni apprese scalando Uber a 2000 ingegneri, 1000 servizi e 8000 repository Git](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |
| WhatsApp | [L'architettura di WhatsApp che Facebook ha acquistato per 19 miliardi di dollari](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| YouTube | [Scalabilità di YouTube](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[Architettura YouTube](http://highscalability.com/youtube-architecture) |

### Blog di ingegneria aziendale

> Architetture delle aziende con cui stai facendo colloqui.
>
> Le domande che incontri potrebbero provenire dallo stesso dominio.

* [Airbnb Engineering](http://nerds.airbnb.com/)
* [Atlassian Developers](https://developer.atlassian.com/blog/)
* [AWS Blog](https://aws.amazon.com/blogs/aws/)
* [Bitly Engineering Blog](http://word.bitly.com/)
* [Box Blogs](https://blog.box.com/blog/category/engineering)
* [Cloudera Developer Blog](http://blog.cloudera.com/)
* [Dropbox Tech Blog](https://tech.dropbox.com/)
* [Engineering at Quora](https://www.quora.com/q/quoraengineering)
* [Ebay Tech Blog](http://www.ebaytechblog.com/)
* [Evernote Tech Blog](https://blog.evernote.com/tech/)
* [Etsy Code as Craft](http://codeascraft.com/)
* [Facebook Engineering](https://www.facebook.com/Engineering)
* [Flickr Code](http://code.flickr.net/)
* [Foursquare Engineering Blog](http://engineering.foursquare.com/)
* [GitHub Engineering Blog](https://github.blog/category/engineering)
* [Google Research Blog](http://googleresearch.blogspot.com/)
* [Groupon Engineering Blog](https://engineering.groupon.com/)
* [Heroku Engineering Blog](https://engineering.heroku.com/)
* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)
* [High Scalability](http://highscalability.com/)
* [Instagram Engineering](http://instagram-engineering.tumblr.com/)
* [Intel Software Blog](https://software.intel.com/en-us/blogs/)
* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)
* [LinkedIn Engineering](http://engineering.linkedin.com/blog)
* [Microsoft Engineering](https://engineering.microsoft.com/)
* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)
* [Netflix Tech Blog](http://techblog.netflix.com/)
* [Paypal Developer Blog](https://medium.com/paypal-engineering)
* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)
* [Reddit Blog](http://www.redditblog.com/)
* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)
* [Slack Engineering Blog](https://slack.engineering/)
* [Spotify Labs](https://labs.spotify.com/)
* [Stripe Engineering Blog](https://stripe.com/blog/engineering)
* [Twilio Engineering Blog](http://www.twilio.com/engineering)
* [Twitter Engineering](https://blog.twitter.com/engineering/)
* [Uber Engineering Blog](http://eng.uber.com/)
* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)
* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)
* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)

#### Fonte(i) e ulteriori letture

Vuoi aggiungere un blog? Per evitare di duplicare il lavoro, considera di aggiungere il blog della tua azienda al seguente repository:

* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)

## In fase di sviluppo

Sei interessato ad aggiungere una sezione o aiutare a completarne una in corso? [Contribuisci](#contributing)!

* Calcolo distribuito con MapReduce
* Hashing consistente
* Scatter gather
* [Contribuisci](#contributing)

## Crediti

I crediti e le fonti sono forniti in tutto questo repository.

Un ringraziamento speciale a:

* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)
* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)
* [High scalability](http://highscalability.com/)
* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)
* [shashank88/system_design](https://github.com/shashank88/system_design)
* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)
* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
* [A distributed systems reading list](http://dancres.github.io/Pages/)
* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)

## Info di contatto

Sentiti libero di contattarmi per discutere qualsiasi problema, domanda o commento.

Le mie informazioni di contatto sono disponibili sulla mia [pagina GitHub](https://github.com/donnemartin).

## Licenza

*Sto fornendo codice e risorse in questo repository sotto una licenza open source. Poiché questo è il mio repository personale, la licenza che ricevi per il mio codice e le risorse proviene da me e non dal mio datore di lavoro (Facebook).*

    Copyright 2017 Donne Martin

    Creative Commons Attribution 4.0 International License (CC BY 4.0)

    http://creativecommons.org/licenses/by/4.0/


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-08-09

---