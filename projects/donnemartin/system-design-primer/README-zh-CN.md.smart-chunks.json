[
  {
    "Id": 1,
    "Content": "*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*",
    "ContentSha": "NV5If+n4caPL9367nN6NPHEHX2NVMyxh97QjgslLVk8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "\n**Help [translate](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) this guide!**\n\n# The System Design Primer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png\">\n  <br/>\n</p>\n\n## Motivation\n\n> Learn how to design large-scale systems.\n>\n> Prep for the system design interview.\n\n### Learn how to design large-scale systems\n\nLearning how to design scalable systems will help you become a better engineer.\n\nSystem design is a broad topic.  There is a **vast amount of resources scattered throughout the web** on system design principles.\n\nThis repo is an **organized collection** of resources to help you learn how to build systems at scale.\n\n### Learn from the open source community\n\nThis is a continually updated, open source project.\n\n[Contributions](#contributing) are welcome!\n\n### Prep for the system design interview\n\nIn addition to coding interviews, system design is a **required component** of the **technical interview process** at many tech companies.\n\n**Practice common system design interview questions** and **compare** your results with **sample solutions**: discussions, code, and diagrams.\n\nAdditional topics for interview prep:\n\n* [Study guide](#study-guide)\n* [How to approach a system design interview question](#how-to-approach-a-system-design-interview-question)",
    "ContentSha": "AbJTT6alKgUjtCBRmG+Q5nAyd3D1OmTONWi5hXEC4sI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**帮助[翻译](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md)本指南！**\n\n# 系统设计入门\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png\">\n  <br/>\n</p>\n\n## 动机\n\n> 学习如何设计大规模系统。\n>\n> 准备系统设计面试。\n\n### 学习如何设计大规模系统\n\n学习如何设计可扩展系统将帮助你成为更优秀的工程师。\n\n系统设计是一个广泛的主题。网络上散布着**大量关于系统设计原则的资源**。\n\n本仓库是一个**有组织的资源集合**，帮助你学习如何构建大规模系统。\n\n### 向开源社区学习\n\n这是一个持续更新的开源项目。\n\n欢迎[贡献](#contributing)！\n\n### 准备系统设计面试\n\n除了编码面试，系统设计是许多科技公司**技术面试流程**中的**必备环节**。\n\n**练习常见的系统设计面试题**，并将你的结果与**示例解答**进行**比较**：讨论、代码和图表。\n\n面试准备的其他主题：\n\n* [学习指南](#study-guide)\n* [如何应对系统设计面试题](#how-to-approach-a-system-design-interview-question)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 3,
    "Content": "* [System design interview questions, **with solutions**](#system-design-interview-questions-with-solutions)\n* [Object-oriented design interview questions, **with solutions**](#object-oriented-design-interview-questions-with-solutions)\n* [Additional system design interview questions](#additional-system-design-interview-questions)\n\n## Anki flashcards\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png\">\n  <br/>\n</p>\n\nThe provided [Anki flashcard decks](https://apps.ankiweb.net/) use spaced repetition to help you retain key system design concepts.\n\n* [System design deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)\n* [System design exercises deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)\n* [Object oriented design exercises deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)\n\nGreat for use while on-the-go.\n\n### Coding Resource: Interactive Coding Challenges\n\nLooking for resources to help you prep for the [**Coding Interview**](https://github.com/donnemartin/interactive-coding-challenges)?\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png\">\n  <br/>\n</p>\n\nCheck out the sister repo [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges), which contains an additional Anki deck:\n\n* [Coding deck](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)\n\n## Contributing\n\n> Learn from the community.\n\nFeel free to submit pull requests to help:\n\n* Fix errors\n* Improve sections",
    "ContentSha": "SXl/9sXgfkMzgSqqZA/bJ68vMrerBbNpRqT5TMAq1Hg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [系统设计面试题，**附答案**](#system-design-interview-questions-with-solutions)\n* [面向对象设计面试题，**附答案**](#object-oriented-design-interview-questions-with-solutions)\n* [额外的系统设计面试题](#additional-system-design-interview-questions)\n\n## Anki 闪卡\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png\">\n  <br/>\n</p>\n\n提供的 [Anki 闪卡套装](https://apps.ankiweb.net/) 使用间隔重复帮助你记忆关键的系统设计概念。\n\n* [系统设计套装](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)\n* [系统设计练习套装](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)\n* [面向对象设计练习套装](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)\n\n非常适合在移动中使用。\n\n### 编程资源：互动编程挑战\n\n想找资源帮助准备[**编程面试**](https://github.com/donnemartin/interactive-coding-challenges)吗？\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png\">\n  <br/>\n</p>\n\n看看姊妹仓库 [**互动编程挑战**](https://github.com/donnemartin/interactive-coding-challenges)，其中包含额外的 Anki 套装：\n\n* [编程套装](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)\n\n## 贡献\n\n> 从社区中学习。\n\n欢迎提交拉取请求帮助：\n\n* 修正错误\n* 改进章节",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 4,
    "Content": "* Add new sections\n* [Translate](https://github.com/donnemartin/system-design-primer/issues/28)\n\nContent that needs some polishing is placed [under development](#under-development).\n\nReview the [Contributing Guidelines](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).\n\n## Index of system design topics\n\n> Summaries of various system design topics, including pros and cons.  **Everything is a trade-off**.\n>\n> Each section contains links to more in-depth resources.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png\">\n  <br/>\n</p>\n\n* [System design topics: start here](#system-design-topics-start-here)\n    * [Step 1: Review the scalability video lecture](#step-1-review-the-scalability-video-lecture)\n    * [Step 2: Review the scalability article](#step-2-review-the-scalability-article)\n    * [Next steps](#next-steps)\n* [Performance vs scalability](#performance-vs-scalability)\n* [Latency vs throughput](#latency-vs-throughput)\n* [Availability vs consistency](#availability-vs-consistency)\n    * [CAP theorem](#cap-theorem)\n        * [CP - consistency and partition tolerance](#cp---consistency-and-partition-tolerance)\n        * [AP - availability and partition tolerance](#ap---availability-and-partition-tolerance)\n* [Consistency patterns](#consistency-patterns)\n    * [Weak consistency](#weak-consistency)\n    * [Eventual consistency](#eventual-consistency)\n    * [Strong consistency](#strong-consistency)\n* [Availability patterns](#availability-patterns)\n    * [Fail-over](#fail-over)\n    * [Replication](#replication)\n    * [Availability in numbers](#availability-in-numbers)\n* [Domain name system](#domain-name-system)\n* [Content delivery network](#content-delivery-network)\n    * [Push CDNs](#push-cdns)\n    * [Pull CDNs](#pull-cdns)",
    "ContentSha": "55nlChjOgBlS9Rz8E9JfxCDdOyXcovuwIdqXYGb4sqo=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 添加新章节\n* [翻译](https://github.com/donnemartin/system-design-primer/issues/28)\n\n需要润色的内容放置在[开发中](#under-development)。\n\n请查看[贡献指南](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md)。\n\n## 系统设计主题索引\n\n> 各种系统设计主题的总结，包括优缺点。**一切都是权衡**。\n>\n> 每个章节包含指向更深入资源的链接。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png\">\n  <br/>\n</p>\n\n* [系统设计主题：从这里开始](#system-design-topics-start-here)\n    * [步骤 1：观看可扩展性视频讲座](#step-1-review-the-scalability-video-lecture)\n    * [步骤 2：阅读可扩展性文章](#step-2-review-the-scalability-article)\n    * [下一步](#next-steps)\n* [性能与可扩展性](#performance-vs-scalability)\n* [延迟与吞吐量](#latency-vs-throughput)\n* [可用性与一致性](#availability-vs-consistency)\n    * [CAP 定理](#cap-theorem)\n        * [CP - 一致性和分区容错](#cp---consistency-and-partition-tolerance)\n        * [AP - 可用性和分区容错](#ap---availability-and-partition-tolerance)\n* [一致性模式](#consistency-patterns)\n    * [弱一致性](#weak-consistency)\n    * [最终一致性](#eventual-consistency)\n    * [强一致性](#strong-consistency)\n* [可用性模式](#availability-patterns)\n    * [故障切换](#fail-over)\n    * [复制](#replication)\n    * [用数字看可用性](#availability-in-numbers)\n* [域名系统](#domain-name-system)\n* [内容分发网络](#content-delivery-network)\n    * [推送型 CDN](#push-cdns)\n    * [拉取型 CDN](#pull-cdns)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 5,
    "Content": "* [Load balancer](#load-balancer)\n    * [Active-passive](#active-passive)\n    * [Active-active](#active-active)\n    * [Layer 4 load balancing](#layer-4-load-balancing)\n    * [Layer 7 load balancing](#layer-7-load-balancing)\n    * [Horizontal scaling](#horizontal-scaling)\n* [Reverse proxy (web server)](#reverse-proxy-web-server)\n    * [Load balancer vs reverse proxy](#load-balancer-vs-reverse-proxy)\n* [Application layer](#application-layer)\n    * [Microservices](#microservices)\n    * [Service discovery](#service-discovery)\n* [Database](#database)\n    * [Relational database management system (RDBMS)](#relational-database-management-system-rdbms)\n        * [Master-slave replication](#master-slave-replication)\n        * [Master-master replication](#master-master-replication)\n        * [Federation](#federation)\n        * [Sharding](#sharding)\n        * [Denormalization](#denormalization)\n        * [SQL tuning](#sql-tuning)\n    * [NoSQL](#nosql)\n        * [Key-value store](#key-value-store)\n        * [Document store](#document-store)\n        * [Wide column store](#wide-column-store)\n        * [Graph Database](#graph-database)\n    * [SQL or NoSQL](#sql-or-nosql)\n* [Cache](#cache)\n    * [Client caching](#client-caching)\n    * [CDN caching](#cdn-caching)\n    * [Web server caching](#web-server-caching)\n    * [Database caching](#database-caching)\n    * [Application caching](#application-caching)\n    * [Caching at the database query level](#caching-at-the-database-query-level)\n    * [Caching at the object level](#caching-at-the-object-level)\n    * [When to update the cache](#when-to-update-the-cache)\n        * [Cache-aside](#cache-aside)\n        * [Write-through](#write-through)\n        * [Write-behind (write-back)](#write-behind-write-back)\n        * [Refresh-ahead](#refresh-ahead)\n* [Asynchronism](#asynchronism)\n    * [Message queues](#message-queues)",
    "ContentSha": "asKFjZ3AfCGQPD58skhfkEeJZEI9zP/H+h/3PnvCFDY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [负载均衡器](#load-balancer)\n    * [主动-被动](#active-passive)\n    * [主动-主动](#active-active)\n    * [第4层负载均衡](#layer-4-load-balancing)\n    * [第7层负载均衡](#layer-7-load-balancing)\n    * [水平扩展](#horizontal-scaling)\n* [反向代理（网页服务器）](#reverse-proxy-web-server)\n    * [负载均衡器 vs 反向代理](#load-balancer-vs-reverse-proxy)\n* [应用层](#application-layer)\n    * [微服务](#microservices)\n    * [服务发现](#service-discovery)\n* [数据库](#database)\n    * [关系型数据库管理系统 (RDBMS)](#relational-database-management-system-rdbms)\n        * [主从复制](#master-slave-replication)\n        * [主主复制](#master-master-replication)\n        * [联合](#federation)\n        * [分片](#sharding)\n        * [反规范化](#denormalization)\n        * [SQL 调优](#sql-tuning)\n    * [NoSQL](#nosql)\n        * [键值存储](#key-value-store)\n        * [文档存储](#document-store)\n        * [宽列存储](#wide-column-store)\n        * [图数据库](#graph-database)\n    * [SQL 或 NoSQL](#sql-or-nosql)\n* [缓存](#cache)\n    * [客户端缓存](#client-caching)\n    * [CDN 缓存](#cdn-caching)\n    * [网页服务器缓存](#web-server-caching)\n    * [数据库缓存](#database-caching)\n    * [应用缓存](#application-caching)\n    * [数据库查询级缓存](#caching-at-the-database-query-level)\n    * [对象级缓存](#caching-at-the-object-level)\n    * [何时更新缓存](#when-to-update-the-cache)\n        * [旁路缓存](#cache-aside)\n        * [写透](#write-through)\n        * [写后（写回）](#write-behind-write-back)\n        * [预刷新](#refresh-ahead)\n* [异步](#asynchronism)\n    * [消息队列](#message-queues)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 6,
    "Content": "    * [Task queues](#task-queues)\n    * [Back pressure](#back-pressure)\n* [Communication](#communication)\n    * [Transmission control protocol (TCP)](#transmission-control-protocol-tcp)\n    * [User datagram protocol (UDP)](#user-datagram-protocol-udp)\n    * [Remote procedure call (RPC)](#remote-procedure-call-rpc)\n    * [Representational state transfer (REST)](#representational-state-transfer-rest)\n* [Security](#security)\n* [Appendix](#appendix)\n    * [Powers of two table](#powers-of-two-table)\n    * [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)\n    * [Additional system design interview questions](#additional-system-design-interview-questions)\n    * [Real world architectures](#real-world-architectures)\n    * [Company architectures](#company-architectures)\n    * [Company engineering blogs](#company-engineering-blogs)\n* [Under development](#under-development)\n* [Credits](#credits)\n* [Contact info](#contact-info)\n* [License](#license)\n\n## Study guide\n\n> Suggested topics to review based on your interview timeline (short, medium, long).\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)\n\n**Q: For interviews, do I need to know everything here?**\n\n**A: No, you don't need to know everything here to prepare for the interview**.\n\nWhat you are asked in an interview depends on variables such as:\n\n* How much experience you have\n* What your technical background is\n* What positions you are interviewing for\n* Which companies you are interviewing with\n* Luck\n\nMore experienced candidates are generally expected to know more about system design.  Architects or team leads might be expected to know more than individual contributors.  Top tech companies are likely to have one or more design interview rounds.\n",
    "ContentSha": "ATTNyUBhYGX23A6dK9YO6hNcpGiZGZByeStHZczOceg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "    * [任务队列](#task-queues)\n    * [反压](#back-pressure)\n* [通信](#communication)\n    * [传输控制协议 (TCP)](#transmission-control-protocol-tcp)\n    * [用户数据报协议 (UDP)](#user-datagram-protocol-udp)\n    * [远程过程调用 (RPC)](#remote-procedure-call-rpc)\n    * [表现层状态转移 (REST)](#representational-state-transfer-rest)\n* [安全](#security)\n* [附录](#appendix)\n    * [二的幂表](#powers-of-two-table)\n    * [每个程序员应知的延迟数字](#latency-numbers-every-programmer-should-know)\n    * [额外的系统设计面试问题](#additional-system-design-interview-questions)\n    * [真实世界架构](#real-world-architectures)\n    * [公司架构](#company-architectures)\n    * [公司工程博客](#company-engineering-blogs)\n* [开发中](#under-development)\n* [鸣谢](#credits)\n* [联系方式](#contact-info)\n* [许可](#license)\n\n## 学习指南\n\n> 根据你的面试时间线建议复习的主题（短期、中期、长期）。\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)\n\n**问：面试时，我需要知道这里的所有内容吗？**\n\n**答：不，你不需要知道这里的所有内容来准备面试**。\n\n面试时被问到的内容取决于以下变量：\n\n* 你的经验有多少\n* 你的技术背景是什么\n* 你面试的职位是什么\n* 你面试的是哪些公司\n* 运气\n\n经验更丰富的候选人通常被期望对系统设计了解更多。架构师或团队负责人可能被期望比普通贡献者知道更多。顶级科技公司很可能有一轮或多轮设计面试。\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 7,
    "Content": "Start broad and go deeper in a few areas.  It helps to know a little about various key system design topics.  Adjust the following guide based on your timeline, experience, what positions you are interviewing for, and which companies you are interviewing with.\n\n* **Short timeline** - Aim for **breadth** with system design topics.  Practice by solving **some** interview questions.\n* **Medium timeline** - Aim for **breadth** and **some depth** with system design topics.  Practice by solving **many** interview questions.\n* **Long timeline** - Aim for **breadth** and **more depth** with system design topics.  Practice by solving **most** interview questions.\n\n| | Short | Medium | Long |\n|---|---|---|---|\n| Read through the [System design topics](#index-of-system-design-topics) to get a broad understanding of how systems work | :+1: | :+1: | :+1: |\n| Read through a few articles in the [Company engineering blogs](#company-engineering-blogs) for the companies you are interviewing with | :+1: | :+1: | :+1: |\n| Read through a few [Real world architectures](#real-world-architectures) | :+1: | :+1: | :+1: |\n| Review [How to approach a system design interview question](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |\n| Work through [System design interview questions with solutions](#system-design-interview-questions-with-solutions) | Some | Many | Most |\n| Work through [Object-oriented design interview questions with solutions](#object-oriented-design-interview-questions-with-solutions) | Some | Many | Most |\n| Review [Additional system design interview questions](#additional-system-design-interview-questions) | Some | Many | Most |\n\n## How to approach a system design interview question\n\n> How to tackle a system design interview question.\n\nThe system design interview is an **open-ended conversation**.  You are expected to lead it.\n\nYou can use the following steps to guide the discussion.  To help solidify this process, work through the [System design interview questions with solutions](#system-design-interview-questions-with-solutions) section using the following steps.\n\n### Step 1: Outline use cases, constraints, and assumptions\n\nGather requirements and scope the problem.  Ask questions to clarify use cases and constraints.  Discuss assumptions.\n\n* Who is going to use it?\n* How are they going to use it?\n* How many users are there?\n* What does the system do?\n* What are the inputs and outputs of the system?\n* How much data do we expect to handle?\n* How many requests per second do we expect?\n* What is the expected read to write ratio?\n\n### Step 2: Create a high level design\n\nOutline a high level design with all important components.",
    "ContentSha": "0rdWLVZbH/nPM3xkHGejRJHpsR4f8urb5LkuDcPAbZM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "从广泛开始，在少数几个领域深入。了解一些关键系统设计主题会很有帮助。根据你的时间安排、经验、面试职位和面试公司调整以下指南。\n\n* **时间紧张** - 目标是系统设计主题的**广度**。通过解决**一些**面试题进行练习。\n* **时间适中** - 目标是系统设计主题的**广度**和**一定深度**。通过解决**许多**面试题进行练习。\n* **时间充裕** - 目标是系统设计主题的**广度**和**更深的深度**。通过解决**大部分**面试题进行练习。\n\n| | 短期 | 中期 | 长期 |\n|---|---|---|---|\n| 通读[系统设计主题](#index-of-system-design-topics)，对系统如何工作有一个广泛的了解 | :+1: | :+1: | :+1: |\n| 阅读你面试公司的[公司工程博客](#company-engineering-blogs)中的几篇文章 | :+1: | :+1: | :+1: |\n| 阅读几篇[真实世界架构](#real-world-architectures) | :+1: | :+1: | :+1: |\n| 复习[如何处理系统设计面试题](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |\n| 练习[带有解答的系统设计面试题](#system-design-interview-questions-with-solutions) | 一些 | 许多 | 大部分 |\n| 练习[带有解答的面向对象设计面试题](#object-oriented-design-interview-questions-with-solutions) | 一些 | 许多 | 大部分 |\n| 复习[额外的系统设计面试题](#additional-system-design-interview-questions) | 一些 | 许多 | 大部分 |\n\n## 如何处理系统设计面试题\n\n> 如何解决系统设计面试题。\n\n系统设计面试是一个**开放式对话**。你需要主导它。\n\n你可以使用以下步骤来引导讨论。为了帮助巩固这个过程，使用以下步骤完成[带有解答的系统设计面试题](#system-design-interview-questions-with-solutions)部分。\n\n### 第一步：概述用例、约束和假设\n\n收集需求并确定问题范围。提问以澄清用例和约束。讨论假设。\n\n* 谁将使用它？\n* 他们将如何使用它？\n* 有多少用户？\n* 系统做什么？\n* 系统的输入和输出是什么？\n* 我们预计处理多少数据？\n* 我们预计每秒多少请求？\n* 预期的读写比例是多少？\n\n### 第二步：创建高级设计\n\n概述一个包含所有重要组件的高级设计。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 8,
    "Content": "\n* Sketch the main components and connections\n* Justify your ideas\n\n### Step 3: Design core components\n\nDive into details for each core component.  For example, if you were asked to [design a url shortening service](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), discuss:\n\n* Generating and storing a hash of the full url\n    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) and [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n    * Hash collisions\n    * SQL or NoSQL\n    * Database schema\n* Translating a hashed url to the full url\n    * Database lookup\n* API and object-oriented design\n\n### Step 4: Scale the design\n\nIdentify and address bottlenecks, given the constraints.  For example, do you need the following to address scalability issues?\n\n* Load balancer\n* Horizontal scaling\n* Caching\n* Database sharding\n\nDiscuss potential solutions and trade-offs.  Everything is a trade-off.  Address bottlenecks using [principles of scalable system design](#index-of-system-design-topics).\n\n### Back-of-the-envelope calculations\n\nYou might be asked to do some estimates by hand.  Refer to the [Appendix](#appendix) for the following resources:\n\n* [Use back of the envelope calculations](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)\n* [Powers of two table](#powers-of-two-table)\n* [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)\n\n### Source(s) and further reading\n\nCheck out the following links to get a better idea of what to expect:\n",
    "ContentSha": "3x8iTXwR6ek+uAlSMupV1OgJsT8IwtVYxDBvXMFsB/g=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 绘制主要组件和连接\n* 说明你的设计思路\n\n### 第3步：设计核心组件\n\n深入讨论每个核心组件的细节。例如，如果你被要求[设计一个URL缩短服务](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)，可以讨论：\n\n* 生成并存储完整URL的哈希值\n    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) 和 [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n    * 哈希冲突\n    * 使用SQL还是NoSQL\n    * 数据库模式设计\n* 将哈希URL转换为完整URL\n    * 数据库查询\n* API设计和面向对象设计\n\n### 第4步：扩展设计\n\n识别并解决瓶颈问题，考虑约束条件。例如，你是否需要以下方案来解决可扩展性问题？\n\n* 负载均衡器\n* 横向扩展\n* 缓存\n* 数据库分片\n\n讨论潜在的解决方案和权衡。所有设计都有权衡。使用[可扩展系统设计原则](#index-of-system-design-topics)来解决瓶颈问题。\n\n### 估算计算\n\n你可能需要手动做一些估算。请参考[附录](#appendix)中的以下资源：\n\n* [使用估算计算](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)\n* [2的幂表](#powers-of-two-table)\n* [每个程序员都该知道的延迟数字](#latency-numbers-every-programmer-should-know)\n\n### 来源和进一步阅读\n\n查看以下链接以更好地了解预期内容：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 9,
    "Content": "* [How to ace a systems design interview](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)\n* [The system design interview](http://www.hiredintech.com/system-design)\n* [Intro to Architecture and Systems Design Interviews](https://www.youtube.com/watch?v=ZgdS0EUmn70)\n* [System design template](https://leetcode.com/discuss/career/229177/My-System-Design-Template)\n\n## System design interview questions with solutions\n\n> Common system design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n| Question | |\n|---|---|\n| Design Pastebin.com (or Bit.ly) | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |\n| Design the Twitter timeline and search (or Facebook feed and search) | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |\n| Design a web crawler | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |\n| Design Mint.com | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |\n| Design the data structures for a social network | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |\n| Design a key-value store for a search engine | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |\n| Design Amazon's sales ranking by category feature | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |\n| Design a system that scales to millions of users on AWS | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |\n| Add a system design question | [Contribute](#contributing) |\n\n### Design Pastebin.com (or Bit.ly)\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)\n\n### Design the Twitter timeline and search (or Facebook feed and search)\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)\n\n### Design a web crawler\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)",
    "ContentSha": "AHgKOfvgyoP47Euk86jhd2olVjkmP2nZB6tXbpOIqic=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [如何通过系统设计面试](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)\n* [系统设计面试](http://www.hiredintech.com/system-design)\n* [架构与系统设计面试简介](https://www.youtube.com/watch?v=ZgdS0EUmn70)\n* [系统设计模板](https://leetcode.com/discuss/career/229177/My-System-Design-Template)\n\n## 系统设计面试题及解决方案\n\n> 常见系统设计面试题，附示例讨论、代码及图表。\n>\n> 解决方案链接指向 `solutions/` 文件夹中的内容。\n\n| 问题 | |\n|---|---|\n| 设计 Pastebin.com（或 Bit.ly） | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |\n| 设计 Twitter 时间线和搜索（或 Facebook 动态和搜索） | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |\n| 设计一个网络爬虫 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |\n| 设计 Mint.com | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |\n| 设计社交网络的数据结构 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |\n| 设计搜索引擎的键值存储 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |\n| 设计亚马逊按类别的销售排名功能 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |\n| 设计一个可扩展至数百万用户的 AWS 系统 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |\n| 添加系统设计题目 | [贡献](#contributing) |\n\n### 设计 Pastebin.com（或 Bit.ly）\n\n[查看练习及解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)\n\n### 设计 Twitter 时间线和搜索（或 Facebook 动态和搜索）\n\n[查看练习及解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)\n\n### 设计一个网络爬虫\n\n[查看练习及解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 10,
    "Content": "\n### Design Mint.com\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)\n\n### Design the data structures for a social network\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)\n\n### Design a key-value store for a search engine\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)\n\n### Design Amazon's sales ranking by category feature\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)\n\n### Design a system that scales to millions of users on AWS\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)\n\n## Object-oriented design interview questions with solutions\n\n> Common object-oriented design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n>**Note: This section is under development**\n\n| Question | |",
    "ContentSha": "o3sbdfQZN6cWPJee4lAmThiTo/ED2IUg9UbWh2T8Jr8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### Design Mint.com\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)\n\n### Design the data structures for a social network\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)\n\n### Design a key-value store for a search engine\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)\n\n### Design Amazon's sales ranking by category feature\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)\n\n### Design a system that scales to millions of users on AWS\n\n[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)\n\n![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)\n\n## Object-oriented design interview questions with solutions\n\n> Common object-oriented design interview questions with sample discussions, code, and diagrams.\n>\n> Solutions linked to content in the `solutions/` folder.\n\n>**Note: This section is under development**\n\n| Question | |",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 11,
    "Content": "|---|---|\n| Design a hash map | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |\n| Design a least recently used cache | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |\n| Design a call center | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |\n| Design a deck of cards | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |\n| Design a parking lot | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |\n| Design a chat server | [Solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |\n| Design a circular array | [Contribute](#contributing)  |\n| Add an object-oriented design question | [Contribute](#contributing) |\n\n## System design topics: start here\n\nNew to system design?\n\nFirst, you'll need a basic understanding of common principles, learning about what they are, how they are used, and their pros and cons.\n\n### Step 1: Review the scalability video lecture\n\n[Scalability Lecture at Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)\n\n* Topics covered:\n    * Vertical scaling\n    * Horizontal scaling\n    * Caching\n    * Load balancing\n    * Database replication\n    * Database partitioning\n\n### Step 2: Review the scalability article\n\n[Scalability](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)\n\n* Topics covered:\n    * [Clones](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n    * [Databases](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n    * [Caches](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n    * [Asynchronism](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)\n\n### Next steps\n",
    "ContentSha": "x8nrhrohPoZjm2NWw4mmB3mvJSUCp+CF0oOOqij1Y4E=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "|---|---|\n| 设计哈希映射 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |\n| 设计最近最少使用缓存 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |\n| 设计呼叫中心 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |\n| 设计一副牌 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |\n| 设计停车场 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |\n| 设计聊天服务器 | [解决方案](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |\n| 设计循环数组 | [贡献](#contributing)  |\n| 添加面向对象设计问题 | [贡献](#contributing) |\n\n## 系统设计主题：从这里开始\n\n系统设计新手？\n\n首先，你需要对常见原则有基本了解，学习它们是什么、如何使用以及它们的优缺点。\n\n### 第一步：观看可扩展性视频讲座\n\n[哈佛可扩展性讲座](https://www.youtube.com/watch?v=-W9F__D3oY4)\n\n* 涉及主题：\n    * 纵向扩展\n    * 横向扩展\n    * 缓存\n    * 负载均衡\n    * 数据库复制\n    * 数据库分区\n\n### 第二步：阅读可扩展性文章\n\n[可扩展性](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)\n\n* 涉及主题：\n    * [克隆](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n    * [数据库](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n    * [缓存](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n    * [异步](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)\n\n### 接下来的步骤\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 12,
    "Content": "Next, we'll look at high-level trade-offs:\n\n* **Performance** vs **scalability**\n* **Latency** vs **throughput**\n* **Availability** vs **consistency**\n\nKeep in mind that **everything is a trade-off**.\n\nThen we'll dive into more specific topics such as DNS, CDNs, and load balancers.\n\n## Performance vs scalability\n\nA service is **scalable** if it results in increased **performance** in a manner proportional to resources added. Generally, increasing performance means serving more units of work, but it can also be to handle larger units of work, such as when datasets grow.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>\n\nAnother way to look at performance vs scalability:\n\n* If you have a **performance** problem, your system is slow for a single user.\n* If you have a **scalability** problem, your system is fast for a single user but slow under heavy load.\n\n### Source(s) and further reading\n\n* [A word on scalability](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n\n## Latency vs throughput\n\n**Latency** is the time to perform some action or to produce some result.\n\n**Throughput** is the number of such actions or results per unit of time.\n\nGenerally, you should aim for **maximal throughput** with **acceptable latency**.\n\n### Source(s) and further reading\n\n* [Understanding latency vs throughput](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)\n\n## Availability vs consistency\n\n### CAP theorem\n",
    "ContentSha": "3J96fMtAPtZfNniAS7/6wzXl1ty5ntM4Q00EOxpO0Ww=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "接下来，我们将关注高级权衡：\n\n* **性能** 与 **可扩展性**\n* **延迟** 与 **吞吐量**\n* **可用性** 与 **一致性**\n\n请记住，**一切都是权衡**。\n\n然后我们将深入探讨更具体的主题，如 DNS、CDN 和负载均衡器。\n\n## 性能与可扩展性\n\n如果服务能够随着资源的增加而按比例提升**性能**，则该服务是**可扩展的**。通常，提高性能意味着处理更多的工作单位，但也可以是处理更大的工作单位，例如数据集增长时。<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>\n\n从另一个角度看性能与可扩展性：\n\n* 如果你有**性能**问题，说明系统对单个用户来说很慢。\n* 如果你有**可扩展性**问题，说明系统对单个用户很快，但在负载重时很慢。\n\n### 资料来源及进一步阅读\n\n* [关于可扩展性的一句话](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)\n* [可扩展性、可用性、稳定性、模式](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n\n## 延迟与吞吐量\n\n**延迟** 是执行某个动作或产生某个结果所需的时间。\n\n**吞吐量** 是单位时间内完成的此类动作或产生的结果数量。\n\n通常，你应当以**最大吞吐量**和**可接受的延迟**为目标。\n\n### 资料来源及进一步阅读\n\n* [理解延迟与吞吐量](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)\n\n## 可用性与一致性\n\n### CAP 定理\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 13,
    "Content": "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png\">\n  <br/>\n  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Source: CAP theorem revisited</a></i>\n</p>\n\nIn a distributed computer system, you can only support two of the following guarantees:\n\n* **Consistency** - Every read receives the most recent write or an error\n* **Availability** - Every request receives a response, without guarantee that it contains the most recent version of the information\n* **Partition Tolerance** - The system continues to operate despite arbitrary partitioning due to network failures\n\n*Networks aren't reliable, so you'll need to support partition tolerance.  You'll need to make a software tradeoff between consistency and availability.*\n\n#### CP - consistency and partition tolerance\n\nWaiting for a response from the partitioned node might result in a timeout error.  CP is a good choice if your business needs require atomic reads and writes.\n\n#### AP - availability and partition tolerance\n\nResponses return the most readily available version of the data available on any node, which might not be the latest.  Writes might take some time to propagate when the partition is resolved.\n\nAP is a good choice if the business needs to allow for [eventual consistency](#eventual-consistency) or when the system needs to continue working despite external errors.\n\n### Source(s) and further reading\n\n* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)\n* [A plain english introduction to CAP theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem)\n* [CAP FAQ](https://github.com/henryr/cap-faq)\n* [The CAP theorem](https://www.youtube.com/watch?v=k-Yaq8AHlFA)\n\n## Consistency patterns\n\nWith multiple copies of the same data, we are faced with options on how to synchronize them so clients have a consistent view of the data.  Recall the definition of consistency from the [CAP theorem](#cap-theorem) - Every read receives the most recent write or an error.\n\n### Weak consistency\n\nAfter a write, reads may or may not see it.  A best effort approach is taken.\n\nThis approach is seen in systems such as memcached.  Weak consistency works well in real time use cases such as VoIP, video chat, and realtime multiplayer games.  For example, if you are on a phone call and lose reception for a few seconds, when you regain connection you do not hear what was spoken during connection loss.",
    "ContentSha": "nlNKM8AB14RiMLs0dLLz8tVwgOHTXV/u3ObIx3G8az4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png\">\n  <br/>\n  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>来源：CAP 定理再访</a></i>\n</p>\n\n在分布式计算系统中，你只能支持以下三项保证中的两项：\n\n* **一致性** - 每次读取都能获得最近的写入内容，或返回错误\n* **可用性** - 每个请求都会收到响应，但不保证包含最新版本的信息\n* **分区容错性** - 系统即使在因网络故障导致的任意分区情况下仍能继续运行\n\n*网络不可靠，因此你需要支持分区容错。你需要在一致性和可用性之间做出软件上的权衡。*\n\n#### CP - 一致性和分区容错性\n\n等待分区节点的响应可能导致超时错误。如果业务需求要求原子读写，CP 是一个不错的选择。\n\n#### AP - 可用性和分区容错性\n\n响应返回任何节点上最容易获得的数据版本，可能不是最新的。当分区恢复时，写操作可能需要一定时间传播。\n\n当业务需要允许[最终一致性](#eventual-consistency)或系统需要在外部错误发生时继续工作时，AP 是一个不错的选择。\n\n### 来源及进一步阅读\n\n* [CAP 定理再访](http://robertgreiner.com/2014/08/cap-theorem-revisited/)\n* [CAP 定理通俗介绍](http://ksat.me/a-plain-english-introduction-to-cap-theorem)\n* [CAP 常见问题解答](https://github.com/henryr/cap-faq)\n* [CAP 定理讲解视频](https://www.youtube.com/watch?v=k-Yaq8AHlFA)\n\n## 一致性模式\n\n当存在多个相同数据副本时，我们面临如何同步它们以保证客户端数据一致性的选择。回想[CAP 定理](#cap-theorem)中一致性的定义——每次读取都能获得最近的写入内容，或返回错误。\n\n### 弱一致性\n\n写入后，读取可能能看到也可能看不到写入内容。采取的是尽力而为的方式。\n\n这种方式见于如 memcached 这类系统。弱一致性在实时应用场景中表现良好，如 VoIP、视频聊天和实时多人游戏。例如，如果你在通话中短暂失去信号，恢复连接后不会听到信号丢失期间的内容。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 14,
    "Content": "\n### Eventual consistency\n\nAfter a write, reads will eventually see it (typically within milliseconds).  Data is replicated asynchronously.\n\nThis approach is seen in systems such as DNS and email.  Eventual consistency works well in highly available systems.\n\n### Strong consistency\n\nAfter a write, reads will see it.  Data is replicated synchronously.\n\nThis approach is seen in file systems and RDBMSes.  Strong consistency works well in systems that need transactions.\n\n### Source(s) and further reading\n\n* [Transactions across data centers](http://snarfed.org/transactions_across_datacenters_io.html)\n\n## Availability patterns\n\nThere are two complementary patterns to support high availability: **fail-over** and **replication**.\n\n### Fail-over\n\n#### Active-passive\n\nWith active-passive fail-over, heartbeats are sent between the active and the passive server on standby.  If the heartbeat is interrupted, the passive server takes over the active's IP address and resumes service.\n\nThe length of downtime is determined by whether the passive server is already running in 'hot' standby or whether it needs to start up from 'cold' standby.  Only the active server handles traffic.\n\nActive-passive failover can also be referred to as master-slave failover.\n\n#### Active-active\n\nIn active-active, both servers are managing traffic, spreading the load between them.\n\nIf the servers are public-facing, the DNS would need to know about the public IPs of both servers.  If the servers are internal-facing, application logic would need to know about both servers.\n\nActive-active failover can also be referred to as master-master failover.\n\n### Disadvantage(s): failover",
    "ContentSha": "Gej6bybZnoGj5vLH+IOLm2NuKTHBE7Z2TA3eWaBaiak=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### 最终一致性\n\n写入后，读取最终会看到该写入（通常在毫秒级内）。数据是异步复制的。\n\n这种方法见于 DNS 和电子邮件等系统。最终一致性在高可用系统中效果良好。\n\n### 强一致性\n\n写入后，读取会立即看到该写入。数据是同步复制的。\n\n这种方法见于文件系统和关系型数据库系统。强一致性适用于需要事务的系统。\n\n### 来源及进一步阅读\n\n* [跨数据中心的事务](http://snarfed.org/transactions_across_datacenters_io.html)\n\n## 可用性模式\n\n支持高可用性的两种互补模式：**故障切换** 和 **复制**。\n\n### 故障切换\n\n#### 主备模式\n\n在主备故障切换中，主服务器与待命的备份服务器之间会发送心跳信号。若心跳中断，备份服务器接管主服务器的 IP 地址并恢复服务。\n\n停机时间长短取决于备份服务器是处于“热”待命状态还是需要从“冷”待命启动。仅主服务器处理流量。\n\n主备故障切换也可称为主从故障切换。\n\n#### 主主模式\n\n在主主模式中，两个服务器都在管理流量，分摊负载。\n\n如果服务器面向公网，DNS 需要知道两个服务器的公网 IP 地址；如果服务器面向内部，应用逻辑需要知道两个服务器。\n\n主主故障切换也可称为主主复制故障切换。\n\n### 缺点：故障切换",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 15,
    "Content": "\n* Fail-over adds more hardware and additional complexity.\n* There is a potential for loss of data if the active system fails before any newly written data can be replicated to the passive.\n\n### Replication\n\n#### Master-slave and master-master\n\nThis topic is further discussed in the [Database](#database) section:\n\n* [Master-slave replication](#master-slave-replication)\n* [Master-master replication](#master-master-replication)\n\n### Availability in numbers\n\nAvailability is often quantified by uptime (or downtime) as a percentage of time the service is available.  Availability is generally measured in number of 9s--a service with 99.99% availability is described as having four 9s.\n\n#### 99.9% availability - three 9s\n\n| Duration            | Acceptable downtime|\n|---------------------|--------------------|\n| Downtime per year   | 8h 45min 57s       |\n| Downtime per month  | 43m 49.7s          |\n| Downtime per week   | 10m 4.8s           |\n| Downtime per day    | 1m 26.4s           |\n\n#### 99.99% availability - four 9s\n\n| Duration            | Acceptable downtime|\n|---------------------|--------------------|\n| Downtime per year   | 52min 35.7s        |\n| Downtime per month  | 4m 23s             |\n| Downtime per week   | 1m 5s              |\n| Downtime per day    | 8.6s               |\n\n#### Availability in parallel vs in sequence\n\nIf a service consists of multiple components prone to failure, the service's overall availability depends on whether the components are in sequence or in parallel.\n\n###### In sequence",
    "ContentSha": "7iHIUIb6fJkzxQcIKEVyv2l5jzfrJATtAgzkxfBD6fg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 故障切换增加了更多硬件和额外的复杂性。\n* 如果活动系统在任何新写入数据复制到被动系统之前失败，可能会导致数据丢失。\n\n### 复制\n\n#### 主从和主主\n\n此主题在[数据库](#database)部分中有更详细的讨论：\n\n* [主从复制](#master-slave-replication)\n* [主主复制](#master-master-replication)\n\n### 可用性数字化\n\n可用性通常通过正常运行时间（或停机时间）作为服务可用时间的百分比来量化。可用性通常用“9”的个数来衡量——具有99.99%可用性的服务被描述为有四个9。\n\n#### 99.9% 可用性 - 三个9\n\n| 时长               | 可接受的停机时间     |\n|--------------------|--------------------|\n| 每年停机时间       | 8小时45分57秒       |\n| 每月停机时间       | 43分49.7秒          |\n| 每周停机时间       | 10分4.8秒           |\n| 每日停机时间       | 1分26.4秒           |\n\n#### 99.99% 可用性 - 四个9\n\n| 时长               | 可接受的停机时间     |\n|--------------------|--------------------|\n| 每年停机时间       | 52分35.7秒          |\n| 每月停机时间       | 4分23秒             |\n| 每周停机时间       | 1分5秒              |\n| 每日停机时间       | 8.6秒               |\n\n#### 并行与串行的可用性\n\n如果服务由多个易失败的组件组成，服务的整体可用性取决于这些组件是串行还是并行。\n\n###### 串行\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 16,
    "Content": "\nOverall availability decreases when two components with availability < 100% are in sequence:\n",
    "ContentSha": "MoWr3NjGedfagwyU1j0TqrIfLCsOUBLZEeMCD+o/O+Q=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n当两个可用性低于100%的组件依次连接时，总体可用性会降低：\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 17,
    "Content": "```\nAvailability (Total) = Availability (Foo) * Availability (Bar)\n```",
    "ContentSha": "lB9bEqLhXuNZd7e3CBBSvV+eKTVRfJQnqnxct5vKoDI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nAvailability (Total) = Availability (Foo) * Availability (Bar)\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 18,
    "Content": "\nIf both `Foo` and `Bar` each had 99.9% availability, their total availability in sequence would be 99.8%.\n\n###### In parallel\n\nOverall availability increases when two components with availability < 100% are in parallel:\n",
    "ContentSha": "8idS6k4SI9XJ+uNRuiFmAXUVaamdekOMo2MnsD7SUdw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "如果 `Foo` 和 `Bar` 各自的可用性都是 99.9%，它们顺序组合的总可用性将是 99.8%。\n\n###### 并行\n\n当两个可用性低于 100% 的组件并行时，总体可用性会提高：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 19,
    "Content": "```\nAvailability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))\n```",
    "ContentSha": "MYI40NgkLqO1BQo3TOiX+3Zu0VfgykdTCZcU4oJjKTs=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nAvailability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 20,
    "Content": "\nIf both `Foo` and `Bar` each had 99.9% availability, their total availability in parallel would be 99.9999%.\n\n## Domain name system\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg\">\n  <br/>\n  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Source: DNS security presentation</a></i>\n</p>\n\nA Domain Name System (DNS) translates a domain name such as www.example.com to an IP address.\n\nDNS is hierarchical, with a few authoritative servers at the top level.  Your router or ISP provides information about which DNS server(s) to contact when doing a lookup.  Lower level DNS servers cache mappings, which could become stale due to DNS propagation delays.  DNS results can also be cached by your browser or OS for a certain period of time, determined by the [time to live (TTL)](https://en.wikipedia.org/wiki/Time_to_live).\n\n* **NS record (name server)** - Specifies the DNS servers for your domain/subdomain.\n* **MX record (mail exchange)** - Specifies the mail servers for accepting messages.\n* **A record (address)** - Points a name to an IP address.\n* **CNAME (canonical)** - Points a name to another name or `CNAME` (example.com to www.example.com) or to an `A` record.\n\nServices such as [CloudFlare](https://www.cloudflare.com/dns/) and [Route 53](https://aws.amazon.com/route53/) provide managed DNS services.  Some DNS services can route traffic through various methods:\n\n* [Weighted round robin](https://www.jscape.com/blog/load-balancing-algorithms)\n    * Prevent traffic from going to servers under maintenance\n    * Balance between varying cluster sizes\n    * A/B testing\n* [Latency-based](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)\n* [Geolocation-based](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)\n\n### Disadvantage(s): DNS\n\n* Accessing a DNS server introduces a slight delay, although mitigated by caching described above.\n* DNS server management could be complex and is generally managed by [governments, ISPs, and large companies](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).\n* DNS services have recently come under [DDoS attack](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), preventing users from accessing websites such as Twitter without knowing Twitter's IP address(es).\n\n### Source(s) and further reading\n\n* [DNS architecture](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)\n* [Wikipedia](https://en.wikipedia.org/wiki/Domain_Name_System)\n* [DNS articles](https://support.dnsimple.com/categories/dns/)",
    "ContentSha": "YhlbRAwaKJI7wcegCHvNOzGIOxkIHtEHSr0a7L+iJEc=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "如果 `Foo` 和 `Bar` 都有 99.9% 的可用性，那么它们并联的总可用性将是 99.9999%。\n\n## 域名系统\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg\">\n  <br/>\n  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>来源：DNS 安全演示文稿</a></i>\n</p>\n\n域名系统（DNS）将诸如 www.example.com 这样的域名转换为 IP 地址。\n\nDNS 是分层的，顶层有少数权威服务器。您的路由器或 ISP 提供关于查找时应联系哪个 DNS 服务器的信息。低级 DNS 服务器会缓存映射，由于 DNS 传播延迟，缓存可能变得过时。DNS 结果也可以由您的浏览器或操作系统缓存一段时间，这取决于[生存时间（TTL）](https://en.wikipedia.org/wiki/Time_to_live)。\n\n* **NS 记录（名称服务器）** - 指定您的域名/子域的 DNS 服务器。\n* **MX 记录（邮件交换）** - 指定接收邮件的邮件服务器。\n* **A 记录（地址）** - 指向一个 IP 地址的名称。\n* **CNAME（规范名称）** - 将一个名称指向另一个名称或 `CNAME`（例如 example.com 指向 www.example.com）或指向一个 `A` 记录。\n\n诸如 [CloudFlare](https://www.cloudflare.com/dns/) 和 [Route 53](https://aws.amazon.com/route53/) 等服务提供托管的 DNS 服务。一些 DNS 服务可以通过多种方法路由流量：\n\n* [加权轮询](https://www.jscape.com/blog/load-balancing-algorithms)\n    * 防止流量流向维护中的服务器\n    * 平衡不同大小的集群\n    * A/B 测试\n* [基于延迟](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)\n* [基于地理位置](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)\n\n### 缺点：DNS\n\n* 访问 DNS 服务器会引入轻微的延迟，尽管上述缓存机制有所缓解。\n* DNS 服务器管理可能很复杂，通常由[政府、ISP 和大型公司](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729)管理。\n* DNS 服务近期遭受过[DDoS 攻击](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/)，导致用户在不知道 Twitter IP 地址的情况下无法访问 Twitter 等网站。\n\n### 资源及进一步阅读\n\n* [DNS 架构](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)\n* [维基百科](https://en.wikipedia.org/wiki/Domain_Name_System)\n* [DNS 相关文章](https://support.dnsimple.com/categories/dns/)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 21,
    "Content": "\n## Content delivery network\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg\">\n  <br/>\n  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Source: Why use a CDN</a></i>\n</p>\n\nA content delivery network (CDN) is a globally distributed network of proxy servers, serving content from locations closer to the user.  Generally, static files such as HTML/CSS/JS, photos, and videos are served from CDN, although some CDNs such as Amazon's CloudFront support dynamic content.  The site's DNS resolution will tell clients which server to contact.\n\nServing content from CDNs can significantly improve performance in two ways:\n\n* Users receive content from data centers close to them\n* Your servers do not have to serve requests that the CDN fulfills\n\n### Push CDNs\n\nPush CDNs receive new content whenever changes occur on your server.  You take full responsibility for providing content, uploading directly to the CDN and rewriting URLs to point to the CDN.  You can configure when content expires and when it is updated.  Content is uploaded only when it is new or changed, minimizing traffic, but maximizing storage.\n\nSites with a small amount of traffic or sites with content that isn't often updated work well with push CDNs.  Content is placed on the CDNs once, instead of being re-pulled at regular intervals.\n\n### Pull CDNs\n\nPull CDNs grab new content from your server when the first user requests the content.  You leave the content on your server and rewrite URLs to point to the CDN.  This results in a slower request until the content is cached on the CDN.\n\nA [time-to-live (TTL)](https://en.wikipedia.org/wiki/Time_to_live) determines how long content is cached.  Pull CDNs minimize storage space on the CDN, but can create redundant traffic if files expire and are pulled before they have actually changed.\n\nSites with heavy traffic work well with pull CDNs, as traffic is spread out more evenly with only recently-requested content remaining on the CDN.\n\n### Disadvantage(s): CDN\n\n* CDN costs could be significant depending on traffic, although this should be weighed with additional costs you would incur not using a CDN.\n* Content might be stale if it is updated before the TTL expires it.\n* CDNs require changing URLs for static content to point to the CDN.\n\n### Source(s) and further reading\n\n* [Globally distributed content delivery](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)\n* [The differences between push and pull CDNs](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)",
    "ContentSha": "bGRlC+2cYKu2Zts6C6nMT6o/JLG5VQ9wuYmJZVvDRI0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n## 内容分发网络\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg\">\n  <br/>\n  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>来源：为什么使用 CDN</a></i>\n</p>\n\n内容分发网络（CDN）是一种全球分布的代理服务器网络，从更靠近用户的位置提供内容。通常，静态文件如 HTML/CSS/JS、照片和视频由 CDN 提供，尽管一些 CDN 如亚马逊的 CloudFront 支持动态内容。网站的 DNS 解析会告诉客户端联系哪个服务器。\n\n从 CDN 提供内容可以通过两种方式显著提升性能：\n\n* 用户从离他们较近的数据中心接收内容\n* 你的服务器不必处理 CDN 已满足的请求\n\n### 推送型 CDN\n\n推送型 CDN 在服务器内容发生变化时接收新内容。你需要全权负责内容的提供，直接上传到 CDN 并重写 URL 指向 CDN。你可以配置内容的过期时间和更新时间。内容仅在新建或更改时上传，最大限度减少流量，同时最大化存储。\n\n流量较小或内容不常更新的网站非常适合推送型 CDN。内容只需上传到 CDN 一次，而不是定期重新拉取。\n\n### 拉取型 CDN\n\n拉取型 CDN 在首个用户请求内容时从你的服务器抓取新内容。你将内容保留在服务器上，并重写 URL 指向 CDN。这导致第一次请求较慢，直到内容缓存到 CDN 上。\n\n[生存时间 (TTL)](https://en.wikipedia.org/wiki/Time_to_live) 决定内容缓存的时长。拉取型 CDN 最大化减少 CDN 上的存储空间，但如果文件过期且尚未实际更改就被拉取，会产生冗余流量。\n\n流量较大的站点适合拉取型 CDN，因为流量更均匀分布，只有最近请求的内容保留在 CDN 上。\n\n### 缺点：CDN\n\n* 根据流量，CDN 费用可能较高，但这应与不使用 CDN 所产生的额外成本进行权衡。\n* 如果内容在 TTL 过期前被更新，可能会出现内容过时的情况。\n* CDN 需要更改静态内容的 URL 指向 CDN。\n\n### 来源及进一步阅读\n\n* [全球分布式内容交付](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)\n* [推送型与拉取型 CDN 的区别](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 22,
    "Content": "* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)\n\n## Load balancer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>\n</p>\n\nLoad balancers distribute incoming client requests to computing resources such as application servers and databases.  In each case, the load balancer returns the response from the computing resource to the appropriate client.  Load balancers are effective at:\n\n* Preventing requests from going to unhealthy servers\n* Preventing overloading resources\n* Helping to eliminate a single point of failure\n\nLoad balancers can be implemented with hardware (expensive) or with software such as HAProxy.\n\nAdditional benefits include:\n\n* **SSL termination** - Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations\n    * Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server\n* **Session persistence** - Issue cookies and route a specific client's requests to same instance if the web apps do not keep track of sessions\n\nTo protect against failures, it's common to set up multiple load balancers, either in [active-passive](#active-passive) or [active-active](#active-active) mode.\n\nLoad balancers can route traffic based on various metrics, including:\n\n* Random\n* Least loaded\n* Session/cookies\n* [Round robin or weighted round robin](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)\n* [Layer 4](#layer-4-load-balancing)\n* [Layer 7](#layer-7-load-balancing)\n\n### Layer 4 load balancing\n\nLayer 4 load balancers look at info at the [transport layer](#communication) to decide how to distribute requests.  Generally, this involves the source, destination IP addresses, and ports in the header, but not the contents of the packet.  Layer 4 load balancers forward network packets to and from the upstream server, performing [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/).\n\n### Layer 7 load balancing",
    "ContentSha": "9cdxRHyBtl0u7vNUNZ/06ZZn+SBn6/L1EyLOFfGBVdU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [维基百科](https://en.wikipedia.org/wiki/Content_delivery_network)\n\n## 负载均衡器\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>来源：可扩展系统设计模式</a></i>\n</p>\n\n负载均衡器将传入的客户端请求分发到计算资源，如应用服务器和数据库。在每种情况下，负载均衡器将计算资源的响应返回给相应的客户端。负载均衡器有效于：\n\n* 防止请求发送到不健康的服务器\n* 防止资源过载\n* 有助于消除单点故障\n\n负载均衡器可以通过硬件（昂贵）或软件实现，如 HAProxy。\n\n其他好处包括：\n\n* **SSL 终止** - 解密传入请求并加密服务器响应，使后端服务器无需执行这些可能耗费资源的操作\n    * 消除了在每台服务器上安装 [X.509 证书](https://en.wikipedia.org/wiki/X.509) 的需求\n* **会话持久性** - 如果 Web 应用不跟踪会话，则发放 Cookie 并将特定客户端的请求路由到相同实例\n\n为防止故障，通常会设置多个负载均衡器，以 [主动-被动](#active-passive) 或 [主动-主动](#active-active) 模式运行。\n\n负载均衡器可以基于多种指标路由流量，包括：\n\n* 随机\n* 最少负载\n* 会话/Cookie\n* [轮询或加权轮询](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)\n* [第 4 层](#layer-4-load-balancing)\n* [第 7 层](#layer-7-load-balancing)\n\n### 第 4 层负载均衡\n\n第 4 层负载均衡器查看[传输层](#communication)的信息来决定如何分配请求。通常，这涉及报头中的源地址、目标 IP 地址和端口，但不包括数据包的内容。第 4 层负载均衡器将网络数据包转发到上游服务器，并执行[网络地址转换 (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)。\n\n### 第 7 层负载均衡",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 23,
    "Content": "\nLayer 7 load balancers look at the [application layer](#communication) to decide how to distribute requests.  This can involve contents of the header, message, and cookies.  Layer 7 load balancers terminate network traffic, reads the message, makes a load-balancing decision, then opens a connection to the selected server.  For example, a layer 7 load balancer can direct video traffic to servers that host videos while directing more sensitive user billing traffic to security-hardened servers.\n\nAt the cost of flexibility, layer 4 load balancing requires less time and computing resources than Layer 7, although the performance impact can be minimal on modern commodity hardware.\n\n### Horizontal scaling\n\nLoad balancers can also help with horizontal scaling, improving performance and availability.  Scaling out using commodity machines is more cost efficient and results in higher availability than scaling up a single server on more expensive hardware, called **Vertical Scaling**.  It is also easier to hire for talent working on commodity hardware than it is for specialized enterprise systems.\n\n#### Disadvantage(s): horizontal scaling\n\n* Scaling horizontally introduces complexity and involves cloning servers\n    * Servers should be stateless: they should not contain any user-related data like sessions or profile pictures\n    * Sessions can be stored in a centralized data store such as a [database](#database) (SQL, NoSQL) or a persistent [cache](#cache) (Redis, Memcached)\n* Downstream servers such as caches and databases need to handle more simultaneous connections as upstream servers scale out\n\n### Disadvantage(s): load balancer\n\n* The load balancer can become a performance bottleneck if it does not have enough resources or if it is not configured properly.\n* Introducing a load balancer to help eliminate a single point of failure results in increased complexity.\n* A single load balancer is a single point of failure, configuring multiple load balancers further increases complexity.\n\n### Source(s) and further reading\n\n* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [Scalability](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n* [Wikipedia](https://en.wikipedia.org/wiki/Load_balancing_(computing))\n* [Layer 4 load balancing](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)\n* [Layer 7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)\n* [ELB listener config](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)\n\n## Reverse proxy (web server)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png\">\n  <br/>\n  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Source: Wikipedia</a></i>\n  <br/>\n</p>",
    "ContentSha": "d9PfMKhS5It6VuFSV5VdEgf336M0xQeGW1c7I8NDHiY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "第7层负载均衡器查看[应用层](#communication)来决定如何分配请求。 这可能涉及头部、消息和Cookie的内容。 第7层负载均衡器终止网络流量，读取消息，做出负载均衡决策，然后打开与选定服务器的连接。 例如，第7层负载均衡器可以将视频流量引导到托管视频的服务器，同时将更敏感的用户计费流量引导到安全加固的服务器。\n\n以灵活性为代价，第4层负载均衡所需的时间和计算资源比第7层少，尽管在现代通用硬件上性能影响可能很小。\n\n### 水平扩展\n\n负载均衡器还可以帮助进行水平扩展，提高性能和可用性。 使用通用机器进行横向扩展比使用更昂贵硬件上的单个服务器进行纵向扩展（称为**纵向扩展**）更具成本效益且可用性更高。 招聘在通用硬件上工作的技术人才也比专门的企业系统更容易。\n\n#### 缺点：水平扩展\n\n* 水平扩展引入复杂性并涉及服务器克隆\n    * 服务器应是无状态的：不应包含任何用户相关数据，如会话或头像\n    * 会话可以存储在集中式数据存储中，例如[数据库](#database)（SQL，NoSQL）或持久性[缓存](#cache)（Redis，Memcached）\n* 下游服务器如缓存和数据库需要处理更多同时连接，因为上游服务器扩展\n\n### 缺点：负载均衡器\n\n* 如果负载均衡器资源不足或配置不当，可能成为性能瓶颈。\n* 引入负载均衡器以消除单点故障会增加复杂性。\n* 单个负载均衡器是单点故障，配置多个负载均衡器会进一步增加复杂性。\n\n### 来源及进一步阅读\n\n* [NGINX架构](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy架构指南](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [可扩展性](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)\n* [维基百科](https://en.wikipedia.org/wiki/Load_balancing_(computing))\n* [第4层负载均衡](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)\n* [第7层负载均衡](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)\n* [ELB监听器配置](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)\n\n## 反向代理（网页服务器）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png\">\n  <br/>\n  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>来源：维基百科</a></i>\n  <br/>\n</p>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 24,
    "Content": "\nA reverse proxy is a web server that centralizes internal services and provides unified interfaces to the public.  Requests from clients are forwarded to a server that can fulfill it before the reverse proxy returns the server's response to the client.\n\nAdditional benefits include:\n\n* **Increased security** - Hide information about backend servers, blacklist IPs, limit number of connections per client\n* **Increased scalability and flexibility** - Clients only see the reverse proxy's IP, allowing you to scale servers or change their configuration\n* **SSL termination** - Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations\n    * Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server\n* **Compression** - Compress server responses\n* **Caching** - Return the response for cached requests\n* **Static content** - Serve static content directly\n    * HTML/CSS/JS\n    * Photos\n    * Videos\n    * Etc\n\n### Load balancer vs reverse proxy\n\n* Deploying a load balancer is useful when you have multiple servers.  Often, load balancers  route traffic to a set of servers serving the same function.\n* Reverse proxies can be useful even with just one web server or application server, opening up the benefits described in the previous section.\n* Solutions such as NGINX and HAProxy can support both layer 7 reverse proxying and load balancing.\n\n### Disadvantage(s): reverse proxy\n\n* Introducing a reverse proxy results in increased complexity.\n* A single reverse proxy is a single point of failure, configuring multiple reverse proxies (ie a [failover](https://en.wikipedia.org/wiki/Failover)) further increases complexity.\n\n### Source(s) and further reading\n\n* [Reverse proxy vs load balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)\n* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)\n\n## Application layer\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png\">\n  <br/>",
    "ContentSha": "mSXIlXJOirzgK7lcCGgaBsQWdB09fQQPiRxJI8Azkv4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "反向代理是一种网络服务器，它集中管理内部服务并向公众提供统一接口。客户端的请求被转发到能够处理该请求的服务器，反向代理再将服务器的响应返回给客户端。\n\n额外的好处包括：\n\n* **增强安全性** - 隐藏后端服务器的信息，黑名单IP，限制每个客户端的连接数\n* **提高可扩展性和灵活性** - 客户端只看到反向代理的IP，允许您扩展服务器或更改其配置\n* **SSL终止** - 解密传入请求并加密服务器响应，使后端服务器无需执行这些可能代价高昂的操作\n    * 免去在每台服务器上安装[X.509证书](https://en.wikipedia.org/wiki/X.509)的需求\n* **压缩** - 压缩服务器响应\n* **缓存** - 返回缓存请求的响应\n* **静态内容** - 直接提供静态内容\n    * HTML/CSS/JS\n    * 图片\n    * 视频\n    * 等等\n\n### 负载均衡器与反向代理\n\n* 当您拥有多台服务器时，部署负载均衡器非常有用。负载均衡器通常将流量路由到执行相同功能的一组服务器。\n* 即使只有一台Web服务器或应用服务器，反向代理也可能有用，可以带来上一节描述的好处。\n* 诸如NGINX和HAProxy等解决方案支持第7层反向代理和负载均衡。\n\n### 缺点：反向代理\n\n* 引入反向代理会增加复杂性。\n* 单个反向代理是单点故障，配置多个反向代理（即[故障转移](https://en.wikipedia.org/wiki/Failover)）会进一步增加复杂性。\n\n### 来源及进一步阅读\n\n* [反向代理与负载均衡器](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)\n* [NGINX架构](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)\n* [HAProxy架构指南](http://www.haproxy.org/download/1.2/doc/architecture.txt)\n* [维基百科](https://en.wikipedia.org/wiki/Reverse_proxy)\n\n## 应用层\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png\">\n  <br/>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 25,
    "Content": "  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>\n</p>\n\nSeparating out the web layer from the application layer (also known as platform layer) allows you to scale and configure both layers independently.  Adding a new API results in adding application servers without necessarily adding additional web servers.  The **single responsibility principle** advocates for small and autonomous services that work together.  Small teams with small services can plan more aggressively for rapid growth.\n\nWorkers in the application layer also help enable [asynchronism](#asynchronism).\n\n### Microservices\n\nRelated to this discussion are [microservices](https://en.wikipedia.org/wiki/Microservices), which can be described as a suite of independently deployable, small, modular services.  Each service runs a unique process and communicates through a well-defined, lightweight mechanism to serve a business goal. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>\n\nPinterest, for example, could have the following microservices: user profile, follower, feed, search, photo upload, etc.\n\n### Service Discovery\n\nSystems such as [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), and [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) can help services find each other by keeping track of registered names, addresses, and ports.  [Health checks](https://www.consul.io/intro/getting-started/checks.html) help verify service integrity and are often done using an [HTTP](#hypertext-transfer-protocol-http) endpoint.  Both Consul and Etcd have a built in [key-value store](#key-value-store) that can be useful for storing config values and other shared data.\n\n### Disadvantage(s): application layer\n\n* Adding an application layer with loosely coupled services requires a different approach from an architectural, operations, and process viewpoint (vs a monolithic system).\n* Microservices can add complexity in terms of deployments and operations.\n\n### Source(s) and further reading\n\n* [Intro to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale)\n* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Service oriented architecture](https://en.wikipedia.org/wiki/Service-oriented_architecture)\n* [Introduction to Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)\n* [Here's what you need to know about building microservices](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)\n\n## Database\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Source: Scaling up to your first 10 million users</a></i>\n</p>\n\n### Relational database management system (RDBMS)\n",
    "ContentSha": "4XnXpBum9tEdb1sG9FZ65dxvl1TxD2b55kzZSCwIQE8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>来源：架构可扩展系统简介</a></i>\n</p>\n\n将 Web 层与应用层（也称为平台层）分离，可以让你独立地扩展和配置这两个层。添加新的 API 会导致添加应用服务器，而不一定需要增加额外的 Web 服务器。**单一职责原则**主张构建小型且自治的服务协同工作。拥有小团队和小服务可以更积极地规划快速增长。\n\n应用层的工作者还帮助实现了[异步](#asynchronism)。\n\n### 微服务\n\n与此相关的是[微服务](https://en.wikipedia.org/wiki/Microservices)，它可以被描述为一套独立部署的小型模块化服务。每个服务运行一个独特的进程，并通过一个定义良好、轻量级的机制进行通信，以实现业务目标。<sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>\n\n例如，Pinterest 可能有以下微服务：用户资料、关注者、动态、搜索、照片上传等。\n\n### 服务发现\n\n诸如[Consul](https://www.consul.io/docs/index.html)、[Etcd](https://coreos.com/etcd/docs/latest)和[Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)等系统可以帮助服务通过跟踪注册的名称、地址和端口找到彼此。[健康检查](https://www.consul.io/intro/getting-started/checks.html)帮助验证服务完整性，通常通过[HTTP](#hypertext-transfer-protocol-http)端点完成。Consul 和 Etcd 都内置了[key-value 存储](#key-value-store)，这对于存储配置值和其他共享数据很有用。\n\n### 缺点：应用层\n\n* 添加一个具有松耦合服务的应用层，从架构、运维和流程视角来看需要不同的方法（相较于单体系统）。\n* 微服务在部署和运维方面可能增加复杂性。\n\n### 来源及进一步阅读\n\n* [架构可扩展系统简介](http://lethain.com/introduction-to-architecting-systems-for-scale)\n* [攻克系统设计面试](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [面向服务架构](https://en.wikipedia.org/wiki/Service-oriented_architecture)\n* [Zookeeper 简介](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)\n* [构建微服务你需要知道的](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)\n\n## 数据库\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>来源：扩展到第一个一千万用户</a></i>\n</p>\n\n### 关系型数据库管理系统（RDBMS）\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 26,
    "Content": "A relational database like SQL is a collection of data items organized in tables.\n\n**ACID** is a set of properties of relational database [transactions](https://en.wikipedia.org/wiki/Database_transaction).\n\n* **Atomicity** - Each transaction is all or nothing\n* **Consistency** - Any transaction will bring the database from one valid state to another\n* **Isolation** - Executing transactions concurrently has the same results as if the transactions were executed serially\n* **Durability** - Once a transaction has been committed, it will remain so\n\nThere are many techniques to scale a relational database: **master-slave replication**, **master-master replication**, **federation**, **sharding**, **denormalization**, and **SQL tuning**.\n\n#### Master-slave replication\n\nThe master serves reads and writes, replicating writes to one or more slaves, which serve only reads.  Slaves can also replicate to additional slaves in a tree-like fashion.  If the master goes offline, the system can continue to operate in read-only mode until a slave is promoted to a master or a new master is provisioned.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### Disadvantage(s): master-slave replication\n\n* Additional logic is needed to promote a slave to a master.\n* See [Disadvantage(s): replication](#disadvantages-replication) for points related to **both** master-slave and master-master.\n\n#### Master-master replication\n\nBoth masters serve reads and writes and coordinate with each other on writes.  If either master goes down, the system can continue to operate with both reads and writes.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\n##### Disadvantage(s): master-master replication\n\n* You'll need a load balancer or you'll need to make changes to your application logic to determine where to write.\n* Most master-master systems are either loosely consistent (violating ACID) or have increased write latency due to synchronization.",
    "ContentSha": "xbwODyHVavckLsfDMlRqRxmfdv3+erTT0ITmoKYGnqg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "关系型数据库如 SQL 是以表格形式组织的数据项集合。\n\n**ACID** 是关系型数据库[事务](https://en.wikipedia.org/wiki/Database_transaction)的一组属性。\n\n* **原子性** - 每个事务要么全部完成，要么全部不做\n* **一致性** - 任何事务都会将数据库从一个有效状态带到另一个有效状态\n* **隔离性** - 并发执行事务的结果与串行执行事务的结果相同\n* **持久性** - 一旦事务提交，其结果将永久保留\n\n有许多技术可以扩展关系型数据库：**主从复制**、**主主复制**、**联合**、**分片**、**反范式设计**和**SQL 调优**。\n\n#### 主从复制\n\n主节点处理读写操作，将写操作复制到一个或多个从节点，从节点仅处理读操作。从节点也可以以树状结构复制到其他从节点。如果主节点离线，系统可以继续以只读模式运行，直到从节点被提升为主节点或新主节点被配置。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>来源：可扩展性、可用性、稳定性模式</a></i>\n</p>\n\n##### 缺点：主从复制\n\n* 需要额外逻辑来将从节点提升为主节点。\n* 有关**主从**和**主主**复制的相关点，请参见[缺点：复制](#disadvantages-replication)。\n\n#### 主主复制\n\n两个主节点都处理读写操作，并在写操作上相互协调。如果任一主节点宕机，系统仍可继续进行读写操作。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>来源：可扩展性、可用性、稳定性模式</a></i>\n</p>\n\n##### 缺点：主主复制\n\n* 你需要负载均衡器，或者需要修改应用逻辑以确定写入位置。\n* 大多数主主系统要么是弱一致的（违反 ACID），要么由于同步导致写延迟增加。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 27,
    "Content": "* Conflict resolution comes more into play as more write nodes are added and as latency increases.\n* See [Disadvantage(s): replication](#disadvantages-replication) for points related to **both** master-slave and master-master.\n\n##### Disadvantage(s): replication\n\n* There is a potential for loss of data if the master fails before any newly written data can be replicated to other nodes.\n* Writes are replayed to the read replicas.  If there are a lot of writes, the read replicas can get bogged down with replaying writes and can't do as many reads.\n* The more read slaves, the more you have to replicate, which leads to greater replication lag.\n* On some systems, writing to the master can spawn multiple threads to write in parallel, whereas read replicas only support writing sequentially with a single thread.\n* Replication adds more hardware and additional complexity.\n\n##### Source(s) and further reading: replication\n\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [Multi-master replication](https://en.wikipedia.org/wiki/Multi-master_replication)\n\n#### Federation\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Source: Scaling up to your first 10 million users</a></i>\n</p>\n\nFederation (or functional partitioning) splits up databases by function.  For example, instead of a single, monolithic database, you could have three databases: **forums**, **users**, and **products**, resulting in less read and write traffic to each database and therefore less replication lag.  Smaller databases result in more data that can fit in memory, which in turn results in more cache hits due to improved cache locality.  With no single central master serializing writes you can write in parallel, increasing throughput.\n\n##### Disadvantage(s): federation\n\n* Federation is not effective if your schema requires huge functions or tables.\n* You'll need to update your application logic to determine which database to read and write.\n* Joining data from two databases is more complex with a [server link](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).\n* Federation adds more hardware and additional complexity.\n\n##### Source(s) and further reading: federation\n\n* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n\n#### Sharding\n\n<p align=\"center\">",
    "ContentSha": "I/gTQQL3xkPYu5E5dWj4YTG/hfUu3BM7YFOD7HwCQH0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 随着写节点的增加和延迟的提高，冲突解决变得更加重要。\n* 有关**主从**和**主主**复制相关的问题，请参见[缺点：复制](#disadvantages-replication)。\n\n##### 缺点：复制\n\n* 如果主节点在新写入数据复制到其他节点之前失败，可能会导致数据丢失。\n* 写入操作会被重放到只读副本。如果写入量很大，只读副本可能会因重放写入而变得繁忙，导致读取能力下降。\n* 只读从库越多，需要复制的数据越多，从而导致更大的复制延迟。\n* 在某些系统中，写入主库可以生成多个线程并行写入，而只读副本仅支持单线程顺序写入。\n* 复制增加了更多的硬件需求和额外的复杂性。\n\n##### 复制的来源和进一步阅读\n\n* [可扩展性、可用性、稳定性及模式](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [多主复制](https://en.wikipedia.org/wiki/Multi-master_replication)\n\n#### 联邦\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png\">\n  <br/>\n  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>来源：扩展到你的第一个1000万用户</a></i>\n</p>\n\n联邦（或功能分区）按功能划分数据库。例如，不使用单一的整体数据库，而是拥有三个数据库：**论坛**、**用户**和**产品**，从而减少每个数据库的读写流量，降低复制延迟。较小的数据库意味着更多数据可以放入内存，进而因缓存局部性改进而提高缓存命中率。没有单一的中央主节点串行写入，写入可以并行进行，提高吞吐量。\n\n##### 联邦的缺点\n\n* 如果你的模式需要庞大的函数或表，联邦效果不佳。\n* 你需要更新应用逻辑来确定读写哪个数据库。\n* 从两个数据库联合查询数据更复杂，需使用[服务器链接](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers)。\n* 联邦增加了更多的硬件需求和额外的复杂性。\n\n##### 联邦的来源和进一步阅读\n\n* [扩展到你的第一个1000万用户](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n\n#### 分片\n\n<p align=\"center\">",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 28,
    "Content": "  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nSharding distributes data across different databases such that each database can only manage a subset of the data.  Taking a users database as an example, as the number of users increases, more shards are added to the cluster.\n\nSimilar to the advantages of [federation](#federation), sharding results in less read and write traffic, less replication, and more cache hits.  Index size is also reduced, which generally improves performance with faster queries.  If one shard goes down, the other shards are still operational, although you'll want to add some form of replication to avoid data loss.  Like federation, there is no single central master serializing writes, allowing you to write in parallel with increased throughput.\n\nCommon ways to shard a table of users is either through the user's last name initial or the user's geographic location.\n\n##### Disadvantage(s): sharding\n\n* You'll need to update your application logic to work with shards, which could result in complex SQL queries.\n* Data distribution can become lopsided in a shard.  For example, a set of power users on a shard could result in increased load to that shard compared to others.\n    * Rebalancing adds additional complexity.  A sharding function based on [consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) can reduce the amount of transferred data.\n* Joining data from multiple shards is more complex.\n* Sharding adds more hardware and additional complexity.\n\n##### Source(s) and further reading: sharding\n\n* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)\n* [Shard database architecture](https://en.wikipedia.org/wiki/Shard_(database_architecture))\n* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)\n\n#### Denormalization\n\nDenormalization attempts to improve read performance at the expense of some write performance.  Redundant copies of the data are written in multiple tables to avoid expensive joins.  Some RDBMS such as [PostgreSQL](https://en.wikipedia.org/wiki/PostgreSQL) and Oracle support [materialized views](https://en.wikipedia.org/wiki/Materialized_view) which handle the work of storing redundant information and keeping redundant copies consistent.\n\nOnce data becomes distributed with techniques such as [federation](#federation) and [sharding](#sharding), managing joins across data centers further increases complexity.  Denormalization might circumvent the need for such complex joins.\n\nIn most systems, reads can heavily outnumber writes 100:1 or even 1000:1.  A read resulting in a complex database join can be very expensive, spending a significant amount of time on disk operations.\n\n##### Disadvantage(s): denormalization\n\n* Data is duplicated.\n* Constraints can help redundant copies of information stay in sync, which increases complexity of the database design.\n* A denormalized database under heavy write load might perform worse than its normalized counterpart.\n\n###### Source(s) and further reading: denormalization",
    "ContentSha": "GzP1YEx8H74doj7cHlqPZNKSbHvkETAbRVSJw4T5QnY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>来源：可扩展性、可用性、稳定性、模式</a></i>\n</p>\n\n分片（Sharding）将数据分布到不同的数据库中，使得每个数据库只能管理数据的一个子集。以用户数据库为例，随着用户数量的增加，集群中会添加更多的分片。\n\n与[联合](#federation)的优点类似，分片带来更少的读写流量、更少的复制以及更多的缓存命中。索引大小也减少，通常这能提升性能，加快查询速度。如果某个分片宕机，其他分片仍然可以正常工作，不过你需要添加某种复制机制以避免数据丢失。像联合一样，没有单一中央主库来串行化写操作，允许你并行写入，提高吞吐量。\n\n常见的用户表分片方式是通过用户的姓氏首字母或用户的地理位置。\n\n##### 缺点：分片\n\n* 你需要更新应用逻辑以支持分片，这可能导致复杂的 SQL 查询。\n* 数据分布在分片中可能不均衡。例如，某个分片上的一组高频用户可能导致该分片负载增加，超过其他分片。\n    * 重新平衡会增加额外复杂性。基于[一致性哈希](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)的分片函数可以减少传输的数据量。\n* 跨多个分片连接数据更复杂。\n* 分片增加了更多硬件需求和额外复杂性。\n\n##### 来源及扩展阅读：分片\n\n* [分片的到来](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)\n* [分片数据库架构](https://en.wikipedia.org/wiki/Shard_(database_architecture))\n* [一致性哈希](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)\n\n#### 反规范化\n\n反规范化试图以牺牲部分写性能为代价来提升读性能。在多个表中写入冗余数据副本以避免昂贵的连接操作。一些关系型数据库管理系统（如[PostgreSQL](https://en.wikipedia.org/wiki/PostgreSQL)和Oracle）支持[物化视图](https://en.wikipedia.org/wiki/Materialized_view)，它们负责存储冗余信息并保持副本一致。\n\n一旦数据通过[联合](#federation)和[分片](#sharding)等技术分布开来，跨数据中心管理连接操作的复杂性进一步增加。反规范化可能避免了这种复杂连接的需求。\n\n在大多数系统中，读操作远远多于写操作，比例可能达到100:1甚至1000:1。一次复杂的数据库连接查询可能非常昂贵，花费大量时间在磁盘操作上。\n\n##### 缺点：反规范化\n\n* 数据被复制。\n* 约束可以帮助冗余信息保持同步，但这增加了数据库设计的复杂性。\n* 在写负载较重时，反规范化的数据库性能可能不如其规范化的对应版本。\n\n###### 来源及扩展阅读：反规范化",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 29,
    "Content": "\n* [Denormalization](https://en.wikipedia.org/wiki/Denormalization)\n\n#### SQL tuning\n\nSQL tuning is a broad topic and many [books](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) have been written as reference.\n\nIt's important to **benchmark** and **profile** to simulate and uncover bottlenecks.\n\n* **Benchmark** - Simulate high-load situations with tools such as [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).\n* **Profile** - Enable tools such as the [slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) to help track performance issues.\n\nBenchmarking and profiling might point you to the following optimizations.\n\n##### Tighten up the schema\n\n* MySQL dumps to disk in contiguous blocks for fast access.\n* Use `CHAR` instead of `VARCHAR` for fixed-length fields.\n    * `CHAR` effectively allows for fast, random access, whereas with `VARCHAR`, you must find the end of a string before moving onto the next one.\n* Use `TEXT` for large blocks of text such as blog posts.  `TEXT` also allows for boolean searches.  Using a `TEXT` field results in storing a pointer on disk that is used to locate the text block.\n* Use `INT` for larger numbers up to 2^32 or 4 billion.\n* Use `DECIMAL` for currency to avoid floating point representation errors.\n* Avoid storing large `BLOBS`, store the location of where to get the object instead.\n* `VARCHAR(255)` is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.\n* Set the `NOT NULL` constraint where applicable to [improve search performance](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).\n\n##### Use good indices\n\n* Columns that you are querying (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) could be faster with indices.\n* Indices are usually represented as self-balancing [B-tree](https://en.wikipedia.org/wiki/B-tree) that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time.\n* Placing an index can keep the data in memory, requiring more space.\n* Writes could also be slower since the index also needs to be updated.\n* When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices.\n\n##### Avoid expensive joins\n\n* [Denormalize](#denormalization) where performance demands it.\n\n##### Partition tables\n",
    "ContentSha": "RC5xUXwhghEuq573LDD6+Is8QYupI3Y4Dn+nKYuNP3o=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n* [反规范化](https://en.wikipedia.org/wiki/Denormalization)\n\n#### SQL 调优\n\nSQL 调优是一个广泛的话题，已经有许多[书籍](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning)作为参考。\n\n进行**基准测试**和**性能分析**来模拟并发现瓶颈非常重要。\n\n* **基准测试** - 使用如 [ab](http://httpd.apache.org/docs/2.2/programs/ab.html) 等工具模拟高负载情况。\n* **性能分析** - 启用如 [慢查询日志](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) 等工具帮助跟踪性能问题。\n\n基准测试和性能分析可能会指引您进行以下优化。\n\n##### 收紧数据库模式\n\n* MySQL 将数据以连续块写入磁盘以实现快速访问。\n* 对于固定长度字段使用 `CHAR` 替代 `VARCHAR`。\n    * `CHAR` 实际上允许快速随机访问，而使用 `VARCHAR` 时必须找到字符串结尾后才能访问下一个。\n* 对于大块文本如博客文章使用 `TEXT`。 `TEXT` 也支持布尔搜索。使用 `TEXT` 字段会在磁盘上存储一个指针，用于定位文本块。\n* 对于最大可达 2^32 或 40 亿的大数字，使用 `INT`。\n* 使用 `DECIMAL` 存储货币，以避免浮点表示错误。\n* 避免存储大 `BLOB`，改为存储对象位置。\n* `VARCHAR(255)` 是 8 位数字能计数的最大字符数，通常在某些关系数据库中最大化一个字节的使用。\n* 在适用情况下设置 `NOT NULL` 约束以[提升搜索性能](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)。\n\n##### 使用合适的索引\n\n* 查询的列（`SELECT`、`GROUP BY`、`ORDER BY`、`JOIN`）使用索引可以更快。\n* 索引通常表现为自平衡的[B树](https://en.wikipedia.org/wiki/B-tree)，保持数据排序，允许对数时间的搜索、顺序访问、插入和删除。\n* 建立索引会占用更多内存空间。\n* 写入速度可能变慢，因为索引也需要更新。\n* 加载大量数据时，禁用索引加载数据然后重建索引可能更快。\n\n##### 避免昂贵的连接\n\n* 在性能要求高时进行[反规范化](#denormalization)。\n\n##### 分区表\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 30,
    "Content": "* Break up a table by putting hot spots in a separate table to help keep it in memory.\n\n##### Tune the query cache\n\n* In some cases, the [query cache](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) could lead to [performance issues](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).\n\n##### Source(s) and further reading: SQL tuning\n\n* [Tips for optimizing MySQL queries](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)\n* [Is there a good reason i see VARCHAR(255) used so often?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)\n* [How do null values affect performance?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)\n* [Slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)\n\n### NoSQL\n\nNoSQL is a collection of data items represented in a **key-value store**, **document store**, **wide column store**, or a **graph database**.  Data is denormalized, and joins are generally done in the application code.  Most NoSQL stores lack true ACID transactions and favor [eventual consistency](#eventual-consistency).\n\n**BASE** is often used to describe the properties of NoSQL databases.  In comparison with the [CAP Theorem](#cap-theorem), BASE chooses availability over consistency.\n\n* **Basically available** - the system guarantees availability.\n* **Soft state** - the state of the system may change over time, even without input.\n* **Eventual consistency** - the system will become consistent over a period of time, given that the system doesn't receive input during that period.\n\nIn addition to choosing between [SQL or NoSQL](#sql-or-nosql), it is helpful to understand which type of NoSQL database best fits your use case(s).  We'll review **key-value stores**, **document stores**, **wide column stores**, and **graph databases** in the next section.\n\n#### Key-value store\n\n> Abstraction: hash table\n\nA key-value store generally allows for O(1) reads and writes and is often backed by memory or SSD.  Data stores can maintain keys in [lexicographic order](https://en.wikipedia.org/wiki/Lexicographical_order), allowing efficient retrieval of key ranges.  Key-value stores can allow for storing of metadata with a value.\n\nKey-value stores provide high performance and are often used for simple data models or for rapidly-changing data, such as an in-memory cache layer.  Since they offer only a limited set of operations, complexity is shifted to the application layer if additional operations are needed.\n\nA key-value store is the basis for more complex systems such as a document store, and in some cases, a graph database.\n\n##### Source(s) and further reading: key-value store\n\n* [Key-value database](https://en.wikipedia.org/wiki/Key-value_database)\n* [Disadvantages of key-value stores](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)\n* [Redis architecture](http://qnimate.com/overview-of-redis-architecture/)",
    "ContentSha": "+vnJh/M2dUlgEZ6CZbzhFf3VoeY7aJE4IGjH1bsbrm8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 通过将热点数据放入单独的表中来拆分表，以帮助保持其在内存中的状态。\n\n##### 调优查询缓存\n\n* 在某些情况下，[查询缓存](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html)可能导致[性能问题](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/)。\n\n##### 来源及进一步阅读：SQL调优\n\n* [优化MySQL查询的技巧](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)\n* [为什么VARCHAR(255)这么常用，有合理的原因吗？](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)\n* [空值如何影响性能？](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)\n* [慢查询日志](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)\n\n### NoSQL\n\nNoSQL 是一组以**键值存储**、**文档存储**、**宽列存储**或**图数据库**形式表示的数据项。数据是非规范化的，连接通常在应用代码中完成。大多数 NoSQL 存储缺乏真正的 ACID 事务，偏向于[最终一致性](#eventual-consistency)。\n\n**BASE** 常用来描述 NoSQL 数据库的特性。与[CAP 定理](#cap-theorem)相比，BASE 选择可用性而非一致性。\n\n* **基本可用** - 系统保证可用性。\n* **软状态** - 系统状态可能随时间变化，即使没有输入。\n* **最终一致性** - 系统将在一段时间内变为一致，前提是在此期间系统未接收输入。\n\n除了在[SQL或NoSQL](#sql-or-nosql)之间选择外，了解哪种类型的 NoSQL 数据库最适合您的用例也很有帮助。我们将在下一节回顾**键值存储**、**文档存储**、**宽列存储**和**图数据库**。\n\n#### 键值存储\n\n> 抽象：哈希表\n\n键值存储通常允许 O(1) 的读写，通常由内存或 SSD 支持。数据存储可以保持键的[字典序](https://en.wikipedia.org/wiki/Lexicographical_order)，从而高效检索键范围。键值存储可以允许与值一起存储元数据。\n\n键值存储提供高性能，常用于简单数据模型或快速变化的数据，如内存缓存层。由于它们仅提供有限的操作集，若需要额外操作，复杂性将转移到应用层。\n\n键值存储是更复杂系统的基础，例如文档存储，某些情况下也是图数据库。\n\n##### 来源及进一步阅读：键值存储\n\n* [键值数据库](https://en.wikipedia.org/wiki/Key-value_database)\n* [键值存储的缺点](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)\n* [Redis 架构概述](http://qnimate.com/overview-of-redis-architecture/)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 31,
    "Content": "* [Memcached architecture](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)\n\n#### Document store\n\n> Abstraction: key-value store with documents stored as values\n\nA document store is centered around documents (XML, JSON, binary, etc), where a document stores all information for a given object.  Document stores provide APIs or a query language to query based on the internal structure of the document itself.  *Note, many key-value stores include features for working with a value's metadata, blurring the lines between these two storage types.*\n\nBased on the underlying implementation, documents are organized by collections, tags, metadata, or directories.  Although documents can be organized or grouped together, documents may have fields that are completely different from each other.\n\nSome document stores like [MongoDB](https://www.mongodb.com/mongodb-architecture) and [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) also provide a SQL-like language to perform complex queries.  [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) supports both key-values and documents.\n\nDocument stores provide high flexibility and are often used for working with occasionally changing data.\n\n##### Source(s) and further reading: document store\n\n* [Document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database)\n* [MongoDB architecture](https://www.mongodb.com/mongodb-architecture)\n* [CouchDB architecture](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)\n* [Elasticsearch architecture](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)\n\n#### Wide column store\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png\">\n  <br/>\n  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Source: SQL & NoSQL, a brief history</a></i>\n</p>\n\n> Abstraction: nested map `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`\n\nA wide column store's basic unit of data is a column (name/value pair).  A column can be grouped in column families (analogous to a SQL table).  Super column families further group column families.  You can access each column independently with a row key, and columns with the same row key form a row.  Each value contains a timestamp for versioning and for conflict resolution.\n\nGoogle introduced [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) as the first wide column store, which influenced the open-source [HBase](https://www.edureka.co/blog/hbase-architecture/) often-used in the Hadoop ecosystem, and [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) from Facebook.  Stores such as BigTable, HBase, and Cassandra maintain keys in lexicographic order, allowing efficient retrieval of selective key ranges.\n\nWide column stores offer high availability and high scalability.  They are often used for very large data sets.\n\n##### Source(s) and further reading: wide column store\n\n* [SQL & NoSQL, a brief history](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)",
    "ContentSha": "qChjAGddKNc8A4k6Ydpi6HXYPt34LJFKDxqqAKCkrXw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Memcached 架构](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)\n\n#### 文档存储\n\n> 抽象：键值存储，文档作为值存储\n\n文档存储以文档（XML、JSON、二进制等）为中心，文档存储给定对象的所有信息。文档存储提供基于文档内部结构的 API 或查询语言进行查询。*注意，许多键值存储包含处理值元数据的功能，模糊了这两种存储类型之间的界限。*\n\n根据底层实现，文档通过集合、标签、元数据或目录进行组织。尽管文档可以被组织或分组，但文档的字段可能彼此完全不同。\n\n一些文档存储如 [MongoDB](https://www.mongodb.com/mongodb-architecture) 和 [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) 也提供类似 SQL 的语言来执行复杂查询。[DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) 同时支持键值和文档。\n\n文档存储提供高度灵活性，常用于处理偶尔变更的数据。\n\n##### 来源及进一步阅读：文档存储\n\n* [面向文档的数据库](https://en.wikipedia.org/wiki/Document-oriented_database)\n* [MongoDB 架构](https://www.mongodb.com/mongodb-architecture)\n* [CouchDB 架构](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)\n* [Elasticsearch 架构](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)\n\n#### 宽列存储\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png\">\n  <br/>\n  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>来源：SQL & NoSQL，简史</a></i>\n</p>\n\n> 抽象：嵌套映射 `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`\n\n宽列存储的数据基本单元是列（名称/值对）。列可以分组到列族中（类似于 SQL 表）。超级列族进一步对列族进行分组。您可以通过行键独立访问每个列，具有相同行键的列组成一行。每个值包含时间戳，用于版本控制和冲突解决。\n\nGoogle 推出了 [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) 作为首个宽列存储，影响了开源的 [HBase](https://www.edureka.co/blog/hbase-architecture/)（常用于 Hadoop 生态系统）和 Facebook 的 [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)。BigTable、HBase 和 Cassandra 等存储按字典序维护键，支持高效检索特定键范围。\n\n宽列存储提供高可用性和高扩展性，常用于超大数据集。\n\n##### 来源及进一步阅读：宽列存储\n\n* [SQL & NoSQL，简史](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 32,
    "Content": "* [Bigtable architecture](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)\n* [HBase architecture](https://www.edureka.co/blog/hbase-architecture/)\n* [Cassandra architecture](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)\n\n#### Graph database\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png\">\n  <br/>\n  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Source: Graph database</a></i>\n</p>\n\n> Abstraction: graph\n\nIn a graph database, each node is a record and each arc is a relationship between two nodes.  Graph databases are optimized to represent complex relationships with many foreign keys or many-to-many relationships.\n\nGraphs databases offer high performance for data models with complex relationships, such as a social network.  They are relatively new and are not yet widely-used; it might be more difficult to find development tools and resources.  Many graphs can only be accessed with [REST APIs](#representational-state-transfer-rest).\n\n##### Source(s) and further reading: graph\n\n* [Graph database](https://en.wikipedia.org/wiki/Graph_database)\n* [Neo4j](https://neo4j.com/)\n* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)\n\n#### Source(s) and further reading: NoSQL\n\n* [Explanation of base terminology](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)\n* [NoSQL databases a survey and decision guidance](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)\n* [Scalability](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n* [Introduction to NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)\n* [NoSQL patterns](http://horicky.blogspot.com/2009/11/nosql-patterns.html)\n\n### SQL or NoSQL\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Source: Transitioning from RDBMS to NoSQL</a></i>\n</p>\n",
    "ContentSha": "yvB08chNWcvF9yiu0b/QLR53EBOeWK574rgWXfnGOXg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Bigtable 架构](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)\n* [HBase 架构](https://www.edureka.co/blog/hbase-architecture/)\n* [Cassandra 架构](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)\n\n#### 图数据库\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png\">\n  <br/>\n  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>来源：图数据库</a></i>\n</p>\n\n> 抽象：图\n\n在图数据库中，每个节点是一个记录，每条弧是两个节点之间的关系。图数据库针对具有许多外键或多对多关系的复杂关系进行了优化。\n\n图数据库为具有复杂关系的数据模型（如社交网络）提供高性能。它们相对较新，尚未被广泛使用；可能更难找到开发工具和资源。许多图只能通过[REST API](#representational-state-transfer-rest)访问。\n\n##### 来源及进一步阅读：图\n\n* [图数据库](https://en.wikipedia.org/wiki/Graph_database)\n* [Neo4j](https://neo4j.com/)\n* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)\n\n#### 来源及进一步阅读：NoSQL\n\n* [BASE 术语解释](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)\n* [NoSQL 数据库调查与决策指导](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)\n* [可扩展性](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)\n* [NoSQL 入门](https://www.youtube.com/watch?v=qI_g07C_Q5I)\n* [NoSQL 模式](http://horicky.blogspot.com/2009/11/nosql-patterns.html)\n\n### SQL 或 NoSQL\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>来源：从关系型数据库到 NoSQL 的转变</a></i>\n</p>\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 33,
    "Content": "Reasons for **SQL**:\n\n* Structured data\n* Strict schema\n* Relational data\n* Need for complex joins\n* Transactions\n* Clear patterns for scaling\n* More established: developers, community, code, tools, etc\n* Lookups by index are very fast\n\nReasons for **NoSQL**:\n\n* Semi-structured data\n* Dynamic or flexible schema\n* Non-relational data\n* No need for complex joins\n* Store many TB (or PB) of data\n* Very data intensive workload\n* Very high throughput for IOPS\n\nSample data well-suited for NoSQL:\n\n* Rapid ingest of clickstream and log data\n* Leaderboard or scoring data\n* Temporary data, such as a shopping cart\n* Frequently accessed ('hot') tables\n* Metadata/lookup tables\n\n##### Source(s) and further reading: SQL or NoSQL\n\n* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)\n* [SQL vs NoSQL differences](https://www.sitepoint.com/sql-vs-nosql-differences/)\n\n## Cache\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png\">\n  <br/>\n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>",
    "ContentSha": "s5JZtpzJOg6uZVhDykP9Uy+U/KEwjhNiySMSqZAIAwI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "**SQL** 的原因：\n\n* 结构化数据  \n* 严格的模式  \n* 关系型数据  \n* 需要复杂的连接  \n* 事务处理  \n* 清晰的扩展模式  \n* 更加成熟：开发者、社区、代码、工具等  \n* 通过索引查找非常快  \n\n**NoSQL** 的原因：\n\n* 半结构化数据  \n* 动态或灵活的模式  \n* 非关系型数据  \n* 无需复杂的连接  \n* 存储大量 TB（或 PB）级数据  \n* 高度数据密集型工作负载  \n* 极高的 IOPS 吞吐量  \n\n适合 NoSQL 的示例数据：\n\n* 快速摄取点击流和日志数据  \n* 排行榜或评分数据  \n* 临时数据，如购物车  \n* 频繁访问的（“热”）表  \n* 元数据/查找表  \n\n##### 来源及进一步阅读：SQL 或 NoSQL\n\n* [扩展到你的第一个 1000 万用户](https://www.youtube.com/watch?v=kKjm4ehYiMs)  \n* [SQL 与 NoSQL 的区别](https://www.sitepoint.com/sql-vs-nosql-differences/)  \n\n## 缓存\n\n<p align=\"center\">  \n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png\">  \n  <br/>  \n  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>来源：可扩展系统设计模式</a></i>",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 34,
    "Content": "</p>\n\nCaching improves page load times and can reduce the load on your servers and databases.  In this model, the dispatcher will first lookup if the request has been made before and try to find the previous result to return, in order to save the actual execution.\n\nDatabases often benefit from a uniform distribution of reads and writes across its partitions.  Popular items can skew the distribution, causing bottlenecks.  Putting a cache in front of a database can help absorb uneven loads and spikes in traffic.\n\n### Client caching\n\nCaches can be located on the client side (OS or browser), [server side](#reverse-proxy-web-server), or in a distinct cache layer.\n\n### CDN caching\n\n[CDNs](#content-delivery-network) are considered a type of cache.\n\n### Web server caching\n\n[Reverse proxies](#reverse-proxy-web-server) and caches such as [Varnish](https://www.varnish-cache.org/) can serve static and dynamic content directly.  Web servers can also cache requests, returning responses without having to contact application servers.\n\n### Database caching\n\nYour database usually includes some level of caching in a default configuration, optimized for a generic use case.  Tweaking these settings for specific usage patterns can further boost performance.\n\n### Application caching\n\nIn-memory caches such as Memcached and Redis are key-value stores between your application and your data storage.  Since the data is held in RAM, it is much faster than typical databases where data is stored on disk.  RAM is more limited than disk, so [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms) algorithms such as [least recently used (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)) can help invalidate 'cold' entries and keep 'hot' data in RAM.\n\nRedis has the following additional features:\n\n* Persistence option\n* Built-in data structures such as sorted sets and lists\n\nThere are multiple levels you can cache that fall into two general categories: **database queries** and **objects**:\n\n* Row level\n* Query-level\n* Fully-formed serializable objects\n* Fully-rendered HTML\n\nGenerally, you should try to avoid file-based caching, as it makes cloning and auto-scaling more difficult.\n",
    "ContentSha": "PfUbgKkIJf45vxersAv0t5I8be53ZYhiGpd5NAhmomo=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "</p>\n\n缓存可以提高页面加载速度，并减少服务器和数据库的负载。在此模型中，调度器会首先查找请求是否已被处理过，尝试找到之前的结果返回，以节省实际执行的时间。\n\n数据库通常受益于跨分区的读写均匀分布。热门项目可能会导致分布不均，造成瓶颈。在数据库前放置缓存可以帮助吸收不均匀的负载和流量峰值。\n\n### 客户端缓存\n\n缓存可以位于客户端（操作系统或浏览器）、[服务器端](#reverse-proxy-web-server)或独立的缓存层。\n\n### CDN 缓存\n\n[内容分发网络（CDN）](#content-delivery-network)被视为一种缓存。\n\n### Web 服务器缓存\n\n[反向代理](#reverse-proxy-web-server)和如 [Varnish](https://www.varnish-cache.org/) 等缓存可以直接提供静态和动态内容。Web 服务器也可以缓存请求，返回响应而无需联系应用服务器。\n\n### 数据库缓存\n\n数据库通常在默认配置中包含一定程度的缓存，针对通用使用场景进行优化。针对特定使用模式调整这些设置可以进一步提升性能。\n\n### 应用缓存\n\n内存缓存如 Memcached 和 Redis 是应用与数据存储之间的键值存储。由于数据存储在内存中，比典型的基于磁盘存储的数据库更快。内存容量有限，因此[缓存失效](https://en.wikipedia.org/wiki/Cache_algorithms)算法如[最近最少使用（LRU）](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU))可以帮助失效“冷”条目，保持“热”数据在内存中。\n\nRedis 具有以下额外功能：\n\n* 持久化选项\n* 内置数据结构，如有序集合和列表\n\n缓存可以存在多个层级，归于两大类：**数据库查询**和**对象**：\n\n* 行级缓存\n* 查询级缓存\n* 完整可序列化对象缓存\n* 完整渲染的 HTML 缓存\n\n通常，应尽量避免基于文件的缓存，因为这会增加克隆和自动扩展的难度。\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 35,
    "Content": "### Caching at the database query level\n\nWhenever you query the database, hash the query as a key and store the result to the cache.  This approach suffers from expiration issues:\n\n* Hard to delete a cached result with complex queries\n* If one piece of data changes such as a table cell, you need to delete all cached queries that might include the changed cell\n\n### Caching at the object level\n\nSee your data as an object, similar to what you do with your application code.  Have your application assemble the dataset from the database into a class instance or a data structure(s):\n\n* Remove the object from cache if its underlying data has changed\n* Allows for asynchronous processing: workers assemble objects by consuming the latest cached object\n\nSuggestions of what to cache:\n\n* User sessions\n* Fully rendered web pages\n* Activity streams\n* User graph data\n\n### When to update the cache\n\nSince you can only store a limited amount of data in cache, you'll need to determine which cache update strategy works best for your use case.\n\n#### Cache-aside\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>\n</p>\n\nThe application is responsible for reading and writing from storage.  The cache does not interact with storage directly.  The application does the following:\n\n* Look for entry in cache, resulting in a cache miss\n* Load entry from the database\n* Add entry to cache\n* Return entry\n",
    "ContentSha": "1LZ2C/EUSShYNdt1FP+/fZdVQMcH8WGFigSx+nEiAZI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 数据库查询级别的缓存\n\n每当查询数据库时，将查询哈希作为键并将结果存储到缓存中。此方法存在过期问题：\n\n* 对于复杂查询，很难删除缓存结果\n* 如果某个数据发生变化（如表中的某个单元格），需要删除所有可能包含该变化单元格的缓存查询\n\n### 对象级别的缓存\n\n将数据视为对象，类似于应用程序代码的处理方式。让应用程序将数据库中的数据集组装成类实例或数据结构：\n\n* 如果底层数据发生变化，则从缓存中移除该对象\n* 支持异步处理：工作线程通过消费最新缓存对象来组装对象\n\n建议缓存的内容：\n\n* 用户会话\n* 完全渲染的网页\n* 活动流\n* 用户图数据\n\n### 何时更新缓存\n\n由于缓存中只能存储有限的数据，需要确定哪种缓存更新策略最适合您的用例。\n\n#### Cache-aside\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>来源：从缓存到内存数据网格简介</a></i>\n</p>\n\n应用程序负责从存储中读取和写入。缓存不直接与存储交互。应用程序执行以下操作：\n\n* 在缓存中查找条目，导致缓存未命中\n* 从数据库加载条目\n* 将条目添加到缓存\n* 返回条目\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 36,
    "Content": "```python\ndef get_user(self, user_id):\n    user = cache.get(\"user.{0}\", user_id)\n    if user is None:\n        user = db.query(\"SELECT * FROM users WHERE user_id = {0}\", user_id)\n        if user is not None:\n            key = \"user.{0}\".format(user_id)\n            cache.set(key, json.dumps(user))\n    return user\n```",
    "ContentSha": "oOOkxiaDDsfJgZibD4WyvNCLh494Kkw0zeQUjNF+dKA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\ndef get_user(self, user_id):\n    user = cache.get(\"user.{0}\", user_id)\n    if user is None:\n        user = db.query(\"SELECT * FROM users WHERE user_id = {0}\", user_id)\n        if user is not None:\n            key = \"user.{0}\".format(user_id)\n            cache.set(key, json.dumps(user))\n    return user\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 37,
    "Content": "\n[Memcached](https://memcached.org/) is generally used in this manner.\n\nSubsequent reads of data added to cache are fast.  Cache-aside is also referred to as lazy loading.  Only requested data is cached, which avoids filling up the cache with data that isn't requested.\n\n##### Disadvantage(s): cache-aside\n\n* Each cache miss results in three trips, which can cause a noticeable delay.\n* Data can become stale if it is updated in the database.  This issue is mitigated by setting a time-to-live (TTL) which forces an update of the cache entry, or by using write-through.\n* When a node fails, it is replaced by a new, empty node, increasing latency.\n\n#### Write-through\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nThe application uses the cache as the main data store, reading and writing data to it, while the cache is responsible for reading and writing to the database:\n\n* Application adds/updates entry in cache\n* Cache synchronously writes entry to data store\n* Return\n\nApplication code:\n",
    "ContentSha": "fTUxdhUP8C+msOuO6oFCQBKVESfJlBRIv+xTex+NRH4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "[Memcached](https://memcached.org/) 通常以这种方式使用。\n\n随后的缓存数据读取速度很快。Cache-aside 也称为懒加载。仅缓存被请求的数据，避免缓存被未请求的数据填满。\n\n##### 缺点：cache-aside\n\n* 每次缓存未命中都会导致三次往返，可能引起明显延迟。\n* 如果数据库中的数据被更新，缓存数据可能变得过时。该问题通过设置生存时间（TTL）来强制更新缓存条目，或使用写直达方式来缓解。\n* 当节点失败时，会被一个新的空节点替换，增加了延迟。\n\n#### 写直达（Write-through）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>来源：可扩展性、可用性、稳定性模式</a></i>\n</p>\n\n应用程序将缓存作为主要数据存储，读写数据时都操作缓存，缓存负责读写数据库：\n\n* 应用程序添加/更新缓存条目\n* 缓存同步写入数据存储\n* 返回\n\n应用程序代码：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 38,
    "Content": "```python\nset_user(12345, {\"foo\":\"bar\"})\n```",
    "ContentSha": "7tpMTtbDSdUbs+oC+Qf5dKLGCUAcRFUe6DfcgSYQP7c=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\nset_user(12345, {\"foo\":\"bar\"})\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 39,
    "Content": "\nCache code:\n",
    "ContentSha": "3TQIz863VWmVTS8NeQVBQ2s9apIl1JpwXxyAqo7YRXU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "缓存代码：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 40,
    "Content": "```python\ndef set_user(user_id, values):\n    user = db.query(\"UPDATE Users WHERE id = {0}\", user_id, values)\n    cache.set(user_id, user)\n```",
    "ContentSha": "2/SVlo2Tq+z8vN6s72UuRvXSio2ONq8aOqxj7V/g+MY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```python\ndef set_user(user_id, values):\n    user = db.query(\"UPDATE Users WHERE id = {0}\", user_id, values)\n    cache.set(user_id, user)\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 41,
    "Content": "\nWrite-through is a slow overall operation due to the write operation, but subsequent reads of just written data are fast.  Users are generally more tolerant of latency when updating data than reading data.  Data in the cache is not stale.\n\n##### Disadvantage(s): write through\n\n* When a new node is created due to failure or scaling, the new node will not cache entries until the entry is updated in the database.  Cache-aside in conjunction with write through can mitigate this issue.\n* Most data written might never be read, which can be minimized with a TTL.\n\n#### Write-behind (write-back)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>\n</p>\n\nIn write-behind, the application does the following:\n\n* Add/update entry in cache\n* Asynchronously write entry to the data store, improving write performance\n\n##### Disadvantage(s): write-behind\n\n* There could be data loss if the cache goes down prior to its contents hitting the data store.\n* It is more complex to implement write-behind than it is to implement cache-aside or write-through.\n\n#### Refresh-ahead\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>\n</p>\n\nYou can configure the cache to automatically refresh any recently accessed cache entry prior to its expiration.\n\nRefresh-ahead can result in reduced latency vs read-through if the cache can accurately predict which items are likely to be needed in the future.\n\n##### Disadvantage(s): refresh-ahead\n",
    "ContentSha": "7f5A+XWrDoL377SvEQn7a+GkFngcY2VPIRUi5SDADy0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "写入直达（Write-through）由于写操作而整体较慢，但随后读取刚写入的数据速度很快。用户在更新数据时通常对延迟更为容忍，而读取数据时则不然。缓存中的数据不会过时。\n\n##### 缺点：写入直达\n\n* 当由于故障或扩容创建新节点时，直到数据库中条目被更新，新节点才会缓存条目。写入直达配合缓存旁路（Cache-aside）可以缓解此问题。\n* 大部分写入的数据可能永远不会被读取，可以通过设置TTL（生存时间）来最小化这种情况。\n\n#### 写入回写（Write-behind / Write-back）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>来源：可扩展性、可用性、稳定性模式</a></i>\n</p>\n\n在写入回写中，应用程序执行以下操作：\n\n* 在缓存中添加/更新条目\n* 异步将条目写入数据存储，从而提升写入性能\n\n##### 缺点：写入回写\n\n* 如果缓存宕机且内容尚未写入数据存储，可能会导致数据丢失。\n* 实现写入回写比实现缓存旁路或写入直达更复杂。\n\n#### 预刷新（Refresh-ahead）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png\">\n  <br/>\n  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>来源：从缓存到内存数据网格</a></i>\n</p>\n\n您可以配置缓存，在条目过期前自动刷新任何最近访问的缓存条目。\n\n如果缓存能够准确预测未来可能需要的条目，预刷新相比读取穿透可以减少延迟。\n\n##### 缺点：预刷新\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 42,
    "Content": "* Not accurately predicting which items are likely to be needed in the future can result in reduced performance than without refresh-ahead.\n\n### Disadvantage(s): cache\n\n* Need to maintain consistency between caches and the source of truth such as the database through [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms).\n* Cache invalidation is a difficult problem, there is additional complexity associated with when to update the cache.\n* Need to make application changes such as adding Redis or memcached.\n\n### Source(s) and further reading\n\n* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)\n* [Scalable system design patterns](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)\n* [Introduction to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)\n* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [Scalability](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n* [AWS ElastiCache strategies](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)\n* [Wikipedia](https://en.wikipedia.org/wiki/Cache_(computing))\n\n## Asynchronism\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png\">\n  <br/>\n  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>\n</p>\n\nAsynchronous workflows help reduce request times for expensive operations that would otherwise be performed in-line.  They can also help by doing time-consuming work in advance, such as periodic aggregation of data.\n\n### Message queues\n\nMessage queues receive, hold, and deliver messages.  If an operation is too slow to perform inline, you can use a message queue with the following workflow:\n\n* An application publishes a job to the queue, then notifies the user of job status\n* A worker picks up the job from the queue, processes it, then signals the job is complete\n\nThe user is not blocked and the job is processed in the background.  During this time, the client might optionally do a small amount of processing to make it seem like the task has completed.  For example, if posting a tweet, the tweet could be instantly posted to your timeline, but it could take some time before your tweet is actually delivered to all of your followers.\n\n**[Redis](https://redis.io/)** is useful as a simple message broker but messages can be lost.\n\n**[RabbitMQ](https://www.rabbitmq.com/)** is popular but requires you to adapt to the 'AMQP' protocol and manage your own nodes.",
    "ContentSha": "m5CQKaSxoSpqZLBi9DEuTpec6TQ1PuzDQenhKpH7SUw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* 不准确地预测未来可能需要的项目可能导致性能不如没有预刷新时的表现。\n\n### 缺点：缓存\n\n* 需要通过[缓存失效](https://zh.wikipedia.org/wiki/缓存算法)来保持缓存与数据源（如数据库）之间的一致性。\n* 缓存失效是一个难题，何时更新缓存存在额外的复杂性。\n* 需要进行应用改动，如添加 Redis 或 memcached。\n\n### 来源及进一步阅读\n\n* [从缓存到内存数据网格](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)\n* [可扩展系统设计模式](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)\n* [系统架构扩展简介](http://lethain.com/introduction-to-architecting-systems-for-scale/)\n* [可扩展性、可用性、稳定性模式](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)\n* [可扩展性](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)\n* [AWS ElastiCache 策略](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)\n* [维基百科](https://zh.wikipedia.org/wiki/Cache_(computing))\n\n## 异步性\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png\">\n  <br/>\n  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>来源：系统架构扩展简介</a></i>\n</p>\n\n异步工作流有助于减少对昂贵操作的请求时间，这些操作本来会同步执行。它们还可以通过提前完成耗时工作（如定期数据聚合）来发挥作用。\n\n### 消息队列\n\n消息队列用于接收、存储和传递消息。如果操作太慢无法同步执行，可以使用消息队列，流程如下：\n\n* 应用将任务发布到队列，然后通知用户任务状态\n* 工作线程从队列获取任务，处理后标记任务完成\n\n用户不会被阻塞，任务在后台处理。此期间，客户端可以执行少量处理，使任务看起来已完成。例如，发送推文时，推文可以立即显示在时间线上，但实际传递给所有关注者可能需要一些时间。\n\n**[Redis](https://redis.io/)** 是一个简单的消息代理，但消息可能丢失。\n\n**[RabbitMQ](https://www.rabbitmq.com/)** 很受欢迎，但需要适应 'AMQP' 协议并自行管理节点。",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 43,
    "Content": "\n**[Amazon SQS](https://aws.amazon.com/sqs/)** is hosted but can have high latency and has the possibility of messages being delivered twice.\n\n### Task queues\n\nTasks queues receive tasks and their related data, runs them, then delivers their results.  They can support scheduling and can be used to run computationally-intensive jobs in the background.\n\n**[Celery](https://docs.celeryproject.org/en/stable/)** has support for scheduling and primarily has python support.\n\n### Back pressure\n\nIf queues start to grow significantly, the queue size can become larger than memory, resulting in cache misses, disk reads, and even slower performance.  [Back pressure](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) can help by limiting the queue size, thereby maintaining a high throughput rate and good response times for jobs already in the queue.  Once the queue fills up, clients get a server busy or HTTP 503 status code to try again later.  Clients can retry the request at a later time, perhaps with [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff).\n\n### Disadvantage(s): asynchronism\n\n* Use cases such as inexpensive calculations and realtime workflows might be better suited for synchronous operations, as introducing queues can add delays and complexity.\n\n### Source(s) and further reading\n\n* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)\n* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)\n* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)\n* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)\n\n## Communication\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg\">\n  <br/>\n  <i><a href=http://www.escotal.com/osilayer.html>Source: OSI 7 layer model</a></i>\n</p>\n\n### Hypertext transfer protocol (HTTP)\n\nHTTP is a method for encoding and transporting data between a client and a server.  It is a request/response protocol: clients issue requests and servers issue responses with relevant content and completion status info about the request.  HTTP is self-contained, allowing requests and responses to flow through many intermediate routers and servers that perform load balancing, caching, encryption, and compression.\n\nA basic HTTP request consists of a verb (method) and a resource (endpoint).  Below are common HTTP verbs:\n\n| Verb | Description | Idempotent* | Safe | Cacheable |\n|---|---|---|---|---|",
    "ContentSha": "EQovDG9OkNb9dVypgpzwJggXSXWXdn7svWuM8fLZ6Es=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n**[Amazon SQS](https://aws.amazon.com/sqs/)** 是托管服务，但可能存在高延迟，并且消息可能会被重复传递。\n\n### 任务队列\n\n任务队列接收任务及其相关数据，执行任务，然后传递结果。它们支持调度，可用于在后台运行计算密集型作业。\n\n**[Celery](https://docs.celeryproject.org/en/stable/)** 支持调度，主要支持 Python。\n\n### 背压\n\n如果队列开始显著增长，队列大小可能超过内存，导致缓存未命中、磁盘读取，甚至性能更慢。[背压](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) 通过限制队列大小来帮助维持高吞吐率和队列中作业的良好响应时间。一旦队列满了，客户端会收到服务器繁忙或 HTTP 503 状态码，提示稍后重试。客户端可以在稍后时间重试请求，可能采用[指数退避](https://en.wikipedia.org/wiki/Exponential_backoff)。\n\n### 缺点：异步性\n\n* 诸如廉价计算和实时工作流的用例可能更适合同步操作，因为引入队列会增加延迟和复杂性。\n\n### 来源及进一步阅读\n\n* [这全是数字游戏](https://www.youtube.com/watch?v=1KRYH75wgy4)\n* [过载时应用背压](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)\n* [Little 法则](https://en.wikipedia.org/wiki/Little%27s_law)\n* [消息队列和任务队列的区别是什么？](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)\n\n## 通信\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg\">\n  <br/>\n  <i><a href=http://www.escotal.com/osilayer.html>来源：OSI 七层模型</a></i>\n</p>\n\n### 超文本传输协议 (HTTP)\n\nHTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一种请求/响应协议：客户端发出请求，服务器发出包含相关内容和请求完成状态信息的响应。HTTP 是自包含的，允许请求和响应通过执行负载均衡、缓存、加密和压缩的多个中间路由器和服务器。\n\n一个基本的 HTTP 请求由动词（方法）和资源（端点）组成。以下是常见的 HTTP 动词：\n\n| 动词 | 描述 | 幂等* | 安全 | 可缓存 |\n|---|---|---|---|---|",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 44,
    "Content": "| GET | Reads a resource | Yes | Yes | Yes |\n| POST | Creates a resource or trigger a process that handles data | No | No | Yes if response contains freshness info |\n| PUT | Creates or replace a resource | Yes | No | No |\n| PATCH | Partially updates a resource | No | No | Yes if response contains freshness info |\n| DELETE | Deletes a resource | Yes | No | No |\n\n*Can be called many times without different outcomes.\n\nHTTP is an application layer protocol relying on lower-level protocols such as **TCP** and **UDP**.\n\n#### Source(s) and further reading: HTTP\n\n* [What is HTTP?](https://www.nginx.com/resources/glossary/http/)\n* [Difference between HTTP and TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)\n* [Difference between PUT and PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)\n\n### Transmission control protocol (TCP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>\n</p>\n\nTCP is a connection-oriented protocol over an [IP network](https://en.wikipedia.org/wiki/Internet_Protocol).  Connection is established and terminated using a [handshake](https://en.wikipedia.org/wiki/Handshaking).  All packets sent are guaranteed to reach the destination in the original order and without corruption through:\n\n* Sequence numbers and [checksum fields](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) for each packet\n* [Acknowledgement](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) packets and automatic retransmission\n\nIf the sender does not receive a correct response, it will resend the packets.  If there are multiple timeouts, the connection is dropped.  TCP also implements [flow control](https://en.wikipedia.org/wiki/Flow_control_(data)) and [congestion control](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control).  These guarantees cause delays and generally result in less efficient transmission than UDP.\n\nTo ensure high throughput, web servers can keep a large number of TCP connections open, resulting in high memory usage.  It can be expensive to have a large number of open connections between web server threads and say, a [memcached](https://memcached.org/) server.  [Connection pooling](https://en.wikipedia.org/wiki/Connection_pool) can help in addition to switching to UDP where applicable.\n\nTCP is useful for applications that require high reliability but are less time critical.  Some examples include web servers, database info, SMTP, FTP, and SSH.\n\nUse TCP over UDP when:\n\n* You need all of the data to arrive intact\n* You want to automatically make a best estimate use of the network throughput\n",
    "ContentSha": "EP5TmrahE1oj6DWbBMp+YEc76iteUbB8TKDGw6d8MFY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| GET | 读取资源 | 是 | 是 | 是 |\n| POST | 创建资源或触发处理数据的进程 | 否 | 否 | 如果响应包含新鲜度信息，则是 |\n| PUT | 创建或替换资源 | 是 | 否 | 否 |\n| PATCH | 部分更新资源 | 否 | 否 | 如果响应包含新鲜度信息，则是 |\n| DELETE | 删除资源 | 是 | 否 | 否 |\n\n* 可以多次调用而不会产生不同的结果。\n\nHTTP 是一种应用层协议，依赖于诸如 **TCP** 和 **UDP** 之类的底层协议。\n\n#### 来源及进一步阅读：HTTP\n\n* [什么是 HTTP？](https://www.nginx.com/resources/glossary/http/)\n* [HTTP 和 TCP 的区别](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)\n* [PUT 与 PATCH 的区别](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)\n\n### 传输控制协议（TCP）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>来源：如何制作多人游戏</a></i>\n</p>\n\nTCP 是基于 [IP 网络](https://en.wikipedia.org/wiki/Internet_Protocol) 的面向连接的协议。连接通过 [握手](https://en.wikipedia.org/wiki/Handshaking) 建立和终止。所有发送的数据包都保证以原始顺序且无损坏地到达目的地，通过：\n\n* 每个数据包的序列号和 [校验和字段](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation)\n* [确认](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) 数据包和自动重传\n\n如果发送方没有收到正确响应，它将重新发送数据包。如果多次超时，连接将被断开。TCP 还实现了 [流量控制](https://en.wikipedia.org/wiki/Flow_control_(data)) 和 [拥塞控制](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control)。这些保障会导致延迟，并且通常比 UDP 传输效率低。\n\n为了确保高吞吐量，Web 服务器可以保持大量 TCP 连接打开，导致高内存使用。在 Web 服务器线程与例如 [memcached](https://memcached.org/) 服务器之间保持大量打开连接可能代价高昂。除了在适用情况下切换到 UDP，使用 [连接池](https://en.wikipedia.org/wiki/Connection_pool) 也能有所帮助。\n\nTCP 适用于需要高可靠性但对时间要求不高的应用。一些例子包括 Web 服务器、数据库信息、SMTP、FTP 和 SSH。\n\n在以下情况下使用 TCP 而非 UDP：\n\n* 你需要所有数据完整无损地到达\n* 你希望自动尽可能高效地利用网络吞吐量\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 45,
    "Content": "### User datagram protocol (UDP)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>\n</p>\n\nUDP is connectionless.  Datagrams (analogous to packets) are guaranteed only at the datagram level.  Datagrams might reach their destination out of order or not at all.  UDP does not support congestion control.  Without the guarantees that TCP support, UDP is generally more efficient.\n\nUDP can broadcast, sending datagrams to all devices on the subnet.  This is useful with [DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) because the client has not yet received an IP address, thus preventing a way for TCP to stream without the IP address.\n\nUDP is less reliable but works well in real time use cases such as VoIP, video chat, streaming, and realtime multiplayer games.\n\nUse UDP over TCP when:\n\n* You need the lowest latency\n* Late data is worse than loss of data\n* You want to implement your own error correction\n\n#### Source(s) and further reading: TCP and UDP\n\n* [Networking for game programming](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)\n* [Key differences between TCP and UDP protocols](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)\n* [Difference between TCP and UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)\n* [Transmission control protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)\n* [User datagram protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)\n* [Scaling memcache at Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)\n\n### Remote procedure call (RPC)\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png\">\n  <br/>\n  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Source: Crack the system design interview</a></i>\n</p>\n\nIn an RPC, a client causes a procedure to execute on a different address space, usually a remote server.  The procedure is coded as if it were a local procedure call, abstracting away the details of how to communicate with the server from the client program.  Remote calls are usually slower and less reliable than local calls so it is helpful to distinguish RPC calls from local calls.  Popular RPC frameworks include [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/), and [Avro](https://avro.apache.org/docs/current/).\n\nRPC is a request-response protocol:",
    "ContentSha": "qWH5LAPvggn7k7ivyK8v6v8/pTXkZRoURbzBFakhSEM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 用户数据报协议（UDP）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg\">\n  <br/>\n  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>来源：如何制作多人游戏</a></i>\n</p>\n\nUDP 是无连接的。数据报（类似于数据包）仅在数据报级别被保证。数据报可能乱序到达目的地，甚至根本无法到达。UDP 不支持拥塞控制。由于缺乏 TCP 提供的保证，UDP 通常更高效。\n\nUDP 可以广播，向子网内所有设备发送数据报。这在 [DHCP](https://zh.wikipedia.org/wiki/动态主机配置协议) 中非常有用，因为客户端尚未收到 IP 地址，因此 TCP 无法在没有 IP 地址的情况下进行流传输。\n\nUDP 可靠性较低，但在 VoIP、视频聊天、流媒体和实时多人游戏等实时应用中表现良好。\n\n在以下情况下使用 UDP 而非 TCP：\n\n* 你需要最低的延迟\n* 延迟的数据比数据丢失更糟\n* 你想实现自己的错误纠正\n\n#### 来源及进一步阅读：TCP 和 UDP\n\n* [游戏编程的网络](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)\n* [TCP 和 UDP 协议的主要区别](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)\n* [TCP 和 UDP 的区别](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)\n* [传输控制协议](https://zh.wikipedia.org/wiki/传输控制协议)\n* [用户数据报协议](https://zh.wikipedia.org/wiki/用户数据报协议)\n* [Facebook 的 memcache 扩展](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)\n\n### 远程过程调用（RPC）\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png\">\n  <br/>\n  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>来源：破解系统设计面试</a></i>\n</p>\n\n在 RPC 中，客户端使一个过程在不同的地址空间上执行，通常是远程服务器。该过程的编码方式就像本地过程调用一样，抽象了如何与服务器通信的细节，客户端程序无需关心。远程调用通常比本地调用更慢且不那么可靠，因此区分 RPC 调用和本地调用是有帮助的。流行的 RPC 框架包括 [Protobuf](https://developers.google.com/protocol-buffers/)、[Thrift](https://thrift.apache.org/) 和 [Avro](https://avro.apache.org/docs/current/)。\n\nRPC 是一种请求-响应协议：",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 46,
    "Content": "\n* **Client program** - Calls the client stub procedure.  The parameters are pushed onto the stack like a local procedure call.\n* **Client stub procedure** - Marshals (packs) procedure id and arguments into a request message.\n* **Client communication module** - OS sends the message from the client to the server.\n* **Server communication module** - OS passes the incoming packets to the server stub procedure.\n* **Server stub procedure** -  Unmarshalls the results, calls the server procedure matching the procedure id and passes the given arguments.\n* The server response repeats the steps above in reverse order.\n\nSample RPC calls:\n",
    "ContentSha": "5PmI2LbQPBewUn/2iz277V+TkEFWqKJeqfFmrsij1fA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n* **客户端程序** - 调用客户端存根过程。参数像本地过程调用一样被压入堆栈。\n* **客户端存根过程** - 将过程ID和参数封装（打包）到请求消息中。\n* **客户端通信模块** - 操作系统将消息从客户端发送到服务器。\n* **服务器通信模块** - 操作系统将接收到的数据包传递给服务器存根过程。\n* **服务器存根过程** - 解封（解包）结果，调用与过程ID匹配的服务器过程并传递给定的参数。\n* 服务器响应按照上述步骤的逆序重复执行。\n\n示例RPC调用：\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 47,
    "Content": "```\nGET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  \"data\":\"anId\";\n  \"anotherdata\": \"another value\"\n}\n```",
    "ContentSha": "BYLxUnd5OWhXrWTwm++n0cxi7AnIAvtoL/RnYPfjXXk=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nGET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  \"data\":\"anId\";\n  \"anotherdata\": \"another value\"\n}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 48,
    "Content": "\nRPC is focused on exposing behaviors.  RPCs are often used for performance reasons with internal communications, as you can hand-craft native calls to better fit your use cases.\n\nChoose a native library (aka SDK) when:\n\n* You know your target platform.\n* You want to control how your \"logic\" is accessed.\n* You want to control how error control happens off your library.\n* Performance and end user experience is your primary concern.\n\nHTTP APIs following **REST** tend to be used more often for public APIs.\n\n#### Disadvantage(s): RPC\n\n* RPC clients become tightly coupled to the service implementation.\n* A new API must be defined for every new operation or use case.\n* It can be difficult to debug RPC.\n* You might not be able to leverage existing technologies out of the box.  For example, it might require additional effort to ensure [RPC calls are properly cached](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) on caching servers such as [Squid](http://www.squid-cache.org/).\n\n### Representational state transfer (REST)\n\nREST is an architectural style enforcing a client/server model where the client acts on a set of resources managed by the server.  The server provides a representation of resources and actions that can either manipulate or get a new representation of resources.  All communication must be stateless and cacheable.\n\nThere are four qualities of a RESTful interface:\n\n* **Identify resources (URI in HTTP)** - use the same URI regardless of any operation.\n* **Change with representations (Verbs in HTTP)** - use verbs, headers, and body.\n* **Self-descriptive error message (status response in HTTP)** - Use status codes, don't reinvent the wheel.\n* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML interface for HTTP)** - your web service should be fully accessible in a browser.\n\nSample REST calls:\n",
    "ContentSha": "Rt/8zO9jLRQq0DxNqYrouOd/1z3QvXPXQYsN4u7rca0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "RPC 专注于暴露行为。RPC 通常用于内部通信以提升性能，因为你可以手工编写本地调用以更好地适应你的用例。\n\n选择本地库（即 SDK）时：\n\n* 你知道你的目标平台。\n* 你想控制你的“逻辑”如何被访问。\n* 你想控制库外的错误控制方式。\n* 性能和最终用户体验是你的主要关注点。\n\n遵循 **REST** 的 HTTP API 更常用于公共 API。\n\n#### 缺点：RPC\n\n* RPC 客户端与服务实现紧密耦合。\n* 每个新操作或用例都必须定义新的 API。\n* 调试 RPC 可能很困难。\n* 你可能无法开箱即用地利用现有技术。例如，可能需要额外工作来确保 [RPC 调用被适当缓存](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) 于如 [Squid](http://www.squid-cache.org/) 等缓存服务器上。\n\n### 表现层状态转移 (REST)\n\nREST 是一种架构风格，强制执行客户端/服务器模型，其中客户端对服务器管理的一组资源进行操作。服务器提供资源的表现形式和可以操作或获取新资源表现形式的动作。所有通信必须是无状态且可缓存的。\n\nRESTful 接口有四个特性：\n\n* **识别资源（HTTP 中的 URI）** - 无论任何操作，使用相同的 URI。\n* **通过表现形式改变（HTTP 中的动词）** - 使用动词、头部和主体。\n* **自描述错误信息（HTTP 中的状态响应）** - 使用状态码，不要重新发明轮子。\n* **[HATEOAS](http://restcookbook.com/Basics/hateoas/)（HTTP 的 HTML 界面）** - 你的 Web 服务应可在浏览器中完全访问。\n\nREST 调用示例：\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 49,
    "Content": "```\nGET /someresources/anId\n\nPUT /someresources/anId\n{\"anotherdata\": \"another value\"}\n```",
    "ContentSha": "LfYrdSaJCXPWw5FeIGqODwCXjq6vLSYullHQ6dtLt9M=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nGET /someresources/anId\n\nPUT /someresources/anId\n{\"anotherdata\": \"another value\"}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 50,
    "Content": "\nREST is focused on exposing data.  It minimizes the coupling between client/server and is often used for public HTTP APIs.  REST uses a more generic and uniform method of exposing resources through URIs, [representation through headers](https://github.com/for-GET/know-your-http-well/blob/master/headers.md), and actions through verbs such as GET, POST, PUT, DELETE, and PATCH.  Being stateless, REST is great for horizontal scaling and partitioning.\n\n#### Disadvantage(s): REST\n\n* With REST being focused on exposing data, it might not be a good fit if resources are not naturally organized or accessed in a simple hierarchy.  For example, returning all updated records from the past hour matching a particular set of events is not easily expressed as a path.  With REST, it is likely to be implemented with a combination of URI path, query parameters, and possibly the request body.\n* REST typically relies on a few verbs (GET, POST, PUT, DELETE, and PATCH) which sometimes doesn't fit your use case.  For example, moving expired documents to the archive folder might not cleanly fit within these verbs.\n* Fetching complicated resources with nested hierarchies requires multiple round trips between the client and server to render single views, e.g. fetching content of a blog entry and the comments on that entry. For mobile applications operating in variable network conditions, these multiple roundtrips are highly undesirable.\n* Over time, more fields might be added to an API response and older clients will receive all new data fields, even those that they do not need, as a result, it bloats the payload size and leads to larger latencies.\n\n### RPC and REST calls comparison\n\n| Operation | RPC | REST |\n|---|---|---|\n| Signup    | **POST** /signup | **POST** /persons |\n| Resign    | **POST** /resign<br/>{<br/>\"personid\": \"1234\"<br/>} | **DELETE** /persons/1234 |\n| Read a person | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |\n| Read a person’s items list | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |\n| Add an item to a person’s items | **POST** /addItemToUsersItemsList<br/>{<br/>\"personid\": \"1234\";<br/>\"itemid\": \"456\"<br/>} | **POST** /persons/1234/items<br/>{<br/>\"itemid\": \"456\"<br/>} |\n| Update an item    | **POST** /modifyItem<br/>{<br/>\"itemid\": \"456\";<br/>\"key\": \"value\"<br/>} | **PUT** /items/456<br/>{<br/>\"key\": \"value\"<br/>} |\n| Delete an item | **POST** /removeItem<br/>{<br/>\"itemid\": \"456\"<br/>} | **DELETE** /items/456 |\n\n<p align=\"center\">\n  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Source: Do you really know why you prefer REST over RPC</a></i>\n</p>\n\n#### Source(s) and further reading: REST and RPC\n\n* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)\n* [When are RPC-ish approaches more appropriate than REST?](http://programmers.stackexchange.com/a/181186)\n* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)\n* [Debunking the myths of RPC and REST](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)\n* [What are the drawbacks of using REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)\n* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Thrift](https://code.facebook.com/posts/1468950976659943/)\n* [Why REST for internal use and not RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)\n\n## Security\n\nThis section could use some updates.  Consider [contributing](#contributing)!",
    "ContentSha": "SY9oRc1IgrKNdRZI1YEjzyytSRn6DjylmnfEWHK6KsU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "REST 专注于数据的暴露。它最大限度地减少了客户端/服务器之间的耦合，通常用于公共 HTTP API。REST 通过 URI、[通过头部的表示](https://github.com/for-GET/know-your-http-well/blob/master/headers.md) 以及通过诸如 GET、POST、PUT、DELETE 和 PATCH 之类的动词来使用更通用和统一的方法暴露资源。由于是无状态的，REST 非常适合水平扩展和分区。\n\n#### 缺点：REST\n\n* 由于 REST 专注于数据的暴露，如果资源本身没有自然组织或以简单的层级方式访问，可能不太适用。例如，返回过去一小时内所有符合特定事件集合的更新记录不容易用路径表达。使用 REST，通常通过 URI 路径、查询参数以及可能的请求体组合来实现。\n* REST 通常依赖于少数几个动词（GET、POST、PUT、DELETE 和 PATCH），有时无法满足您的用例。例如，将过期文档移动到归档文件夹可能无法很好地适应这些动词。\n* 获取具有嵌套层级的复杂资源需要客户端和服务器之间多次往返以渲染单个视图，例如获取博客条目的内容及该条目的评论。对于在不稳定网络条件下运行的移动应用，这些多次往返是非常不理想的。\n* 随着时间推移，API 响应中可能会添加更多字段，旧客户端会接收所有新字段，即使它们不需要，这会导致有效载荷膨胀并增加延迟。\n\n### RPC 和 REST 调用比较\n\n| 操作 | RPC | REST |\n|---|---|---|\n| 注册    | **POST** /signup | **POST** /persons |\n| 辞职    | **POST** /resign<br/>{<br/>\"personid\": \"1234\"<br/>} | **DELETE** /persons/1234 |\n| 读取某人 | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |\n| 读取某人的物品列表 | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |\n| 向某人物品列表添加物品 | **POST** /addItemToUsersItemsList<br/>{<br/>\"personid\": \"1234\";<br/>\"itemid\": \"456\"<br/>} | **POST** /persons/1234/items<br/>{<br/>\"itemid\": \"456\"<br/>} |\n| 更新物品    | **POST** /modifyItem<br/>{<br/>\"itemid\": \"456\";<br/>\"key\": \"value\"<br/>} | **PUT** /items/456<br/>{<br/>\"key\": \"value\"<br/>} |\n| 删除物品 | **POST** /removeItem<br/>{<br/>\"itemid\": \"456\"<br/>} | **DELETE** /items/456 |\n\n<p align=\"center\">\n  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>来源：你真的知道为什么你更喜欢 REST 而不是 RPC 吗</a></i>\n</p>\n\n#### 来源及进一步阅读：REST 和 RPC\n\n* [你真的知道为什么你更喜欢 REST 而不是 RPC 吗](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)\n* [什么时候 RPC 式方法比 REST 更合适？](http://programmers.stackexchange.com/a/181186)\n* [REST 与 JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)\n* [揭穿 RPC 和 REST 的神话](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)\n* [使用 REST 的缺点是什么](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)\n* [破解系统设计面试](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n* [Thrift](https://code.facebook.com/posts/1468950976659943/)\n* [为什么内部使用 REST 而不是 RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)\n\n## 安全\n\n本节内容需要更新。欢迎[贡献](#contributing)！\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 51,
    "Content": "\nSecurity is a broad topic.  Unless you have considerable experience, a security background, or are applying for a position that requires knowledge of security, you probably won't need to know more than the basics:\n\n* Encrypt in transit and at rest.\n* Sanitize all user inputs or any input parameters exposed to user to prevent [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) and [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* Use parameterized queries to prevent SQL injection.\n* Use the principle of [least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege).\n\n### Source(s) and further reading\n\n* [API security checklist](https://github.com/shieldfy/API-Security-Checklist)\n* [Security guide for developers](https://github.com/FallibleInc/security-guide-for-developers)\n* [OWASP top ten](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)\n\n## Appendix\n\nYou'll sometimes be asked to do 'back-of-the-envelope' estimates.  For example, you might need to determine how long it will take to generate 100 image thumbnails from disk or how much memory a data structure will take.  The **Powers of two table** and **Latency numbers every programmer should know** are handy references.\n\n### Powers of two table\n",
    "ContentSha": "lttd9OX13KgyFAZReRo/UiwT2DoGI4tHaEGVoAH3mCA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "安全是一个广泛的话题。除非你有丰富的经验、安全背景，或者申请的职位需要安全知识，否则你可能只需要了解基础知识：\n\n* 传输和存储时加密。\n* 清理所有用户输入或任何暴露给用户的输入参数，以防止[XSS](https://en.wikipedia.org/wiki/Cross-site_scripting)和[SQL注入](https://en.wikipedia.org/wiki/SQL_injection)。\n* 使用参数化查询以防止SQL注入。\n* 使用[最小权限原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)。\n\n### 来源及进一步阅读\n\n* [API安全清单](https://github.com/shieldfy/API-Security-Checklist)\n* [开发者安全指南](https://github.com/FallibleInc/security-guide-for-developers)\n* [OWASP十大](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)\n\n## 附录\n\n有时你会被要求做“信封背面”的估算。例如，你可能需要确定从磁盘生成100个图像缩略图需要多长时间，或者一个数据结构会占用多少内存。**二的幂表**和**每个程序员都应了解的延迟数字**是很好的参考资料。\n\n### 二的幂表\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 52,
    "Content": "```\nPower           Exact Value         Approx Value        Bytes\n---------------------------------------------------------------\n7                             128\n8                             256\n10                           1024   1 thousand           1 KB\n16                         65,536                       64 KB\n20                      1,048,576   1 million            1 MB\n30                  1,073,741,824   1 billion            1 GB\n32                  4,294,967,296                        4 GB\n40              1,099,511,627,776   1 trillion           1 TB\n```",
    "ContentSha": "tY3s4yO7vTGsjW+GZNlakuBkrCR3FXNKe9N9AYlzPrU=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nPower           Exact Value         Approx Value        Bytes\n---------------------------------------------------------------\n7                             128\n8                             256\n10                           1024   1 thousand           1 KB\n16                         65,536                       64 KB\n20                      1,048,576   1 million            1 MB\n30                  1,073,741,824   1 billion            1 GB\n32                  4,294,967,296                        4 GB\n40              1,099,511,627,776   1 trillion           1 TB\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 53,
    "Content": "\n#### Source(s) and further reading\n\n* [Powers of two](https://en.wikipedia.org/wiki/Power_of_two)\n\n### Latency numbers every programmer should know\n",
    "ContentSha": "ppBLjl4GPpTTuZuZkRCmUB3lr0F/LbyDBiLBdXbuDDw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n#### 来源及进一步阅读\n\n* [二的幂](https://en.wikipedia.org/wiki/Power_of_two)\n\n### 每个程序员都应了解的延迟数字\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 54,
    "Content": "```\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy            10,000   ns       10 us\nSend 1 KB bytes over 1 Gbps network     10,000   ns       10 us\nRead 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nHDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD\nRead 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns\n```",
    "ContentSha": "Cxjssj59JwVoJhpDLS31tIAyvakR0WQUIHZP4hMVLy8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy            10,000   ns       10 us\nSend 1 KB bytes over 1 Gbps network     10,000   ns       10 us\nRead 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nHDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD\nRead 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 55,
    "Content": "\nHandy metrics based on numbers above:\n\n* Read sequentially from HDD at 30 MB/s\n* Read sequentially from 1 Gbps Ethernet at 100 MB/s\n* Read sequentially from SSD at 1 GB/s\n* Read sequentially from main memory at 4 GB/s\n* 6-7 world-wide round trips per second\n* 2,000 round trips per second within a data center\n\n#### Latency numbers visualized\n\n![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)\n\n#### Source(s) and further reading\n\n* [Latency numbers every programmer should know - 1](https://gist.github.com/jboner/2841832)\n* [Latency numbers every programmer should know - 2](https://gist.github.com/hellerbarde/2843375)\n* [Designs, lessons, and advice from building large distributed systems](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)\n* [Software Engineering Advice from Building Large-Scale Distributed Systems](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)\n\n### Additional system design interview questions\n\n> Common system design interview questions, with links to resources on how to solve each.\n\n| Question | Reference(s) |\n|---|---|\n| Design a file sync service like Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| Design a search engine like Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |\n| Design a scalable web crawler like Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |\n| Design Google docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |\n| Design a key-value store like Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| Design a cache system like Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Design a recommendation system like Amazon's | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |\n| Design a tinyurl system like Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |\n| Design a chat app like WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)\n| Design a picture sharing system like Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |\n| Design the Facebook news feed function | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |\n| Design the Facebook timeline function | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |\n| Design the Facebook chat function | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |",
    "ContentSha": "ufMEAJjeJvG/71zGm1ZrFnYShGruhPDGcpEQX8jnGIY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "基于以上数字的实用指标：\n\n* 从 HDD 顺序读取速度为 30 MB/s\n* 从 1 Gbps 以太网顺序读取速度为 100 MB/s\n* 从 SSD 顺序读取速度为 1 GB/s\n* 从主内存顺序读取速度为 4 GB/s\n* 每秒 6-7 次全球范围往返\n* 数据中心内每秒 2000 次往返\n\n#### 延迟数字可视化\n\n![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)\n\n#### 来源及进一步阅读\n\n* [每个程序员都该知道的延迟数字 - 1](https://gist.github.com/jboner/2841832)\n* [每个程序员都该知道的延迟数字 - 2](https://gist.github.com/hellerbarde/2843375)\n* [构建大型分布式系统的设计、经验与建议](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)\n* [构建大规模分布式系统的软件工程建议](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)\n\n### 额外的系统设计面试题\n\n> 常见系统设计面试题，附带解决资源链接。\n\n| 问题 | 参考资料 |\n|---|---|\n| 设计一个类似 Dropbox 的文件同步服务 | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| 设计一个类似 Google 的搜索引擎 | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |\n| 设计一个类似 Google 的可扩展网络爬虫 | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |\n| 设计 Google 文档 | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |\n| 设计一个类似 Redis 的键值存储 | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| 设计一个类似 Memcached 的缓存系统 | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| 设计一个类似亚马逊的推荐系统 | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |\n| 设计一个类似 Bitly 的短链接系统 | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |\n| 设计一个类似 WhatsApp 的聊天应用 | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| 设计一个类似 Instagram 的图片分享系统 | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |\n| 设计 Facebook 新闻推送功能 | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |\n| 设计 Facebook 时间线功能 | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |\n| 设计 Facebook 聊天功能 | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 56,
    "Content": "| Design a graph search function like Facebook's | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |\n| Design a content delivery network like CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |\n| Design a trending topic system like Twitter's | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |\n| Design a random ID generation system | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |\n| Return the top k requests during a time interval | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |\n| Design a system that serves data from multiple data centers | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |\n| Design an online multiplayer card game | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |\n| Design a garbage collection system | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |\n| Design an API rate limiter | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |\n| Design a Stock Exchange (like NASDAQ or Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |\n| Add a system design question | [Contribute](#contributing) |\n\n### Real world architectures\n\n> Articles on how real world systems are designed.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Source: Twitter timelines at scale</a></i>\n</p>\n\n**Don't focus on nitty gritty details for the following articles, instead:**\n\n* Identify shared principles, common technologies, and patterns within these articles\n* Study what problems are solved by each component, where it works, where it doesn't\n* Review the lessons learned\n\n|Type | System | Reference(s) |\n|---|---|---|\n| Data processing | **MapReduce** - Distributed data processing from Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |\n| Data processing | **Spark** - Distributed data processing from Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |\n| Data processing | **Storm** - Distributed data processing from Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |\n| | | |\n| Data store | **Bigtable** - Distributed column-oriented database from Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |\n| Data store | **HBase** - Open source implementation of Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |\n| Data store | **Cassandra** - Distributed column-oriented database from Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)\n| Data store | **DynamoDB** - Document-oriented database from Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |\n| Data store | **MongoDB** - Document-oriented database | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |\n| Data store | **Spanner** - Globally-distributed database from Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |",
    "ContentSha": "5hNQndfbSnlP1RLa/GyRt8pzzHWJN34J9g6lOThi724=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| 设计一个类似 Facebook 的图搜索功能 | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |\n| 设计一个类似 CloudFlare 的内容分发网络 | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |\n| 设计一个类似 Twitter 的热门话题系统 | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |\n| 设计一个随机 ID 生成系统 | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |\n| 返回某一时间区间内的前 k 个请求 | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |\n| 设计一个从多个数据中心提供数据的系统 | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |\n| 设计一个在线多人纸牌游戏 | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |\n| 设计一个垃圾回收系统 | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |\n| 设计一个 API 速率限制器 | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |\n| 设计一个股票交易所（如 NASDAQ 或 Binance） | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang 实现](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go 实现](http://bhomnick.net/building-a-simple-limit-order-in-go/) |\n| 添加一个系统设计问题 | [贡献](#contributing) |\n\n### 现实世界架构\n\n> 关于现实世界系统设计的文章。\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png\">\n  <br/>\n  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>来源：Twitter 时间线的可扩展性</a></i>\n</p>\n\n**以下文章不要关注细枝末节，而应：**\n\n* 识别文章中共享的原则、常用技术和模式\n* 研究每个组件解决了什么问题，适用场景和局限\n* 回顾所学到的经验教训\n\n| 类型 | 系统 | 参考资料 |\n|---|---|---|\n| 数据处理 | **MapReduce** - Google 的分布式数据处理 | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |\n| 数据处理 | **Spark** - Databricks 的分布式数据处理 | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |\n| 数据处理 | **Storm** - Twitter 的分布式数据处理 | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |\n| | | |\n| 数据存储 | **Bigtable** - Google 的分布式列式数据库 | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |\n| 数据存储 | **HBase** - Bigtable 的开源实现 | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |\n| 数据存储 | **Cassandra** - Facebook 的分布式列式数据库 | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666) |\n| 数据存储 | **DynamoDB** - Amazon 的文档数据库 | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |\n| 数据存储 | **MongoDB** - 文档数据库 | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |\n| 数据存储 | **Spanner** - Google 的全球分布式数据库 | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 57,
    "Content": "| Data store | **Memcached** - Distributed memory caching system | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| Data store | **Redis** - Distributed memory caching system with persistence and value types | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| | | |\n| File system | **Google File System (GFS)** - Distributed file system | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |\n| File system | **Hadoop File System (HDFS)** - Open source implementation of GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |\n| | | |\n| Misc | **Chubby** - Lock service for loosely-coupled distributed systems from Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |\n| Misc | **Dapper** - Distributed systems tracing infrastructure | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)\n| Misc | **Kafka** - Pub/sub message queue from LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |\n| Misc | **Zookeeper** - Centralized infrastructure and services enabling synchronization | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |\n| | Add an architecture | [Contribute](#contributing) |\n\n### Company architectures\n\n| Company | Reference(s) |\n|---|---|\n| Amazon | [Amazon architecture](http://highscalability.com/amazon-architecture) |\n| Cinchcast | [Producing 1,500 hours of audio every day](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |\n| DataSift | [Realtime datamining At 120,000 tweets per second](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |\n| Dropbox | [How we've scaled Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| ESPN | [Operating At 100,000 duh nuh nuhs per second](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |\n| Google | [Google architecture](http://highscalability.com/google-architecture) |\n| Instagram | [14 million users, terabytes of photos](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[What powers Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |\n| Justin.tv | [Justin.Tv's live video broadcasting architecture](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |\n| Facebook | [Scaling memcached at Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebook’s distributed data store for the social graph](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook’s photo storage](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[How Facebook Live Streams To 800,000 Simultaneous Viewers](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |\n| Flickr | [Flickr architecture](http://highscalability.com/flickr-architecture) |\n| Mailbox | [From 0 to one million users in 6 weeks](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |\n| Netflix | [A 360 Degree View Of The Entire Netflix Stack](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: What Happens When You Press Play?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |\n| Pinterest | [From 0 To 10s of billions of page views a month](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 million visitors, 10x growth, 12 employees](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |\n| Playfish | [50 million monthly users and growing](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |\n| PlentyOfFish | [PlentyOfFish architecture](http://highscalability.com/plentyoffish-architecture) |\n| Salesforce | [How they handle 1.3 billion transactions a day](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |\n| Stack Overflow | [Stack Overflow architecture](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |\n| TripAdvisor | [40M visitors, 200M dynamic page views, 30TB data](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |\n| Tumblr | [15 billion page views a month](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |\n| Twitter | [Making Twitter 10000 percent faster](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Storing 250 million tweets a day using MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M active users, 300K QPS, a 22 MB/S firehose](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Timelines at scale](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Big and small data at Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operations at Twitter: scaling beyond 100 million users](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[How Twitter Handles 3,000 Images Per Second](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |\n| Uber | [How Uber scales their real-time market platform](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lessons Learned From Scaling Uber To 2000 Engineers, 1000 Services, And 8000 Git Repositories](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |\n| WhatsApp | [The WhatsApp architecture Facebook bought for $19 billion](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| YouTube | [YouTube scalability](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube architecture](http://highscalability.com/youtube-architecture) |\n",
    "ContentSha": "HJ43cGa2ts5Z1+EHjvCRBV9mq+PjUY5QXfwqLIs80oA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "| 数据存储 | **Memcached** - 分布式内存缓存系统 | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |\n| 数据存储 | **Redis** - 具有持久化和多种值类型的分布式内存缓存系统 | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |\n| | | |\n| 文件系统 | **谷歌文件系统 (GFS)** - 分布式文件系统 | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |\n| 文件系统 | **Hadoop 文件系统 (HDFS)** - GFS 的开源实现 | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |\n| | | |\n| 其他 | **Chubby** - 谷歌为松耦合分布式系统提供的锁服务 | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |\n| 其他 | **Dapper** - 分布式系统追踪基础设施 | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)\n| 其他 | **Kafka** - 来自 LinkedIn 的发布/订阅消息队列 | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |\n| 其他 | **Zookeeper** - 实现同步的集中式基础设施和服务 | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |\n| | 添加一个架构 | [贡献](#contributing) |\n\n### 公司架构\n\n| 公司 | 参考资料 |\n|---|---|\n| 亚马逊 | [亚马逊架构](http://highscalability.com/amazon-architecture) |\n| Cinchcast | [每天生产1500小时音频](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |\n| DataSift | [每秒12万条推文的实时数据挖掘](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |\n| Dropbox | [我们如何扩展 Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |\n| ESPN | [每秒10万“呃呃呃”操作的运行](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |\n| 谷歌 | [谷歌架构](http://highscalability.com/google-architecture) |\n| Instagram | [1400万用户，数TB照片](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Instagram的动力](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |\n| Justin.tv | [Justin.Tv 的直播视频广播架构](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |\n| Facebook | [Facebook 上的 memcached 扩展](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO：Facebook 社交图的分布式数据存储](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook 的照片存储](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Facebook 实时直播给80万同时观看者](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |\n| Flickr | [Flickr 架构](http://highscalability.com/flickr-architecture) |\n| Mailbox | [6周内从0到100万用户](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |\n| Netflix | [Netflix 全栈360度视图](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix：按下播放键会发生什么？](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |\n| Pinterest | [从0到数百亿月页面浏览量](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[1800万访客，10倍增长，12名员工](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |\n| Playfish | [5000万月活用户且持续增长](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |\n| PlentyOfFish | [PlentyOfFish 架构](http://highscalability.com/plentyoffish-architecture) |\n| Salesforce | [每天处理13亿交易](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |\n| Stack Overflow | [Stack Overflow 架构](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |\n| TripAdvisor | [4000万访客，2亿动态页面浏览，30TB数据](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |\n| Tumblr | [每月150亿页面浏览量](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |\n| Twitter | [让 Twitter 快1万倍](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[使用 MySQL 存储每天2.5亿条推文](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[1.5亿活跃用户，30万QPS，22MB/s数据流](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[大规模时间线](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Twitter 的大数据与小数据](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Twitter 运维：超越1亿用户的扩展](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[Twitter 如何处理每秒3000张图片](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |\n| Uber | [Uber 如何扩展其实时市场平台](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[扩展 Uber 到2000名工程师、1000个服务和8000个 Git 仓库的经验教训](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |\n| WhatsApp | [Facebook 以190亿美元收购的 WhatsApp 架构](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |\n| YouTube | [YouTube 可扩展性](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube 架构](http://highscalability.com/youtube-architecture) |\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 58,
    "Content": "### Company engineering blogs\n\n> Architectures for companies you are interviewing with.\n>\n> Questions you encounter might be from the same domain.\n\n* [Airbnb Engineering](http://nerds.airbnb.com/)\n* [Atlassian Developers](https://developer.atlassian.com/blog/)\n* [AWS Blog](https://aws.amazon.com/blogs/aws/)\n* [Bitly Engineering Blog](http://word.bitly.com/)\n* [Box Blogs](https://blog.box.com/blog/category/engineering)\n* [Cloudera Developer Blog](http://blog.cloudera.com/)\n* [Dropbox Tech Blog](https://tech.dropbox.com/)\n* [Engineering at Quora](https://www.quora.com/q/quoraengineering)\n* [Ebay Tech Blog](http://www.ebaytechblog.com/)\n* [Evernote Tech Blog](https://blog.evernote.com/tech/)\n* [Etsy Code as Craft](http://codeascraft.com/)\n* [Facebook Engineering](https://www.facebook.com/Engineering)\n* [Flickr Code](http://code.flickr.net/)\n* [Foursquare Engineering Blog](http://engineering.foursquare.com/)\n* [GitHub Engineering Blog](https://github.blog/category/engineering)\n* [Google Research Blog](http://googleresearch.blogspot.com/)\n* [Groupon Engineering Blog](https://engineering.groupon.com/)\n* [Heroku Engineering Blog](https://engineering.heroku.com/)\n* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)\n* [High Scalability](http://highscalability.com/)\n* [Instagram Engineering](http://instagram-engineering.tumblr.com/)\n* [Intel Software Blog](https://software.intel.com/en-us/blogs/)\n* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)\n* [LinkedIn Engineering](http://engineering.linkedin.com/blog)\n* [Microsoft Engineering](https://engineering.microsoft.com/)\n* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)\n* [Netflix Tech Blog](http://techblog.netflix.com/)\n* [Paypal Developer Blog](https://medium.com/paypal-engineering)\n* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)\n* [Reddit Blog](http://www.redditblog.com/)\n* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)\n* [Slack Engineering Blog](https://slack.engineering/)\n* [Spotify Labs](https://labs.spotify.com/)\n* [Stripe Engineering Blog](https://stripe.com/blog/engineering)",
    "ContentSha": "K2HaPjFBuIAolMM1jFJHWyWd16kC4a7w+PNnWCMvsfw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 公司工程博客\n\n> 你面试的公司的架构。\n>\n> 你遇到的问题可能来自同一领域。\n\n* [Airbnb 工程](http://nerds.airbnb.com/)\n* [Atlassian 开发者](https://developer.atlassian.com/blog/)\n* [AWS 博客](https://aws.amazon.com/blogs/aws/)\n* [Bitly 工程博客](http://word.bitly.com/)\n* [Box 博客](https://blog.box.com/blog/category/engineering)\n* [Cloudera 开发者博客](http://blog.cloudera.com/)\n* [Dropbox 技术博客](https://tech.dropbox.com/)\n* [Quora 工程](https://www.quora.com/q/quoraengineering)\n* [Ebay 技术博客](http://www.ebaytechblog.com/)\n* [Evernote 技术博客](https://blog.evernote.com/tech/)\n* [Etsy 代码如工艺](http://codeascraft.com/)\n* [Facebook 工程](https://www.facebook.com/Engineering)\n* [Flickr 代码](http://code.flickr.net/)\n* [Foursquare 工程博客](http://engineering.foursquare.com/)\n* [GitHub 工程博客](https://github.blog/category/engineering)\n* [Google 研究博客](http://googleresearch.blogspot.com/)\n* [Groupon 工程博客](https://engineering.groupon.com/)\n* [Heroku 工程博客](https://engineering.heroku.com/)\n* [Hubspot 工程博客](http://product.hubspot.com/blog/topic/engineering)\n* [High Scalability](http://highscalability.com/)\n* [Instagram 工程](http://instagram-engineering.tumblr.com/)\n* [Intel 软件博客](https://software.intel.com/en-us/blogs/)\n* [Jane Street 技术博客](https://blogs.janestreet.com/category/ocaml/)\n* [LinkedIn 工程](http://engineering.linkedin.com/blog)\n* [Microsoft 工程](https://engineering.microsoft.com/)\n* [Microsoft Python 工程](https://blogs.msdn.microsoft.com/pythonengineering/)\n* [Netflix 技术博客](http://techblog.netflix.com/)\n* [Paypal 开发者博客](https://medium.com/paypal-engineering)\n* [Pinterest 工程博客](https://medium.com/@Pinterest_Engineering)\n* [Reddit 博客](http://www.redditblog.com/)\n* [Salesforce 工程博客](https://developer.salesforce.com/blogs/engineering/)\n* [Slack 工程博客](https://slack.engineering/)\n* [Spotify 实验室](https://labs.spotify.com/)\n* [Stripe 工程博客](https://stripe.com/blog/engineering)",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 59,
    "Content": "* [Twilio Engineering Blog](http://www.twilio.com/engineering)\n* [Twitter Engineering](https://blog.twitter.com/engineering/)\n* [Uber Engineering Blog](http://eng.uber.com/)\n* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)\n* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)\n* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)\n\n#### Source(s) and further reading\n\nLooking to add a blog?  To avoid duplicating work, consider adding your company blog to the following repo:\n\n* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)\n\n## Under development\n\nInterested in adding a section or helping complete one in-progress?  [Contribute](#contributing)!\n\n* Distributed computing with MapReduce\n* Consistent hashing\n* Scatter gather\n* [Contribute](#contributing)\n\n## Credits\n\nCredits and sources are provided throughout this repo.\n\nSpecial thanks to:\n\n* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)\n* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)\n* [High scalability](http://highscalability.com/)\n* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)\n* [shashank88/system_design](https://github.com/shashank88/system_design)\n* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)\n* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)\n* [A distributed systems reading list](http://dancres.github.io/Pages/)\n* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n\n## Contact info\n",
    "ContentSha": "Ybn7ZSN9UGUEPKyqpiStfZWdM+FBaEvnQtoViA95ahg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "* [Twilio 工程博客](http://www.twilio.com/engineering)\n* [Twitter 工程](https://blog.twitter.com/engineering/)\n* [Uber 工程博客](http://eng.uber.com/)\n* [Yahoo 工程博客](http://yahooeng.tumblr.com/)\n* [Yelp 工程博客](http://engineeringblog.yelp.com/)\n* [Zynga 工程博客](https://www.zynga.com/blogs/engineering)\n\n#### 来源及进一步阅读\n\n想添加博客？为了避免重复劳动，考虑将贵公司的博客添加到以下仓库：\n\n* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)\n\n## 开发中\n\n有兴趣添加新章节或帮助完成正在进行中的章节？[贡献](#contributing)！\n\n* 使用 MapReduce 的分布式计算\n* 一致性哈希\n* 散射聚合\n* [贡献](#contributing)\n\n## 致谢\n\n致谢和来源贯穿本仓库。\n\n特别感谢：\n\n* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)\n* [破解编码面试](https://www.amazon.com/dp/0984782850/)\n* [高可扩展性](http://highscalability.com/)\n* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)\n* [shashank88/system_design](https://github.com/shashank88/system_design)\n* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)\n* [系统设计备忘单](https://gist.github.com/vasanthk/485d1c25737e8e72759f)\n* [分布式系统阅读列表](http://dancres.github.io/Pages/)\n* [破解系统设计面试](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)\n\n## 联系方式\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 60,
    "Content": "Feel free to contact me to discuss any issues, questions, or comments.\n\nMy contact info can be found on my [GitHub page](https://github.com/donnemartin).\n\n## License\n\n*I am providing code and resources in this repository to you under an open source license.  Because this is my personal repository, the license you receive to my code and resources is from me and not my employer (Facebook).*\n\n    Copyright 2017 Donne Martin\n\n    Creative Commons Attribution 4.0 International License (CC BY 4.0)\n\n    http://creativecommons.org/licenses/by/4.0/\n",
    "ContentSha": "pZfW5OoDeEHMjsOQIbYzifgEtKuSRxAcRTUdmpdKaBQ=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "欢迎随时联系我讨论任何问题、疑问或意见。\n\n我的联系方式可以在我的[GitHub 页面](https://github.com/donnemartin)找到。\n\n## 许可证\n\n*我在此仓库中向您提供的代码和资源均遵循开源许可证。由于这是我的个人仓库，您获得的代码和资源的许可证由我本人而非我的雇主（Facebook）授权。*\n\n    版权 2017 Donne Martin\n\n    知识共享 署名 4.0 国际许可协议 (CC BY 4.0)\n\n    http://creativecommons.org/licenses/by/4.0/\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  }
]