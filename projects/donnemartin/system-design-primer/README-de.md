*[English](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md) ∙ [日本語](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md) ∙ [简体中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md) ∙ [繁體中文](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*

**Hilf mit, [diesen Leitfaden](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md) zu übersetzen!**

# Das System Design Primer

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png">
  <br/>
</p>

## Motivation

> Lerne, wie man groß angelegte Systeme entwirft.
>
> Vorbereitung auf das Systemdesign-Interview.

### Lerne, wie man groß angelegte Systeme entwirft

Das Erlernen der Skalierung von Systemen hilft dir, ein besserer Ingenieur zu werden.

Systemdesign ist ein breit gefächertes Thema. Es gibt **eine riesige Menge an Ressourcen, die im Web verstreut sind** zu Prinzipien des Systemdesigns.

Dieses Repository ist eine **organisierte Sammlung** von Ressourcen, die dir helfen, Systeme im großen Maßstab zu bauen.

### Lerne von der Open-Source-Community

Dies ist ein fortlaufend aktualisiertes Open-Source-Projekt.

[Beiträge](#contributing) sind willkommen!

### Vorbereitung auf das Systemdesign-Interview

Neben Coding-Interviews ist Systemdesign ein **notwendiger Bestandteil** des **technischen Bewerbungsprozesses** bei vielen Tech-Unternehmen.

**Übe gängige Systemdesign-Interviewfragen** und **vergleiche** deine Ergebnisse mit **Beispiellösungen**: Diskussionen, Code und Diagramme.

Zusätzliche Themen zur Interviewvorbereitung:

* [Lernleitfaden](#study-guide)
* [Wie man eine Systemdesign-Interviewfrage angeht](#how-to-approach-a-system-design-interview-question)
* [Systemdesign-Interviewfragen, **mit Lösungen**](#system-design-interview-questions-with-solutions)
* [Objektorientierte Design-Interviewfragen, **mit Lösungen**](#object-oriented-design-interview-questions-with-solutions)
* [Zusätzliche Systemdesign-Interviewfragen](#additional-system-design-interview-questions)

## Anki-Lernkarten

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png">
  <br/>
</p>

Die bereitgestellten [Anki-Lernkartendecks](https://apps.ankiweb.net/) nutzen verteiltes Wiederholen, um Ihnen beim Behalten wichtiger Systemdesign-Konzepte zu helfen.

* [Systemdesign-Deck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)
* [Systemdesign-Übungsdeck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)
* [Objektorientiertes Design-Übungsdeck](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)

Ideal für unterwegs.

### Coding Resource: Interaktive Programmieraufgaben

Suchen Sie nach Ressourcen, um sich auf das [**Coding-Interview**](https://github.com/donnemartin/interactive-coding-challenges) vorzubereiten?

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png">
  <br/>
</p>

Werfen Sie einen Blick auf das Schwester-Repository [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges), das ein weiteres Anki-Deck enthält:

* [Coding-Deck](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)

## Mitwirken

> Lernen Sie von der Community.

Sie können gerne Pull-Requests einreichen, um zu helfen:

* Fehler beheben
* Abschnitte verbessern
* Neue Abschnitte hinzufügen
* [Übersetzen](https://github.com/donnemartin/system-design-primer/issues/28)

Inhalt, der noch überarbeitet werden muss, befindet sich [in Entwicklung](#under-development).

Siehe die [Mitwirkungsrichtlinien](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md).

## Index der Themen zum Systemdesign

> Zusammenfassungen verschiedener Systemdesign-Themen, einschließlich Vor- und Nachteilen.  **Alles ist ein Kompromiss**.
>
> Jeder Abschnitt enthält Links zu weiterführenden Ressourcen.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png">
  <br/>
</p>

* [Systemdesign-Themen: Hier starten](#system-design-topics-start-here)
    * [Schritt 1: Sehen Sie sich die Skalierbarkeits-Videovorlesung an](#step-1-review-the-scalability-video-lecture)
    * [Schritt 2: Lesen Sie den Skalierbarkeits-Artikel](#step-2-review-the-scalability-article)
    * [Nächste Schritte](#next-steps)
* [Performance vs Skalierbarkeit](#performance-vs-scalability)
* [Latenz vs Durchsatz](#latency-vs-throughput)
* [Verfügbarkeit vs Konsistenz](#availability-vs-consistency)
    * [CAP-Theorem](#cap-theorem)
        * [CP - Konsistenz und Partitionstoleranz](#cp---consistency-and-partition-tolerance)
        * [AP - Verfügbarkeit und Partitionstoleranz](#ap---availability-and-partition-tolerance)
* [Konsistenzmuster](#consistency-patterns)
    * [Schwache Konsistenz](#weak-consistency)
    * [Eventuelle Konsistenz](#eventual-consistency)
    * [Starke Konsistenz](#strong-consistency)
* [Verfügbarkeitsmuster](#availability-patterns)
    * [Failover](#fail-over)
    * [Replikation](#replication)
    * [Verfügbarkeit in Zahlen](#availability-in-numbers)
* [Domain Name System](#domain-name-system)
* [Content Delivery Network](#content-delivery-network)
    * [Push-CDNs](#push-cdns)
    * [Pull-CDNs](#pull-cdns)
* [Load Balancer](#load-balancer)
    * [Aktiv-passiv](#active-passive)
    * [Aktiv-aktiv](#active-active)
    * [Layer-4-Lastverteilung](#layer-4-load-balancing)
    * [Layer-7-Lastverteilung](#layer-7-load-balancing)
    * [Horizontale Skalierung](#horizontal-scaling)
* [Reverse Proxy (Webserver)](#reverse-proxy-web-server)
    * [Lastverteiler vs Reverse Proxy](#load-balancer-vs-reverse-proxy)
* [Application Layer](#application-layer)
    * [Microservices](#microservices)
    * [Service Discovery](#service-discovery)
* [Datenbank](#database)
    * [Relationales Datenbankmanagementsystem (RDBMS)](#relational-database-management-system-rdbms)
        * [Master-Slave-Replikation](#master-slave-replication)
        * [Master-Master-Replikation](#master-master-replication)
        * [Föderation](#federation)
        * [Sharding](#sharding)
        * [Denormalisierung](#denormalization)
        * [SQL-Tuning](#sql-tuning)
    * [NoSQL](#nosql)
        * [Key-Value-Store](#key-value-store)
        * [Dokumenten-Store](#document-store)
        * [Wide Column Store](#wide-column-store)
        * [Graphdatenbank](#graph-database)
    * [SQL oder NoSQL](#sql-or-nosql)
* [Cache](#cache)
    * [Client-Caching](#client-caching)
    * [CDN-Caching](#cdn-caching)
    * [Webserver-Caching](#web-server-caching)
    * [Datenbank-Caching](#database-caching)
    * [Anwendungs-Caching](#application-caching)
    * [Caching auf Datenbankabfrage-Ebene](#caching-at-the-database-query-level)
    * [Caching auf Objektebene](#caching-at-the-object-level)
    * [Wann wird der Cache aktualisiert](#when-to-update-the-cache)
        * [Cache-aside](#cache-aside)
        * [Write-through](#write-through)
        * [Write-behind (Write-back)](#write-behind-write-back)
        * [Refresh-ahead](#refresh-ahead)
* [Asynchronität](#asynchronism)
    * [Message Queues](#message-queues)
    * [Aufgabenwarteschlangen](#task-queues)
    * [Backpressure](#back-pressure)
* [Kommunikation](#communication)
    * [Transmission Control Protocol (TCP)](#transmission-control-protocol-tcp)
    * [User Datagram Protocol (UDP)](#user-datagram-protocol-udp)
    * [Remote Procedure Call (RPC)](#remote-procedure-call-rpc)
    * [Representational State Transfer (REST)](#representational-state-transfer-rest)
* [Sicherheit](#security)
* [Anhang](#appendix)
    * [Zweierpotenztabelle](#powers-of-two-table)
    * [Latenzzahlen, die jeder Programmierer kennen sollte](#latency-numbers-every-programmer-should-know)
    * [Weitere Systemdesign-Interviewfragen](#additional-system-design-interview-questions)
    * [Reale Architekturen](#real-world-architectures)
    * [Unternehmensarchitekturen](#company-architectures)
    * [Engineering-Blogs von Unternehmen](#company-engineering-blogs)
* [In Entwicklung](#under-development)
* [Danksagungen](#credits)
* [Kontaktinformationen](#contact-info)
* [Lizenz](#license)

## Lernleitfaden

> Vorgeschlagene Themen zur Wiederholung, basierend auf deinem Interview-Zeitplan (kurz, mittel, lang).

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png)

**F: Muss ich für Interviews alles hier wissen?**

**A: Nein, du musst nicht alles hier wissen, um dich auf das Interview vorzubereiten**.

Was in einem Interview gefragt wird, hängt von Faktoren wie folgenden ab:

* Wie viel Erfahrung du hast
* Was dein technischer Hintergrund ist
* Für welche Positionen du dich bewirbst
* Bei welchen Unternehmen du dich bewirbst
* Glück

Von erfahrenen Kandidaten wird im Allgemeinen mehr Wissen über Systemdesign erwartet. Architekten oder Teamleiter sollten mehr wissen als einzelne Entwickler. Bei führenden Tech-Unternehmen gibt es wahrscheinlich eine oder mehrere Design-Interviewrunden.

Beginnen Sie mit einem breiten Überblick und vertiefen Sie sich in einige Bereiche. Es hilft, ein wenig über verschiedene wichtige Themen im Bereich Systemdesign zu wissen. Passen Sie den folgenden Leitfaden an Ihren Zeitplan, Ihre Erfahrung, die Positionen, für die Sie sich bewerben, und die Unternehmen, bei denen Sie sich bewerben, an.

* **Kurzer Zeitrahmen** – Streben Sie nach **Breite** bei Systemdesign-Themen. Üben Sie, indem Sie **einige** Interviewfragen lösen.
* **Mittlerer Zeitrahmen** – Streben Sie nach **Breite** und **etwas Tiefe** bei Systemdesign-Themen. Üben Sie, indem Sie **viele** Interviewfragen lösen.
* **Langer Zeitrahmen** – Streben Sie nach **Breite** und **mehr Tiefe** bei Systemdesign-Themen. Üben Sie, indem Sie **die meisten** Interviewfragen lösen.

| | Kurz | Mittel | Lang |
|---|---|---|---|
| Lesen Sie die [Systemdesign-Themen](#index-of-system-design-topics), um ein breites Verständnis davon zu bekommen, wie Systeme funktionieren | :+1: | :+1: | :+1: |
| Lesen Sie einige Artikel in den [Engineering-Blogs der Unternehmen](#company-engineering-blogs), bei denen Sie sich bewerben | :+1: | :+1: | :+1: |
| Lesen Sie einige [Architekturen aus der Praxis](#real-world-architectures) | :+1: | :+1: | :+1: |
| Überprüfen Sie [Wie man eine Systemdesign-Interviewfrage angeht](#how-to-approach-a-system-design-interview-question) | :+1: | :+1: | :+1: |
| Bearbeiten Sie [Systemdesign-Interviewfragen mit Lösungen](#system-design-interview-questions-with-solutions) | Einige | Viele | Die meisten |
| Bearbeiten Sie [Objektorientierte Design-Interviewfragen mit Lösungen](#object-oriented-design-interview-questions-with-solutions) | Einige | Viele | Die meisten |
| Überprüfen Sie [Weitere Systemdesign-Interviewfragen](#additional-system-design-interview-questions) | Einige | Viele | Die meisten |

## Wie man eine Systemdesign-Interviewfrage angeht

> Wie man eine Systemdesign-Interviewfrage angeht.

Das Systemdesign-Interview ist ein **offenes Gespräch**. Sie sollen es führen.

Sie können die folgenden Schritte nutzen, um die Diskussion zu leiten. Um diesen Prozess zu festigen, arbeiten Sie den Abschnitt [Systemdesign-Interviewfragen mit Lösungen](#system-design-interview-questions-with-solutions) anhand der folgenden Schritte durch.

### Schritt 1: Anwendungsfälle, Einschränkungen und Annahmen umreißen

Ermitteln Sie Anforderungen und stecken Sie das Problem ab. Stellen Sie Fragen, um Anwendungsfälle und Einschränkungen zu klären. Diskutieren Sie Annahmen.

* Wer wird es benutzen?
* Wie werden sie es benutzen?
* Wie viele Benutzer gibt es?
* Was macht das System?
* Was sind die Eingaben und Ausgaben des Systems?
* Wie viele Daten erwarten wir zu verarbeiten?
* Wie viele Anfragen pro Sekunde erwarten wir?
* Wie ist das erwartete Lese-/Schreibverhältnis?

### Schritt 2: Entwerfen Sie ein High-Level-Design

Umreißen Sie ein High-Level-Design mit allen wichtigen Komponenten.

* Skizzieren Sie die Hauptkomponenten und Verbindungen
* Begründen Sie Ihre Ideen

### Schritt 3: Entwerfen Sie die Kernkomponenten

Gehen Sie ins Detail für jede Kernkomponente. Wenn Sie beispielsweise gebeten würden, einen [URL-Verkürzungsdienst zu entwerfen](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md), besprechen Sie:

* Generieren und Speichern eines Hashs der vollständigen URL
    * [MD5](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) und [Base62](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)
    * Hash-Kollisionen
    * SQL oder NoSQL
    * Datenbankschema
* Übersetzen einer gehashten URL zur vollständigen URL
    * Datenbankabfrage
* API- und objektorientiertes Design

### Schritt 4: Skalieren Sie das Design

Identifizieren und adressieren Sie Engpässe unter den gegebenen Einschränkungen. Benötigen Sie beispielsweise Folgendes, um Skalierbarkeitsprobleme zu lösen?

* Lastverteiler
* Horizontale Skalierung
* Caching
* Datenbank-Sharding

Diskutieren Sie mögliche Lösungen und Kompromisse. Alles ist ein Kompromiss. Gehen Sie auf Engpässe ein und nutzen Sie die [Prinzipien des skalierbaren Systemdesigns](#index-of-system-design-topics).

### Überschlagsrechnungen

Es kann sein, dass Sie einige Schätzungen von Hand durchführen sollen. Siehe [Anhang](#appendix) für die folgenden Ressourcen:

* [Überschlagsrechnungen verwenden](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)
* [Zweiertabelle](#powers-of-two-table)
* [Latenzzahlen, die jeder Programmierer kennen sollte](#latency-numbers-every-programmer-should-know)

### Quelle(n) und weiterführende Literatur

Schauen Sie sich die folgenden Links an, um einen besseren Eindruck davon zu bekommen, was Sie erwartet:

* [Wie man ein Systemdesign-Interview meistert](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)
* [Das Systemdesign-Interview](http://www.hiredintech.com/system-design)
* [Einführung in Architektur- und Systemdesign-Interviews](https://www.youtube.com/watch?v=ZgdS0EUmn70)
* [Systemdesign-Vorlage](https://leetcode.com/discuss/career/229177/My-System-Design-Template)

## Systemdesign-Interviewfragen mit Lösungen

> Häufige Systemdesign-Interviewfragen mit Beispiel-Diskussionen, Code und Diagrammen.
>
> Lösungen sind mit Inhalten im Ordner `solutions/` verlinkt.

| Frage | |
|---|---|
| Entwerfen Sie Pastebin.com (oder Bit.ly) | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md) |
| Entwerfen Sie die Twitter-Timeline und Suche (oder Facebook-Feed und Suche) | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md) |
| Entwerfen Sie einen Webcrawler | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md) |
| Entwerfen Sie Mint.com | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md) |
| Entwerfen Sie die Datenstrukturen für ein soziales Netzwerk | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md) |
| Entwerfen Sie einen Key-Value-Store für eine Suchmaschine | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md) |
| Entwerfen Sie die Verkaufsrangliste nach Kategorie von Amazon | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md) |
| Entwerfen Sie ein System, das auf AWS für Millionen von Nutzern skaliert | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md) |
| Fügen Sie eine Systemdesign-Frage hinzu | [Beitragen](#contributing) |

### Pastebin.com (oder Bit.ly) entwerfen

[Übung und Lösung ansehen](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png)

### Die Twitter-Timeline und Suche entwerfen (oder Facebook-Feed und Suche)

[Übung und Lösung ansehen](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png)

### Einen Webcrawler entwerfen

[Übung und Lösung ansehen](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png)

### Design Mint.com

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png)

### Design the data structures for a social network

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png)

### Design a key-value store for a search engine

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png)

### Design Amazon's sales ranking by category feature

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png)

### Design a system that scales to millions of users on AWS

[View exercise and solution](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md)

![Imgur](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png)

## Object-oriented design interview questions with solutions

> Common object-oriented design interview questions with sample discussions, code, and diagrams.
>
> Solutions linked to content in the `solutions/` folder.

>**Note: This section is under development**

| Question | |
|---|---|
| Entwerfen Sie eine Hash Map | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb)  |
| Entwerfen Sie einen Least Recently Used Cache | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |
| Entwerfen Sie ein Callcenter | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb)  |
| Entwerfen Sie ein Kartenspiel-Deck | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |
| Entwerfen Sie einen Parkplatz | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |
| Entwerfen Sie einen Chat-Server | [Lösung](https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb)  |
| Entwerfen Sie ein zirkuläres Array | [Mitwirken](#contributing)  |
| Fügen Sie eine objektorientierte Designfrage hinzu | [Mitwirken](#contributing) |

## Themen zur Systemarchitektur: Starten Sie hier

Neu im Bereich Systemarchitektur?

Zuerst benötigen Sie ein grundlegendes Verständnis für gängige Prinzipien, erfahren, was sie sind, wie sie verwendet werden und ihre Vor- und Nachteile.

### Schritt 1: Sehen Sie sich die Skalierbarkeits-Vorlesung an

[Skalierbarkeits-Vorlesung an der Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)

* Behandelte Themen:
    * Vertikale Skalierung
    * Horizontale Skalierung
    * Caching
    * Lastverteilung
    * Datenbankreplikation
    * Datenbankpartitionierung

### Schritt 2: Lesen Sie den Skalierbarkeits-Artikel

[Skalierbarkeit](https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono)

* Behandelte Themen:
    * [Klone](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
    * [Datenbanken](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
    * [Caches](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
    * [Asynchronität](https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)

### Nächste Schritte

Als nächstes betrachten wir hochrangige Abwägungen:

* **Leistung** vs **Skalierbarkeit**
* **Latenz** vs **Durchsatz**
* **Verfügbarkeit** vs **Konsistenz**

Beachte, dass **alles eine Abwägung** ist.

Anschließend tauchen wir in spezifischere Themen wie DNS, CDNs und Load Balancer ein.

## Leistung vs Skalierbarkeit

Ein Dienst ist **skalierbar**, wenn er eine gesteigerte **Leistung** proportional zu hinzugefügten Ressourcen zeigt. Im Allgemeinen bedeutet eine Leistungssteigerung, mehr Arbeitseinheiten zu bedienen, aber es kann auch bedeuten, größere Arbeitseinheiten zu bewältigen, etwa wenn Datensätze wachsen.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>

Eine weitere Sichtweise auf Leistung vs Skalierbarkeit:

* Wenn du ein **Leistungsproblem** hast, ist dein System für einen einzelnen Nutzer langsam.
* Wenn du ein **Skalierbarkeitsproblem** hast, ist dein System für einen einzelnen Nutzer schnell, aber langsam bei hoher Last.

### Quelle(n) und weiterführende Literatur

* [Ein Wort zur Skalierbarkeit](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)
* [Skalierbarkeit, Verfügbarkeit, Stabilität, Muster](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)

## Latenz vs Durchsatz

**Latenz** ist die Zeit, um eine Aktion auszuführen oder ein Ergebnis zu erzeugen.

**Durchsatz** ist die Anzahl solcher Aktionen oder Ergebnisse pro Zeiteinheit.

Im Allgemeinen solltest du auf **maximalen Durchsatz** mit **akzeptabler Latenz** abzielen.

### Quelle(n) und weiterführende Literatur

* [Latenz vs Durchsatz verstehen](https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput)

## Verfügbarkeit vs Konsistenz

### CAP-Theorem

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Quelle: CAP-Theorem erneut betrachtet</a></i>
</p>

In einem verteilten Computersystem können Sie nur zwei der folgenden Garantien unterstützen:

* **Konsistenz** – Jeder Lesevorgang erhält entweder den aktuellsten Schreibvorgang oder einen Fehler
* **Verfügbarkeit** – Jede Anfrage erhält eine Antwort, ohne Garantie, dass sie die aktuellste Version der Information enthält
* **Partitionstoleranz** – Das System funktioniert weiterhin trotz beliebiger Partitionierungen durch Netzwerkausfälle

*Netzwerke sind nicht zuverlässig, daher müssen Sie Partitionstoleranz unterstützen. Sie müssen einen Software-Kompromiss zwischen Konsistenz und Verfügbarkeit eingehen.*

#### CP – Konsistenz und Partitionstoleranz

Das Warten auf eine Antwort vom partitionierten Knoten kann zu einem Timeout-Fehler führen. CP ist eine gute Wahl, wenn Ihr Geschäftsbedarf atomare Lese- und Schreibvorgänge erfordert.

#### AP – Verfügbarkeit und Partitionstoleranz

Antworten liefern die am einfachsten verfügbare Version der Daten auf einem beliebigen Knoten, die möglicherweise nicht die aktuellste ist. Schreibvorgänge können etwas Zeit benötigen, um sich nach Behebung der Partition zu verbreiten.

AP ist eine gute Wahl, wenn die Geschäftsanforderungen [eventuelle Konsistenz](#eventual-consistency) erlauben oder das System trotz externer Fehler weiterarbeiten muss.

### Quelle(n) und weiterführende Literatur

* [CAP-Theorem erneut betrachtet](http://robertgreiner.com/2014/08/cap-theorem-revisited/)
* [Eine einfach erklärte Einführung ins CAP-Theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem)
* [CAP FAQ](https://github.com/henryr/cap-faq)
* [Das CAP-Theorem](https://www.youtube.com/watch?v=k-Yaq8AHlFA)

## Konsistenzmuster

Bei mehreren Kopien derselben Daten stehen wir vor der Frage, wie wir diese synchronisieren, sodass Clients eine konsistente Sicht auf die Daten erhalten. Erinnern Sie sich an die Definition von Konsistenz aus dem [CAP-Theorem](#cap-theorem) – Jeder Lesevorgang erhält entweder den aktuellsten Schreibvorgang oder einen Fehler.

### Schwache Konsistenz

Nach einem Schreibvorgang kann ein Lesevorgang diesen sehen oder auch nicht. Es wird ein Best-Effort-Ansatz verfolgt.

Dieser Ansatz findet sich in Systemen wie memcached. Schwache Konsistenz funktioniert gut in Echtzeit-Anwendungen wie VoIP, Videochat und Echtzeit-Mehrspieler-Spielen. Wenn Sie beispielsweise während eines Telefonats für einige Sekunden den Empfang verlieren, hören Sie nach Wiederherstellung der Verbindung nicht, was während des Verbindungsverlusts gesprochen wurde.

### Eventual Consistency (Schlussendliche Konsistenz)

Nach einem Schreibvorgang werden Leseoperationen diesen Wert schließlich sehen (typischerweise innerhalb von Millisekunden). Daten werden asynchron repliziert.

Dieser Ansatz findet sich in Systemen wie DNS und E-Mail. Schlussendliche Konsistenz funktioniert gut in hochverfügbaren Systemen.

### Starke Konsistenz

Nach einem Schreibvorgang werden Leseoperationen diesen Wert sehen. Daten werden synchron repliziert.

Dieser Ansatz findet sich in Dateisystemen und RDBMS. Starke Konsistenz eignet sich gut für Systeme, die Transaktionen benötigen.

### Quelle(n) und weiterführende Literatur

* [Transaktionen über Rechenzentren hinweg](http://snarfed.org/transactions_across_datacenters_io.html)

## Verfügbarkeitsmuster

Es gibt zwei ergänzende Muster zur Unterstützung hoher Verfügbarkeit: **Failover** und **Replikation**.

### Failover

#### Aktiv-Passiv

Beim Aktiv-Passiv-Failover werden Heartbeats zwischen dem aktiven und dem passiven Server im Standby-Modus gesendet. Wenn der Heartbeat unterbrochen wird, übernimmt der passive Server die IP-Adresse des aktiven Servers und setzt den Dienst fort.

Die Ausfallzeit hängt davon ab, ob der passive Server bereits im 'heißen' Standby läuft oder erst aus dem 'kalten' Standby hochgefahren werden muss. Nur der aktive Server verarbeitet den Datenverkehr.

Aktiv-Passiv-Failover wird auch als Master-Slave-Failover bezeichnet.

#### Aktiv-Aktiv

Beim Aktiv-Aktiv-Failover verwalten beide Server den Datenverkehr und verteilen die Last zwischen sich.

Wenn die Server öffentlich zugänglich sind, muss das DNS über die öffentlichen IPs beider Server Bescheid wissen. Wenn die Server intern genutzt werden, muss die Anwendungslogik beide Server kennen.

Aktiv-Aktiv-Failover wird auch als Master-Master-Failover bezeichnet.

### Nachteil(e): Failover

* Failover erfordert mehr Hardware und zusätzliche Komplexität.
* Es besteht die Möglichkeit eines Datenverlusts, wenn das aktive System ausfällt, bevor neu geschriebene Daten auf das passive repliziert werden können.

### Replikation

#### Master-Slave und Master-Master

Dieses Thema wird im Abschnitt [Datenbank](#database) weiter behandelt:

* [Master-Slave-Replikation](#master-slave-replication)
* [Master-Master-Replikation](#master-master-replication)

### Verfügbarkeit in Zahlen

Verfügbarkeit wird häufig anhand der Betriebszeit (oder Ausfallzeit) als Prozentsatz der Zeit gemessen, in der der Dienst verfügbar ist. Die Verfügbarkeit wird allgemein in Anzahl der Neunen angegeben–ein Dienst mit 99,99 % Verfügbarkeit wird als vier Neunen beschrieben.

#### 99,9 % Verfügbarkeit - drei Neunen

| Zeitraum            | Zulässige Ausfallzeit|
|---------------------|----------------------|
| Ausfallzeit pro Jahr| 8h 45min 57s         |
| Ausfallzeit pro Monat| 43m 49,7s           |
| Ausfallzeit pro Woche| 10m 4,8s            |
| Ausfallzeit pro Tag | 1m 26,4s             |

#### 99,99 % Verfügbarkeit - vier Neunen

| Zeitraum            | Zulässige Ausfallzeit|
|---------------------|----------------------|
| Ausfallzeit pro Jahr| 52min 35,7s          |
| Ausfallzeit pro Monat| 4m 23s              |
| Ausfallzeit pro Woche| 1m 5s               |
| Ausfallzeit pro Tag | 8,6s                 |

#### Verfügbarkeit in Parallel- vs. Reihenfolge

Wenn ein Dienst aus mehreren ausfallgefährdeten Komponenten besteht, hängt die Gesamtverfügbarkeit des Dienstes davon ab, ob die Komponenten in Reihenfolge oder parallel angeordnet sind.

###### In Reihenfolge
Die Gesamtverfügbarkeit sinkt, wenn zwei Komponenten mit einer Verfügbarkeit von < 100% in Reihe geschaltet sind:


```
Availability (Total) = Availability (Foo) * Availability (Bar)
```

Wenn sowohl `Foo` als auch `Bar` jeweils eine Verfügbarkeit von 99,9 % hätten, läge ihre Gesamtverfügbarkeit in Reihe bei 99,8 %.

###### Parallel

Die Gesamtverfügbarkeit steigt, wenn zwei Komponenten mit einer Verfügbarkeit < 100 % parallel geschaltet sind:

```
Availability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))
```
Wenn sowohl `Foo` als auch `Bar` jeweils 99,9 % Verfügbarkeit hätten, läge ihre Gesamtverfügbarkeit im Parallelbetrieb bei 99,9999 %.

## Domain Name System

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Quelle: DNS Security Presentation</a></i>
</p>

Ein Domain Name System (DNS) übersetzt einen Domainnamen wie www.example.com in eine IP-Adresse.

DNS ist hierarchisch aufgebaut, mit wenigen autoritativen Servern auf der obersten Ebene.  Ihr Router oder ISP gibt an, welchen DNS-Server (bzw. welche Server) Sie bei einer Abfrage kontaktieren sollen.  DNS-Server auf niedrigeren Ebenen speichern Zuordnungen im Cache, die durch DNS-Propagation veralten können.  Auch Ihr Browser oder Betriebssystem kann DNS-Ergebnisse für eine bestimmte Zeitspanne cachen, die durch die [Time to Live (TTL)](https://de.wikipedia.org/wiki/Time_to_live) bestimmt wird.

* **NS-Record (Name Server)** – Gibt die DNS-Server für Ihre Domain/Subdomain an.
* **MX-Record (Mail Exchange)** – Gibt die Mailserver für den Empfang von Nachrichten an.
* **A-Record (Address)** – Verweist einen Namen auf eine IP-Adresse.
* **CNAME (Canonical)** – Verweist einen Namen auf einen anderen Namen oder `CNAME` (example.com zu www.example.com) oder auf einen `A`-Record.

Dienste wie [CloudFlare](https://www.cloudflare.com/dns/) und [Route 53](https://aws.amazon.com/route53/) bieten verwaltete DNS-Dienste an.  Manche DNS-Dienste können den Datenverkehr auf verschiedene Arten routen:

* [Weighted Round Robin](https://www.jscape.com/blog/load-balancing-algorithms)
    * Verhindert, dass Traffic zu Servern unter Wartung geleitet wird
    * Ausgleich zwischen unterschiedlich großen Clustern
    * A/B-Testing
* [Latenz-basiert](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html)
* [Geolocation-basiert](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html)

### Nachteil(e): DNS

* Der Zugriff auf einen DNS-Server verursacht eine geringe Verzögerung, die jedoch durch das oben beschriebene Caching abgemildert wird.
* Die Verwaltung von DNS-Servern kann komplex sein und wird im Allgemeinen von [Regierungen, ISPs und großen Unternehmen](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729) übernommen.
* DNS-Dienste sind in letzter Zeit [DDoS-Angriffen](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/) ausgesetzt gewesen, wodurch Nutzer z. B. Twitter nicht mehr aufrufen konnten, wenn sie die IP-Adresse(n) nicht kannten.

### Quelle(n) und weiterführende Literatur

* [DNS-Architektur](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)
* [Wikipedia](https://de.wikipedia.org/wiki/Domain_Name_System)
* [DNS-Artikel](https://support.dnsimple.com/categories/dns/)


## Content-Delivery-Netzwerk

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Quelle: Warum ein CDN nutzen</a></i>
</p>

Ein Content-Delivery-Netzwerk (CDN) ist ein weltweit verteiltes Netzwerk von Proxy-Servern, das Inhalte von Standorten in der Nähe des Nutzers bereitstellt. Im Allgemeinen werden statische Dateien wie HTML/CSS/JS, Fotos und Videos von CDNs bereitgestellt, obwohl einige CDNs wie Amazons CloudFront auch dynamische Inhalte unterstützen. Die DNS-Auflösung der Website teilt den Clients mit, welchen Server sie kontaktieren sollen.

Die Bereitstellung von Inhalten über CDNs kann die Performance auf zwei Arten erheblich verbessern:

* Nutzer erhalten Inhalte aus Rechenzentren in ihrer Nähe
* Ihre Server müssen keine Anfragen bedienen, die vom CDN erfüllt werden

### Push-CDNs

Push-CDNs erhalten neue Inhalte, sobald Änderungen auf Ihrem Server erfolgen. Sie sind vollständig verantwortlich für die Bereitstellung der Inhalte, laden sie direkt auf das CDN hoch und passen die URLs an, sodass sie auf das CDN verweisen. Sie können konfigurieren, wann Inhalte ablaufen und aktualisiert werden. Inhalte werden nur hochgeladen, wenn sie neu oder geändert sind, was den Traffic minimiert, aber den Speicherbedarf maximiert.

Webseiten mit wenig Traffic oder Webseiten mit Inhalten, die selten aktualisiert werden, funktionieren gut mit Push-CDNs. Inhalte werden einmalig auf das CDN geladen, statt regelmäßig neu abgerufen zu werden.

### Pull-CDNs

Pull-CDNs laden neue Inhalte von Ihrem Server, wenn der erste Nutzer die Inhalte anfordert. Sie lassen die Inhalte auf Ihrem Server und passen die URLs an, sodass sie auf das CDN verweisen. Dies führt zu einer langsameren Anfrage, bis die Inhalte im CDN zwischengespeichert sind.

Ein [Time-to-Live (TTL)](https://de.wikipedia.org/wiki/Time_to_live) bestimmt, wie lange Inhalte zwischengespeichert werden. Pull-CDNs minimieren den Speicherbedarf im CDN, können aber zu redundantem Traffic führen, wenn Dateien ablaufen und abgerufen werden, bevor sie tatsächlich geändert wurden.

Webseiten mit viel Traffic funktionieren gut mit Pull-CDNs, da der Traffic gleichmäßiger verteilt wird und nur kürzlich angeforderte Inhalte auf dem CDN verbleiben.

### Nachteil(e): CDN

* CDN-Kosten können je nach Traffic erheblich sein, wobei dies gegen die zusätzlichen Kosten abzuwägen ist, die ohne CDN entstehen würden.
* Inhalte könnten veraltet sein, wenn sie aktualisiert werden, bevor der TTL abläuft.
* CDNs erfordern, dass URLs für statische Inhalte geändert werden, sodass sie auf das CDN verweisen.

### Quelle(n) und weiterführende Literatur

* [Global verteilte Content-Delivery](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)
* [Die Unterschiede zwischen Push- und Pull-CDNs](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)
* [Wikipedia](https://de.wikipedia.org/wiki/Content_Delivery_Network)

## Load Balancer

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Quelle: Skalierbare Systemdesignmuster</a></i>
</p>

Load Balancer verteilen eingehende Client-Anfragen an Computerressourcen wie Anwendungsserver und Datenbanken. In jedem Fall gibt der Load Balancer die Antwort der Computerressource an den entsprechenden Client zurück. Load Balancer sind effektiv bei:

* Verhindern, dass Anfragen an nicht funktionsfähige Server gesendet werden
* Verhindern der Überlastung von Ressourcen
* Mithelfen, einen Single Point of Failure zu eliminieren

Load Balancer können mit Hardware (teuer) oder mit Software wie HAProxy implementiert werden.

Zusätzliche Vorteile sind:

* **SSL-Termination** – Entschlüsseln eingehender Anfragen und Verschlüsseln von Serverantworten, sodass Backend-Server diese potenziell teuren Operationen nicht ausführen müssen
    * Entfernt die Notwendigkeit, [X.509-Zertifikate](https://de.wikipedia.org/wiki/X.509) auf jedem Server zu installieren
* **Sitzungspersistenz** – Ausstellen von Cookies und Weiterleiten der Anfragen eines bestimmten Clients an dieselbe Instanz, falls die Webanwendungen Sitzungen nicht verfolgen

Um sich vor Ausfällen zu schützen, ist es üblich, mehrere Load Balancer einzurichten, entweder im [Active-Passive](#active-passive)- oder [Active-Active](#active-active)-Modus.

Load Balancer können den Datenverkehr anhand verschiedener Metriken routen, darunter:

* Zufällig
* Am wenigsten ausgelastet
* Sitzung/Cookies
* [Round Robin oder Weighted Round Robin](https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb)
* [Layer 4](#layer-4-load-balancing)
* [Layer 7](#layer-7-load-balancing)

### Layer-4-Load-Balancing

Layer-4-Load-Balancer betrachten Informationen auf der [Transportschicht](#communication), um zu entscheiden, wie Anfragen verteilt werden. Im Allgemeinen betrifft dies die Quell- und Ziel-IP-Adressen und Ports im Header, jedoch nicht den Inhalt des Pakets. Layer-4-Load-Balancer leiten Netzwerkpakete zum und vom Upstream-Server weiter und führen [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/) durch.

### Layer-7-Load-Balancing
Layer-7-Load-Balancer betrachten die [Application Layer](#communication), um zu entscheiden, wie Anfragen verteilt werden. Dies kann Inhalte des Headers, der Nachricht und Cookies beinhalten. Layer-7-Load-Balancer beenden den Netzwerkverkehr, lesen die Nachricht, treffen eine Load-Balancing-Entscheidung und öffnen dann eine Verbindung zum ausgewählten Server. Ein Layer-7-Load-Balancer kann beispielsweise Videodatenverkehr zu Servern leiten, die Videos hosten, während sensibler Benutzer-Abrechnungsverkehr zu sicherheitsgehärteten Servern geleitet wird.

Auf Kosten der Flexibilität erfordert Layer-4-Load-Balancing weniger Zeit und Rechenressourcen als Layer-7, obwohl der Performance-Einfluss auf moderner Standardhardware minimal sein kann.

### Horizontales Skalieren

Load-Balancer können auch beim horizontalen Skalieren helfen und so Leistung und Verfügbarkeit verbessern. Das Skalieren mit Standardmaschinen ist kostengünstiger und führt zu höherer Verfügbarkeit als das Aufrüsten eines einzelnen Servers auf teurerer Hardware, was als **vertikales Skalieren** bezeichnet wird. Es ist außerdem einfacher, Fachkräfte für Standardhardware zu finden als für spezialisierte Enterprise-Systeme.

#### Nachteil(e): horizontales Skalieren

* Horizontales Skalieren führt zu Komplexität und beinhaltet das Klonen von Servern
    * Server sollten zustandslos sein: Sie sollten keine benutzerbezogenen Daten wie Sessions oder Profilbilder enthalten
    * Sessions können in einem zentralisierten Datenspeicher wie einer [Datenbank](#database) (SQL, NoSQL) oder einem persistenten [Cache](#cache) (Redis, Memcached) gespeichert werden
* Nachgelagerte Server wie Caches und Datenbanken müssen mehr gleichzeitige Verbindungen bewältigen, wenn vorgelagerte Server skaliert werden

### Nachteil(e): Load-Balancer

* Der Load-Balancer kann zu einem Performance-Engpass werden, wenn er nicht über genügend Ressourcen verfügt oder nicht richtig konfiguriert ist.
* Die Einführung eines Load-Balancers zur Beseitigung eines einzelnen Ausfallpunkts führt zu erhöhter Komplexität.
* Ein einzelner Load-Balancer ist ein einzelner Ausfallpunkt; die Konfiguration mehrerer Load-Balancer erhöht die Komplexität weiter.

### Quelle(n) und weiterführende Literatur

* [NGINX-Architektur](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy Architekturleitfaden](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Skalierbarkeit](https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
* [Wikipedia](https://de.wikipedia.org/wiki/Lastverteilung_(Informatik))
* [Layer-4-Load-Balancing](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)
* [Layer-7-Load-Balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)
* [ELB Listener-Konfiguration](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)

## Reverse Proxy (Webserver)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Quelle: Wikipedia</a></i>
  <br/>
</p>


Ein Reverse Proxy ist ein Webserver, der interne Dienste zentralisiert und öffentliche Schnittstellen bereitstellt. Anfragen von Clients werden an einen Server weitergeleitet, der sie erfüllen kann, bevor der Reverse Proxy die Antwort des Servers an den Client zurückgibt.

Weitere Vorteile sind:

* **Erhöhte Sicherheit** – Informationen über Backend-Server verbergen, IPs auf die schwarze Liste setzen, Anzahl der Verbindungen pro Client begrenzen
* **Erhöhte Skalierbarkeit und Flexibilität** – Clients sehen nur die IP des Reverse Proxys, sodass Sie Server skalieren oder deren Konfiguration ändern können
* **SSL-Terminierung** – Entschlüsseln eingehender Anfragen und Verschlüsseln von Serverantworten, damit Backend-Server diese potenziell ressourcenintensiven Operationen nicht ausführen müssen
    * Erspart die Installation von [X.509-Zertifikaten](https://de.wikipedia.org/wiki/X.509) auf jedem Server
* **Komprimierung** – Serverantworten komprimieren
* **Caching** – Antwort für zwischengespeicherte Anfragen zurückgeben
* **Statische Inhalte** – Statische Inhalte direkt bereitstellen
    * HTML/CSS/JS
    * Fotos
    * Videos
    * Etc

### Load Balancer vs Reverse Proxy

* Der Einsatz eines Load Balancers ist sinnvoll, wenn Sie mehrere Server haben. Oft leiten Load Balancer den Datenverkehr an eine Gruppe von Servern mit derselben Funktion weiter.
* Reverse Proxys können auch bei nur einem Web- oder Anwendungsserver nützlich sein und bieten die Vorteile aus dem vorherigen Abschnitt.
* Lösungen wie NGINX und HAProxy unterstützen sowohl Layer-7-Reverse-Proxying als auch Load Balancing.

### Nachteil(e): Reverse Proxy

* Das Einführen eines Reverse Proxys erhöht die Komplexität.
* Ein einzelner Reverse Proxy ist ein Single Point of Failure, die Konfiguration mehrerer Reverse Proxys (z.B. ein [Failover](https://de.wikipedia.org/wiki/Failover)) erhöht die Komplexität weiter.

### Quelle(n) und weiterführende Literatur

* [Reverse Proxy vs Load Balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)
* [NGINX-Architektur](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy Architektur Leitfaden](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Wikipedia](https://de.wikipedia.org/wiki/Reverse_Proxy)

## Anwendungsschicht

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Quelle: Einführung in die Systemarchitektur für Skalierung</a></i>
</p>

Die Trennung der Webschicht von der Anwendungsschicht (auch als Plattformschicht bekannt) ermöglicht es, beide Schichten unabhängig voneinander zu skalieren und zu konfigurieren. Das Hinzufügen einer neuen API führt zum Hinzufügen von Anwendungsservern, ohne dass zwangsläufig zusätzliche Webserver benötigt werden. Das **Single-Responsibility-Prinzip** befürwortet kleine und autonome Dienste, die zusammenarbeiten. Kleine Teams mit kleinen Diensten können aggressiver für schnelles Wachstum planen.

Worker in der Anwendungsschicht ermöglichen außerdem [Asynchronität](#asynchronism).

### Microservices

Verwandt mit dieser Diskussion sind [Microservices](https://de.wikipedia.org/wiki/Microservices), die als eine Suite von unabhängig bereitstellbaren, kleinen, modularen Diensten beschrieben werden können. Jeder Dienst läuft in einem eigenen Prozess und kommuniziert über einen klar definierten, leichtgewichtigen Mechanismus, um ein Geschäftsziel zu erfüllen. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>

Pinterest könnte beispielsweise folgende Microservices haben: Nutzerprofil, Follower, Feed, Suche, Foto-Upload usw.

### Service Discovery

Systeme wie [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), und [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) helfen Diensten, sich gegenseitig zu finden, indem sie registrierte Namen, Adressen und Ports verfolgen. [Health Checks](https://www.consul.io/intro/getting-started/checks.html) helfen, die Integrität der Dienste zu überprüfen und werden oft über einen [HTTP](#hypertext-transfer-protocol-http)-Endpunkt durchgeführt. Sowohl Consul als auch Etcd verfügen über einen eingebauten [Key-Value Store](#key-value-store), der sich zum Speichern von Konfigurationswerten und anderen gemeinsamen Daten eignet.

### Nachteil(e): Anwendungsschicht

* Das Hinzufügen einer Anwendungsschicht mit lose gekoppelten Diensten erfordert aus architektonischer, betrieblicher und prozessbezogener Sicht einen anderen Ansatz (im Vergleich zu einem monolithischen System).
* Microservices können zusätzliche Komplexität hinsichtlich Bereitstellung und Betrieb verursachen.

### Quelle(n) und weiterführende Literatur

* [Einführung in die Systemarchitektur für Skalierung](http://lethain.com/introduction-to-architecting-systems-for-scale)
* [Das Systemdesign-Interview meistern](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Serviceorientierte Architektur](https://de.wikipedia.org/wiki/Serviceorientierte_Architektur)
* [Einführung in Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)
* [Das sollten Sie über den Aufbau von Microservices wissen](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)

## Datenbank

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Quelle: Skalierung auf die ersten 10 Millionen Nutzer</a></i>
</p>

### Relationale Datenbankmanagementsysteme (RDBMS)

Eine relationale Datenbank wie SQL ist eine Sammlung von Datenelementen, die in Tabellen organisiert sind.

**ACID** ist eine Eigenschaftengruppe von relationalen Datenbank-[Transaktionen](https://de.wikipedia.org/wiki/Transaktion_(Datenbank)).

* **Atomarität** – Jede Transaktion wird ganz oder gar nicht ausgeführt
* **Konsistenz** – Jede Transaktion bringt die Datenbank von einem gültigen Zustand in einen anderen
* **Isolation** – Gleichzeitige Ausführung von Transaktionen hat die gleichen Ergebnisse, als würden die Transaktionen seriell ausgeführt
* **Dauerhaftigkeit** – Sobald eine Transaktion bestätigt wurde, bleibt sie bestehen

Es gibt viele Techniken, um eine relationale Datenbank zu skalieren: **Master-Slave-Replikation**, **Master-Master-Replikation**, **Föderation**, **Sharding**, **Denormalisierung** und **SQL-Tuning**.

#### Master-Slave-Replikation

Der Master verarbeitet Lese- und Schreibzugriffe und repliziert Schreibzugriffe an einen oder mehrere Slaves, die ausschließlich Lesezugriffe bedienen. Slaves können auch an weitere Slaves in einer baumartigen Struktur replizieren. Wenn der Master ausfällt, kann das System im Nur-Lese-Modus weiterarbeiten, bis ein Slave zum Master befördert oder ein neuer Master bereitgestellt wird.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Quelle: Skalierbarkeit, Verfügbarkeit, Stabilität, Muster</a></i>
</p>

##### Nachteil(e): Master-Slave-Replikation

* Zusätzliche Logik ist erforderlich, um einen Slave zum Master zu befördern.
* Siehe [Nachteil(e): Replikation](#disadvantages-replication) für Punkte, die **sowohl** Master-Slave als auch Master-Master betreffen.

#### Master-Master-Replikation

Beide Master bedienen Lese- und Schreibzugriffe und koordinieren Schreibzugriffe miteinander. Fällt einer der Master aus, kann das System weiterhin mit Lese- und Schreibzugriffen arbeiten.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Quelle: Skalierbarkeit, Verfügbarkeit, Stabilität, Muster</a></i>
</p>

##### Nachteil(e): Master-Master-Replikation

* Sie benötigen einen Load-Balancer oder müssen Änderungen an Ihrer Anwendungslogik vornehmen, um zu bestimmen, wo geschrieben wird.
* Die meisten Master-Master-Systeme sind entweder lose konsistent (Verstoß gegen ACID) oder haben erhöhte Schreiblatenz durch Synchronisation.
* Die Konfliktlösung wird wichtiger, je mehr Schreibknoten hinzugefügt werden und je höher die Latenz ist.
* Siehe [Nachteil(e): Replikation](#disadvantages-replication) für Punkte, die **sowohl** Master-Slave als auch Master-Master betreffen.

##### Nachteil(e): Replikation

* Es besteht die Möglichkeit eines Datenverlusts, wenn der Master ausfällt, bevor neu geschriebene Daten auf andere Knoten repliziert werden können.
* Schreibvorgänge werden auf die Lese-Replikas übertragen. Wenn es viele Schreibvorgänge gibt, können die Lese-Replikas durch das Wiederholen der Schreibvorgänge überlastet werden und dadurch weniger Lesevorgänge ausführen.
* Je mehr Lese-Slaves es gibt, desto mehr muss repliziert werden, was zu einer größeren Replikationsverzögerung führt.
* In einigen Systemen kann das Schreiben auf den Master mehrere Threads zur parallelen Verarbeitung verwenden, während Lese-Replikas das Schreiben nur sequenziell mit einem einzelnen Thread unterstützen.
* Replikation erfordert mehr Hardware und zusätzliche Komplexität.

##### Quelle(n) und weiterführende Literatur: Replikation

* [Skalierbarkeit, Verfügbarkeit, Stabilität, Muster](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Multi-Master-Replikation](https://de.wikipedia.org/wiki/Multi-master_replication)

#### Föderation

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Quelle: Scaling up to your first 10 million users</a></i>
</p>

Föderation (oder funktionale Partitionierung) teilt Datenbanken nach Funktion auf. Zum Beispiel könnte man statt einer einzigen, monolithischen Datenbank drei Datenbanken haben: **foren**, **benutzer** und **produkte**, was zu weniger Lese- und Schreibverkehr pro Datenbank und somit zu geringerer Replikationsverzögerung führt. Kleinere Datenbanken erlauben mehr Daten im Arbeitsspeicher, was wiederum zu mehr Cache-Treffern durch verbesserte Cache-Lokalität führt. Da kein zentraler Master die Schreibvorgänge serialisiert, kann parallel geschrieben werden, was den Durchsatz erhöht.

##### Nachteil(e): Föderation

* Föderation ist nicht effektiv, wenn Ihr Schema große Funktionen oder Tabellen erfordert.
* Sie müssen Ihre Anwendungslogik aktualisieren, um zu bestimmen, aus welcher Datenbank gelesen und in welche geschrieben werden soll.
* Das Zusammenführen von Daten aus zwei Datenbanken ist mit einem [Server-Link](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers) komplexer.
* Föderation erfordert mehr Hardware und zusätzliche Komplexität.

##### Quelle(n) und weiterführende Literatur: Föderation

* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=kKjm4ehYiMs)

#### Sharding

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Quelle: Skalierbarkeit, Verfügbarkeit, Stabilitätsmuster</a></i>
</p>

Sharding verteilt Daten auf verschiedene Datenbanken, so dass jede Datenbank nur einen Teil der Daten verwalten kann. Am Beispiel einer Benutzerdatenbank: Mit steigender Anzahl der Benutzer werden dem Cluster weitere Shards hinzugefügt.

Ähnlich wie die Vorteile von [Federation](#federation) führt Sharding zu weniger Lese- und Schreibverkehr, weniger Replikation und mehr Cache-Treffern. Auch die Indexgröße wird reduziert, was die Performance mit schnelleren Abfragen meist verbessert. Fällt ein Shard aus, sind die anderen weiterhin funktionsfähig, obwohl man zur Vermeidung von Datenverlust eine Replikation hinzufügen sollte. Wie bei Federation gibt es keinen zentralen Master, der Schreibvorgänge serialisiert, sodass paralleles Schreiben mit höherem Durchsatz möglich ist.

Übliche Methoden zum Sharding einer Benutzertabelle sind entweder über das Anfangsbuchstaben des Nachnamens oder den geografischen Standort des Benutzers.

##### Nachteil(e): Sharding

* Die Anwendungslogik muss an die Arbeit mit Shards angepasst werden, was zu komplexen SQL-Abfragen führen kann.
* Die Datenverteilung in einem Shard kann unausgewogen sein. Beispielsweise kann eine Gruppe von Power-Usern auf einem Shard zu erhöhter Belastung dieses Shards im Vergleich zu anderen führen.
    * Rebalancing erhöht die Komplexität zusätzlich. Eine Sharding-Funktion auf Basis von [konsistentem Hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) kann die Menge der zu übertragenden Daten reduzieren.
* Das Zusammenführen von Daten aus mehreren Shards ist komplexer.
* Sharding erfordert mehr Hardware und zusätzliche Komplexität.

##### Quelle(n) und weiterführende Literatur: Sharding

* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)
* [Shard-Datenbankarchitektur](https://de.wikipedia.org/wiki/Shard_(database_architecture))
* [Konsistentes Hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)

#### Denormalisierung

Denormalisierung versucht, die Leseleistung auf Kosten der Schreibperformance zu verbessern. Redundante Kopien der Daten werden in mehreren Tabellen gespeichert, um teure Joins zu vermeiden. Einige relationale DBMS wie [PostgreSQL](https://de.wikipedia.org/wiki/PostgreSQL) und Oracle unterstützen [materialisierte Sichten](https://de.wikipedia.org/wiki/Materialisierte_Sicht), die das Speichern redundanter Informationen und deren Konsistenz automatisch übernehmen.

Sobald Daten mit Techniken wie [Federation](#federation) und [Sharding](#sharding) verteilt werden, erhöht das Management von Joins über Rechenzentren hinweg die Komplexität weiter. Denormalisierung kann die Notwendigkeit solcher komplexen Joins umgehen.

In den meisten Systemen stehen die Lesezugriffe den Schreibzugriffen im Verhältnis 100:1 oder sogar 1000:1 gegenüber. Ein Lesezugriff, der einen komplexen Datenbank-Join erfordert, kann sehr teuer sein und viel Zeit für Plattenoperationen beanspruchen.

##### Nachteil(e): Denormalisierung

* Daten werden dupliziert.
* Constraints können helfen, redundante Kopien von Informationen synchron zu halten, was die Komplexität des Datenbankdesigns erhöht.
* Eine denormalisierte Datenbank unter hoher Schreiblast kann schlechter performen als ihr normalisiertes Pendant.

###### Quelle(n) und weiterführende Literatur: Denormalisierung

* [Denormalisierung](https://de.wikipedia.org/wiki/Denormalisierung)

#### SQL-Tuning

SQL-Tuning ist ein umfangreiches Thema und viele [Bücher](https://www.amazon.de/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) wurden als Referenz geschrieben.

Es ist wichtig, **Benchmarks** und **Profiling** durchzuführen, um Engpässe zu simulieren und aufzudecken.

* **Benchmark** – Simuliere Hochlastsituationen mit Tools wie [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).
* **Profiling** – Aktiviere Tools wie das [Slow Query Log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html), um Performanceprobleme zu verfolgen.

Benchmarking und Profiling können auf folgende Optimierungen hinweisen.

##### Das Schema optimieren

* MySQL schreibt Daten auf die Festplatte in zusammenhängenden Blöcken für schnellen Zugriff.
* Verwende `CHAR` anstelle von `VARCHAR` für Felder mit fester Länge.
    * `CHAR` ermöglicht effektiv schnellen, zufälligen Zugriff, während bei `VARCHAR` das Ende eines Strings gefunden werden muss, bevor zum nächsten gewechselt werden kann.
* Verwende `TEXT` für große Textblöcke wie Blogbeiträge. `TEXT` ermöglicht auch boolesche Suchen. Die Verwendung eines `TEXT`-Feldes führt dazu, dass ein Zeiger auf der Festplatte gespeichert wird, der zum Auffinden des Textblocks dient.
* Verwende `INT` für größere Zahlen bis zu 2^32 oder 4 Milliarden.
* Verwende `DECIMAL` für Währungsbeträge, um Fehler bei der Fließkommadarstellung zu vermeiden.
* Vermeide das Speichern großer `BLOBS`, speichere stattdessen den Ort, an dem das Objekt abgelegt ist.
* `VARCHAR(255)` ist die größte Anzahl von Zeichen, die in einer 8-Bit-Zahl gezählt werden kann, was oft die Nutzung eines Bytes in manchen RDBMS maximiert.
* Setze das `NOT NULL`-Constraint, wo dies möglich ist, um [die Suchleistung zu verbessern](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).

##### Gute Indizes verwenden

* Spalten, nach denen du abfragst (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`), können mit Indizes schneller sein.
* Indizes werden meist als selbstbalancierende [B-Bäume](https://de.wikipedia.org/wiki/B-Baum) dargestellt, die Daten sortiert halten und Suchen, sequentiellen Zugriff, Einfügen und Löschen in logarithmischer Zeit ermöglichen.
* Ein Index kann dazu führen, dass die Daten im Speicher gehalten werden, was mehr Speicherplatz erfordert.
* Schreibvorgänge können langsamer werden, da auch der Index aktualisiert werden muss.
* Beim Laden großer Datenmengen kann es schneller sein, Indizes zu deaktivieren, die Daten zu laden und dann die Indizes neu zu erstellen.

##### Aufwändige Joins vermeiden

* [Denormalisiere](#denormalisierung), wenn es die Performance erfordert.

##### Tabellen partitionieren

* Zerlegen Sie eine Tabelle, indem Sie Hotspots in eine separate Tabelle legen, um sie besser im Speicher zu halten.

##### Optimieren Sie den Abfrage-Cache

* In einigen Fällen kann der [Abfrage-Cache](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) zu [Leistungsproblemen](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/) führen.

##### Quelle(n) und weitere Lektüre: SQL-Tuning

* [Tipps zur Optimierung von MySQL-Abfragen](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)
* [Gibt es einen guten Grund, warum VARCHAR(255) so oft verwendet wird?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [Wie beeinflussen Null-Werte die Leistung?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Langsame Abfragelog](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)

### NoSQL

NoSQL ist eine Sammlung von Datenelementen, die als **Key-Value Store**, **Dokumenten-Store**, **Wide Column Store** oder **Graphdatenbank** dargestellt werden. Die Daten sind denormalisiert, und Joins werden in der Regel im Anwendungscode durchgeführt. Die meisten NoSQL-Stores verfügen nicht über echte ACID-Transaktionen und bevorzugen [eventuelle Konsistenz](#eventual-consistency).

**BASE** wird oft verwendet, um die Eigenschaften von NoSQL-Datenbanken zu beschreiben. Im Vergleich zum [CAP-Theorem](#cap-theorem) wählt BASE Verfügbarkeit statt Konsistenz.

* **Basically available** – das System garantiert Verfügbarkeit.
* **Soft state** – der Zustand des Systems kann sich im Laufe der Zeit ändern, auch ohne Eingaben.
* **Eventual consistency** – das System wird über einen Zeitraum hinweg konsistent, sofern das System während dieses Zeitraums keine Eingaben erhält.

Zusätzlich zur Entscheidung zwischen [SQL oder NoSQL](#sql-or-nosql) ist es hilfreich zu verstehen, welcher Typ von NoSQL-Datenbank am besten zu Ihrem Anwendungsfall passt. Im nächsten Abschnitt werden wir **Key-Value Stores**, **Dokumenten-Stores**, **Wide Column Stores** und **Graphdatenbanken** betrachten.

#### Key-Value Store

> Abstraktion: Hashtabelle

Ein Key-Value Store erlaubt im Allgemeinen O(1)-Lese- und Schreibzugriffe und basiert oft auf Speicher oder SSD. Datenspeicher können Schlüssel in [lexikographischer Reihenfolge](https://de.wikipedia.org/wiki/Lexikographische_Ordnung) halten, was eine effiziente Abfrage von Schlüsselbereichen ermöglicht. Key-Value Stores erlauben das Speichern von Metadaten zusammen mit einem Wert.

Key-Value Stores bieten hohe Leistung und werden häufig für einfache Datenmodelle oder für sich schnell ändernde Daten wie z.B. eine In-Memory-Cache-Schicht verwendet. Da sie nur einen begrenzten Satz von Operationen bieten, wird zusätzliche Komplexität bei Bedarf auf die Anwendungsebene verlagert.

Ein Key-Value Store bildet die Grundlage für komplexere Systeme wie z.B. einen Dokumenten-Store und in manchen Fällen auch für eine Graphdatenbank.

##### Quelle(n) und weitere Lektüre: Key-Value Store

* [Key-Value-Datenbank](https://de.wikipedia.org/wiki/Key-Value-Datenbank)
* [Nachteile von Key-Value Stores](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)
* [Redis-Architektur](http://qnimate.com/overview-of-redis-architecture/)
* [Memcached-Architektur](https://adayinthelifeof.nl/2011/02/06/memcache-internals/)

#### Dokumentenspeicher

> Abstraktion: Schlüssel-Wert-Speicher mit Dokumenten als Werte

Ein Dokumentenspeicher konzentriert sich auf Dokumente (XML, JSON, Binärdateien, usw.), wobei ein Dokument alle Informationen für ein bestimmtes Objekt speichert. Dokumentenspeicher bieten APIs oder eine Abfragesprache, um auf Basis der internen Struktur des Dokuments selbst zu suchen. *Beachte, viele Schlüssel-Wert-Speicher bieten Funktionen zur Arbeit mit den Metadaten eines Werts, wodurch die Grenzen zwischen diesen beiden Speichertypen verschwimmen.*

Je nach zugrundeliegender Implementierung werden Dokumente nach Sammlungen, Tags, Metadaten oder Verzeichnissen organisiert. Obwohl Dokumente organisiert oder gruppiert werden können, können sie Felder aufweisen, die sich völlig voneinander unterscheiden.

Einige Dokumentenspeicher wie [MongoDB](https://www.mongodb.com/mongodb-architecture) und [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) bieten auch eine SQL-ähnliche Sprache, um komplexe Abfragen durchzuführen. [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) unterstützt sowohl Schlüssel-Werte als auch Dokumente.

Dokumentenspeicher bieten hohe Flexibilität und werden oft für die Arbeit mit gelegentlich veränderlichen Daten verwendet.

##### Quelle(n) und weiterführende Literatur: Dokumentenspeicher

* [Dokumentenorientierte Datenbank](https://de.wikipedia.org/wiki/Dokumentenorientierte_Datenbank)
* [MongoDB-Architektur](https://www.mongodb.com/mongodb-architecture)
* [CouchDB-Architektur](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Elasticsearch-Architektur](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)

#### Wide Column Store

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Quelle: SQL & NoSQL, eine kurze Geschichte</a></i>
</p>

> Abstraktion: verschachtelte Map `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`

Die Grundeinheit eines Wide Column Store ist eine Spalte (Name/Wert-Paar). Eine Spalte kann in Spaltenfamilien gruppiert werden (vergleichbar mit einer SQL-Tabelle). Super-Spaltenfamilien gruppieren Spaltenfamilien weiter. Jede Spalte kann unabhängig mit einem Zeilenschlüssel abgerufen werden, und Spalten mit demselben Zeilenschlüssel bilden eine Zeile. Jeder Wert enthält einen Zeitstempel zur Versionierung und zur Konfliktlösung.

Google stellte [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) als ersten Wide Column Store vor, was das Open-Source-Projekt [HBase](https://www.edureka.co/blog/hbase-architecture/) im Hadoop-Ökosystem und [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) von Facebook beeinflusste. Stores wie BigTable, HBase und Cassandra halten Schlüssel in lexikografischer Reihenfolge und ermöglichen eine effiziente Abfrage von selektiven Schlüsselbereichen.

Wide Column Stores bieten hohe Verfügbarkeit und hohe Skalierbarkeit. Sie werden häufig für sehr große Datensätze eingesetzt.

##### Quelle(n) und weiterführende Literatur: Wide Column Store

* [SQL & NoSQL, eine kurze Geschichte](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)
* [Bigtable-Architektur](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)
* [HBase-Architektur](https://www.edureka.co/blog/hbase-architecture/)
* [Cassandra-Architektur](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)

#### Graphdatenbank

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png">
  <br/>
  <i><a href=https://de.wikipedia.org/wiki/Datei:GraphDatabase_PropertyGraph.png>Quelle: Graphdatenbank</a></i>
</p>

> Abstraktion: Graph

In einer Graphdatenbank ist jeder Knoten ein Datensatz und jeder Bogen eine Beziehung zwischen zwei Knoten. Graphdatenbanken sind darauf optimiert, komplexe Beziehungen mit vielen Fremdschlüsseln oder viele-zu-viele-Beziehungen darzustellen.

Graphdatenbanken bieten eine hohe Leistung für Datenmodelle mit komplexen Beziehungen, wie beispielsweise ein soziales Netzwerk. Sie sind relativ neu und werden noch nicht weit verbreitet eingesetzt; es kann schwieriger sein, Entwicklungswerkzeuge und Ressourcen zu finden. Viele Graphen sind nur über [REST-APIs](#representational-state-transfer-rest) zugänglich.

##### Quelle(n) und weiterführende Literatur: Graph

* [Graphdatenbank](https://de.wikipedia.org/wiki/Graphdatenbank)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)

#### Quelle(n) und weiterführende Literatur: NoSQL

* [Erklärung der Basisterminologie](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [NoSQL-Datenbanken – eine Übersicht und Entscheidungshilfe](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [Skalierbarkeit](https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [Einführung in NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [NoSQL-Muster](http://horicky.blogspot.com/2009/11/nosql-patterns.html)

### SQL oder NoSQL

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Quelle: Übergang von RDBMS zu NoSQL</a></i>
</p>

Gründe für **SQL**:

* Strukturierte Daten
* Striktes Schema
* Relationale Daten
* Bedarf an komplexen Joins
* Transaktionen
* Klare Muster für Skalierung
* Etablierter: Entwickler, Community, Code, Tools, usw.
* Suchvorgänge über Index sind sehr schnell

Gründe für **NoSQL**:

* Semistrukturierte Daten
* Dynamisches oder flexibles Schema
* Nicht-relationale Daten
* Kein Bedarf an komplexen Joins
* Speicherung vieler TB (oder PB) an Daten
* Sehr datenintensive Arbeitslast
* Sehr hohe Durchsatzrate für IOPS

Beispieldaten, die gut für NoSQL geeignet sind:

* Schnelles Einlesen von Clickstream- und Logdaten
* Leaderboard- oder Bewertungsdaten
* Temporäre Daten, wie z. B. ein Warenkorb
* Häufig abgerufene ('heiße') Tabellen
* Metadaten-/Lookup-Tabellen

##### Quelle(n) und weiterführende Literatur: SQL oder NoSQL

* [Skalierung auf die ersten 10 Millionen Nutzer](https://www.youtube.com/watch?v=kKjm4ehYiMs)
* [Unterschiede zwischen SQL und NoSQL](https://www.sitepoint.com/sql-vs-nosql-differences/)

## Cache

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Quelle: Skalierbare Systemdesign-Muster</a></i>
</p>

Caching verbessert die Ladezeiten von Seiten und kann die Belastung Ihrer Server und Datenbanken verringern. In diesem Modell prüft der Dispatcher zunächst, ob die Anfrage bereits gestellt wurde und versucht, das vorherige Ergebnis zu finden und zurückzugeben, um die tatsächliche Ausführung zu sparen.

Datenbanken profitieren oft von einer gleichmäßigen Verteilung von Lese- und Schreibvorgängen über ihre Partitionen. Beliebte Elemente können die Verteilung verzerren und Engpässe verursachen. Ein Cache vor der Datenbank kann helfen, ungleichmäßige Lasten und Verkehrsspitzen abzufangen.

### Client-Caching

Caches können sich auf der Client-Seite (Betriebssystem oder Browser), [Server-Seite](#reverse-proxy-web-server) oder in einer eigenen Cache-Schicht befinden.

### CDN-Caching

[CDNs](#content-delivery-network) werden als eine Art Cache betrachtet.

### Webserver-Caching

[Reverse Proxies](#reverse-proxy-web-server) und Caches wie [Varnish](https://www.varnish-cache.org/) können statische und dynamische Inhalte direkt ausliefern. Webserver können ebenfalls Anfragen cachen und Antworten zurückgeben, ohne die Anwendungsserver zu kontaktieren.

### Datenbank-Caching

Ihre Datenbank enthält normalerweise ein gewisses Maß an Caching in der Standardkonfiguration, optimiert für einen generischen Anwendungsfall. Die Anpassung dieser Einstellungen an spezifische Nutzungsmuster kann die Leistung weiter steigern.

### Anwendungs-Caching

In-Memory-Caches wie Memcached und Redis sind Key-Value-Stores zwischen Ihrer Anwendung und Ihrem Datenspeicher. Da die Daten im RAM gehalten werden, ist der Zugriff viel schneller als bei typischen Datenbanken, bei denen die Daten auf Festplatte gespeichert sind. RAM ist begrenzter als Festplattenspeicher, daher können [Cache-Invalidierungs-Algorithmen](https://de.wikipedia.org/wiki/Cache_Algorithmen) wie [Least Recently Used (LRU)](https://de.wikipedia.org/wiki/Cache-Ersatzstrategie#Least_Recently_Used_(LRU)) helfen, „kalte“ Einträge zu entfernen und „heiße“ Daten im RAM zu halten.

Redis bietet folgende zusätzliche Funktionen:

* Persistenzoption
* Eingebaute Datenstrukturen wie sortierte Sets und Listen

Es gibt mehrere Ebenen, auf denen Sie cachen können, die in zwei Hauptkategorien fallen: **Datenbankabfragen** und **Objekte**:

* Zeilenebene
* Abfrageebene
* Vollständig geformte serialisierbare Objekte
* Vollständig gerendertes HTML

Im Allgemeinen sollten Sie dateibasiertes Caching vermeiden, da es das Klonen und Auto-Scaling erschwert.

### Caching auf Datenbankabfrage-Ebene

Jedes Mal, wenn Sie die Datenbank abfragen, hashen Sie die Abfrage als Schlüssel und speichern das Ergebnis im Cache. Dieser Ansatz leidet unter Ablaufproblemen:

* Schwer zu löschendes, zwischengespeichertes Ergebnis bei komplexen Abfragen
* Wenn ein Datenstück wie eine Tabellenzelle geändert wird, müssen alle zwischengespeicherten Abfragen gelöscht werden, die die geänderte Zelle enthalten könnten

### Caching auf Objektebene

Betrachten Sie Ihre Daten als Objekt, ähnlich wie Sie es mit Ihrem Anwendungscode tun. Lassen Sie Ihre Anwendung den Datensatz aus der Datenbank zu einer Klasseninstanz oder Datenstruktur(en) zusammensetzen:

* Entfernen Sie das Objekt aus dem Cache, wenn sich die zugrundeliegenden Daten geändert haben
* Ermöglicht asynchrone Verarbeitung: Worker erstellen Objekte, indem sie das aktuellste zwischengespeicherte Objekt konsumieren

Vorschläge, was zwischengespeichert werden sollte:

* Benutzersitzungen
* Komplett gerenderte Webseiten
* Aktivitätsstreams
* Benutzergrafdaten

### Wann sollte der Cache aktualisiert werden

Da Sie nur eine begrenzte Menge an Daten im Cache speichern können, müssen Sie bestimmen, welche Strategie zur Cache-Aktualisierung am besten für Ihren Anwendungsfall geeignet ist.

#### Cache-aside

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Quelle: From cache to in-memory data grid</a></i>
</p>

Die Anwendung ist dafür verantwortlich, aus dem Speicher zu lesen und zu schreiben. Der Cache interagiert nicht direkt mit dem Speicher. Die Anwendung tut Folgendes:

* Suche nach Eintrag im Cache, was zu einem Cache-Miss führt
* Lade Eintrag aus der Datenbank
* Füge Eintrag zum Cache hinzu
* Gib Eintrag zurück

```python
def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```
[Memcached](https://memcached.org/) wird in der Regel auf diese Weise verwendet.

Nachfolgende Lesezugriffe auf in den Cache hinzugefügte Daten sind schnell. Cache-aside wird auch als Lazy Loading bezeichnet. Es werden nur angeforderte Daten zwischengespeichert, wodurch vermieden wird, dass der Cache mit nicht angeforderten Daten gefüllt wird.

##### Nachteil(e): Cache-aside

* Jeder Cache-Miss führt zu drei Zugriffen, was zu einer spürbaren Verzögerung führen kann.
* Daten können veraltet sein, wenn sie in der Datenbank aktualisiert werden. Dieses Problem wird durch das Setzen einer Time-to-Live (TTL) gemildert, die ein Update des Cache-Eintrags erzwingt, oder durch die Verwendung von Write-through.
* Fällt ein Knoten aus, wird er durch einen neuen, leeren Knoten ersetzt, was die Latenz erhöht.

#### Write-through

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Quelle: Skalierbarkeit, Verfügbarkeit, Stabilität, Muster</a></i>
</p>

Die Anwendung verwendet den Cache als Hauptdatenspeicher, liest und schreibt Daten darin, während der Cache für das Lesen und Schreiben in die Datenbank verantwortlich ist:

* Die Anwendung fügt einen Eintrag zum Cache hinzu oder aktualisiert ihn
* Der Cache schreibt den Eintrag synchron in den Datenspeicher
* Rückgabe

Anwendungscode:


```python
set_user(12345, {"foo":"bar"})
```

Cache-Code:

```python
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```
Write-through ist insgesamt ein langsamerer Vorgang aufgrund der Schreiboperation, aber nachfolgende Lesevorgänge von gerade geschriebenen Daten sind schnell. Benutzer sind im Allgemeinen toleranter gegenüber Latenz beim Aktualisieren von Daten als beim Lesen von Daten. Daten im Cache sind nicht veraltet.

##### Nachteil(e): Write-through

* Wenn ein neuer Knoten aufgrund eines Ausfalls oder Skalierung erstellt wird, wird der neue Knoten keine Einträge cachen, bis der Eintrag in der Datenbank aktualisiert wird. Cache-aside in Verbindung mit Write-through kann dieses Problem mindern.
* Die meisten geschriebenen Daten werden möglicherweise nie gelesen, was durch eine TTL minimiert werden kann.

#### Write-behind (Write-back)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Quelle: Skalierbarkeit, Verfügbarkeit, Stabilitätsmuster</a></i>
</p>

Beim Write-behind führt die Anwendung Folgendes aus:

* Hinzufügen/Aktualisieren des Eintrags im Cache
* Asynchrones Schreiben des Eintrags in den Datenspeicher, was die Schreibleistung verbessert

##### Nachteil(e): Write-behind

* Es kann zu Datenverlust kommen, wenn der Cache ausfällt, bevor sein Inhalt den Datenspeicher erreicht.
* Die Implementierung von Write-behind ist komplexer als die von Cache-aside oder Write-through.

#### Refresh-ahead

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Quelle: Vom Cache zum In-Memory Data Grid</a></i>
</p>

Der Cache kann so konfiguriert werden, dass kürzlich abgerufene Cache-Einträge automatisch vor deren Ablauf aktualisiert werden.

Refresh-ahead kann zu geringerer Latenz im Vergleich zu Read-through führen, wenn der Cache genau vorhersagen kann, welche Elemente wahrscheinlich zukünftig benötigt werden.

##### Nachteil(e): Refresh-ahead


* Wenn nicht genau vorhergesagt wird, welche Elemente in Zukunft benötigt werden, kann dies zu einer geringeren Performance führen als ohne Refresh-Ahead.

### Nachteil(e): Cache

* Es muss Konsistenz zwischen Caches und der maßgeblichen Quelle wie der Datenbank durch [Cache-Invalidierung](https://de.wikipedia.org/wiki/Cache-Algorithmen) aufrechterhalten werden.
* Cache-Invalidierung ist ein schwieriges Problem, es entsteht zusätzliche Komplexität im Zusammenhang mit dem Zeitpunkt der Aktualisierung des Caches.
* Es sind Änderungen an der Anwendung erforderlich, wie z. B. das Hinzufügen von Redis oder Memcached.

### Quelle(n) und weiterführende Literatur

* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [Scalable system design patterns](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [Introduction to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Scalability](https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [AWS ElastiCache strategies](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)
* [Wikipedia](https://de.wikipedia.org/wiki/Cache_(Informatik))

## Asynchronität

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Quelle: Intro to architecting systems for scale</a></i>
</p>

Asynchrone Workflows helfen, Anforderungszeiten für aufwendige Operationen zu verkürzen, die sonst inline ausgeführt würden. Sie können auch helfen, indem sie zeitaufwändige Arbeiten im Voraus erledigen, wie z. B. periodische Aggregationen von Daten.

### Message Queues

Message Queues empfangen, halten und liefern Nachrichten aus. Wenn eine Operation zu langsam ist, um sie inline auszuführen, kann eine Message Queue mit folgendem Ablauf verwendet werden:

* Eine Anwendung veröffentlicht einen Job in der Warteschlange und benachrichtigt den Nutzer über den Jobstatus
* Ein Worker nimmt den Job aus der Warteschlange, verarbeitet ihn und signalisiert anschließend, dass der Job abgeschlossen ist

Der Nutzer wird nicht blockiert und der Job wird im Hintergrund verarbeitet. Während dieser Zeit kann der Client optional eine kleine Verarbeitung durchführen, um es so erscheinen zu lassen, als sei die Aufgabe bereits erledigt. Zum Beispiel kann beim Posten eines Tweets der Tweet sofort in deiner Timeline erscheinen, es kann jedoch einige Zeit dauern, bis dein Tweet tatsächlich allen Followern zugestellt wird.

**[Redis](https://redis.io/)** ist als einfacher Message Broker nützlich, aber Nachrichten können verloren gehen.

**[RabbitMQ](https://www.rabbitmq.com/)** ist beliebt, erfordert jedoch die Anpassung an das 'AMQP'-Protokoll und das Verwalten eigener Nodes.

**[Amazon SQS](https://aws.amazon.com/sqs/)** ist gehostet, kann jedoch eine hohe Latenz aufweisen und es besteht die Möglichkeit, dass Nachrichten doppelt zugestellt werden.

### Aufgabenwarteschlangen

Aufgabenwarteschlangen empfangen Aufgaben und die zugehörigen Daten, führen diese aus und liefern dann ihre Ergebnisse. Sie können die Planung unterstützen und werden verwendet, um rechenintensive Jobs im Hintergrund auszuführen.

**[Celery](https://docs.celeryproject.org/en/stable/)** unterstützt die Planung und bietet hauptsächlich Unterstützung für Python.

### Rückstau (Back pressure)

Wenn Warteschlangen signifikant wachsen, kann die Warteschlangengröße größer als der Arbeitsspeicher werden, was zu Cache-Verlusten, Festplattenzugriffen und noch langsamerer Leistung führt. [Rückstau](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) kann helfen, indem die Warteschlangengröße begrenzt wird und so eine hohe Durchsatzrate und gute Antwortzeiten für bereits in der Warteschlange befindliche Jobs erhalten bleiben. Sobald die Warteschlange voll ist, erhalten Clients einen „Server busy“- oder HTTP-503-Statuscode, um es später erneut zu versuchen. Clients können die Anfrage zu einem späteren Zeitpunkt erneut senden, eventuell mit [exponentiellem Backoff](https://en.wikipedia.org/wiki/Exponential_backoff).

### Nachteil(e): Asynchronität

* Anwendungsfälle wie kostengünstige Berechnungen und Echtzeit-Workflows sind möglicherweise besser für synchrone Operationen geeignet, da die Einführung von Warteschlangen Verzögerungen und Komplexität verursachen kann.

### Quellen und weiterführende Literatur

* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)
* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)
* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)

## Kommunikation

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Quelle: OSI 7-Schichten-Modell</a></i>
</p>

### Hypertext Transfer Protocol (HTTP)

HTTP ist eine Methode zur Kodierung und Übertragung von Daten zwischen einem Client und einem Server. Es handelt sich um ein Request/Response-Protokoll: Clients stellen Anfragen und Server liefern Antworten mit relevanten Inhalten und Statusinformationen zur Anfrage. HTTP ist selbstständig und ermöglicht, dass Anfragen und Antworten durch viele Zwischenrouter und Server fließen, die Lastverteilung, Caching, Verschlüsselung und Kompression durchführen.

Eine grundlegende HTTP-Anfrage besteht aus einem Verb (Methode) und einer Ressource (Endpunkt). Nachfolgend sind gängige HTTP-Verben aufgeführt:

| Verb | Beschreibung | Idempotent* | Sicher | Cachefähig |
|---|---|---|---|---|
| GET | Liest eine Ressource | Ja | Ja | Ja |
| POST | Erstellt eine Ressource oder löst einen Prozess zur Datenverarbeitung aus | Nein | Nein | Ja, falls die Antwort Frischeinformationen enthält |
| PUT | Erstellt oder ersetzt eine Ressource | Ja | Nein | Nein |
| PATCH | Aktualisiert eine Ressource teilweise | Nein | Nein | Ja, falls die Antwort Frischeinformationen enthält |
| DELETE | Löscht eine Ressource | Ja | Nein | Nein |

*Kann mehrfach aufgerufen werden, ohne unterschiedliche Ergebnisse zu erzeugen.

HTTP ist ein Protokoll der Anwendungsschicht, das auf darunterliegenden Protokollen wie **TCP** und **UDP** basiert.

#### Quelle(n) und weiterführende Literatur: HTTP

* [Was ist HTTP?](https://www.nginx.com/resources/glossary/http/)
* [Unterschied zwischen HTTP und TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [Unterschied zwischen PUT und PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)

### Transmission Control Protocol (TCP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Quelle: How to make a multiplayer game</a></i>
</p>

TCP ist ein verbindungsorientiertes Protokoll über ein [IP-Netzwerk](https://en.wikipedia.org/wiki/Internet_Protocol).  Die Verbindung wird mittels eines [Handshakes](https://en.wikipedia.org/wiki/Handshaking) aufgebaut und beendet.  Alle gesendeten Pakete sind garantiert in der ursprünglichen Reihenfolge und ohne Fehler am Ziel angekommen durch:

* Sequenznummern und [Prüfsummenfelder](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) für jedes Paket
* [Bestätigungspakete](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) und automatische erneute Übertragung

Wenn der Sender keine korrekte Antwort erhält, sendet er die Pakete erneut. Bei mehreren Timeouts wird die Verbindung beendet. TCP implementiert zudem [Flusskontrolle](https://en.wikipedia.org/wiki/Flow_control_(data)) und [Staukontrolle](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control). Diese Garantien verursachen Verzögerungen und führen im Allgemeinen zu einer weniger effizienten Übertragung als bei UDP.

Um einen hohen Durchsatz zu gewährleisten, können Webserver viele TCP-Verbindungen offen halten, was zu hohem Speicherverbrauch führt. Es kann teuer sein, viele offene Verbindungen zwischen Webserver-Threads und beispielsweise einem [memcached](https://memcached.org/) Server zu haben. [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool) kann helfen, zusätzlich zum Wechsel auf UDP, wo dies möglich ist.

TCP ist nützlich für Anwendungen, die hohe Zuverlässigkeit, aber geringere Zeitkritikalität erfordern. Beispiele sind Webserver, Datenbankinformationen, SMTP, FTP und SSH.

Verwenden Sie TCP statt UDP, wenn:

* Sie sicherstellen müssen, dass alle Daten unversehrt ankommen
* Sie automatisch die bestmögliche Netzauslastung erreichen möchten

### User Datagram Protocol (UDP)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Quelle: How to make a multiplayer game</a></i>
</p>

UDP ist verbindungslos. Datagramme (vergleichbar mit Paketen) sind nur auf Datagramm-Ebene garantiert. Datagramme können ihr Ziel in falscher Reihenfolge erreichen oder gar nicht. UDP unterstützt keine Staukontrolle. Ohne die Garantien, die TCP bietet, ist UDP im Allgemeinen effizienter.

UDP kann Broadcasts durchführen und Datagramme an alle Geräte im Subnetz senden. Dies ist nützlich bei [DHCP](https://de.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol), da der Client noch keine IP-Adresse erhalten hat und somit verhindert wird, dass TCP ohne IP-Adresse streamt.

UDP ist weniger zuverlässig, funktioniert aber gut in Echtzeit-Anwendungen wie VoIP, Videochat, Streaming und Echtzeit-Mehrspieler-Spielen.

Verwenden Sie UDP anstelle von TCP, wenn:

* Sie die niedrigste Latenz benötigen
* Späte Daten schlimmer als Datenverlust sind
* Sie Ihre eigene Fehlerkorrektur implementieren möchten

#### Quelle(n) und weiterführende Literatur: TCP und UDP

* [Netzwerkprogrammierung für Spiele](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)
* [Wichtige Unterschiede zwischen TCP- und UDP-Protokollen](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Unterschied zwischen TCP und UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Transmission Control Protocol](https://de.wikipedia.org/wiki/Transmission_Control_Protocol)
* [User Datagram Protocol](https://de.wikipedia.org/wiki/User_Datagram_Protocol)
* [Memcache-Skalierung bei Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)

### Remote Procedure Call (RPC)

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Quelle: Crack the system design interview</a></i>
</p>

Bei einem RPC veranlasst ein Client die Ausführung einer Prozedur in einem anderen Adressraum, meist auf einem entfernten Server. Die Prozedur wird so programmiert, als wäre es ein lokaler Prozeduraufruf, wobei die Details der Kommunikation mit dem Server für das Clientprogramm abstrahiert werden. Remote-Aufrufe sind in der Regel langsamer und weniger zuverlässig als lokale Aufrufe, daher ist es hilfreich, RPC-Aufrufe von lokalen Aufrufen zu unterscheiden. Bekannte RPC-Frameworks sind [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/) und [Avro](https://avro.apache.org/docs/current/).

RPC ist ein Request-Response-Protokoll:

* **Client-Programm** – Ruft die Client-Stub-Prozedur auf. Die Parameter werden wie bei einem lokalen Prozeduraufruf auf den Stack gelegt.
* **Client-Stub-Prozedur** – Marshalt (verpackt) die Prozedur-ID und Argumente in eine Anforderungsnachricht.
* **Client-Kommunikationsmodul** – Das Betriebssystem sendet die Nachricht vom Client zum Server.
* **Server-Kommunikationsmodul** – Das Betriebssystem übergibt die eingehenden Pakete an die Server-Stub-Prozedur.
* **Server-Stub-Prozedur** – Demarshallt die Ergebnisse, ruft die Server-Prozedur mit der passenden Prozedur-ID auf und übergibt die angegebenen Argumente.
* Die Serverantwort wiederholt die obigen Schritte in umgekehrter Reihenfolge.

Beispielhafte RPC-Aufrufe:

```
GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
```

RPC konzentriert sich darauf, Verhaltensweisen offenzulegen. RPCs werden häufig aus Leistungsgründen bei interner Kommunikation eingesetzt, da Sie native Aufrufe handhaben können, um sie besser an Ihre Anwendungsfälle anzupassen.

Wählen Sie eine native Bibliothek (auch SDK genannt), wenn:

* Sie Ihre Zielplattform kennen.
* Sie steuern möchten, wie auf Ihre "Logik" zugegriffen wird.
* Sie kontrollieren möchten, wie die Fehlerbehandlung außerhalb Ihrer Bibliothek erfolgt.
* Leistung und Benutzererfahrung sind Ihre Hauptanliegen.

HTTP-APIs nach **REST** werden häufiger für öffentliche APIs verwendet.

#### Nachteil(e): RPC

* RPC-Clients werden eng an die Service-Implementierung gekoppelt.
* Für jede neue Operation oder jeden neuen Anwendungsfall muss eine neue API definiert werden.
* Das Debuggen von RPC kann schwierig sein.
* Sie können möglicherweise vorhandene Technologien nicht direkt nutzen. Beispielsweise kann zusätzlicher Aufwand erforderlich sein, um sicherzustellen, dass [RPC-Aufrufe ordnungsgemäß zwischengespeichert werden](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) auf Caching-Servern wie [Squid](http://www.squid-cache.org/).

### Representational State Transfer (REST)

REST ist ein Architekturstil, der ein Client/Server-Modell erzwingt, bei dem der Client auf einen Satz von Ressourcen zugreift, die vom Server verwaltet werden. Der Server stellt eine Darstellung von Ressourcen und Aktionen bereit, die entweder Ressourcen manipulieren oder eine neue Darstellung von Ressourcen erhalten können. Die gesamte Kommunikation muss zustandslos und cachefähig sein.

Es gibt vier Eigenschaften einer RESTful-Schnittstelle:

* **Ressourcen identifizieren (URI in HTTP)** – Verwenden Sie unabhängig von der Operation die gleiche URI.
* **Änderung durch Repräsentationen (Verben in HTTP)** – Verwenden Sie Verben, Header und Body.
* **Selbstbeschreibende Fehlermeldung (Statusantwort in HTTP)** – Verwenden Sie Statuscodes, erfinden Sie das Rad nicht neu.
* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML-Schnittstelle für HTTP)** – Ihr Webservice sollte vollständig im Browser zugänglich sein.

Beispielhafte REST-Aufrufe:

```
GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
```

REST konzentriert sich auf die Bereitstellung von Daten. Es minimiert die Kopplung zwischen Client und Server und wird häufig für öffentliche HTTP-APIs verwendet. REST nutzt eine allgemeinere und einheitlichere Methode zur Bereitstellung von Ressourcen über URIs, [Repräsentation über Header](https://github.com/for-GET/know-your-http-well/blob/master/headers.md) und Aktionen über Verben wie GET, POST, PUT, DELETE und PATCH. Da REST zustandslos ist, eignet es sich hervorragend für horizontale Skalierung und Partitionierung.

#### Nachteil(e): REST

* Da REST auf die Bereitstellung von Daten ausgerichtet ist, eignet es sich möglicherweise nicht gut, wenn Ressourcen nicht auf natürliche Weise organisiert sind oder nicht in einer einfachen Hierarchie zugänglich sind. Beispielsweise lässt sich das Zurückgeben aller aktualisierten Datensätze der letzten Stunde, die einer bestimmten Ereignismenge entsprechen, nicht leicht als Pfad ausdrücken. Bei REST wird dies wahrscheinlich durch eine Kombination aus URI-Pfad, Abfrageparametern und möglicherweise dem Anfrageinhalt umgesetzt.
* REST verlässt sich typischerweise auf wenige Verben (GET, POST, PUT, DELETE und PATCH), die manchmal nicht zum Anwendungsfall passen. Beispielsweise passt das Verschieben abgelaufener Dokumente in den Archivordner nicht sauber in diese Verben.
* Das Abrufen komplexer Ressourcen mit verschachtelten Hierarchien erfordert mehrere Roundtrips zwischen Client und Server, um einzelne Ansichten darzustellen, z. B. das Abrufen des Inhalts eines Blog-Eintrags und der Kommentare dazu. Für mobile Anwendungen mit variablen Netzwerkbedingungen sind diese mehrfachen Roundtrips äußerst unerwünscht.
* Mit der Zeit könnten weitere Felder zur API-Antwort hinzugefügt werden, und ältere Clients erhalten alle neuen Datenfelder, auch solche, die sie nicht benötigen; dadurch wird die Payload größer und die Latenz steigt.

### Vergleich von RPC- und REST-Aufrufen

| Operation | RPC | REST |
|---|---|---|
| Anmeldung | **POST** /signup | **POST** /persons |
| Kündigung | **POST** /resign<br/>{<br/>"personid": "1234"<br/>} | **DELETE** /persons/1234 |
| Person lesen | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |
| Liste der Gegenstände einer Person lesen | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |
| Gegenstand zur Liste einer Person hinzufügen | **POST** /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | **POST** /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Gegenstand aktualisieren | **POST** /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | **PUT** /items/456<br/>{<br/>"key": "value"<br/>} |
| Gegenstand löschen | **POST** /removeItem<br/>{<br/>"itemid": "456"<br/>} | **DELETE** /items/456 |

<p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Quelle: Do you really know why you prefer REST over RPC</a></i>
</p>

#### Quellen und weiterführende Literatur: REST und RPC

* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [Wann sind RPC-ähnliche Ansätze angemessener als REST?](http://programmers.stackexchange.com/a/181186)
* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [Entlarvung der Mythen von RPC und REST](https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)
* [Was sind die Nachteile der Verwendung von REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Thrift](https://code.facebook.com/posts/1468950976659943/)
* [Warum REST für interne Nutzung und nicht RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)

## Sicherheit

Dieser Abschnitt könnte ein paar Aktualisierungen gebrauchen. Überlegen Sie, [beizutragen](#contributing)!

Sicherheit ist ein umfassendes Thema.  Sofern Sie nicht über umfangreiche Erfahrung, einen Sicherheits-Hintergrund verfügen oder sich auf eine Position bewerben, die Sicherheitskenntnisse erfordert, müssen Sie wahrscheinlich nicht mehr als die Grundlagen wissen:

* Verschlüsseln Sie Daten während der Übertragung und im Ruhezustand.
* Säubern Sie alle Benutzereingaben oder jegliche Eingabeparameter, die dem Benutzer zugänglich sind, um [XSS](https://de.wikipedia.org/wiki/Cross-site_scripting) und [SQL-Injection](https://de.wikipedia.org/wiki/SQL-Injection) zu verhindern.
* Verwenden Sie parametrisierte Abfragen, um SQL-Injection zu vermeiden.
* Nutzen Sie das Prinzip der [geringsten Privilegien](https://de.wikipedia.org/wiki/Prinzip_des_geringsten_Privilegs).

### Quelle(n) und weiterführende Literatur

* [API-Sicherheits-Checkliste](https://github.com/shieldfy/API-Security-Checklist)
* [Sicherheitsleitfaden für Entwickler](https://github.com/FallibleInc/security-guide-for-developers)
* [OWASP Top Ten](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)

## Anhang

Gelegentlich werden Sie gebeten, „Überschlagsrechnungen“ durchzuführen.  Zum Beispiel müssen Sie vielleicht abschätzen, wie lange das Erzeugen von 100 Bild-Thumbnails von der Festplatte dauert oder wie viel Speicher eine Datenstruktur benötigt.  Die **Zweierpotenztabelle** und **Latenzwerte, die jeder Programmierer kennen sollte** sind dabei nützliche Referenzen.

### Zweierpotenztabelle

```
Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
```

#### Quelle(n) und weiterführende Literatur

* [Zweierpotenzen](https://de.wikipedia.org/wiki/Zweierpotenz)

### Latenzzahlen, die jeder Programmierer kennen sollte

```
Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
HDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
```

Praktische Kennzahlen basierend auf den obigen Zahlen:

* Sequenzielles Lesen von HDD mit 30 MB/s
* Sequenzielles Lesen über 1 Gbps Ethernet mit 100 MB/s
* Sequenzielles Lesen von SSD mit 1 GB/s
* Sequenzielles Lesen aus dem Hauptspeicher mit 4 GB/s
* 6-7 weltweite Round-Trips pro Sekunde
* 2.000 Round-Trips pro Sekunde innerhalb eines Rechenzentrums

#### Visualisierung der Latenzzeiten

![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)

#### Quelle(n) und weiterführende Literatur

* [Latenzzeiten, die jeder Programmierer kennen sollte - 1](https://gist.github.com/jboner/2841832)
* [Latenzzeiten, die jeder Programmierer kennen sollte - 2](https://gist.github.com/hellerbarde/2843375)
* [Designs, Lektionen und Ratschläge aus dem Bau großer verteilter Systeme](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)
* [Software-Engineering-Ratschläge aus dem Bau großskaliger verteilter Systeme](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)

### Weitere Fragen zum Systemdesign-Interview

> Gängige Fragen zum Systemdesign-Interview mit Links zu Ressourcen, wie man jede löst.

| Frage | Referenz(en) |
|---|---|
| Entwerfen Sie einen Datei-Sync-Dienst wie Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| Entwerfen Sie eine Suchmaschine wie Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br/>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |
| Entwerfen Sie einen skalierbaren Web-Crawler wie Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |
| Entwerfen Sie Google Docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |
| Entwerfen Sie einen Key-Value-Store wie Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| Entwerfen Sie ein Cache-System wie Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Entwerfen Sie ein Empfehlungssystem wie das von Amazon | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |
| Entwerfen Sie ein TinyURL-System wie Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |
| Entwerfen Sie eine Chat-App wie WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)
| Entwerfen Sie ein Bilder-Sharing-System wie Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |
| Entwerfen Sie die Facebook-Newsfeed-Funktion | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |
| Entwerfen Sie die Facebook-Timeline-Funktion | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |
| Entwerfen Sie die Facebook-Chat-Funktion | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |
| Entwerfen Sie eine Graph-Suchfunktion wie Facebooks | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |
| Entwerfen Sie ein Content Delivery Network wie CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |
| Entwerfen Sie ein Trending Topic System wie das von Twitter | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |
| Entwerfen Sie ein System zur zufälligen ID-Generierung | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |
| Geben Sie die Top-k-Anfragen in einem Zeitintervall zurück | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |
| Entwerfen Sie ein System, das Daten aus mehreren Rechenzentren bereitstellt | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |
| Entwerfen Sie ein Online-Multiplayer-Kartenspiel | [indieflashblog.com](https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |
| Entwerfen Sie ein Garbage Collection System | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |
| Entwerfen Sie einen API-Rate-Limiter | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |
| Entwerfen Sie eine Börse (wie NASDAQ oder Binance) | [Jane Street](https://youtu.be/b1e4t2k2KJY)<br/>[Golang Implementation](https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/)<br/>[Go Implementation](http://bhomnick.net/building-a-simple-limit-order-in-go/) |
| Fügen Sie eine Systemdesign-Frage hinzu | [Contribute](#contributing) |

### Architekturen aus der realen Welt

> Artikel darüber, wie reale Systeme entworfen werden.

<p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Quelle: Twitter timelines at scale</a></i>
</p>

**Konzentrieren Sie sich bei den folgenden Artikeln nicht auf kleinste Details, sondern:**

* Identifizieren Sie gemeinsame Prinzipien, Technologien und Muster in diesen Artikeln
* Studieren Sie, welche Probleme durch jede Komponente gelöst werden, wo sie funktioniert und wo nicht
* Überprüfen Sie die gewonnenen Erkenntnisse

|Typ | System | Referenz(en) |
|---|---|---|
| Datenverarbeitung | **MapReduce** - Verteilte Datenverarbeitung von Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |
| Datenverarbeitung | **Spark** - Verteilte Datenverarbeitung von Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |
| Datenverarbeitung | **Storm** - Verteilte Datenverarbeitung von Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |
| | | |
| Datenspeicher | **Bigtable** - Verteilte spaltenorientierte Datenbank von Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |
| Datenspeicher | **HBase** - Open-Source-Implementierung von Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |
| Datenspeicher | **Cassandra** - Verteilte spaltenorientierte Datenbank von Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)
| Datenspeicher | **DynamoDB** - Dokumentenorientierte Datenbank von Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |
| Datenspeicher | **MongoDB** - Dokumentenorientierte Datenbank | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |
| Datenspeicher | **Spanner** - Global verteilte Datenbank von Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |
| Datenspeicher | **Memcached** - Verteilter Speicher-Caching-System | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Datenspeicher | **Redis** - Verteilter Speicher-Caching-System mit Persistenz und Werttypen | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| | | |
| Dateisystem | **Google File System (GFS)** - Verteiltes Dateisystem | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |
| Dateisystem | **Hadoop File System (HDFS)** - Open-Source-Implementierung von GFS | [apache.org](http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) |
| | | |
| Sonstiges | **Chubby** - Sperrdienst für locker gekoppelte verteilte Systeme von Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |
| Sonstiges | **Dapper** - Infrastruktur zur Ablaufverfolgung verteilter Systeme | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)
| Sonstiges | **Kafka** - Pub/Sub-Nachrichtenwarteschlange von LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |
| Sonstiges | **Zookeeper** - Zentralisierte Infrastruktur und Dienste für Synchronisierung | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |
| | Architektur hinzufügen | [Beitragen](#contributing) |

### Unternehmensarchitekturen

| Unternehmen | Referenz(en) |
|---|---|
| Amazon | [Amazon Architektur](http://highscalability.com/amazon-architecture) |
| Cinchcast | [Produktion von 1.500 Stunden Audio täglich](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |
| DataSift | [Echtzeit-Datenanalyse bei 120.000 Tweets pro Sekunde](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |
| Dropbox | [Wie wir Dropbox skaliert haben](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| ESPN | [Betrieb mit 100.000 duh nuh nuhs pro Sekunde](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |
| Google | [Google Architektur](http://highscalability.com/google-architecture) |
| Instagram | [14 Millionen Nutzer, Terabytes an Fotos](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[Was Instagram antreibt](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |
| Justin.tv | [Live-Video-Übertragungsarchitektur von Justin.tv](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |
| Facebook | [Memcached-Skalierung bei Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebooks verteiltes Datenspeichersystem für das soziale Netzwerk](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebooks Foto-Speicherung](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[Wie Facebook Live Streams für 800.000 gleichzeitige Zuschauer bereitstellt](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |
| Flickr | [Flickr Architektur](http://highscalability.com/flickr-architecture) |
| Mailbox | [Von 0 auf eine Million Nutzer in 6 Wochen](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |
| Netflix | [Ein 360-Grad-Blick auf den gesamten Netflix-Stack](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: Was passiert, wenn Sie Play drücken?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |
| Pinterest | [Von 0 auf dutzende Milliarden Seitenaufrufe pro Monat](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 Millionen Besucher, 10-faches Wachstum, 12 Mitarbeiter](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |
| Playfish | [50 Millionen monatliche Nutzer und steigend](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |
| PlentyOfFish | [PlentyOfFish Architektur](http://highscalability.com/plentyoffish-architecture) |
| Salesforce | [Wie sie 1,3 Milliarden Transaktionen pro Tag verarbeiten](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |
| Stack Overflow | [Stack Overflow Architektur](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |
| TripAdvisor | [40M Besucher, 200M dynamische Seitenaufrufe, 30TB Daten](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |
| Tumblr | [15 Milliarden Seitenaufrufe pro Monat](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |
| Twitter | [Twitter 10.000 Prozent schneller machen](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[250 Millionen Tweets pro Tag mit MySQL speichern](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M aktive Nutzer, 300K QPS, ein 22 MB/S-Datenstrom](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Timelines im großen Maßstab](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Große und kleine Daten bei Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Betrieb bei Twitter: Skalierung über 100 Millionen Nutzer hinaus](https://www.youtube.com/watch?v=z8LU0Cj6BOU)<br/>[Wie Twitter 3.000 Bilder pro Sekunde verarbeitet](http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html) |
| Uber | [Wie Uber seine Echtzeit-Marktplattform skaliert](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lektionen aus dem Skalieren von Uber auf 2000 Ingenieure, 1000 Services und 8000 Git-Repositories](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |
| WhatsApp | [Die WhatsApp-Architektur, die Facebook für 19 Milliarden Dollar kaufte](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| YouTube | [YouTube Skalierbarkeit](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube Architektur](http://highscalability.com/youtube-architecture) |

### Ingenieurblogs von Unternehmen

> Architekturen von Unternehmen, bei denen Sie sich bewerben.
>
> Fragen, denen Sie begegnen, könnten aus demselben Bereich stammen.

* [Airbnb Engineering](http://nerds.airbnb.com/)
* [Atlassian Developers](https://developer.atlassian.com/blog/)
* [AWS Blog](https://aws.amazon.com/blogs/aws/)
* [Bitly Engineering Blog](http://word.bitly.com/)
* [Box Blogs](https://blog.box.com/blog/category/engineering)
* [Cloudera Developer Blog](http://blog.cloudera.com/)
* [Dropbox Tech Blog](https://tech.dropbox.com/)
* [Engineering at Quora](https://www.quora.com/q/quoraengineering)
* [Ebay Tech Blog](http://www.ebaytechblog.com/)
* [Evernote Tech Blog](https://blog.evernote.com/tech/)
* [Etsy Code as Craft](http://codeascraft.com/)
* [Facebook Engineering](https://www.facebook.com/Engineering)
* [Flickr Code](http://code.flickr.net/)
* [Foursquare Engineering Blog](http://engineering.foursquare.com/)
* [GitHub Engineering Blog](https://github.blog/category/engineering)
* [Google Research Blog](http://googleresearch.blogspot.com/)
* [Groupon Engineering Blog](https://engineering.groupon.com/)
* [Heroku Engineering Blog](https://engineering.heroku.com/)
* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)
* [High Scalability](http://highscalability.com/)
* [Instagram Engineering](http://instagram-engineering.tumblr.com/)
* [Intel Software Blog](https://software.intel.com/en-us/blogs/)
* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)
* [LinkedIn Engineering](http://engineering.linkedin.com/blog)
* [Microsoft Engineering](https://engineering.microsoft.com/)
* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)
* [Netflix Tech Blog](http://techblog.netflix.com/)
* [Paypal Developer Blog](https://medium.com/paypal-engineering)
* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)
* [Reddit Blog](http://www.redditblog.com/)
* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)
* [Slack Engineering Blog](https://slack.engineering/)
* [Spotify Labs](https://labs.spotify.com/)
* [Stripe Engineering Blog](https://stripe.com/blog/engineering)
* [Twilio Engineering Blog](http://www.twilio.com/engineering)
* [Twitter Engineering](https://blog.twitter.com/engineering/)
* [Uber Engineering Blog](http://eng.uber.com/)
* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)
* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)
* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)

#### Quelle(n) und weiterführende Literatur

Möchten Sie einen Blog hinzufügen? Um doppelte Arbeit zu vermeiden, sollten Sie Ihren Firmenblog zu folgendem Repository hinzufügen:

* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)

## In Entwicklung

Interessiert daran, einen Abschnitt hinzuzufügen oder bei einem laufenden mitzuhelfen? [Mitmachen](#contributing)!

* Verteiltes Rechnen mit MapReduce
* Konsistentes Hashing
* Scatter Gather
* [Mitmachen](#contributing)

## Danksagungen

Quellen und Danksagungen sind über dieses Repository verteilt aufgeführt.

Besonderer Dank an:

* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)
* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)
* [High scalability](http://highscalability.com/)
* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)
* [shashank88/system_design](https://github.com/shashank88/system_design)
* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)
* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
* [A distributed systems reading list](http://dancres.github.io/Pages/)
* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)

## Kontaktinformationen

Zögern Sie nicht, mich zu kontaktieren, um etwaige Probleme, Fragen oder Kommentare zu besprechen.

Meine Kontaktdaten finden Sie auf meiner [GitHub-Seite](https://github.com/donnemartin).

## Lizenz

*Ich stelle Ihnen Code und Ressourcen in diesem Repository unter einer Open-Source-Lizenz zur Verfügung.  Da dies mein persönliches Repository ist, erhalten Sie die Lizenz für meinen Code und meine Ressourcen von mir und nicht von meinem Arbeitgeber (Facebook).*

    Copyright 2017 Donne Martin

    Creative Commons Attribution 4.0 International License (CC BY 4.0)

    http://creativecommons.org/licenses/by/4.0/


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-08-09

---