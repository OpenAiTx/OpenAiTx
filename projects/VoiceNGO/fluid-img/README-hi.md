# फ्लूइड इमेज वेब कंपोनेंट

इमेजें जो किसी भी वांछित आकार में बुद्धिमानी से स्केल हो जाती हैं (उचित सीमाओं के भीतर)।

![फ्लूइड इमेज](https://raw.githubusercontent.com/VoiceNGO/fluid-img/refs/heads/main/resources/images/responsive-images.jpg)

**बहुत छोटी!:** 7kb मिनिफाइड और ग्ज़िप्ड

## उपयोग

```html
<script src="fluid-img.js"></script>
<fluid-img src="image.jpg"></fluid-img>
```

बस इतना ही। इमेज को जैसे चाहें स्केल करें, वे अपने आप सही ढंग से समायोजित हो जाएंगी।

## डेमो

[यहाँ डेमो देखें](https://voicengo.github.io/fluid-img/public/fluid-demo.html)

[अपनी खुद की इमेज के साथ प्रयोग करने के लिए एक प्लेग्राउंड भी उपलब्ध है](https://voicengo.github.io/fluid-img/public)।
## स्थापना

### क्लाइंट लाइब्रेरी

```sh
npm install fluid-img
```

फिर अपने प्रोजेक्ट में `fluid-img` इम्पोर्ट करें, जो वेब-कम्पोनेंट प्रदान करता है और रजिस्टर करता है:

```ts
import 'fluid-img';
```

या jsdelivr या unpkg से स्क्रिप्ट शामिल करें:

```html
<script src="https://cdn.jsdelivr.net/npm/fluid-img@latest/dist/fluid-img.js" />

<!-- या -->

<script src="https://unpkg.com/fluid-img@latest/dist/fluid-img.js" />
```
### चेतावनियाँ

फ्लुइड इमेज कंपोनेंट लगभग 0.5x से 1.5x तक की अपनी मूल आकार सीमा में क्षैतिज या ऊर्ध्वाधर रूप से स्केलिंग वाली इमेजों के लिए सबसे अच्छा काम करता है। यह बड़े या छोटे स्केल को संभाल सकता है, लेकिन दृश्य गुणवत्ता जल्दी खराब हो सकती है। यह उन इमेजों के लिए अनुशंसित नहीं है जहाँ सटीक पिक्सेल अखंडता महत्वपूर्ण है, जैसे कि पोर्ट्रेट, ग्राफ, या विस्तृत तकनीकी चित्रण, क्योंकि सीम कार्विंग से विकृति आ सकती है। अपनी इमेजों को विभिन्न आकारों में टेस्ट करना अत्यधिक अनुशंसित है ताकि वे आपकी दृश्य अपेक्षाओं पर खरी उतरें।

#### CORS

ब्राउज़र सुरक्षा प्रतिबंधों के कारण, यदि इमेज किसी भिन्न ओरिजिन (डोमेन, प्रोटोकॉल, या पोर्ट) से लोड की जाती है, तो वह Cross-Origin Resource Sharing (CORS) त्रुटि उत्पन्न करेगी। इस कंपोनेंट को इमेज के कच्चे पिक्सेल डाटा तक पहुँच की आवश्यकता होती है, जो CORS द्वारा प्रतिबंधित है।

अगर आप किसी भिन्न ओरिजिन से इमेज का उपयोग करना चाहते हैं, तो इमेज की मेजबानी करने वाले सर्वर को उपयुक्त CORS हेडर (जैसे, `Access-Control-Allow-Origin: *` या `Access-Control-Allow-Origin: your-domain.com`) भेजने के लिए कॉन्फ़िगर करना होगा। इन हेडरों के बिना, कंपोनेंट इमेज को प्रोसेस नहीं कर सकेगा।

(जानकारी के लिए, टेस्टिंग के प्रयोजन से, imgur पर कोई भी इमेज आवश्यक CORS हेडर के साथ आती है)

#### फॉलबैक

यदि कंपोनेंट इमेज को लोड या प्रोसेस करने में विफल रहता है, या कोई आंतरिक त्रुटि फेंकता है, तो यह सौम्य रूप से `<fluid-img>` कंपोनेंट के भीतर एक मानक `<img>` टैग को इंजेक्ट कर देगा, जिसकी चौड़ाई और ऊँचाई 100% होगी, जिससे इमेज फिर भी प्रदर्शित होगी।

## विकल्प

प्रयोग: `<fluid-img src="image.jpg" generator="random" max-carve-up-scale="5"></fluid-img>`

डिफ़ॉल्ट रूप से, `random` जनरेटर का उपयोग किया जाता है क्योंकि यह सबसे तेज़ है।

| विकल्प                         | मान                              | डिफ़ॉल्ट      | विवरण                                                                                                            |
| ------------------------------ | -------------------------------- | ------------ | ---------------------------------------------------------------------------------------------------------------- |
| `src`                          | URL                              |              | प्रोसेस की जाने वाली इमेज का URL।                                                                               |
| `generator`                    | `random`, `predictive`           | `predictive` | उपयोग में लिया जाने वाला सीम कार्विंग जनरेटर। `random` तेज़ है लेकिन गुणवत्ता में कम है।                        |
| `scaling-axis`                 | `horizontal`, `vertical`, `auto` | `horizontal` | स्केलिंग के लिए अक्ष। `auto` एस्पेक्ट रेशियो परिवर्तन के आधार पर क्षैतिज या ऊर्ध्वाधर स्केलिंग करता है।         |
| `mask`                         | URL                              |              | एक मास्क इमेज का URL। मास्क के काले क्षेत्र में ऊर्जा कम होती है और ये क्षेत्र अधिक सुरक्षित रहते हैं।          |
| `carving-priority`             | संख्या (0-1, जैसे `0.5`)         | `1`          | सीम कार्विंग बनाम पारंपरिक इमेज स्केलिंग द्वारा की जाने वाली स्केलिंग का प्रतिशत।                                 |
| `max-carve-up-seam-percentage` | संख्या (0-1, जैसे `0.5`)         | `0.6`        | स्केलिंग अप करते समय जोड़े जाने वाले सीम का अधिकतम प्रतिशत। इमेज गुणवत्ता बनाए रखने के लिए नए सीम की संख्या सीमित करता है। |
| `max-carve-up-scale`           | संख्या (जैसे `3`)                | `3`          | सीम कार्विंग द्वारा अधिकतम बढ़ाने का गुणांक। इसके आगे पारंपरिक स्केलिंग का उपयोग होगा।                           |
| `max-carve-down-scale`         | संख्या (0-1, जैसे `0.7`)         | `0.7`        | डाउनस्केलिंग के समय सीम कार्विंग द्वारा हटाए जाने वाले इमेज के अधिकतम प्रतिशत।                                    |
### जनरेटर विशिष्ट विकल्प

जनरेटर-विशिष्ट विकल्प `<fluid-img>` कॉम्पोनेंट में जोड़े जाते हैं, लेकिन ये केवल तब मान्य होते हैं जब संबंधित `generator` एट्रिब्यूट भी सेट किया गया हो।

#### रैंडम एवं प्रेडिक्टिव जनरेटर विकल्प

| विकल्प             | मान                    | डिफ़ॉल्ट | विवरण                                            |
| ------------------ | --------------------- | -------- | ------------------------------------------------- |
| `batch-percentage` | संख्या (0-1, जैसे 0.1) | 0.1      | प्रति बैच जनरेट किए जाने वाले सीम्स का प्रतिशत     |
| `min-batch-size`   | संख्या (जैसे `10`)     | 10       | प्रति बैच जनरेट किए जाने वाले सीम्स की न्यूनतम संख्या |

## यह कैसे काम करता है

सीम कार्विंग एक कंटेंट-अवेयर इमेज रिसाइज़िंग तकनीक है, जो इंटेलीजेंट तरीके से पिक्सल्स को हटाती या जोड़ती है, जिससे छवि को बिना महत्वपूर्ण कंटेंट को डिस्टॉर्ट किए रिसाइज़ किया जा सकता है। अधिक जानकारी के लिए, इस विषय पर [विकिपीडिया लेख](https://en.wikipedia.org/wiki/Seam_carving) देखें।

ऐतिहासिक रूप से, सीम कार्विंग वेब ब्राउज़रों में रियल-टाइम उपयोग के लिए बहुत अधिक कम्प्यूटेशनल था। हालांकि, इस सीमा को ऐसे वैकल्पिक एल्गोरिद्म का उपयोग करके दूर किया जा सकता है, जो कम संसाधन मांगते हैं और कई परिस्थितियों में अच्छे से काम करते हैं।

सीम कार्विंग जनरेटर की दो इम्प्लीमेंटेशन हैं:
### रैंडम कार्विंग

रैंडम सीम कार्विंग विधि पारंपरिक सीम कार्विंग एल्गोरिदम को छोड़ देती है, जो रीयल-टाइम ब्राउज़र निष्पादन के लिए बहुत धीमी है।

इसके बजाय, यह यादृच्छिक सीम का एक सेट उत्पन्न करती है, जो प्रत्येक पंक्ति के प्रत्येक पिक्सेल को अगली पंक्ति के पड़ोसी पिक्सेल से जोड़कर 100% छवि कवरेज प्रदान करता है। फिर यह प्रत्येक सीम के माध्यम से इटरेट करती है, उसकी ऊर्जा की गणना करती है, और सबसे कम-ऊर्जा वाली सीमों के एक बैच को हटा देती है। यह प्रक्रिया तब तक दोहराई जाती है जब तक वांछित संख्या की सीमें नहीं मिल जातीं। यह विधि कई छवियों के लिए आश्चर्यजनक रूप से अच्छे परिणाम उत्पन्न करती है।

### प्रेडिक्टिव कार्विंग

रैंडम कार्विंग के समान, यह विधि ऊर्जा मानचित्र उत्पन्न करती है और सीमों को बैच में बनाती है। यह प्रत्येक बैच के लिए एक न्यूनतम ऊर्जा मानचित्र भी उत्पन्न करती है। मुख्य विचार "अच्छी" और "खराब" सीमों दोनों का निर्माण करना है। अच्छी सीमों की ऊर्जा कम होती है और उन्हें रखा जाता है। खराब सीमों में उच्च-ऊर्जा पिक्सेल शामिल होते हैं, जिससे उन्हें बाद में फ़िल्टर किया जा सकता है।

पहली पंक्ति से शुरू होकर, यह पिक्सेल के जोड़ों को अगली पंक्ति के संबंधित जोड़ों से जोड़ती है। रनिंग गणना से कम-ऊर्जा वाली सीम को न्यूनतम ऊर्जा मानचित्र से कम-ऊर्जा वाली सीम से जोड़ा जाता है।

परिणामस्वरूप एक वास्तव में इष्टतम सीम, कई "बहुत अच्छी" सीम, कई "बहुत खराब" सीम, और बहुत सारी औसत सीमें मिलती हैं। हम "अच्छी" सीमों के एक बैच का चयन करते हैं, शेष को हटा देते हैं, और प्रक्रिया दोहराते हैं।

##

## TODO

### उच्च प्राथमिकता

- [x] वेब घटक
- [x] रेंडरर जो जनरेटर से डेटा लेता है और किसी भी आकार में स्केल करता है
- [x] रैंडम जनरेटर
- [x] वर्टिकल कार्विंग
- [x] प्रेडिक्टिव जनरेटर
- [ ] सभी जनरेटर के लिए वेब वर्कर
### कम प्राथमिकता

- [x] मास्किंग
- [ ] फेसियल रिकग्निशन

### कल्पनात्मक

- [ ] 2D कर्विंग

## लाइसेंसिंग

यह सॉफ़्टवेयर Fluid-Img Revenue-Limited License के अंतर्गत लाइसेंस प्राप्त है।

**नि:शुल्क उपयोग** उन व्यक्तियों और संगठनों के लिए जिनकी वार्षिक सकल आय $10,000,000 USD से कम है।

**व्यावसायिक लाइसेंस आवश्यक** उन संगठनों के लिए जिनकी वार्षिक आय $10M+ है। व्यावसायिक लाइसेंसिंग शर्तों के लिए [licensing@voice.ngo] से संपर्क करें।

पूरा विवरण [LICENSE](./LICENSE) फ़ाइल में देखें।

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-11

---