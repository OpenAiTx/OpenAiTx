{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// دالة الاستدعاء تُستدعى عندما تصبح isWatched تساوي true، إذا كانت سابقًا false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// دالة الاستدعاء تُستدعى كلما أصبحت isWatched تساوي false، إذا كانت سابقًا true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### كيف تعمل الإشارات (Signals)\n\nتمثل الإشارة (Signal) خلية بيانات قد تتغير بمرور الوقت. قد تكون الإشارات إما \"حالة\" (مجرد قيمة يتم تعيينها يدويًا) أو \"محسوبة\" (معادلة تستند إلى إشارات أخرى).\n\nتعمل الإشارات المحسوبة من خلال تتبع تلقائي للإشارات الأخرى التي تتم قراءتها أثناء التقييم. عند قراءة إشارة محسوبة، تتحقق مما إذا كان أي من التبعيات المسجلة سابقًا قد تغير، وتعيد تقييم نفسها إذا كان الأمر كذلك. عند تداخل إشارات محسوبة متعددة، فإن كل إسناد التتبع يذهب إلى الأعمق بينها.\n\nالإشارات المحسوبة تعمل بشكل كسول (أي تعتمد على السحب): لا يتم إعادة تقييمها إلا عندما يتم الوصول إليها، حتى إذا كانت إحدى تبعياتها قد تغيرت مسبقًا.\n\nينبغي أن تكون دالة الاستدعاء الممررة إلى الإشارات المحسوبة \"نقية\" عمومًا، بمعنى أنها دالة حتمية وخالية من التأثيرات الجانبية بالنسبة للإشارات الأخرى التي تصل إليها. في الوقت ذاته، فإن توقيت استدعاء الدالة حتمي، مما يسمح باستخدام التأثيرات الجانبية بحذر.\n\nتتميز الإشارات بوجود ذاكرة تخزين مؤقت/تذكير بارز: كل من الإشارات الحالة والمحسوبة تتذكر قيمتها الحالية، ولا تؤدي إلى إعادة حساب الإشارات المحسوبة التي تشير إليها إلا إذا تغيرت فعليًا. ولا يلزم حتى إجراء مقارنة متكررة بين القيم القديمة والجديدة -- تتم المقارنة مرة واحدة عند إعادة تعيين/تقييم مصدر الإشارة، وآلية الإشارة تتعقب أي العناصر التي تشير إلى تلك الإشارة لم يتم تحديثها بناءً على القيمة الجديدة بعد. داخليًا، يتم تمثيل ذلك عمومًا من خلال \"تلوين الرسم البياني\" كما هو موضح في (منشور مدونة ميلو).\n\nتتبع الإشارات المحسوبة تبعياتها بشكل ديناميكي -- في كل مرة يتم تشغيلها، قد تعتمد على أشياء مختلفة، ويتم الحفاظ على مجموعة التبعيات الدقيقة هذه محدثة في رسم إشارة البيانات. هذا يعني أنه إذا كان لديك تبعية مطلوبة في أحد الفروع فقط، وكان التقييم السابق قد اتخذ الفرع الآخر، فإن التغيير في تلك القيمة غير المستخدمة مؤقتًا لن يتسبب في إعادة حساب الإشارة المحسوبة، حتى عند سحبها.\n\nعلى عكس وعود الجافاسكريبت (Promises)، كل شيء في الإشارات يعمل بشكل متزامن:\n- تعيين إشارة إلى قيمة جديدة يتم بشكل متزامن، وهذا ينعكس على الفور عند قراءة أي إشارة محسوبة تعتمد عليها لاحقًا. لا يوجد تجميع مدمج لهذا التغيير.\n- قراءة الإشارات المحسوبة متزامنة -- قيمتها متاحة دائمًا.\n- دالة الاستدعاء `notify` في المراقبين (Watchers)، كما هو موضح أدناه، تعمل بشكل متزامن أثناء استدعاء `.set()` الذي قام بتحفيزها (لكن بعد اكتمال تلوين الرسم البياني).\n\nمثل الوعود (Promises)، يمكن للإشارات أن تمثل حالة خطأ: إذا قامت دالة الاستدعاء لإشارة محسوبة برمي خطأ، فإنه يتم تخزين هذا الخطأ مؤقتًا مثل أي قيمة أخرى، ويعاد رميه في كل مرة تتم فيها قراءة الإشارة.\n\n### فهم فئة Signal\n\nيمثل كائن `Signal` القدرة على قراءة قيمة تتغير ديناميكيًا وتتم متابعة تحديثاتها مع مرور الوقت. كما يتضمن ضمنيًا القدرة على الاشتراك في الإشارة، بشكل ضمني من خلال وصول متتبع من إشارة محسوبة أخرى.\n\nتم تصميم واجهة البرمجة هذه لتتوافق مع التوافق التقريبي الكبير بين مكتبات الإشارات في النظام البيئي من حيث استخدام أسماء مثل \"signal\" و\"computed\" و\"state\". ومع ذلك، يتم الوصول إلى الإشارات المحسوبة والحالة عبر دالة `.get()`، وهذا يخالف جميع واجهات برمجة تطبيقات الإشارات الشائعة، التي تستخدم إما وسيط وصول على شكل `.value`، أو استدعاء على شكل `signal()`.\n\nتم تصميم الواجهة لتقليل عدد التخصيصات، لجعل الإشارات مناسبة للدمج في أطر عمل جافاسكريبت مع تحقيق نفس أو أداء أفضل من إشارات الأطر الحالية. هذا يعني:\n- إشارات الحالة عبارة عن كائن قابل للكتابة مرة واحدة، يمكن الوصول إليه وتعيينه من نفس المرجع. (انظر الآثار أدناه في قسم \"فصل القدرات\".)\n- كل من إشارات الحالة والمحسوبة مصممة لتكون قابلة للتوريث، لتسهيل قدرة الأطر على إضافة خصائص إضافية من خلال الحقول العامة والخاصة (وكذلك طرق استخدام تلك الحالة).\n- يتم استدعاء العديد من دوال الاستدعاء (مثل `equals`، ودالة الإشارة المحسوبة) مع إشارة السياق المناسبة كـ `this`، بحيث لا يلزم إغلاق جديد لكل إشارة. بدلاً من ذلك، يمكن حفظ السياق في خصائص إضافية للإشارة نفسها.\n\nبعض شروط الأخطاء التي تفرضها هذه الواجهة:\n- من الخطأ قراءة إشارة محسوبة بشكل متكرر (recursively).\n- لا يمكن لدالة الاستدعاء `notify` في المراقب قراءة أو كتابة أي إشارات\n- إذا قامت دالة الاستدعاء لإشارة محسوبة برمي خطأ، فإن الوصولات اللاحقة إلى الإشارة تعيد رمي ذلك الخطأ المخزن، حتى تتغير إحدى التبعيات ويعاد حسابها.\n\nبعض الحالات التي *لا* تفرض:\n- يمكن للإشارات المحسوبة الكتابة إلى إشارات أخرى، بشكل متزامن داخل دالة الاستدعاء الخاصة بها\n- يمكن للعمل المجدول بواسطة دالة الاستدعاء `notify` في المراقب قراءة أو كتابة إشارات، مما يجعل من الممكن تكرار [أنماط React الكلاسيكية غير الموصى بها](https://react.dev/learn/you-might-not-need-an-effect) من حيث الإشارات!\n\n### تنفيذ التأثيرات (Effects)\n\nتعطي واجهة `Watcher` المعرفة أعلاه الأساس لتنفيذ واجهات برمجة تطبيقات جافاسكريبت النموذجية للتأثيرات: دوال الاستدعاء التي يعاد تشغيلها عند تغير إشارات أخرى، وذلك فقط لأثرها الجانبي. يمكن تعريف دالة `effect` المستخدمة أعلاه في المثال الأولي كما يلي:\n\n```ts\n// عادة ما تعيش هذه الدالة في مكتبة/إطار عمل وليس في كود التطبيق\n// ملاحظة: منطق الجدولة هذا بسيط جدًا ليكون مفيدًا. لا تنسخه أو تلصقه.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// إشارة تأثير (effect) يتم تقييمها إلى cb، وتجدول قراءة نفسها في قائمة مهام microtask\n// كلما تغيرت إحدى تبعياتها المحتملة\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nلا تتضمن واجهة برمجة الإشارات أي دالة مضمنة مثل `effect`. ذلك لأن جدولة التأثيرات أمر دقيق وغالبًا ما يرتبط بدورات العرض في الأطر وغيرها من الحالات أو الاستراتيجيات الخاصة بمستوى الأطر العليا التي لا يمكن لجافاسكريبت الوصول إليها.\n\nعند استعراض العمليات المختلفة المستخدمة هنا: دالة الاستدعاء `notify` الممررة إلى منشئ `Watcher` هي الدالة التي تُستدعى عندما تنتقل الإشارة من حالة \"نظيفة\" (حيث نعلم أن ذاكرة التخزين المؤقت مهيأة وصحيحة) إلى حالة \"مفحوصة\" أو \"قذرة\" (حيث قد تكون ذاكرة التخزين المؤقت صحيحة أو لا، لأن واحدة على الأقل من الحالات التي تعتمد عليها تغيرت).\n\nتتم في النهاية عمليات استدعاء `notify` بواسطة استدعاء `.set()` على إحدى إشارات الحالة. هذا الاستدعاء متزامن: يحدث قبل أن تعيد دالة `.set` النتيجة. لكن لا داعي للقلق من أن تلاحظ دالة الاستدعاء هذه رسم الإشارة في حالة معالجة جزئية، لأنه أثناء دالة الاستدعاء `notify`، لا يمكن قراءة أو كتابة أي إشارة، حتى في استدعاء `untrack`. نظرًا لأن `notify` تُستدعى أثناء `.set()`، فهي تقاطع خيطًا آخر من المنطق، قد لا يكون مكتملًا. لقراءة أو كتابة إشارات من `notify`، قم بجدولة العمل ليعمل لاحقًا، مثل كتابة الإشارة في قائمة ليتم الوصول إليها لاحقًا، أو باستخدام `queueMicrotask` كما في الأعلى.\n\nلاحظ أنه من الممكن تمامًا استخدام الإشارات بفعالية دون `Signal.subtle.Watcher` من خلال جدولة الاستطلاع (polling) للإشارات المحسوبة، كما يفعل Glimmer. مع ذلك، وجدت العديد من الأطر أنه غالبًا ما يكون من المفيد أن يعمل منطق الجدولة هذا بشكل متزامن، ولهذا السبب تم تضمينه في واجهة برمجة الإشارات.\n\nكل من الإشارات المحسوبة والحالة يتم جمعها (garbage-collected) مثل أي قيمة جافاسكريبت. لكن المراقبين (Watchers) لديهم طريقة خاصة للحفاظ على الأشياء حية: أي إشارات تتم مراقبتها بواسطة مراقب ستظل حية طالما أن أيًا من الحالات الأساسية قابلة للوصول، حيث يمكن أن تؤدي هذه إلى استدعاء `notify` في المستقبل (ثم استدعاء `.get()` في المستقبل). لهذا السبب، تذكر أن تستدعي `Watcher.prototype.unwatch` لتنظيف التأثيرات.\n\n### مخرج غير سليم (Escape Hatch) غير آمن\n\n`Signal.subtle.untrack` هو مخرج يسمح بقراءة الإشارات *دون* تتبع تلك القراءات. هذه الإمكانية غير آمنة لأنها تسمح بإنشاء إشارات محسوبة تعتمد قيمتها على إشارات أخرى، ولكنها لا تتحدث عند تغير تلك الإشارات. يجب استخدامها عندما لا تؤثر القراءات غير المتتبعة على نتيجة الحساب.\n\n<!--\nTODO: عرض مثال حيث من المناسب استخدام untrack\n\n### استخدام watched/unwatched",
  "status": "ok"
}