{
  "id": 1,
  "origin": "# 🚦 JavaScript Signals standard proposal🚦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and more…\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# 🚦 JavaScript Signals 標準提案 🚦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nステージ 1（[説明](https://tc39.es/process-document/)）\n\nTC39 提案チャンピオン: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nオリジナル著者: Rob Eisenberg と Daniel Ehrenberg\n\nこのドキュメントは、JavaScript におけるシグナルの初期の共通方向性を記述しています。これは、ES2015 で TC39 によって標準化された Promise に先立つ Promises/A+ の取り組みに似ています。[ポリフィル](https://github.com/proposal-signals/signal-polyfill) を使って、ご自身で試すこともできます。\n\nPromises/A+ と同様に、この取り組みは JavaScript エコシステムの整合性に重点を置いています。この整合性が成功すれば、その経験に基づいて標準が生まれる可能性があります。複数のフレームワーク作者が、リアクティビティコアの基盤となる共通モデルにここで協力しています。現在のドラフトは、[Angular](https://angular.io/)、[Bubble](https://bubble.io/)、[Ember](https://emberjs.com/)、[FAST](https://www.fast.design/)、[MobX](https://mobx.js.org/)、[Preact](https://preactjs.com/)、[Qwik](https://qwik.dev/)、[RxJS](https://rxjs.dev/)、[Solid](https://www.solidjs.com/)、[Starbeam](https://www.starbeamjs.com/)、[Svelte](https://svelte.dev/)、[Vue](https://vuejs.org/)、[Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a) などの作者/メンテナからの設計入力に基づいています。\n\nPromises/A+ と異なり、共通の開発者向け API を解決することは目的ではなく、シグナルグラフの根底にある正確なコアセマンティクスを扱うことが目的です。この提案には完全な具体的 API も含まれますが、その API はほとんどのアプリケーション開発者を対象としていません。代わりに、ここでのシグナル API はフレームワークが上に構築するのに適しており、共通のシグナルグラフと自動トラッキング機構を通じて相互運用性を提供します。\n\nこの提案の計画は、ステージ 1 を超えて進む前に、いくつかのフレームワークへの統合も含めて、初期の重要なプロトタイピングを行うことです。私たちは、複数のフレームワークで実際に利用でき、フレームワーク提供のシグナルよりも実際に利点がある場合にのみ、Signals を標準化したいと考えています。十分な初期プロトタイピングによってこの情報が得られることを期待しています。詳細は下記の「ステータスと開発計画」を参照してください。\n\n## 背景: なぜ Signals なのか？\n\n複雑なユーザーインターフェイス（UI）を開発するには、JavaScript アプリケーション開発者は、アプリケーションのビュー層に状態を効率的に保存、計算、無効化、同期、プッシュする必要があります。UI では単純な値の管理にとどまらず、他の複雑な値や自身も計算された状態に依存した計算済み状態のレンダリングがよく必要です。Signals の目標は、こうしたアプリケーション状態管理の基盤を提供し、開発者がビジネスロジックに集中できるようにすることです。\n\nシグナルのような仕組みは、UI 以外のコンテキストでも独立して有用であることが分かっており、特にビルドシステムで不要な再ビルドを回避するために役立っています。\n\nSignals はリアクティブプログラミングにおいて、アプリケーションの更新管理の必要性をなくすために使用されます。\n\n> 状態の変化に基づく更新のための宣言的なプログラミングモデル。\n\n_［What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_ より。\n\n#### 例 - VanillaJS カウンター\n\n変数 `counter` があり、その値が偶数か奇数かを DOM に表示したいとします。`counter` が変更されるたびに、最新のパリティで DOM を更新したい。Vanilla JS では、次のようになります。\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// 外部からの counter 更新をシミュレート…\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> ここでは説明のためにグローバル変数を使用しています。適切な状態管理には多くの方法があり、この提案の例はできるだけ最小限になるようにしています。この提案はグローバル変数を推奨するものではありません。\n\nこのコードにはいくつかの問題があります…\n\n* `counter` の設定がノイズが多く、ボイラープレートが多い。\n* `counter` 状態がレンダリングシステムと密結合している。\n* `counter` が変化しても `parity` が変化しない場合（例: counter が 2 から 4 になる）、不要なパリティ計算や不要なレンダリングが発生する。\n* UI の他の部分が `counter` の更新時だけレンダリングしたい場合はどうするか？\n* UI の他の部分が `isEven` や `parity` のみを依存している場合はどうするか？\n\nこの比較的単純なシナリオでも、すぐに多くの問題が発生します。これを回避するために、`counter` に pub/sub を導入することが考えられます。これにより、`counter` の追加の利用者が状態変更への独自のリアクションを追加できるようになります。\n\nしかし、それでも次のような問題が残ります。\n\n* `parity` にしか依存していないレンダリング関数が、実際には `counter` にサブスクライブしなければならないことを「知っている」必要がある。\n* `counter` に直接関与せずに、`isEven` や `parity` のみで UI を更新することができない。\n* ボイラープレートが増えた。何かを使うたびに、関数を呼ぶか変数を読むだけでなく、サブスクライブしてそこで更新処理をしなければならない。購読解除の管理も特に複雑。\n\n今度は、`counter` だけでなく `isEven` や `parity` にも pub/sub を追加すればいくつかの問題は解決できます。しかしその場合、`isEven` を `counter` に、`parity` を `isEven` に、`render` を `parity` にサブスクライブさせなければなりません。残念ながら、これでボイラープレートコードが爆発的に増え、サブスクリプションの管理が非常に煩雑になり、すべてを正しくクリーンアップしないとメモリリークの危険も生じます。つまり、いくつかの問題は解決したものの、新たなカテゴリの問題と大量のコードが発生します。さらに悪いことに、このプロセスをシステム内のすべての状態で繰り返さなければなりません。\n\n### Signals の導入\n\nモデルとビューのデータバインディング抽象化は、複数のプログラミング言語にわたる UI フレームワークの中核となってきましたが、JS やウェブプラットフォームにはそのような仕組みが組み込まれていません。JS フレームワークやライブラリの中では、このバインディングの表現方法について多くの実験が行われてきており、一次データ型として状態や他のデータから導出される計算値を表現する「Signals」と呼ばれるものと一方向データフローの組み合わせの強力さが示されてきました。\nこの一次リアクティブ値アプローチは、[Knockout](https://knockoutjs.com/) が [2010年に](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/) オープンソースの JavaScript ウェブフレームワークで初めて広く登場したようです。それ以来、多くのバリエーションや実装が生まれています。ここ数年で、Signal プリミティブや関連するアプローチがさらに注目を集め、ほぼすべてのモダンな JavaScript ライブラリやフレームワークが何らかの形でこれに似たものを持つようになりました。\n\nSignals を理解するために、前述の例を下記でさらに詳しく述べる Signal API で再構成してみましょう。\n\n#### 例 - Signals カウンター\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// ライブラリやフレームワークが、他の Signal プリミティブに基づく副作用を定義\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// 外部からの counter 更新をシミュレート…\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nすぐに分かることがいくつかあります:\n* 前の例での `counter` 変数に関するノイズの多いボイラープレートがなくなった。\n* 値、計算、そして副作用を扱うための統一 API がある。\n* `counter` と `render` 間の循環参照や逆依存関係の問題がない。\n* 手動のサブスクリプションや管理が不要。\n* 副作用のタイミングやスケジューリングを制御する手段がある。\n\nSignals は、API の表面から見える以上の多くの利点を私たちにもたらします。",
  "status": "ok"
}