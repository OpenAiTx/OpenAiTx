{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Показать пример преобразования Observable в вычисляемый сигнал, на который подписываются только при использовании эффектом\n\nTODO: Показать пример вычисляемого сигнала, который представляет результат fetch, направленного на состояние, который отменяется\n\n### Интроспекция для SSR\n\nTODO: Показать, как работает сериализация графа сигналов\n\nTODO: Показать, как можно «гидратировать» сигнал от состояния к вычисляемому позже, используя несколько сигналов.\n-->\n\n### Пока опущено\n\nЭти возможности могут быть добавлены позже, но в текущем черновике они отсутствуют. Их опущение связано с отсутствием устоявшегося консенсуса в области проектирования между фреймворками, а также с продемонстрированной способностью обходиться без них с помощью механизмов, построенных поверх концепции Signals, описанной в этом документе. Однако, к сожалению, их отсутствие ограничивает потенциал для взаимодействия между фреймворками. По мере создания прототипов Signals, описанных в этом документе, будет предпринята попытка пересмотреть, было ли это опущение правильным решением.\n\n* **Асинхронность**: В этой модели сигналы всегда доступны для синхронной оценки. Однако часто бывает полезно иметь определённые асинхронные процессы, которые приводят к установке сигнала, и понимать, когда сигнал всё ещё «загружается». Один из простых способов смоделировать состояние загрузки — использовать исключения, и поведение кэширования исключений в вычисляемых сигналах довольно разумно сочетается с этим приёмом. Улучшенные техники обсуждаются в [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Транзакции**: Для переходов между представлениями часто бывает полезно поддерживать активное состояние как для состояния «откуда», так и «куда». Состояние «куда» отображается в фоновом режиме, пока не будет готово к переключению (коммиту транзакции), а состояние «откуда» остаётся интерактивным. Для одновременного поддержания обоих состояний требуется «форкать» состояние графа сигналов, и может даже быть полезно поддерживать несколько ожидающих переходов одновременно. Обсуждение в [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nТакже опущены некоторые возможные [вспомогательные методы](https://github.com/proposal-signals/proposal-signals/issues/32).\n\n## Статус и план разработки\n\nЭто предложение включено в повестку дня TC39 на апрель 2024 года для Stage 1. В настоящее время его можно рассматривать как «Stage 0».\n\n[Полифил](https://github.com/proposal-signals/signal-polyfill) для этого предложения доступен с некоторыми базовыми тестами. Некоторые авторы фреймворков начали экспериментировать с заменой своей реализации сигналов на эту, но это использование пока находится на ранней стадии.\n\nУчастники работы над предложением Signal хотят быть особенно **консервативными** в продвижении этого предложения, чтобы не попасть в ловушку, когда что-то внедряется, а затем оказывается бесполезным. Наш план — выполнить следующие дополнительные задачи, не требуемые процессом TC39, чтобы убедиться, что предложение находится на правильном пути:\n\nПеред переходом на Stage 2 мы планируем:\n- Разработать несколько полифильных реализаций промышленного уровня, которые будут надёжными, хорошо протестированными (например, проходят тесты различных фреймворков, а также тесты в стиле test262), и конкурентоспособными по производительности (что подтверждено тщательным набором бенчмарков сигналов/фреймворков).\n- Интегрировать предлагаемое API Signal в большое количество JS-фреймворков, которые мы считаем в какой-то степени репрезентативными, а также чтобы некоторые крупные приложения работали на этой основе. Протестировать, что оно работает эффективно и корректно в этих контекстах.\n- Иметь чёткое понимание пространства возможных расширений API и прийти к выводу, какие из них (если вообще какие-то) стоит включить в это предложение.\n\n## Алгоритмы сигналов\n\nВ этом разделе описывается каждый из API, доступных для JavaScript, с точки зрения реализуемых ими алгоритмов. Это можно рассматривать как протоспецификацию и включено на этом раннем этапе, чтобы закрепить возможный набор семантики, при этом оставляя пространство для изменений.\n\nНекоторые особенности алгоритма:\n- Порядок чтения сигналов внутри вычисления имеет значение и наблюдаем в порядке выполнения определённых обратных вызовов (вызывается `Watcher`, `equals`, первый параметр в `new Signal.Computed` и обратные вызовы `watched`/`unwatched`). Это значит, что источники вычисляемого сигнала должны храниться в определённом порядке.\n- Все эти четыре обратных вызова могут выбрасывать исключения, и эти исключения передаются вызывающему JS-коду предсказуемым образом. Исключения *не* останавливают выполнение этого алгоритма и не оставляют граф в полуобработанном состоянии. Для ошибок, возникших в обратном вызове `notify` у Watcher, это исключение передаётся в вызов `.set()`, который его вызвал, используя AggregateError, если исключений было несколько. Остальные (включая `watched`/`unwatched`?) сохраняются в значении сигнала, чтобы быть повторно выброшенными при чтении, и такой повторно выбрасываемый сигнал может быть помечен как `~clean~` так же, как и любой другой с обычным значением.\n- Предусмотрены меры по предотвращению циклических зависимостей в случаях вычисляемых сигналов, которые не «наблюдаются» (не отслеживаются никаким Watcher), чтобы их можно было собрать сборщиком мусора независимо от других частей графа сигналов. Внутренне это можно реализовать с помощью системы номеров поколений, которые всегда собираются; обратите внимание, что оптимизированные реализации могут также включать локальные номера поколений для отдельных узлов или не отслеживать некоторые номера для наблюдаемых сигналов.\n\n### Скрытое глобальное состояние\n\nАлгоритмы Signal должны обращаться к определённому глобальному состоянию. Это состояние глобально для всего потока или «агента».\n\n- `computing`: Самый внутренний вычисляемый или эффектный сигнал, который в данный момент пересчитывается из-за вызова `.get` или `.run`, либо `null`. Изначально `null`.\n- `frozen`: Булево значение, обозначающее, выполняется ли в данный момент обратный вызов, который требует, чтобы граф не изменялся. Изначально `false`.\n- `generation`: Инкрементируемое целое число, начинающееся с 0, используется для отслеживания актуальности значения и предотвращения циклических зависимостей.\n\n### Пространство имён `Signal`\n\n`Signal` — это обычный объект, который служит пространством имён для классов и функций, связанных с Signal.\n\n`Signal.subtle` — подобный внутренний объект-пространство имён.\n\n### Класс `Signal.State`\n\n#### Внутренние слоты `Signal.State`\n\n- `value`: Текущее значение сигнала состояния\n- `equals`: Функция сравнения, используемая при изменении значений\n- `watched`: Обратный вызов, вызываемый, когда сигнал становится отслеживаемым эффектом\n- `unwatched`: Обратный вызов, вызываемый, когда сигнал больше не отслеживается эффектом\n- `sinks`: Множество отслеживаемых сигналов, зависящих от этого\n\n#### Конструктор: `Signal.State(initialValue, options)`\n\n1. Установить `value` этого сигнала в `initialValue`.\n1. Установить `equals` этого сигнала в options?.equals\n1. Установить `watched` этого сигнала в options?.[Signal.subtle.watched]\n1. Установить `unwatched` этого сигнала в options?.[Signal.subtle.unwatched]\n1. Установить `sinks` этого сигнала в пустое множество\n\n#### Метод: `Signal.State.prototype.get()`\n\n1. Если `frozen` истинно, выбросить исключение.\n1. Если `computing` не `undefined`, добавить этот сигнал в множество `sources` у `computing`.\n1. ПРИМЕЧАНИЕ: Мы не добавляем `computing` в множество `sinks` этого сигнала, пока на него не подпишется Watcher.\n1. Вернуть значение этого сигнала.\n\n#### Метод: `Signal.State.prototype.set(newValue)`\n\n1. Если текущий контекст выполнения находится в состоянии `frozen`, выбросить исключение.\n1. Выполнить алгоритм «установки значения сигнала» с этим сигналом и первым параметром в качестве значения.\n1. Если этот алгоритм вернул `~clean~`, вернуть undefined.\n1. Установить состояние всех `sinks` этого сигнала в (если это вычисляемый сигнал) `~dirty~`, если они были ранее чистыми, или (если это Watcher) `~pending~`, если ранее были в состоянии `~watching~`.\n1. Рекурсивно установить состояние всех зависимостей вычисляемых сигналов sinks в `~checked~`, если они были ранее `~clean~` (оставляя грязные метки на месте), или для Watchers — `~pending~`, если ранее были `~watching~`.\n1. Для каждого ранее `~watching~` Watcher, найденного при этом рекурсивном поиске, затем в порядке обхода в глубину:\n    1. Установить `frozen` в true.\n    1. Вызвать их обратный вызов `notify` (сохраняя любое выброшенное исключение, но игнорируя возвращаемое значение `notify`).\n    1. Восстановить `frozen` в false.\n    1. Установить состояние Watcher в `~waiting~`.\n1. Если какой-либо обратный вызов `notify` выбросил исключение, передать его вызывающему после завершения всех `notify`. Если исключений несколько, собрать их в AggregateError и выбросить его.\n1. Вернуть undefined.\n\n### Класс `Signal.Computed`\n\n#### Состояния автомата `Signal.Computed`",
  "status": "ok"
}