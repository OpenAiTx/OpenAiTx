{
  "id": 1,
  "origin": "# 🚦 JavaScript Signals standard proposal🚦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and more…\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# 🚦 Proposta di standard Signals per JavaScript 🚦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([spiegazione](https://tc39.es/process-document/))\n\nChampions della proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nAutori originali: Rob Eisenberg e Daniel Ehrenberg\n\nQuesto documento descrive una prima direzione comune per i signals in JavaScript, simile all'iniziativa Promises/A+ che ha preceduto le Promesse standardizzate dal TC39 in ES2015. Provalo tu stesso, utilizzando [un polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nAnalogamente a Promises/A+, questo lavoro si concentra sull'allineamento dell'ecosistema JavaScript. Se tale allineamento avrà successo, potrebbe emergere uno standard, basato su tale esperienza. Diversi autori di framework stanno collaborando qui su un modello comune che potrebbe supportare il core della loro reattività. La bozza attuale si basa su input progettuali degli autori/manutentori di [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), e altri ancora…\n\nDiversamente da Promises/A+, non stiamo cercando di risolvere una superficie API comune rivolta agli sviluppatori, ma piuttosto le precise semantiche core del grafo dei signal sottostante. Questa proposta include una API completamente concreta, ma l’API non è destinata alla maggior parte degli sviluppatori di applicazioni. Invece, la signal API qui proposta è più adatta a essere usata dai framework come base, fornendo interoperabilità attraverso un grafo di signal comune e un meccanismo di auto-tracking.\n\nIl piano per questa proposta è di effettuare prototipazione significativa nelle fasi iniziali, inclusa l’integrazione in diversi framework, prima di avanzare oltre lo Stage 1. Siamo interessati a standardizzare i Signals solo se risultano adatti all’uso pratico in più framework e forniscono reali vantaggi rispetto ai signals forniti dai framework stessi. Speriamo che la prototipazione significativa nelle fasi iniziali ci fornirà queste informazioni. Vedi \"Status and development plan\" di seguito per maggiori dettagli.\n\n## Contesto: Perché i Signals?\n\nPer sviluppare un'interfaccia utente (UI) complessa, gli sviluppatori di applicazioni JavaScript devono memorizzare, calcolare, invalidare, sincronizzare e trasmettere lo stato al layer di visualizzazione dell’applicazione in modo efficiente. Le UI comunemente coinvolgono molto più che la semplice gestione di valori semplici, ma spesso comportano il rendering di stati computati che dipendono da un albero complesso di altri valori o stati anch’essi computati. L’obiettivo dei Signals è fornire infrastruttura per la gestione di tali stati applicativi, così che gli sviluppatori possano concentrarsi sulla logica di business anziché su questi dettagli ripetitivi.\n\nCostrutti simili ai signal si sono rivelati utili anche in contesti non-UI, in particolare nei sistemi di build per evitare ricostruzioni non necessarie.\n\nI signals sono usati nella programmazione reattiva per rimuovere la necessità di gestire manualmente gli aggiornamenti nelle applicazioni.\n\n> Un modello di programmazione dichiarativo per l’aggiornamento basato sui cambiamenti di stato.\n\nda _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Esempio - Un contatore VanillaJS\n\nDato una variabile, `counter`, vuoi renderizzare nel DOM se il contatore è pari o dispari. Ogni volta che `counter` cambia, vuoi aggiornare il DOM con la nuova parità. In Vanilla JS, potresti avere qualcosa del genere:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simula aggiornamenti esterni del counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Le variabili globali sono usate qui solo a scopo dimostrativo. La gestione corretta dello stato ha molte soluzioni, e gli esempi in questa proposta sono pensati per essere quanto più minimali possibile. Questa proposta non incoraggia l’uso di variabili globali.\n\n\nQuesto presenta diversi problemi...\n\n* L’impostazione di `counter` è rumorosa e ricca di boilerplate.\n* Lo stato di `counter` è strettamente accoppiato al sistema di rendering.\n* Se `counter` cambia ma `parity` no (es. counter passa da 2 a 4), allora calcoliamo inutilmente la parità e facciamo un rendering non necessario.\n* Cosa succede se un’altra parte della nostra UI vuole solo renderizzare quando `counter` si aggiorna?\n* Cosa succede se un’altra parte della nostra UI dipende solo da `isEven` o `parity`?\n\nAnche in questo scenario relativamente semplice, sorgono rapidamente diverse problematiche. Potremmo provare ad aggirare queste difficoltà introducendo un pub/sub per `counter`. Questo permetterebbe a ulteriori consumatori di `counter` di iscriversi e aggiungere le proprie reazioni ai cambiamenti di stato.\n\nTuttavia, rimangono i seguenti problemi:\n\n* La funzione di rendering, che dipende solo da `parity`, deve invece “sapere” che in realtà deve iscriversi a `counter`.\n* Non è possibile aggiornare la UI basandosi solo su `isEven` o `parity`, senza interagire direttamente con `counter`.\n* Abbiamo aumentato il nostro boilerplate. Ogni volta che si usa qualcosa, non basta più chiamare una funzione o leggere una variabile, ma bisogna iscriversi e gestire gli aggiornamenti lì. Gestire la disiscrizione è anche particolarmente complicato.\n\nOra, potremmo risolvere alcuni problemi aggiungendo il pub/sub non solo a `counter` ma anche a `isEven` e `parity`. Dovremmo quindi iscrivere `isEven` a `counter`, `parity` a `isEven` e `render` a `parity`. Sfortunatamente, non solo il nostro codice boilerplate è esploso, ma ci ritroviamo con una gran quantità di gestione delle iscrizioni e un potenziale disastro di memory leak se non puliamo tutto correttamente. Quindi, abbiamo risolto alcuni problemi ma creato una nuova categoria di problemi e molto codice aggiuntivo. Peggio ancora, dobbiamo ripetere questo processo per ogni pezzo di stato nel nostro sistema.\n\n### Introduzione ai Signals\n\nLe astrazioni di data binding nelle UI per il modello e la vista sono da sempre fondamentali nei framework UI di diversi linguaggi di programmazione, nonostante l’assenza di un tale meccanismo integrato in JS o nella piattaforma web. All’interno dei framework e delle librerie JS, c’è stata molta sperimentazione su diversi modi di rappresentare questo binding, e l’esperienza ha mostrato la potenza del data flow unidirezionale in combinazione con un tipo di dato di prima classe che rappresenta una cella di stato o una computazione derivata da altri dati, ora spesso chiamati “Signals”.\nQuesto approccio di valore reattivo di prima classe sembra essere comparso per la prima volta in modo popolare nei framework web JavaScript open-source con [Knockout](https://knockoutjs.com/) [nel 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). Negli anni successivi, sono state create molte varianti e implementazioni. Negli ultimi 3-4 anni, il primitivo Signal e gli approcci correlati hanno guadagnato ulteriore trazione, con quasi ogni libreria o framework moderno di JavaScript che offre qualcosa di simile, sotto un nome o un altro.\n\nPer capire i Signals, diamo un’occhiata all’esempio sopra, re-immaginato con una Signal API ulteriormente articolata qui sotto.\n\n#### Esempio - Un contatore con Signals\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// Una libreria o un framework definisce effetti basati su altri primitivi Signal\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simula aggiornamenti esterni del counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nCi sono alcune cose che possiamo notare subito:\n* Abbiamo eliminato il boilerplate rumoroso attorno alla variabile `counter` dell’esempio precedente.\n* C’è una API unificata per gestire valori, computazioni ed effetti collaterali.\n* Non ci sono problemi di riferimento circolare o dipendenze invertite tra `counter` e `render`.\n* Non ci sono iscrizioni manuali, né alcuna necessità di gestione aggiuntiva.\n* Esiste un modo per controllare il timing/la schedulazione degli effetti collaterali.\n\nI signals ci offrono molto di più di quanto si possa vedere in superficie dalla API:",
  "status": "ok"
}