{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Pelacakan Ketergantungan Otomatis** - Sebuah Signal terhitung secara otomatis menemukan Signal lain yang menjadi ketergantungannya, baik itu Signal berupa nilai sederhana atau komputasi lain.\n* **Evaluasi Malas (Lazy Evaluation)** - Komputasi tidak dievaluasi secara langsung saat dideklarasikan, ataupun segera dievaluasi ketika ketergantungannya berubah. Komputasi hanya dievaluasi ketika nilainya secara eksplisit diminta.\n* **Memoisasi** - Signal terhitung menyimpan cache nilai terakhirnya sehingga komputasi yang tidak memiliki perubahan pada ketergantungannya tidak perlu dievaluasi ulang, berapa pun kali mereka diakses.\n\n## Motivasi standarisasi Signals\n\n#### Interoperabilitas\n\nSetiap implementasi Signal memiliki mekanisme auto-tracking sendiri untuk melacak sumber yang ditemui saat mengevaluasi Signal terhitung. Hal ini menyulitkan untuk berbagi model, komponen, dan pustaka antar framework berbeda—karena biasanya Signal diimplementasikan sebagai bagian dari framework JS.\n\nSalah satu tujuan proposal ini adalah memisahkan sepenuhnya model reaktif dari tampilan render, memungkinkan developer bermigrasi ke teknologi render baru tanpa menulis ulang kode non-UI mereka, atau mengembangkan model reaktif bersama di JS untuk digunakan dalam berbagai konteks. Sayangnya, karena masalah versi dan duplikasi, berbagi pada tingkat pustaka JS ternyata tidak praktis—built-in menawarkan jaminan berbagi yang lebih kuat.\n\n#### Performa/Penggunaan Memori\n\nSelalu ada potensi peningkatan performa dengan mengirimkan lebih sedikit kode karena pustaka yang umum digunakan sudah built-in, namun implementasi Signal umumnya cukup kecil sehingga efek ini tidak diharapkan terlalu besar.\n\nKami menduga bahwa implementasi native C++ untuk struktur data dan algoritma terkait Signal dapat sedikit lebih efisien dibanding yang dapat dicapai di JS, dalam skala faktor konstanta. Namun, tidak ada perubahan algoritma yang diantisipasi dibandingkan dengan apa yang ada pada polyfill; engine tidak diharapkan \"ajaib\" di sini, dan algoritma reaktivitasnya sendiri akan terdefinisi dengan baik dan tidak ambigu.\n\nKelompok champion berharap dapat mengembangkan berbagai implementasi Signal, dan menggunakannya untuk menyelidiki kemungkinan performa ini.\n\n#### DevTools\n\nDengan pustaka Signal berbasis JS yang ada saat ini, sulit untuk melacak hal seperti:\n* Callstack di sepanjang rantai Signal terhitung, memperlihatkan rantai kausal untuk sebuah error\n* Grafik referensi antar Signal, ketika satu bergantung pada yang lain—penting saat debugging penggunaan memori\n\nSignal bawaan memungkinkan runtime JS dan DevTools untuk kemungkinan memiliki dukungan yang lebih baik dalam menginspeksi Signal, terutama untuk debugging atau analisis performa, baik ini dibangun ke dalam browser atau melalui ekstensi bersama. Alat yang sudah ada seperti inspector elemen, snapshot performa, dan profiler memori bisa diperbarui untuk menyorot Signal secara khusus dalam penyajian informasinya.\n\n#### Manfaat Sekunder\n\n##### Manfaat pustaka standar\n\nSecara umum, JavaScript memiliki pustaka standar yang cukup minimal, namun tren di TC39 adalah membuat JS lebih seperti bahasa \"baterai-termasuk\", dengan fungsi built-in berkualitas tinggi. Contohnya, Temporal menggantikan moment.js, dan sejumlah fitur kecil, misalnya, `Array.prototype.flat` dan `Object.groupBy` menggantikan banyak kasus penggunaan lodash. Manfaatnya meliputi ukuran bundle yang lebih kecil, stabilitas dan kualitas yang lebih baik, lebih sedikit yang harus dipelajari saat bergabung ke proyek baru, dan kosakata yang umum di antara developer JS.\n\n##### Integrasi HTML/DOM (kemungkinan di masa depan)\n\nPekerjaan saat ini di W3C dan oleh pengembang browser berupaya menghadirkan templating native ke HTML ([DOM Parts][wicg-pr-1023] dan [Template Instantiation][wicg-propsal-template-instantiation]). Selain itu, W3C Web Components CG sedang mengeksplorasi kemungkinan memperluas Web Components untuk menawarkan API HTML deklaratif sepenuhnya. Untuk mencapai kedua tujuan ini, pada akhirnya primitif reaktif akan dibutuhkan oleh HTML. Selain itu, banyak peningkatan ergonomis pada DOM melalui integrasi Signal dapat dibayangkan dan telah diminta oleh komunitas.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Catatan, integrasi ini akan menjadi upaya terpisah di kemudian hari, bukan bagian dari proposal ini sendiri.\n\n##### Pertukaran informasi ekosistem (*bukan* alasan untuk diadopsi)\n\nUpaya standarisasi kadang-kadang dapat berguna hanya di tingkat \"komunitas\", bahkan tanpa perubahan di browser. Upaya Signals mempertemukan banyak penulis framework berbeda untuk diskusi mendalam tentang sifat reaktivitas, algoritma, dan interoperabilitas. Ini sudah bermanfaat, namun tidak menjadi alasan untuk memasukkan ke dalam engine JS dan browser; Signal hanya boleh ditambahkan ke standar JavaScript jika ada manfaat signifikan *di luar* pertukaran informasi ekosistem yang dimungkinkan.\n\n## Tujuan desain untuk Signals\n\nTernyata pustaka Signal yang ada tidak terlalu berbeda satu sama lain, pada intinya. Proposal ini bertujuan membangun keberhasilan mereka dengan mengimplementasikan kualitas penting dari banyak pustaka tersebut.\n\n### Fitur inti\n\n* Tipe Signal yang merepresentasikan state, yaitu Signal yang dapat ditulis. Ini adalah nilai yang dapat dibaca oleh pihak lain.\n* Tipe Signal terhitung/memo/derived, yang bergantung pada Signal lain dan dihitung secara malas serta di-cache.\n    * Komputasi bersifat malas, artinya Signal terhitung tidak dihitung ulang secara default saat salah satu ketergantungannya berubah, namun hanya dijalankan jika memang ada yang membacanya.\n    * Komputasi bebas \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\", artinya tidak ada perhitungan yang tidak perlu dilakukan. Ini mengimplikasikan bahwa, ketika aplikasi membaca Signal terhitung, terdapat penyortiran topologis bagian-bagian grafik yang mungkin \"kotor\" untuk dijalankan, guna menghilangkan duplikasi.\n    * Komputasi di-cache, artinya jika, setelah perubahan terakhir pada ketergantungan, tidak ada yang berubah, maka Signal terhitung *tidak* dihitung ulang saat diakses.\n    * Perbandingan kustom dimungkinkan untuk Signal terhitung maupun Signal state, untuk menandai kapan Signal terhitung lain yang bergantung padanya perlu diperbarui.\n* Reaksi terhadap kondisi di mana sebuah Signal terhitung memiliki salah satu (atau turunan) ketergantungannya menjadi \"kotor\" dan berubah, artinya nilai Signal mungkin sudah usang.\n    * Reaksi ini dimaksudkan untuk menjadwalkan pekerjaan yang lebih signifikan untuk dilakukan nanti.\n    * Efek diimplementasikan dalam hal reaksi ini, plus penjadwalan pada tingkat framework.\n    * Signal terhitung memerlukan kemampuan untuk bereaksi terhadap apakah mereka terdaftar sebagai (turunan) ketergantungan dari salah satu reaksi ini.\n* Memungkinkan framework JS melakukan penjadwalan sendiri. Tidak ada penjadwalan built-in gaya Promise yang dipaksakan.\n    * Reaksi sinkron diperlukan untuk memungkinkan penjadwalan pekerjaan selanjutnya berdasarkan logika framework.\n    * Penulisan bersifat sinkron dan langsung berlaku (framework yang melakukan batching penulisan dapat melakukannya di atas ini).\n    * Memungkinkan pemisahan antara pengecekan apakah sebuah efek \"kotor\" dari benar-benar menjalankan efek (memungkinkan scheduler efek dua tahap).\n* Kemampuan membaca Signal *tanpa* memicu pencatatan ketergantungan (`untrack`)\n* Memungkinkan komposisi berbagai basis kode yang menggunakan Signal/reaktivitas, misalnya,\n    * Menggunakan beberapa framework bersama selama pelacakan/reaktivitas itu sendiri (modulo pengecualian, lihat di bawah)\n    * Struktur data reaktif independen framework (misal, proxy store reaktif rekursif, Map dan Set dan Array reaktif, dll.)\n\n### Soundness\n\n* Mencegah/melarang penggunaan naif reaksi sinkron.\n    * Risiko soundness: dapat memunculkan \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" jika digunakan secara tidak benar: Jika rendering dilakukan langsung saat Signal di-set, dapat memperlihatkan state aplikasi yang belum lengkap ke pengguna akhir. Oleh karena itu, fitur ini hanya boleh digunakan untuk menjadwalkan pekerjaan cerdas untuk nanti, setelah logika aplikasi selesai.\n    * Solusi: Melarang membaca dan menulis Signal apa pun dari dalam callback reaksi sinkron\n* Mencegah penggunaan `untrack` dan menandai sifatnya yang tidak sound\n    * Risiko soundness: memungkinkan pembuatan Signal terhitung yang nilainya bergantung pada Signal lain, namun tidak diperbarui ketika Signal tersebut berubah. Harus digunakan ketika akses yang tidak dilacak tidak mengubah hasil komputasi.\n    * Solusi: API diberi tanda \"unsafe\" pada namanya.\n* Catatan: Proposal ini memang memperbolehkan Signal untuk dibaca dan ditulis baik dari Signal terhitung maupun efek, tanpa membatasi penulisan yang datang setelah pembacaan, meskipun ada risiko soundness. Keputusan ini diambil untuk menjaga fleksibilitas dan kompatibilitas dalam integrasi dengan framework.\n\n### Surface API\n\n* Harus menjadi fondasi kokoh bagi berbagai framework untuk mengimplementasikan mekanisme Signal/reaktivitas mereka.\n    * Harus menjadi dasar yang baik untuk proxy store rekursif, reaktivitas field class berbasis decorator, dan API gaya `.value` maupun `[state, setState]`.\n    * Semantik harus bisa mengekspresikan pola valid yang diaktifkan oleh berbagai framework. Misalnya, harus memungkinkan Signal ini menjadi dasar untuk penulisan yang langsung tercermin maupun penulisan yang di-batch dan diterapkan kemudian.\n* Akan lebih baik jika API ini dapat digunakan langsung oleh developer JavaScript.\n    * Jika sebuah fitur sesuai dengan konsep ekosistem, menggunakan kosakata umum adalah hal yang baik.\n        * Namun, penting untuk tidak secara literal meniru nama yang sama persis!\n    * Terdapat ketegangan antara \"keterpakaiannya untuk dev JS\" dan \"menyediakan semua hook ke framework\"\n        * Ide: Sediakan semua hook, namun sertakan error jika disalahgunakan jika memungkinkan.\n        * Ide: Tempatkan API yang halus di namespace `subtle`, mirip dengan [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), untuk menandai perbedaan antara API yang diperlukan untuk penggunaan tingkat lanjut seperti implementasi framework atau alat dev vs penggunaan pengembangan aplikasi sehari-hari seperti menginstansiasi signal untuk digunakan dengan framework.\n* Dapat diimplementasikan dan digunakan dengan performa baik—Surface API tidak menimbulkan overhead berlebih\n    * Memungkinkan subclassing, sehingga framework dapat menambahkan metode dan field sendiri, termasuk field privat. Ini penting untuk menghindari kebutuhan alokasi tambahan pada tingkat framework. Lihat \"manajemen memori\" di bawah.\n\n### Manajemen memori\n\n* Jika memungkinkan: Signal terhitung harus dapat di-garbage collect jika tidak ada referensi aktif untuk pembacaan di masa mendatang, meskipun terhubung ke grafik yang lebih luas yang tetap hidup (misal, dengan membaca state yang tetap hidup).",
  "status": "ok"
}