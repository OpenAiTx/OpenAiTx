{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "[AsyncContext](https://github.com/tc39/proposal-async-context) ile, `new Signal.subtle.Watcher`'a geçirilen callback, yapıcı çağrıldığında alınan anlık görüntüye *kapanmaz*, böylece yazma sırasında çevresel bilgiler görülebilir olur.\n\n#### Metod: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Eğer `frozen` true ise, bir istisna fırlat.\n1. Argümanlardan herhangi biri bir signal değilse, bir istisna fırlat.\n1. Tüm argümanları bu nesnenin `signals`'ının sonuna ekle.\n1. Her yeni izlenen signal için, soldan sağa sırasıyla,\n    1. Bu watcher’ı o signal’e bir `sink` olarak ekle.\n    1. Eğer bu ilk sink ise, kaynaklara kadar rekürsif olarak o signal’i bir sink olarak ekle.\n    1. `frozen`'ı true olarak ayarla.\n    1. Varsa `watched` callback’ini çağır.\n    1. `frozen`'ı tekrar false olarak ayarla.\n1. Eğer Signal’in `state`’i `~waiting~` ise, onu `~watching~` olarak ayarla.\n\n#### Metod: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Eğer `frozen` true ise, bir istisna fırlat.\n1. Argümanlardan herhangi biri bir signal değilse veya bu watcher tarafından izlenmiyorsa, bir istisna fırlat.\n1. Argümanlardaki her bir signal için, soldan sağa sırasıyla,\n    1. O signal’i bu Watcher’ın `signals` kümesinden çıkar.\n    1. Bu Watcher’ı o Signal’in `sink` kümesinden çıkar.\n    1. Eğer o Signal’in `sink` kümesi boş kaldıysa, o Signal’i her bir kaynağından bir sink olarak çıkar.\n    1. `frozen`'ı true olarak ayarla.\n    1. Varsa `unwatched` callback’ini çağır.\n    1. `frozen`'ı tekrar false olarak ayarla.\n1. Eğer watcher’ın artık hiç `signals`’ı yoksa ve `state`’i `~watching~` ise, onu `~waiting~` olarak ayarla.\n\n#### Metod: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. `signals` kümesinin, durumu `~dirty~` veya `~pending~` olan Hesaplanmış Signal'lerinden oluşan bir Dizi döndür.\n\n### Metod: `Signal.subtle.untrack(cb)`\n\n1. `c`'yi yürütme bağlamının mevcut `computing` durumu olarak ayarla.\n1. `computing`’i null olarak ayarla.\n1. `cb`’yi çağır.\n1. `computing`’i `c`’ye geri yükle (cb bir istisna fırlatsa bile).\n1. `cb`’nin dönüş değerini döndür (herhangi bir istisnayı yeniden fırlat).\n\nNot: untrack seni `frozen` durumundan çıkarmaz, bu durum kesin olarak korunur.\n\n### Metod: `Signal.subtle.currentComputed()`\n\n1. Mevcut `computing` değerini döndür.\n\n### Ortak algoritmalar\n\n##### Algoritma: kirli hesaplanmış Signal’i yeniden hesapla\n\n1. Bu Signal’in `sources` kümesini temizle ve kendisini o kaynakların `sinks` kümelerinden çıkar.\n1. Önceki `computing` değerini kaydet ve `computing`’i bu Signal olarak ayarla.\n1. Bu Signal’in durumunu `~computing~` olarak ayarla.\n1. Bu hesaplanmış Signal’in callback’ini, this değeri olarak bu Signal’i kullanarak çalıştır. Dönüş değerini kaydet ve eğer callback bir istisna fırlatırsa, yeniden fırlatmak üzere onu kaydet.\n1. Önceki `computing` değerini geri yükle.\n1. Callback’in dönüş değerine \"Signal değerini ayarla\" algoritmasını uygula.\n2. Bu Signal’in durumunu `~clean~` olarak ayarla.\n1. Eğer bu algoritma `~dirty~` döndürdüyse: Bu Signal’in tüm sink’lerini `~dirty~` olarak işaretle (önceden, sink’ler kontrol edilmiş ve kirli bir karışımda olabilirdi). (Ya da, eğer bu izlenmiyorsa, kirlenmişliği göstermek için yeni bir nesil numarası ata, ya da buna benzer bir şey yap.)\n1. Aksi halde, algoritma `~clean~` döndürdü: Bu durumda, bu Signal’in her bir `~checked~` sink’i için, eğer o Signal’in tüm kaynakları artık temizse, o Signal’i de `~clean~` olarak işaretle. Bu temizlik adımını, kontrol edilmiş sink’leri olan yeni temiz Signal’lere özyinelemeli olarak uygula. (Ya da, bu izlenmiyorsa, temizlik gecikmeli ilerleyebilsin diye aynı şekilde bir işaretleme yap.)\n\n##### Signal değeri ayarlama algoritması\n\n1. Eğer bu algoritmaya bir değer (kirli hesaplanmış Signal algoritmasından yeniden fırlatılacak bir istisna yerine) iletildiyse:\n    1. Bu Signal’in `equals` fonksiyonunu, mevcut `value`, yeni değer ve bu Signal parametreleriyle çağır. Eğer bir istisna fırlatılırsa, bu istisnayı (okunurken yeniden fırlatılmak üzere) Signal’in değeri olarak kaydet ve callback false döndürmüş gibi devam et.\n    1. Eğer bu fonksiyon true döndürdüyse, `~clean~` döndür.\n1. Bu Signal’in `value`’sini parametre ile ayarla.\n1. `~dirty~` döndür\n\n## SSS\n\n**S**: Sinyallerle ilgili bir şeyi standartlaştırmak için biraz erken değil mi, daha yeni 2022’de gündem oldular? Onların evrilip istikrar kazanmasına daha fazla zaman tanımamız gerekmiyor mu?\n\n**C**: Web framework’lerinde Sinyallerin mevcut hali, 10 yılı aşkın sürekli bir gelişimin sonucudur. Yatırımlar son yıllarda arttıkça, neredeyse tüm web framework’leri çok benzer bir Signal çekirdek modeline yaklaşmaktadır. Bu öneri, web framework’lerinde şu anda lider olan çok sayıda kişi arasında yapılan ortak bir tasarım çalışmasının ürünüdür ve farklı bağlamlarda o alanın uzmanlarının onayı olmadan standartlaştırmaya taşınmayacaktır.\n\n#### Sinyaller nasıl kullanılır?\n\n**S**: Dahili Sinyaller, render ve sahiplik ile bu kadar sıkı entegre olduklarından framework’ler tarafından gerçekten kullanılabilir mi?\n\n**C**: Daha framework’e özgü olan kısımlar genellikle etkiler, zamanlama ve sahiplik/bertaraf alanlarındadır, ki bu öneri onları çözmeyi amaçlamaz. Standartları izleyen Sinyallerle prototiplemedeki ilk önceliğimiz, mevcut framework’lerin “altında” uyumlu ve iyi performansla çalışabildiklerini doğrulamaktır.\n\n**S**: Signal API’si doğrudan uygulama geliştiricileri tarafından mı, yoksa framework’ler tarafından sarmalanarak mı kullanılacak?\n\n**C**: Bu API doğrudan uygulama geliştiricileri tarafından da kullanılabilir (en azından `Signal.subtle` ad alanında olmayan kısmı), ancak özellikle ergonomik olması için tasarlanmamıştır. Bunun yerine, kütüphane/framework yazarlarının ihtiyaçları ön plandadır. Çoğu framework’ün, temel `Signal.State` ve `Signal.Computed` API’lerini bile, kendi ergonomik yaklaşımlarını yansıtan bir şeyle sarmalaması beklenir. Pratikte, Sinyaller genellikle bir framework aracılığıyla kullanılır; bu framework, daha karmaşık özellikleri (örn. Watcher, `untrack`) ve sahiplik ile bertarafı (örn. sinyallerin ne zaman watcher’lara eklenip çıkarılacağını bulma), ayrıca DOM’a render zamanlamasını yönetir—bu öneri bu problemleri çözmeyi amaçlamaz.\n\n**S**: Bir widget yok edildiğinde, ona bağlı Sinyalleri de yok etmek zorunda mıyım? Bunun API’si nedir?\n\n**C**: Buradaki ilgili yok etme işlemi `Signal.subtle.Watcher.prototype.unwatch`’tır. Sadece izlenen Sinyaller temizlenmelidir (unwatch edilerek), izlenmeyen Sinyaller ise otomatik olarak garbage collector tarafından yok edilebilir.\n\n**S**: Sinyaller VDOM ile mi, yoksa doğrudan temel HTML DOM ile mi çalışır?\n\n**C**: Evet! Sinyaller render teknolojisinden bağımsızdır. Signal-benzeri yapılar kullanan mevcut JavaScript framework’leri, VDOM (örn. Preact), yerel DOM (örn. Solid) ve bir kombinasyonunu (örn. Vue) entegre eder. Aynı şey dahili Sinyaller ile de mümkün olacaktır.\n\n**S**: Sinyaller, Angular ve Lit gibi sınıf tabanlı framework’ler bağlamında ergonomik olacak mı? Ya da Svelte gibi derleyici tabanlı framework’ler için?\n\n**C**: Sınıf alanları, [Signal polyfill readme’sinde](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators) gösterildiği gibi, basit bir accessor decorator ile Signal tabanlı hale getirilebilir. Sinyaller, Svelte 5’in Runes’ları ile çok yakın hizalanır—bir derleyicinin runes’ları burada tanımlanan Signal API’sine dönüştürmesi kolaydır ve aslında Svelte 5 bunu dahili olarak yapar (ama kendi Sinyal kütüphanesiyle).\n\n**S**: Sinyaller SSR ile çalışır mı? Hydration? Resumability?\n\n**C**: Evet. Qwik, bu özelliklerin her ikisinde de Sinyalleri iyi bir şekilde kullanır ve diğer framework’ler de Sinyallerle hydration konusunda farklı dengelerle gelişmiş yaklaşımlara sahiptir. Qwik’in devam ettirilebilir Sinyallerinin, birbirine bağlı bir State ve Computed signal ile modellenebileceğini ve bunu kodda kanıtlamayı planlıyoruz.",
  "status": "ok"
}