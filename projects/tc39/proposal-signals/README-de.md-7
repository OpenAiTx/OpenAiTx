{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Mit [AsyncContext](https://github.com/tc39/proposal-async-context) schließt der Callback, der an `new Signal.subtle.Watcher` übergeben wird, *nicht* den Schnappschuss von dem Zeitpunkt ein, zu dem der Konstruktor aufgerufen wurde, sodass kontextbezogene Informationen rund um das Schreiben sichtbar sind.\n\n#### Methode: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Wenn `frozen` wahr ist, eine Ausnahme auslösen.\n1. Wenn eines der Argumente kein Signal ist, eine Ausnahme auslösen.\n1. Hänge alle Argumente an das Ende des `signals`-Arrays dieses Objekts an.\n1. Für jedes neu beobachtete Signal, von links nach rechts,\n    1. Füge diesen Watcher als `sink` zu diesem Signal hinzu.\n    1. Wenn dies der erste Sink war, dann rekursiv zu den Quellen hochgehen, um dieses Signal als Sink hinzuzufügen.\n    1. Setze `frozen` auf wahr.\n    1. Rufe den `watched`-Callback auf, falls vorhanden.\n    1. Setze `frozen` wieder auf falsch.\n1. Wenn der `state` des Signals `~waiting~` ist, dann setze ihn auf `~watching~`.\n\n#### Methode: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Wenn `frozen` wahr ist, eine Ausnahme auslösen.\n1. Wenn eines der Argumente kein Signal ist oder von diesem Watcher nicht beobachtet wird, eine Ausnahme auslösen.\n1. Für jedes Signal in den Argumenten, von links nach rechts,\n    1. Entferne dieses Signal aus dem `signals`-Set dieses Watchers.\n    1. Entferne diesen Watcher aus dem `sink`-Set dieses Signals.\n    1. Wenn das `sink`-Set dieses Signals leer geworden ist, entferne dieses Signal als Sink aus jeder seiner Quellen.\n    1. Setze `frozen` auf wahr.\n    1. Rufe den `unwatched`-Callback auf, falls vorhanden.\n    1. Setze `frozen` wieder auf falsch.\n1. Wenn der Watcher jetzt keine `signals` mehr hat und sein `state` `~watching~` ist, dann setze ihn auf `~waiting~`.\n\n#### Methode: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Gib ein Array zurück, das die Teilmenge der `signals` enthält, die berechnete Signale im Zustand `~dirty~` oder `~pending~` sind.\n\n### Methode: `Signal.subtle.untrack(cb)`\n\n1. Setze `c` auf den aktuellen `computing`-Zustand des Ausführungskontextes.\n1. Setze `computing` auf null.\n1. Rufe `cb` auf.\n1. Setze `computing` auf `c` zurück (auch wenn `cb` eine Ausnahme ausgelöst hat).\n1. Gib den Rückgabewert von `cb` zurück (und wirf ggf. eine Ausnahme erneut).\n\nHinweis: `untrack` hebt den `frozen`-Zustand nicht auf, dieser wird strikt beibehalten.\n\n### Methode: `Signal.subtle.currentComputed()`\n\n1. Gib den aktuellen Wert von `computing` zurück.\n\n### Gemeinsame Algorithmen\n\n##### Algorithmus: Berechnung eines schmutzigen berechneten Signals\n\n1. Leere das `sources`-Set dieses Signals und entferne es aus den `sinks`-Sets dieser Quellen.\n1. Speichere den vorherigen Wert von `computing` und setze `computing` auf dieses Signal.\n1. Setze den Zustand dieses Signals auf `~computing~`.\n1. Führe den Callback dieses berechneten Signals aus, wobei dieses Signal als this-Wert verwendet wird. Speichere den Rückgabewert und falls der Callback eine Ausnahme ausgelöst hat, speichere diese zum späteren erneuten Werfen.\n1. Stelle den vorherigen Wert von `computing` wieder her.\n1. Wende den Algorithmus „Signalwert setzen“ auf den Rückgabewert des Callbacks an.\n2. Setze den Zustand dieses Signals auf `~clean~`.\n1. Wenn dieser Algorithmus `~dirty~` zurückgegeben hat: Markiere alle Sinks dieses Signals als `~dirty~` (zuvor konnten die Sinks sowohl geprüft als auch schmutzig gewesen sein). (Oder, wenn dies unbeobachtet ist, übernehme eine neue Generationsnummer zur Anzeige der Schmutzigkeit oder Ähnlichem.)\n1. Andernfalls, wenn der Algorithmus `~clean~` zurückgegeben hat: In diesem Fall, für jeden `~checked~`-Sink dieses Signals, falls alle Quellen dieses Signals jetzt sauber sind, markiere auch dieses Signal als `~clean~`. Wende diesen Bereinigungsschritt rekursiv auf weitere Sinks an, auf alle neu sauberen Signale, die geprüfte Sinks haben. (Oder, falls dies unbeobachtet ist, kennzeichne dies entsprechend, sodass die Bereinigung verzögert durchgeführt werden kann.)\n\n##### Algorithmus „Signalwert setzen“\n\n1. Falls diesem Algorithmus ein Wert übergeben wurde (im Gegensatz zu einer Ausnahme zum erneuten Werfen aus dem Algorithmus zur Berechnung eines schmutzigen berechneten Signals):\n    1. Rufe die `equals`-Funktion dieses Signals auf, mit den Parametern: aktuellem `value`, neuem Wert und diesem Signal. Falls eine Ausnahme ausgelöst wird, speichere diese Ausnahme (zum erneuten Werfen beim Lesen) als Wert des Signals und fahre fort, als hätte der Callback `false` zurückgegeben.\n    1. Wenn diese Funktion `true` zurückgegeben hat, gib `~clean~` zurück.\n1. Setze den `value` dieses Signals auf den Parameter.\n1. Gib `~dirty~` zurück.\n\n## FAQ\n\n**F**: Ist es nicht ein wenig früh, etwas im Zusammenhang mit Signals zu standardisieren, wo sie doch erst 2022 zum heißen neuen Thema wurden? Sollten wir ihnen nicht mehr Zeit zur Entwicklung und Stabilisierung geben?\n\n**A**: Der aktuelle Stand von Signals in Web-Frameworks ist das Ergebnis von über 10 Jahren kontinuierlicher Entwicklung. Da die Investitionen in den letzten Jahren zugenommen haben, nähern sich fast alle Web-Frameworks einem sehr ähnlichen Kernmodell für Signals an. Dieser Vorschlag ist das Ergebnis einer gemeinsamen Designübung einer großen Anzahl aktueller Führungskräfte im Bereich Web-Frameworks und wird nicht ohne die Validierung dieser Expertengruppe aus verschiedenen Kontexten zur Standardisierung vorangetrieben.\n\n#### Wie werden Signals verwendet?\n\n**F**: Können eingebaute Signals überhaupt von Frameworks genutzt werden, angesichts ihrer engen Integration mit Rendering und Ownership?\n\n**A**: Die Teile, die eher frameworkspezifisch sind, betreffen vor allem Effekte, Scheduling und Ownership/Disposal, die mit diesem Vorschlag nicht gelöst werden sollen. Unsere erste Priorität bei der Prototypisierung von Standards-Track-Signals ist es, zu validieren, dass sie „unterhalb“ bestehender Frameworks kompatibel und mit guter Performance funktionieren können.\n\n**F**: Ist die Signal-API dazu gedacht, direkt von Anwendungsentwicklern verwendet zu werden, oder wird sie von Frameworks ummantelt?\n\n**A**: Während diese API direkt von Anwendungsentwicklern genutzt werden könnte (zumindest der Teil außerhalb des Namensraums `Signal.subtle`), ist sie nicht besonders ergonomisch gestaltet. Stattdessen stehen die Anforderungen von Bibliotheks-/Framework-Autoren im Vordergrund. Die meisten Frameworks werden sogar die grundlegenden APIs wie `Signal.State` und `Signal.Computed` mit etwas ummanteln, das ihren ergonomischen Ansatz ausdrückt. In der Praxis ist es meistens am besten, Signals über ein Framework zu verwenden, das kompliziertere Funktionen (z. B. Watcher, `untrack`) sowie Ownership und Disposal (z. B. Ermittlung, wann Signals zu Watchern hinzugefügt und entfernt werden sollen) und das Scheduling des Renderings zum DOM verwaltet – diese Probleme werden von diesem Vorschlag nicht adressiert.\n\n**F**: Muss ich Signals, die zu einem Widget gehören, zerstören, wenn dieses Widget zerstört wird? Wie sieht die API dafür aus?\n\n**A**: Die relevante Teardown-Operation ist hier `Signal.subtle.Watcher.prototype.unwatch`. Nur beobachtete Signals müssen bereinigt werden (durch Unwatchen), während unbeobachtete Signals automatisch vom Garbage Collector entfernt werden können.\n\n**F**: Funktionieren Signals mit VDOM oder direkt mit dem zugrunde liegenden HTML DOM?\n\n**A**: Ja! Signals sind unabhängig von der Rendering-Technologie. Bestehende JavaScript-Frameworks, die Signal-ähnliche Konstrukte verwenden, integrieren sich sowohl mit VDOM (z. B. Preact), dem nativen DOM (z. B. Solid) als auch mit einer Kombination (z. B. Vue). Dasselbe wird auch mit eingebauten Signals möglich sein.\n\n**F**: Wird es ergonomisch sein, Signals im Kontext von klassenbasierten Frameworks wie Angular und Lit zu verwenden? Was ist mit Compiler-basierten Frameworks wie Svelte?\n\n**A**: Klassenfelder können mit einem einfachen Accessor-Decorator signalbasiert gemacht werden, wie in [dem Signal-Polyfill-Readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators) gezeigt wird. Signals sind sehr eng mit Svelte 5's Runes verwandt – es ist einfach für einen Compiler, Runes in die hier definierte Signal-API umzuwandeln, und tatsächlich macht Svelte 5 dies intern (aber mit seiner eigenen Signals-Bibliothek).\n\n**F**: Funktionieren Signals mit SSR? Hydration? Resumability?\n\n**A**: Ja. Qwik nutzt Signals mit beiden Eigenschaften sehr effektiv und andere Frameworks haben andere, gut entwickelte Ansätze zur Hydration mit Signals mit unterschiedlichen Kompromissen. Wir glauben, dass es möglich ist, die resumierbaren Signals von Qwik mit einem State- und Computed-Signal, die miteinander verbunden sind, zu modellieren, und planen, dies im Code zu beweisen.",
  "status": "ok"
}