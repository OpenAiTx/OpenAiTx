{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Hiển thị ví dụ chuyển đổi một Observable thành một computed signal, chỉ đăng ký khi được sử dụng bởi một effect\n\nTODO: Hiển thị ví dụ về một computed signal đại diện cho kết quả của một fetch hướng tới một trạng thái, có thể bị hủy bỏ\n\n### Khả năng nội suy cho SSR\n\nTODO: Hiển thị cách hoạt động của việc tuần tự hóa biểu đồ signal\n\nTODO: Hiển thị cách bạn có thể \"hydrate\" một signal từ trạng thái sang computed sau này, sử dụng một vài signals.\n-->\n\n### Tạm thời bỏ qua\n\nNhững tính năng này có thể sẽ được bổ sung sau, nhưng hiện chưa có trong bản dự thảo hiện tại. Việc bỏ qua này là do chưa có sự đồng thuận vững chắc trong không gian thiết kế giữa các framework, cũng như đã có các cơ chế giải quyết trên nền tảng Signals như mô tả trong tài liệu này. Tuy nhiên, đáng tiếc là việc bỏ qua này làm hạn chế tiềm năng tương tác giữa các framework. Khi các nguyên mẫu của Signals như mô tả trong tài liệu này được phát triển, sẽ có nỗ lực xem xét lại liệu việc bỏ qua này có phải là quyết định thích hợp hay không.\n\n* **Bất đồng bộ (Async)**: Trong mô hình này, Signals luôn có thể được đánh giá đồng bộ. Tuy nhiên, việc có một số tiến trình bất đồng bộ dẫn đến một signal được thiết lập, đồng thời có thể hiểu được khi nào một signal vẫn đang \"loading\" là rất hữu ích. Một cách đơn giản để mô hình hóa trạng thái loading là sử dụng ngoại lệ, và hành vi lưu bộ nhớ đệm ngoại lệ của computed signals có thể phối hợp hợp lý với kỹ thuật này. Các kỹ thuật cải tiến hơn được thảo luận tại [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Giao dịch (Transactions)**: Đối với quá trình chuyển đổi giữa các view, việc duy trì trạng thái sống cho cả trạng thái \"từ\" và \"đến\" thường rất hữu ích. Trạng thái \"đến\" được render ở nền cho đến khi sẵn sàng chuyển đổi (commit giao dịch), trong khi trạng thái \"từ\" vẫn còn tương tác được. Duy trì đồng thời cả hai trạng thái yêu cầu phải \"fork\" trạng thái của biểu đồ signal, thậm chí có thể hữu ích khi hỗ trợ nhiều lần chuyển đổi đang chờ cùng lúc. Thảo luận tại [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nMột số [phương thức tiện lợi](https://github.com/proposal-signals/proposal-signals/issues/32) cũng bị bỏ qua.\n\n## Tình trạng và kế hoạch phát triển\n\nĐề xuất này có trong chương trình nghị sự TC39 tháng 4 năm 2024 ở Giai đoạn 1. Hiện tại có thể xem là \"Giai đoạn 0\".\n\n[Một polyfill](https://github.com/proposal-signals/signal-polyfill) cho đề xuất này đã có sẵn, với một số bài kiểm tra cơ bản. Một số tác giả framework đã bắt đầu thử nghiệm thay thế bằng triển khai signal này, nhưng việc sử dụng vẫn còn ở giai đoạn đầu.\n\nNhững người cộng tác trong đề xuất Signal muốn thật sự **thận trọng** trong việc thúc đẩy đề xuất này, để tránh rơi vào cái bẫy đưa ra một thứ mà sau này chúng ta hối tiếc và không thực sự sử dụng. Kế hoạch của chúng tôi là thực hiện các nhiệm vụ bổ sung sau, không yêu cầu bởi quy trình TC39, để đảm bảo đề xuất này đi đúng hướng:\n\nTrước khi đề xuất lên Giai đoạn 2, chúng tôi dự định:\n- Phát triển nhiều bản polyfill đạt cấp độ sản xuất, chắc chắn, được kiểm thử kỹ lưỡng (ví dụ, vượt qua các bài kiểm tra từ nhiều framework cũng như các bài kiểm tra kiểu test262), và có hiệu năng cạnh tranh (được xác minh qua một bộ benchmark signal/framework kỹ lưỡng).\n- Tích hợp API Signal đề xuất vào nhiều framework JS mà chúng tôi cho là đại diện, và một số ứng dụng lớn làm việc trên cơ sở này. Kiểm tra xem nó hoạt động hiệu quả và chính xác trong các bối cảnh này.\n- Có cái nhìn chắc chắn về không gian các phần mở rộng có thể cho API, và kết luận phần nào (nếu có) nên được thêm vào đề xuất này.\n\n## Thuật toán Signal\n\nPhần này mô tả từng API được lộ ra cho JavaScript, theo các thuật toán mà chúng thực hiện. Có thể coi đây là một bản tiền-đặc-tả, được đưa vào ở giai đoạn đầu để cố định một tập hợp ngữ nghĩa khả dĩ, đồng thời rất sẵn sàng thay đổi.\n\nMột số khía cạnh của thuật toán:\n- Thứ tự đọc Signals bên trong một computed là có ý nghĩa, và có thể quan sát được qua thứ tự mà một số callback nhất định (`Watcher` được gọi, `equals`, tham số đầu tiên cho `new Signal.Computed`, và các callback `watched`/`unwatched`) được thực thi. Điều này có nghĩa là các nguồn của một computed Signal phải được lưu theo thứ tự.\n- Bốn callback này đều có thể ném ngoại lệ, và các ngoại lệ này được truyền một cách dự đoán được đến mã JS gọi. Các ngoại lệ *không* dừng thực thi thuật toán này hoặc làm cho biểu đồ ở trạng thái xử lý dở dang. Đối với các lỗi phát sinh trong callback `notify` của một Watcher, ngoại lệ đó được gửi đến lệnh `.set()` đã kích hoạt nó, sử dụng AggregateError nếu có nhiều ngoại lệ được ném ra. Các callback khác (bao gồm cả `watched`/`unwatched`?) được lưu trữ trong giá trị của Signal, sẽ được ném lại khi đọc, và signal bị ném lại như vậy có thể được đánh dấu `~clean~` như bất kỳ signal nào khác với giá trị bình thường.\n- Cẩn thận tránh các vòng lặp trong trường hợp các computed signals không được \"watched\" (bị quan sát bởi bất kỳ Watcher nào), để chúng có thể được thu gom rác một cách độc lập với các phần khác của biểu đồ signal. Về mặt nội bộ, điều này có thể được triển khai với hệ thống số thế hệ luôn được thu gom; lưu ý rằng các triển khai tối ưu hóa cũng có thể bao gồm số thế hệ cục bộ cho từng node, hoặc tránh theo dõi một số số trên các signals được watched.\n\n### Trạng thái toàn cục ẩn\n\nCác thuật toán Signal cần tham chiếu đến một số trạng thái toàn cục nhất định. Trạng thái này là toàn cục cho toàn bộ luồng (thread), hoặc \"agent\".\n\n- `computing`: Computed hoặc effect Signal lồng trong cùng hiện đang được đánh giá lại do một lệnh gọi `.get` hoặc `.run`, hoặc `null`. Ban đầu là `null`.\n- `frozen`: Biến boolean cho biết có đang có callback nào thực thi yêu cầu không được thay đổi biểu đồ. Ban đầu là `false`.\n- `generation`: Một số nguyên tăng dần, bắt đầu từ 0, dùng để theo dõi giá trị hiện tại tránh vòng lặp.\n\n### Không gian tên `Signal`\n\n`Signal` là một đối tượng thông thường đóng vai trò là không gian tên cho các lớp và hàm liên quan đến Signal.\n\n`Signal.subtle` là một đối tượng không gian tên nội bộ tương tự.\n\n### Lớp `Signal.State`\n\n#### Thuộc tính nội bộ của `Signal.State`\n\n- `value`: Giá trị hiện tại của state signal\n- `equals`: Hàm so sánh dùng khi thay đổi giá trị\n- `watched`: Callback sẽ được gọi khi signal được quan sát bởi một effect\n- `unwatched`: Callback sẽ được gọi khi signal không còn được quan sát bởi một effect\n- `sinks`: Tập hợp các signal được watched phụ thuộc vào signal này\n\n#### Hàm khởi tạo: `Signal.State(initialValue, options)`\n\n1. Đặt `value` của Signal này thành `initialValue`.\n1. Đặt `equals` của Signal này thành options?.equals\n1. Đặt `watched` của Signal này thành options?.[Signal.subtle.watched]\n1. Đặt `unwatched` của Signal này thành options?.[Signal.subtle.unwatched]\n1. Đặt `sinks` của Signal này thành tập rỗng\n\n#### Phương thức: `Signal.State.prototype.get()`\n\n1. Nếu `frozen` là true, ném một ngoại lệ.\n1. Nếu `computing` không phải `undefined`, thêm Signal này vào tập `sources` của `computing`.\n1. LƯU Ý: Chúng ta không thêm `computing` vào tập `sinks` của Signal này cho đến khi nó được watched bởi một Watcher.\n1. Trả về `value` của Signal này.\n\n#### Phương thức: `Signal.State.prototype.set(newValue)`\n\n1. Nếu ngữ cảnh thực thi hiện tại là `frozen`, ném một ngoại lệ.\n1. Thực thi thuật toán \"set Signal value\" với Signal này và giá trị truyền vào đầu tiên.\n1. Nếu thuật toán đó trả về `~clean~`, trả về undefined.\n1. Đặt trạng thái (`state`) của tất cả các `sink` của Signal này thành (nếu là Computed Signal) `~dirty~` nếu trước đó là clean, hoặc (nếu là Watcher) `~pending~` nếu trước đó là `~watching~`.\n1. Đặt trạng thái của tất cả các phụ thuộc Computed Signal của các sink (đệ quy) thành `~checked~` nếu trước đó là `~clean~` (tức là, giữ nguyên đánh dấu dirty), hoặc với Watchers, `~pending~` nếu trước đó là `~watching~`.\n1. Với mỗi Watcher trước đó ở trạng thái `~watching~` được gặp trong quá trình tìm kiếm đệ quy, lần lượt theo thứ tự duyệt sâu,\n    1. Đặt `frozen` thành true.\n    1. Gọi callback `notify` của chúng (lưu lại mọi ngoại lệ ném ra, nhưng bỏ qua giá trị trả về của `notify`).\n    1. Khôi phục `frozen` về false.\n    1. Đặt trạng thái của Watcher thành `~waiting~`.\n1. Nếu có ngoại lệ nào được ném từ callback `notify`, truyền nó lên caller sau khi tất cả callback `notify` đã chạy. Nếu có nhiều ngoại lệ, đóng gói chúng vào một AggregateError và ném ra.\n1. Trả về undefined.\n\n### Lớp `Signal.Computed`\n\n#### Máy trạng thái `Signal.Computed`",
  "status": "ok"
}