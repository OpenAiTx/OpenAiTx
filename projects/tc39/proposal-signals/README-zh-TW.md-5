{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: 展示如何將 Observable 轉換為僅在被 effect 使用時訂閱的 computed signal 的範例\n\nTODO: 展示代表 fetch 針對某個 state 結果的 computed signal 範例，並且可被取消\n\n### SSR 的內省\n\nTODO: 展示如何序列化 signal graph 的運作方式\n\nTODO: 展示如何使用幾個 signal，從 state「水合」為 computed\n\n-->\n\n### 暫時省略\n\n這些功能未來可能會加入，但目前草案尚未包含。這些功能的省略，是因為各框架在設計空間尚未有明確共識，並且已經證明可以透過本文所述 Signals 機制上的其他方法來解決。不過，這些省略遺憾地限制了各框架之間的互操作性潛力。隨著依據本文描述的 Signals 原型逐步產生，將會重新檢視這些省略是否為適當決定。\n\n* **非同步（Async）**：在此模型中，Signals 總是可以同步取得評估結果。但實務上，常常需要有某些非同步流程會設定 signal，並且要能理解 signal 目前是否處於「載入中」狀態。一個簡單的做法是用例外來表達 loading 狀態，且 computed signal 的例外快取行為與此技巧能夠一定程度地組合。更進階的技術討論可見於 [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30)。\n* **交易（Transactions）**：在畫面轉換時，通常需要同時維持「來源」與「目標」狀態的即時狀態。「目標」狀態會在背景渲染，直到準備好交換（提交交易），而「來源」狀態則持續可互動。要同時維持兩個狀態，需要「分叉」 signal graph 的狀態，甚至可能需要同時支援多個暫存中的轉換。相關討論見 [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73)。\n\n有些[便利方法](https://github.com/proposal-signals/proposal-signals/issues/32)也同樣被省略。\n\n## 狀態與開發計畫\n\n本提案已列入 2024 年 4 月 TC39 議程，階段為 Stage 1。目前可以視為「Stage 0」。\n\n本提案已有一個[相容實作（polyfill）](https://github.com/proposal-signals/signal-polyfill)，並包含一些基本測試。有些框架作者已經開始嘗試用此 signal 實作來替換現有方案，但此用法仍處於初期階段。\n\nSignal 提案的協作者們希望在推進本提案時特別**保守**，以免最後推出了後悔且實際上沒人採用的東西。我們計畫執行以下 TC39 程序未要求的額外任務，以確保本提案的進度正確：\n\n在進入 Stage 2 前，我們計畫：\n- 開發多個達到產品等級、穩健且經過良好測試（例如通過多個框架測試及 test262 風格測試）、效能具競爭力（經 signal/框架基準集嚴格驗證）的 polyfill 實作。\n- 將擬議的 Signal API 整合進大量我們認為具代表性的 JS 框架，並讓部分大型應用以此為基礎運作。測試其在這些情境下的效能與正確性。\n- 充分理解 API 的潛在擴充空間，並決定哪些（如有）應納入本提案。\n\n## Signal 演算法\n\n本節說明每個對 JavaScript 暴露的 API，其所實作的演算法。可視為一份原型規格，雖然內容開放修正，但有助於先釐清一組可能的語意。\n\n演算法的幾個重點：\n- 在 computed 內部對 Signals 的讀取順序很重要，並可藉由某些回呼（如 `Watcher` 被觸發、`equals`、`new Signal.Computed` 的第一個參數、`watched`/`unwatched` 回呼）執行的順序觀察到。這意味著 computed Signal 的來源必須是有順序地儲存。\n- 這四個回呼都可能拋出例外，且這些例外會以可預期方式傳遞給呼叫的 JS 程式碼。這些例外*不會*導致演算法中止或讓 graph 處於半處理狀態。若在 Watcher 的 `notify` 回呼中發生錯誤，該例外會傳給觸發它的 `.set()` 呼叫，若有多個例外則包成 AggregateError 丟出。其他例外（包括 `watched`/`unwatched`？）則存於 Signal 的值，當讀取時再拋出，且這類會拋出例外的 Signal 也能如一般有值的 Signal 一樣被標記為 `~clean~`。\n- 對於未被「監看」（未被任何 Watcher 觀察）的 computed signal，演算法特別避免循環依賴，讓這些 signal 能獨立於 graph 其他部分被垃圾回收。內部可用「世代編號（generation number）」系統實作，且優化實作可能還會有每個節點的區域世代編號，或避免追蹤某些已被監看的 signal 的編號。\n\n### 隱含的全域狀態\n\nSignal 演算法需要參考某些全域狀態。這些狀態在整個執行緒（或「代理」）內全域有效。\n\n- `computing`：目前因 `.get` 或 `.run` 呼叫而正在重新計算的最內層 computed 或 effect Signal，或為 `null`。初始值為 `null`。\n- `frozen`：布林值，表示目前是否有回呼正在執行且要求不得修改 graph。初始值為 `false`。\n- `generation`：自 0 開始遞增的整數，用來追蹤值的新舊並避免循環依賴。\n\n### `Signal` 命名空間\n\n`Signal` 是一個普通物件，作為 Signal 相關類別與函式的命名空間。\n\n`Signal.subtle` 是一個類似的內部命名空間物件。\n\n### `Signal.State` 類別\n\n#### `Signal.State` 內部欄位\n\n- `value`：state signal 的目前值\n- `equals`：變更值時使用的比較函式\n- `watched`：signal 首次被 effect 觀察時呼叫的回呼\n- `unwatched`：signal 不再被 effect 觀察時呼叫的回呼\n- `sinks`：依賴此 signal 的所有被監看的 signals 集合\n\n#### 建構子：`Signal.State(initialValue, options)`\n\n1. 設定本 Signal 的 `value` 為 `initialValue`。\n1. 設定本 Signal 的 `equals` 為 options?.equals\n1. 設定本 Signal 的 `watched` 為 options?.[Signal.subtle.watched]\n1. 設定本 Signal 的 `unwatched` 為 options?.[Signal.subtle.unwatched]\n1. 設定本 Signal 的 `sinks` 為空集合\n\n#### 方法：`Signal.State.prototype.get()`\n\n1. 若 `frozen` 為 true，丟出例外。\n1. 若 `computing` 不為 `undefined`，將本 Signal 加入 `computing` 的 `sources` 集合。\n1. 備註：只有當被 Watcher 監看時，才會把 `computing` 加入本 Signal 的 `sinks` 集合。\n1. 回傳本 Signal 的 `value`。\n\n#### 方法：`Signal.State.prototype.set(newValue)`\n\n1. 若目前執行環境為 `frozen`，丟出例外。\n1. 以本 Signal 與傳入值執行「設定 Signal 值」演算法。\n1. 若該演算法回傳 `~clean~`，則回傳 undefined。\n1. 將本 Signal 所有 `sinks` 的 `state` 設為（若為 Computed Signal）`~dirty~`（若其先前為 clean），或（若為 Watcher）`~pending~`（若其先前為 `~watching~`）。\n1. 將所有這些 sinks 的 Computed Signal 依賴（遞迴）設為 `~checked~`（若其先前為 `~clean~`；若為 dirty 則維持），或 Watchers 設為 `~pending~`（若先前為 `~watching~`）。\n1. 對於遞迴搜尋中遇到的每個先前為 `~watching~` 的 Watcher，依深度優先順序：\n    1. 設定 `frozen` 為 true。\n    1. 呼叫其 `notify` 回呼（若有例外則記錄，但忽略 `notify` 的回傳值）。\n    1. 還原 `frozen` 為 false。\n    1. 將 Watcher 的 `state` 設為 `~waiting~`。\n1. 若任何 `notify` 回呼拋出例外，則於所有 `notify` 執行完畢後將例外傳遞給呼叫端；若有多個例外則包成 AggregateError 丟出。\n1. 回傳 undefined。\n\n### `Signal.Computed` 類別\n\n#### `Signal.Computed` 狀態機",
  "status": "ok"
}