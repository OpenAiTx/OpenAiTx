{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback called when isWatched becomes true, if it was previously false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback called whenever isWatched becomes false, if it was previously true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Signal 的運作方式\n\nSignal 代表一個隨時間可能變化的資料儲存格。Signal 可以是「狀態型」（僅以手動方式設置的值），也可以是「計算型」（基於其他 Signal 的公式）。\n\n計算型 Signal 的運作方式是：在其評估過程中，自動追蹤讀取了哪些其他 Signal。當讀取計算型 Signal 時，它會檢查先前記錄的依賴項是否有變更，如果有就重新計算自身。當多個計算型 Signal 巢狀時，所有追蹤的歸因都會集中在最內層的那一個。\n\n計算型 Signal 是惰性（即拉取式）的：只有在被存取時才會重新計算，即使其中一個依賴項較早前已經改變。\n\n傳遞給計算型 Signal 的回呼通常應該是「純粹」的，也就是說，必須是其他 Signal 的確定性、無副作用的函數。同時，回呼被呼叫的時機是確定性的，因此可以小心地使用副作用。\n\nSignal 具有明顯的快取／記憶化特性：狀態型與計算型 Signal 都會記住其目前的值，只有在它們實際變更時，才會觸發引用它們的計算型 Signal 重新計算。甚至不需要重複比較舊值和新值——比較只會在來源 Signal 被重設或重新計算時進行一次，而 Signal 機制會追蹤哪些引用該 Signal 的項目尚未根據新值更新。在內部，這通常透過「圖著色」來實現，如（Milo 的部落格文章）所述。\n\n計算型 Signal 會動態追蹤其依賴項——每次運行時，可能依賴不同的項目，而這個精確的依賴集會在 Signal 圖中保持最新。這表示，如果你只在某個分支上需要某個依賴，而先前的計算走的是另一個分支，那麼對於那個暫時未使用的值的變更，不會導致計算型 Signal 被重新計算，即使被拉取。\n\n與 JavaScript 的 Promise 不同，Signal 的所有操作都是同步執行的：\n- 將 Signal 設為新值是同步的，這會立即反映在隨後讀取任何依賴它的計算型 Signal 上。這個變異沒有內建的批次處理。\n- 讀取計算型 Signal 是同步的——它們的值總是可用。\n- 如下所述，Watcher 的 `notify` 回呼會在觸發它的 `.set()` 呼叫期間同步執行（但會在圖著色完成後）。\n\n和 Promise 一樣，Signal 也可以表示錯誤狀態：如果計算型 Signal 的回呼拋出錯誤，該錯誤會像其他值一樣被快取，每次讀取 Signal 都會重新拋出該錯誤。\n\n### Signal 類別解析\n\n一個 `Signal` 實例代表可以讀取一個動態變化且其更新會被追蹤的值的能力。它也隱含地包含了訂閱該 Signal 的能力，這是透過其他計算型 Signal 的追蹤存取來實現的。\n\n這裡的 API 設計是為了符合 Signal 生態圈在「signal」、「computed」和「state」等名稱上的粗略共識。不過，對計算型和狀態型 Signal 的存取是透過 `.get()` 方法，而這與所有流行的 Signal API 不同，它們要麼使用 `.value` 存取器，要麼使用 `signal()` 呼叫語法。\n\nAPI 設計目標是減少資源分配數量，使 Signal 適合嵌入於 JavaScript 框架中，同時達到與現有框架專用 Signal 相同或更好的效能。這意味著：\n- 狀態型 Signal 是單一可寫物件，可以從同一參考中存取和設置。（詳見下方「能力分離」章節的影響。）\n- 狀態型與計算型 Signal 均可被子類化，方便框架通過公開或私有類別欄位（以及使用該狀態的方法）添加額外屬性。\n- 各種回呼（如 `equals`、計算型回呼）都會以對應的 Signal 作為 `this` 值呼叫，這樣每個 Signal 不需要新建閉包。上下文可保存在 Signal 本身的額外屬性中。\n\n此 API 強制執行的一些錯誤條件：\n- 遞迴讀取計算型 Signal 屬於錯誤行為。\n- Watcher 的 `notify` 回呼不可讀取或寫入任何 Signal。\n- 如果計算型 Signal 的回呼拋出錯誤，則後續存取該 Signal 會重拋快取的錯誤，直到依賴項之一改變並重新計算。\n\n未被強制執行的一些條件：\n- 計算型 Signal 可以在其回呼中同步寫入其他 Signal。\n- Watcher 的 `notify` 回呼所佇列的工作可能會讀寫 Signal，這使得可以用 Signal 複製[經典 React 反模式](https://react.dev/learn/you-might-not-need-an-effect)！\n\n### 實作 effect\n\n上面定義的 `Watcher` 介面為實作典型 JS effect API 提供了基礎：即當其他 Signal 變化時重新執行回呼，純粹用於副作用。最初範例中使用的 `effect` 函數可定義如下：\n\n```ts\n// 這個函數通常存在於函式庫／框架中，而非應用程式碼\n// 注意：這個排程邏輯過於基礎，不建議複製／貼上。\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// 一個 effect Signal，當其依賴可能改變時，會將自身的讀取排入 microtask queue\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nSignal API 本身並未內建如 `effect` 這類函數。這是因為 effect 排程非常微妙，且常常結合框架的渲染週期及其他高階、框架專屬的狀態或策略，而 JS 本身無法存取這些。\n\n來看一下這裡使用的不同操作：傳遞給 `Watcher` 建構子的 `notify` 回呼，是當 Signal 從「乾淨」狀態（我們知道快取已初始化且有效）進入「已檢查」或「髒」狀態（快取可能有效也可能無效，因為至少有一個遞迴依賴的狀態已被更改）時會被呼叫的函數。\n\n`notify` 的呼叫最終是由某個狀態型 Signal 的 `.set()` 呼叫所觸發。這個呼叫是同步的：它發生在 `.set` 返回之前。但不必擔心這個回呼會在 Signal 圖尚未完全處理時觀察到其狀態，因為在 `notify` 回呼期間，任何 Signal 都不可被讀寫，即使是在 `untrack` 呼叫中也是如此。由於 `notify` 是在 `.set()` 期間呼叫的，它會中斷另一段尚未完成的邏輯。若要在 `notify` 中讀寫 Signal，應安排稍後執行的工作，例如將 Signal 記錄在清單中，或像上面一樣用 `queueMicrotask`。\n\n請注意，即使不使用 `Signal.subtle.Watcher`，只要定時輪詢計算型 Signal（如 Glimmer 所做），也可以有效地運用 Signal。但許多框架發現，同步執行這些排程邏輯通常十分有用，因此 Signal API 也包含了這個能力。\n\n計算型與狀態型 Signal 都像其他 JS 值一樣會被垃圾回收。不過 Watcher 有一種特殊的方式能讓物件保持存活：任何被 Watcher 監看的 Signal 只要底層狀態仍可達，就會保持存活，因為這些狀態可能會觸發未來的 `notify` 呼叫（進而觸發後續的 `.get()`）。因此，請記得呼叫 `Watcher.prototype.unwatch` 來清理 effect。\n\n### 一個不安全的逃生出口\n\n`Signal.subtle.untrack` 是一個逃生出口，允許在*不*追蹤這些讀取的情況下讀取 Signal。這種能力是不安全的，因為它可能會產生依賴其他 Signal 但在這些 Signal 變化時卻不會更新自身的計算型 Signal。只有在未追蹤的存取不會改變計算結果時才應使用。\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### 使用 watched/unwatched\n-->",
  "status": "ok"
}