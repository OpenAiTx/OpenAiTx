{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// isWatchedが以前falseだった場合にtrueになると呼び出されるコールバック\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// isWatchedが以前trueだった場合にfalseになるたびに呼び出されるコールバック\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### シグナルの仕組み\n\nシグナルは、時間とともに変化する可能性があるデータのセルを表します。シグナルには「状態」（手動で設定される単なる値）と「計算」（他のシグナルに基づく式）の2種類があります。\n\n計算シグナルは、その評価中に読み取られた他のシグナルを自動的に追跡することで動作します。計算シグナルが読み取られると、以前に記録した依存関係のいずれかが変更されていないかをチェックし、変更されていれば再評価します。複数の計算シグナルがネストされている場合、追跡の帰属は最も内側のものに行われます。\n\n計算シグナルは遅延評価、すなわちプルベースで動作します。依存関係のいずれかが以前に変更されていても、アクセスされたときにのみ再評価されます。\n\n計算シグナルに渡すコールバックは、アクセスする他のシグナルの決定論的で副作用のない関数（「純粋関数」）であるべきです。同時に、コールバックが呼び出されるタイミングは決定的であるため、副作用も注意して使用できます。\n\nシグナルは強力なキャッシュ／メモ化機能を備えています。状態シグナルも計算シグナルも現在の値を記憶し、参照している計算シグナルが実際に変更された場合にのみ再計算をトリガーします。古い値と新しい値の比較を繰り返す必要すらありません。比較はソースのシグナルがリセット／再評価されたときに1度だけ行われ、シグナル機構が、そのシグナルを参照しているがまだ新しい値で更新されていないものを追跡します。内部的には、これは一般的に（Miloのブログ記事で説明されているような）「グラフ彩色」によって表現されます。\n\n計算シグナルは依存関係を動的に追跡します。実行されるたびに異なるものに依存する可能性があり、その正確な依存関係セットがシグナルグラフ内で最新の状態に保たれます。したがって、ある分岐でのみ必要な依存関係があり、以前の計算で別の分岐を通っていた場合、一時的に未使用だった値が変更されても、その計算シグナルは再計算されません（プルされた場合でも）。\n\nJavaScriptのPromiseとは異なり、シグナル内のすべては同期的に動作します。\n- シグナルに新しい値を設定するのは同期的であり、その後それに依存する計算シグナルを読み取った際にも即座に反映されます。このミューテーションのバッチ処理は組み込まれていません。\n- 計算シグナルの読み取りも同期的です—常に値が取得できます。\n- 下記で説明するWatcherの`notify`コールバックは、トリガーされた`.set()`呼び出し中（ただしグラフ彩色が完了した後）に同期的に実行されます。\n\nPromiseと同様に、シグナルはエラー状態を表すこともできます。計算シグナルのコールバックが例外をスローした場合、そのエラーは他の値と同様にキャッシュされ、シグナルが読み取られるたびに再スローされます。\n\n### Signalクラスの理解\n\n`Signal`インスタンスは、時間とともに更新が追跡される動的な値を読み取る能力を表します。また、他の計算シグナルからの追跡付きアクセスによって暗黙的にシグナルを購読する能力も含まれます。\n\nここでのAPIは、「signal」「computed」「state」といった名称の使用に関して、シグナルライブラリの多くの間で大まかに合意されているエコシステムの流れに合わせています。ただし、計算シグナルと状態シグナルへのアクセスは`.get()`メソッドを通して行います。これは、`.value`スタイルのアクセッサや`signal()`呼び出し構文を用いる一般的なシグナルAPIとは異なります。\n\nこのAPIは割り当て回数を減らすように設計されており、既存のフレームワーク専用シグナルと同等かそれ以上のパフォーマンスで、シグナルをJavaScriptフレームワークに組み込むのに適しています。これには以下の意味があります。\n- 状態シグナルは単一の書き込み可能なオブジェクトであり、同じ参照からアクセスと設定の両方が可能です（「能力分離」セクション参照）。\n- 状態シグナルと計算シグナルの両方はサブクラス化可能であり、フレームワークがpublic/privateクラスフィールド（およびその状態を利用するメソッド）を通じて追加プロパティを持たせることができます。\n- 各種コールバック（`equals`や計算用コールバックなど）は、`this`値として該当シグナルを受け取ります。これにより、シグナルごとに新しいクロージャを作成する必要がなくなります。代わりに、コンテキストはシグナル自身の追加プロパティに保存できます。\n\nこのAPIで強制されるいくつかのエラー条件：\n- 計算シグナルを再帰的に読み取るのはエラーです。\n- Watcherの`notify`コールバックでは、いかなるシグナルの読み書きもできません。\n- 計算シグナルのコールバックが例外をスローした場合、その後のシグナルへのアクセスでは依存関係が変化し再計算されるまで、そのキャッシュされたエラーを再スローします。\n\n*強制されない*条件：\n- 計算シグナルは、コールバック内で他のシグナルに同期的に書き込むことができます。\n- Watcherの`notify`コールバックでキューされた作業はシグナルの読み書きが可能であり、[古典的なReactアンチパターン](https://react.dev/learn/you-might-not-need-an-effect)をシグナルで再現することもできます！\n\n### エフェクトの実装\n\n上記で定義した`Watcher`インターフェースは、他のシグナルが変化したときに副作用のためだけにコールバックを再実行する、典型的なJS API（エフェクト）を実装する基盤となります。冒頭の例で使用した`effect`関数は次のように定義できます。\n\n```ts\n// この関数は通常、アプリケーションコードではなくライブラリ／フレームワーク内に存在します\n// 注意：このスケジューリングロジックは単純すぎて実用的ではありません。コピペしないでください。\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// 任意の依存関係が変わるたびに自身の読み取りをマイクロタスクキューにスケジュールする、cbを評価するエフェクトシグナル\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nSignal APIには、`effect`のような組み込み関数は存在しません。これは、エフェクトのスケジューリングが微妙であり、多くの場合フレームワークのレンダリングサイクルやその他の高レベルなフレームワーク固有の状態や戦略と結びつくことが多く、JSからは直接アクセスできないからです。\n\nここで使われているさまざまな操作について説明します。`Watcher`コンストラクタに渡される`notify`コールバックは、シグナルが「クリーン」状態（キャッシュが初期化済みで有効であることが分かっている）から「チェック済み」または「ダーティ」状態（その依存状態のうち少なくとも1つが変更されたためキャッシュが有効かもしれないし無効かもしれない）に遷移したときに呼ばれる関数です。\n\n`notify`の呼び出しは、最終的にはある状態シグナルの`.set()`呼び出しによってトリガーされます。この呼び出しは同期的であり、`.set`の戻り値より前に発生します。しかし、このコールバックがシグナルグラフの処理途中の状態を見ることを心配する必要はありません。なぜなら`notify`コールバック中は、`untrack`呼び出し内ですら、どのシグナルも読み書きできないからです。`notify`は`.set()`中に呼び出されるため、未完了の他のロジックの途中で割り込むことになります。`notify`からシグナルを読み書きする必要がある場合は、リストに書き込んで後でアクセスする、もしくは上記のように`queueMicrotask`で後回しにするなど、作業を後で実行するようスケジューリングしてください。\n\nなお、`Signal.subtle.Watcher`を使用せず、計算シグナルのポーリングをスケジューリングする（Glimmerのような）手法でも、シグナルを効果的に活用することは十分可能です。しかし多くのフレームワークは、このスケジューリングロジックを同期的に実行するのが非常に有用であると考えています。そのため、シグナルAPIにはこれが含まれています。\n\n計算シグナルも状態シグナルも、他のJS値と同様にガベージコレクションされます。ただし、Watcherは特別な方法で参照を維持します。Watcherによって監視されているシグナルは、基になる状態がどれか1つでも到達可能な限り保持されます。これらは将来`notify`コールをトリガーし（そしてその後`.get()`を呼ぶ）可能性があるためです。このため、効果のクリーンアップ時には必ず`Watcher.prototype.unwatch`を呼ぶようにしてください。\n\n### 型安全でないエスケープハッチ\n\n`Signal.subtle.untrack`は、読み取りを追跡せずにシグナルを読むためのエスケープハッチです。この機能は、他のシグナルに依存するが、それらが変化しても更新されない計算シグナルを作成できてしまうため、安全ではありません。アン・トラックされたアクセスが計算結果に影響しない場合にのみ使用してください。\n\n<!--\nTODO: untrackを使うのが適切な例を示す\n\n### watched/unwatchedの利用",
  "status": "ok"
}