{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: نمایش نمونه‌ای از تبدیل یک Observable به یک سیگنال محاسبه‌شده، که تنها زمانی که توسط یک اثر استفاده می‌شود، مشترک می‌شود\n\nTODO: نمایش نمونه‌ای از یک سیگنال محاسبه‌شده که نتیجه‌ی یک fetch هدایت‌شده به یک وضعیت را نمایش می‌دهد، که لغو می‌شود\n\n### درون‌بینی برای SSR\n\nTODO: نمایش چگونگی کارکرد serialize کردن گراف سیگنال\n\nTODO: نمایش چگونگی اینکه چگونه می‌توانید یک سیگنال را از حالت state به computed بعداً \"hydrate\" کنید، با استفاده از چند سیگنال.\n-->\n\n### فعلاً حذف شده\n\nاین ویژگی‌ها ممکن است بعداً اضافه شوند، اما در پیش‌نویس فعلی گنجانده نشده‌اند. حذف آن‌ها به دلیل نبود اجماع تثبیت‌شده در فضای طراحی میان فریم‌ورک‌ها و همچنین قابلیت اثبات‌شده برای دور زدن نبود آن‌ها با مکانیزم‌هایی بر پایه مفهوم سیگنال‌ها که در این سند توضیح داده شده، است. با این حال، متأسفانه این حذف‌ها پتانسیل همکاری بین فریم‌ورک‌ها را محدود می‌کند. با تولید نمونه‌های اولیه از سیگنال‌هایی که در این سند توصیف شده‌اند، تلاشی برای بازنگری اینکه آیا این حذف‌ها تصمیم مناسبی بوده‌اند، صورت خواهد گرفت.\n\n* **Async**: سیگنال‌ها در این مدل همواره به صورت همزمان برای ارزیابی در دسترس هستند. با این حال، اغلب مفید است که برخی فرایندهای غیرهمزمان وجود داشته باشد که منجر به تنظیم یک سیگنال شوند، و دانستن اینکه چه زمانی یک سیگنال هنوز در حالت \"بارگذاری\" است، اهمیت دارد. یکی از روش‌های ساده برای مدل‌سازی وضعیت بارگذاری، استفاده از استثناها است، و رفتار کش کردن استثناها در سیگنال‌های محاسبه‌شده تا حدی با این تکنیک ترکیب می‌شود. تکنیک‌های بهبود یافته در [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30) مورد بحث قرار گرفته‌اند.\n* **تراکنش‌ها**: برای انتقال بین نماها، اغلب مفید است که وضعیت زنده برای هر دو وضعیت \"مبدأ\" و \"مقصد\" حفظ شود. وضعیت \"مقصد\" در پس‌زمینه رندر می‌شود تا زمانی که آماده جایگزینی شود (تأیید تراکنش)، در حالی که وضعیت \"مبدأ\" همچنان تعاملی باقی می‌ماند. حفظ هر دو وضعیت به طور همزمان نیازمند \"انشعاب\" وضعیت گراف سیگنال است و حتی ممکن است پشتیبانی از چندین انتقال در حال انتظار به طور همزمان مفید باشد. بحث در [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nبرخی [متدهای تسهیل‌گر](https://github.com/proposal-signals/proposal-signals/issues/32) نیز حذف شده‌اند.\n\n## وضعیت و برنامه توسعه\n\nاین پیشنهاد در دستور جلسه آوریل ۲۰۲۴ TC39 برای مرحله ۱ قرار دارد. در حال حاضر می‌توان آن را \"مرحله ۰\" در نظر گرفت.\n\n[یک پلی‌فیل](https://github.com/proposal-signals/signal-polyfill) برای این پیشنهاد در دسترس است، همراه با برخی تست‌های پایه‌ای. برخی نویسندگان فریم‌ورک‌ها شروع به آزمایش جایگزینی این پیاده‌سازی سیگنال کرده‌اند، اما این استفاده در مراحل ابتدایی است.\n\nهمکاران در پیشنهاد سیگنال به ویژه می‌خواهند در پیشبرد این پیشنهاد **محتاطانه** عمل کنند تا در دام ارائه چیزی که بعداً پشیمان شویم و عملاً استفاده نشود، نیفتیم. برنامه ما انجام کارهای اضافی زیر است که توسط فرایند TC39 لازم نیست، تا مطمئن شویم این پیشنهاد در مسیر صحیح قرار دارد:\n\nقبل از پیشنهاد برای مرحله ۲، برنامه داریم که:\n- چندین پیاده‌سازی پلی‌فیل با کیفیت تولیدی توسعه دهیم که قوی، به خوبی تست شده (مثلاً، عبور از تست‌های فریم‌ورک‌های مختلف و همچنین تست‌های سبک test262) و از نظر عملکرد رقابتی باشند (مطابق با یک مجموعه بنچمارک سیگنال/فریم‌ورک جامع ارزیابی شود).\n- API پیشنهادی سیگنال را در تعداد زیادی از فریم‌ورک‌های JS که آن‌ها را نسبتاً نماینده می‌دانیم، ادغام کنیم و برخی برنامه‌های بزرگ نیز با این مبنا کار کنند. تست کنیم که در این زمینه‌ها به طور مؤثر و صحیح کار می‌کند.\n- درک جامعی از فضای گسترش‌های ممکن برای API داشته باشیم و نتیجه بگیریم که کدام (در صورت وجود) باید به این پیشنهاد اضافه شوند.\n\n## الگوریتم‌های سیگنال\n\nاین بخش هر یک از APIهایی که به جاوااسکریپت ارائه می‌شوند را از نظر الگوریتم‌هایی که پیاده‌سازی می‌کنند توصیف می‌کند. این بخش را می‌توان به عنوان یک پیش‌مشخصات در نظر گرفت و در این مرحله اولیه گنجانده شده است تا مجموعه‌ای از معانی ممکن را تثبیت کند، در حالی که برای تغییرات بسیار باز است.\n\nبرخی جنبه‌های الگوریتم:\n- ترتیب خواندن سیگنال‌ها در یک محاسبه‌شده مهم است و در ترتیب اجرای برخی callbacks (مانند زمانی که `Watcher` فراخوانی می‌شود، `equals`، اولین پارامتر به `new Signal.Computed`، و callbacks مربوط به `watched`/`unwatched`) قابل مشاهده است. این بدان معناست که منابع یک سیگنال محاسبه‌شده باید به صورت مرتب‌شده ذخیره شوند.\n- این چهار callback همگی ممکن است استثنا پرتاب کنند و این استثناها به شکل قابل پیش‌بینی به کد JS فراخواننده منتقل می‌شوند. این استثناها اجرای الگوریتم را متوقف نمی‌کنند یا گراف را در حالت نیمه‌پردازش رها نمی‌کنند. برای خطاهایی که در callback `notify` یک Watcher پرتاب می‌شوند، آن استثنا به فراخوانی `.set()` که آن را فعال کرده، ارسال می‌شود و اگر چندین استثنا پرتاب شده باشد، در قالب AggregateError بسته‌بندی می‌شوند. سایر موارد (از جمله `watched`/`unwatched`?) در مقدار سیگنال ذخیره می‌شوند تا هنگام خواندن دوباره پرتاب شوند و چنین سیگنال پرتاب‌کننده‌ای می‌تواند مانند سایر سیگنال‌ها با مقدار معمولی به عنوان `~clean~` علامت‌گذاری شود.\n- دقت شده تا از ایجاد دور در موارد سیگنال‌های محاسبه‌شده که \"مشاهده\" نمی‌شوند (توسط هیچ Watcher مشاهده نمی‌شوند) جلوگیری شود، تا بتوان آن‌ها را مستقل از بخش‌های دیگر گراف سیگنال جمع‌آوری زباله کرد. به طور داخلی، این می‌تواند با سیستمی از شماره نسل‌ها که همیشه جمع‌آوری می‌شوند پیاده‌سازی شود؛ توجه داشته باشید که پیاده‌سازی‌های بهینه ممکن است شامل شماره نسل محلی برای هر گره نیز باشند، یا برخی شماره‌ها را روی سیگنال‌های مشاهده‌شده پیگیری نکنند.\n\n### وضعیت سراسری مخفی\n\nالگوریتم‌های سیگنال نیاز دارند به برخی وضعیت‌های سراسری ارجاع دهند. این وضعیت برای کل نخ یا \"عامل\" سراسری است.\n\n- `computing`: درونی‌ترین سیگنال محاسبه‌شده یا اثر که در حال حاضر به دلیل فراخوانی `.get` یا `.run` دوباره ارزیابی می‌شود، یا `null`. در ابتدا `null`.\n- `frozen`: یک مقدار بولی که نشان می‌دهد آیا در حال حاضر یک callback در حال اجراست که نیاز دارد گراف تغییر نکند. در ابتدا `false`.\n- `generation`: یک عدد صحیح افزایشی که از ۰ شروع می‌شود و برای پیگیری به‌روز بودن یک مقدار در حالی که از دور جلوگیری می‌شود، استفاده می‌شود.\n\n### فضای نام `Signal`\n\n`Signal` یک شیء معمولی است که به عنوان فضای نام برای کلاس‌ها و توابع مرتبط با سیگنال عمل می‌کند.\n\n`Signal.subtle` یک شیء فضای نام داخلی مشابه است.\n\n### کلاس `Signal.State`\n\n#### اسلات‌های داخلی `Signal.State`\n\n- `value`: مقدار فعلی سیگنال وضعیت\n- `equals`: تابع مقایسه‌ای که هنگام تغییر مقادیر استفاده می‌شود\n- `watched`: callback‌ای که وقتی سیگنال توسط یک اثر مشاهده می‌شود فراخوانی می‌شود\n- `unwatched`: callback‌ای که وقتی سیگنال دیگر توسط یک اثر مشاهده نمی‌شود فراخوانی می‌شود\n- `sinks`: مجموعه‌ای از سیگنال‌های مشاهده‌شده که به این سیگنال وابسته‌اند\n\n#### سازنده: `Signal.State(initialValue, options)`\n\n1. مقدار `value` این سیگنال را برابر با `initialValue` قرار دهید.\n1. مقدار `equals` این سیگنال را برابر با options?.equals قرار دهید.\n1. مقدار `watched` این سیگنال را برابر با options?.[Signal.subtle.watched] قرار دهید.\n1. مقدار `unwatched` این سیگنال را برابر با options?.[Signal.subtle.unwatched] قرار دهید.\n1. مقدار `sinks` این سیگنال را به مجموعه تهی تنظیم کنید.\n\n#### متد: `Signal.State.prototype.get()`\n\n1. اگر `frozen` برابر true بود، یک استثنا پرتاب کنید.\n1. اگر `computing` برابر `undefined` نبود، این سیگنال را به مجموعه `sources` متعلق به `computing` اضافه کنید.\n1. توجه: ما تا زمانی که این سیگنال توسط یک Watcher مشاهده نشود، `computing` را به مجموعه `sinks` این سیگنال اضافه نمی‌کنیم.\n1. مقدار `value` این سیگنال را بازگردانید.\n\n#### متد: `Signal.State.prototype.set(newValue)`\n\n1. اگر زمینه اجرایی فعلی `frozen` باشد، یک استثنا پرتاب کنید.\n1. الگوریتم \"تنظیم مقدار سیگنال\" را با این سیگنال و پارامتر اول برای مقدار اجرا کنید.\n1. اگر آن الگوریتم مقدار `~clean~` را بازگرداند، مقدار undefined را بازگردانید.\n1. وضعیت تمام `sinks`های این سیگنال را (اگر سیگنال محاسبه‌شده باشد) به `~dirty~` در صورتی که قبلاً clean بوده‌اند، یا (اگر Watcher باشد) به `~pending~` در صورتی که قبلاً `~watching~` بوده است، تنظیم کنید.\n1. وضعیت تمامی وابستگی‌های سیگنال محاسبه‌شده‌ی sinksها (به طور بازگشتی) را به `~checked~` در صورتی که قبلاً `~clean~` بوده‌اند (یعنی علامت‌های dirty را سر جای خود باقی بگذارید)، یا برای Watcherها، به `~pending~` اگر قبلاً `~watching~` بوده‌اند، تنظیم کنید.\n1. برای هر Watcher که قبلاً `~watching~` بوده و در آن جستجوی بازگشتی به ترتیب عمق-اول یافت شده،\n    1. مقدار `frozen` را به true تنظیم کنید.\n    1. callback مربوط به `notify` آن‌ها را فراخوانی کنید (هر استثنای پرتاب‌شده را کنار بگذارید اما مقدار بازگشتی `notify` را نادیده بگیرید).\n    1. مقدار `frozen` را به false برگردانید.\n    1. وضعیت Watcher را به `~waiting~` تنظیم کنید.\n1. اگر هرگونه استثنایی از callbackهای `notify` پرتاب شد، پس از اجرای همه callbackهای `notify` آن را به فراخواننده منتقل کنید. اگر چندین استثنا وجود داشت، آن‌ها را در قالب AggregateError بسته‌بندی و پرتاب کنید.\n1. مقدار undefined را بازگردانید.\n\n### کلاس `Signal.Computed`\n\n#### ماشین وضعیت `Signal.Computed`",
  "status": "ok"
}