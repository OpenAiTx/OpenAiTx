{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Monitoraggio automatico delle dipendenze** - Un Signal computato scopre automaticamente qualsiasi altro Signal da cui dipende, siano essi semplici valori o altri calcoli.\n* **Valutazione pigra (Lazy Evaluation)** - I calcoli non vengono eseguiti immediatamente quando vengono dichiarati, né vengono subito ricalcolati quando cambiano le loro dipendenze. Vengono valutati solo quando il loro valore viene esplicitamente richiesto.\n* **Memoizzazione** - I Signal computati memorizzano nella cache il loro ultimo valore, in modo che i calcoli le cui dipendenze non sono cambiate non debbano essere ricalcolati, indipendentemente da quante volte vengano letti.\n\n## Motivazione per la standardizzazione dei Signals\n\n#### Interoperabilità\n\nOgni implementazione di Signal ha il proprio meccanismo di auto-tracciamento, per tenere traccia delle sorgenti incontrate durante la valutazione di un Signal computato. Questo rende difficile condividere modelli, componenti e librerie tra diversi framework: tendono ad avere un falso accoppiamento con il loro motore di rendering (dato che i Signals sono solitamente implementati come parte dei framework JS).\n\nUn obiettivo di questa proposta è separare completamente il modello reattivo dalla vista di rendering, permettendo agli sviluppatori di migrare verso nuove tecnologie di rendering senza riscrivere il loro codice non-UI, oppure di sviluppare modelli reattivi condivisi in JS da distribuire in diversi contesti. Sfortunatamente, a causa di versioning e duplicazioni, si è rivelato poco pratico raggiungere un alto livello di condivisione tramite librerie a livello JS: i built-in offrono una garanzia di condivisione più forte.\n\n#### Prestazioni/Utilizzo della memoria\n\nC'è sempre un piccolo potenziale incremento prestazionale nel distribuire meno codice grazie al fatto che le librerie più comuni sono built-in, ma le implementazioni dei Signals sono generalmente piuttosto ridotte, quindi non ci aspettiamo che questo effetto sia molto significativo.\n\nSospettiamo che implementazioni native C++ delle strutture dati e degli algoritmi correlati ai Signals possano essere leggermente più efficienti di quanto sia ottenibile in JS, per un fattore costante. Tuttavia, non sono previsti cambiamenti algoritmici rispetto a quanto sarebbe presente in un polyfill; non ci si aspetta che i motori siano \"magici\" qui, e gli algoritmi reattivi stessi saranno ben definiti e non ambigui.\n\nIl gruppo dei proponenti prevede di sviluppare varie implementazioni di Signals e di utilizzare queste per indagare queste possibilità prestazionali.\n\n#### DevTools\n\nCon le attuali librerie di Signal nel linguaggio JS, può essere difficile tracciare cose come:\n* Lo stack delle chiamate attraverso una catena di Signals computati, mostrando la catena causale di un errore\n* Il grafo delle referenze tra Signals, quando uno dipende da un altro -- importante per il debug dell'uso della memoria\n\nI Signals integrati consentono ai runtime JS e ai DevTools di avere potenzialmente un supporto migliorato per l'ispezione dei Signals, in particolare per il debug o l'analisi delle prestazioni, sia che ciò sia integrato nei browser sia tramite un'estensione condivisa. Strumenti esistenti come l'inspector degli elementi, snapshot delle prestazioni e profiler di memoria potrebbero essere aggiornati per evidenziare specificamente i Signals nella presentazione delle informazioni.\n\n#### Benefici secondari\n\n##### Benefici di una libreria standard\n\nIn generale, JavaScript ha sempre avuto una libreria standard piuttosto minimale, ma una tendenza in TC39 è stata quella di rendere JS un linguaggio più \"batteries-included\", con un set di funzionalità di alta qualità e integrate. Ad esempio, Temporal sta sostituendo moment.js, e una serie di piccole funzionalità, ad esempio, `Array.prototype.flat` e `Object.groupBy` stanno sostituendo molti casi d'uso di lodash. I benefici includono bundle più piccoli, maggiore stabilità e qualità, meno cose da imparare quando si entra in un nuovo progetto e un vocabolario generalmente comune tra gli sviluppatori JS.\n\n##### Integrazione HTML/DOM (una possibilità futura)\n\nLavori in corso nel W3C e da parte degli implementatori dei browser stanno cercando di portare il templating nativo in HTML ([DOM Parts][wicg-pr-1023] e [Template Instantiation][wicg-propsal-template-instantiation]). Inoltre, il W3C Web Components CG sta esplorando la possibilità di estendere i Web Components per offrire una API HTML completamente dichiarativa. Per raggiungere entrambi questi obiettivi, in futuro sarà necessaria una primitiva reattiva per l'HTML. Inoltre, molte migliorie ergonomiche al DOM tramite l'integrazione dei Signals possono essere immaginate e sono state richieste dalla comunità.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Nota, questa integrazione sarebbe uno sforzo separato da realizzare in seguito, non fa parte di questa proposta stessa.\n\n##### Scambio di informazioni nell’ecosistema (*non* un motivo per implementare)\n\nGli sforzi di standardizzazione possono essere utili anche solo a livello \"comunitario\", anche senza cambiamenti nei browser. Il lavoro sui Signals sta unendo diversi autori di framework per una discussione approfondita sulla natura della reattività, degli algoritmi e dell'interoperabilità. Questo è già stato utile, ma non giustifica l'inclusione nei motori JS e nei browser; i Signals dovrebbero essere aggiunti allo standard JavaScript solo se ci sono benefici significativi *oltre* lo scambio di informazioni abilitato nell’ecosistema.\n\n## Obiettivi di progettazione per i Signals\n\nSi scopre che le attuali librerie di Signal non sono poi così diverse tra loro, alla radice. Questa proposta mira a costruire sul loro successo implementando le qualità importanti di molte di queste librerie.\n\n### Caratteristiche principali\n\n* Un tipo Signal che rappresenta uno stato, cioè un Signal scrivibile. Questo è un valore che altri possono leggere.\n* Un tipo Signal computato/memo/derivato, che dipende da altri ed è calcolato e memorizzato nella cache in modo pigro.\n    * Il calcolo è pigro, il che significa che i Signals computati non vengono ricalcolati di default quando una delle loro dipendenze cambia, ma vengono eseguiti solo se qualcuno li legge effettivamente.\n    * Il calcolo è \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", ovvero non vengono mai eseguiti calcoli non necessari. Questo implica che, quando un'applicazione legge un Signal computato, c'è un ordinamento topologico delle parti potenzialmente \"sporche\" del grafo da eseguire, per eliminare eventuali duplicati.\n    * Il calcolo è memorizzato nella cache, il che significa che se, dopo l'ultimo cambiamento di una dipendenza, nessuna dipendenza è cambiata, allora il Signal computato *non* viene ricalcolato quando viene letto.\n    * Sono possibili confronti personalizzati sia per i Signals computati che per quelli di stato, per determinare quando altri Signals computati che dipendono da essi devono essere aggiornati.\n* Reazioni alla condizione in cui un Signal computato ha una delle sue dipendenze (o dipendenze annidate) che diventa \"sporca\" e cambia, il che significa che il valore del Signal potrebbe essere obsoleto.\n    * Questa reazione serve a pianificare l'esecuzione di lavoro più significativo in un secondo momento.\n    * Gli effetti sono implementati in termini di queste reazioni, più la pianificazione a livello di framework.\n    * I Signal computati hanno bisogno della capacità di reagire al fatto di essere registrati come (annidati) dipendenti di una di queste reazioni.\n* Consentire ai framework JS di gestire la propria pianificazione. Nessuna pianificazione forzata incorporata in stile Promise.\n    * Sono necessarie reazioni sincrone per consentire la pianificazione di lavori successivi sulla base della logica del framework.\n    * Le scritture sono sincrone e hanno effetto immediato (un framework che raggruppa le scritture può farlo sopra).\n    * È possibile separare il controllo se un effetto può essere \"sporco\" dall'esecuzione effettiva dell'effetto (abilitando uno scheduler di effetti a due stadi).\n* Possibilità di leggere Signals *senza* attivare la registrazione delle dipendenze (`untrack`)\n* Consentire la composizione di diversi codebase che usano Signals/reattività, ad esempio,\n    * Uso di più framework insieme per quanto riguarda il tracciamento/la reattività stessa (salvo omissioni, vedi sotto)\n    * Strutture dati reattive indipendenti dal framework (ad esempio, proxy store ricorsivo reattivo, Map, Set e Array reattivi, ecc.)\n\n### Solidità\n\n* Sconsigliare/proibire l’uso ingenuo delle reazioni sincrone.\n    * Rischio di solidità: potrebbe esporre \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" se usato in modo improprio: se il rendering viene fatto immediatamente quando si imposta un Signal, potrebbe esporre uno stato applicativo incompleto all’utente finale. Questa funzione dovrebbe quindi essere usata solo per pianificare intelligentemente lavoro futuro, una volta che la logica applicativa è terminata.\n    * Soluzione: vietare la lettura e la scrittura di qualsiasi Signal all’interno di una callback di reazione sincrona\n* Sconsigliare `untrack` e segnalarne la natura non sicura\n    * Rischio di solidità: consente la creazione di Signals computati il cui valore dipende da altri Signals, ma che non vengono aggiornati quando quei Signals cambiano. Va utilizzato solo quando gli accessi non tracciati non cambieranno il risultato del calcolo.\n    * Soluzione: l’API è contrassegnata come \"unsafe\" nel nome.\n* Nota: Questa proposta consente ai signals di essere sia letti che scritti da signals computati ed effetti, senza limitare le scritture successive alle letture, nonostante il rischio di solidità. Questa decisione è stata presa per preservare flessibilità e compatibilità nell’integrazione coi framework.\n\n### API di superficie\n\n* Deve essere una solida base per diversi framework per implementare i loro meccanismi di Signals/reattività.\n    * Dovrebbe essere una buona base per proxy store ricorsivi, reattività sui campi di classe tramite decorator, e sia API in stile `.value` sia `[state, setState]`.\n    * La semantica deve poter esprimere i pattern validi abilitati dai diversi framework. Ad esempio, dovrebbe essere possibile per questi Signals essere la base sia di scritture immediatamente riflesse sia di scritture raggruppate e applicate successivamente.\n* Sarebbe auspicabile che questa API fosse direttamente utilizzabile dagli sviluppatori JavaScript.\n    * Se una funzionalità coincide con un concetto nell’ecosistema, usare un vocabolario comune è utile.\n        * Tuttavia, è importante non ombreggiare letteralmente gli stessi nomi!\n    * Tensione tra \"usabilità per gli sviluppatori JS\" e \"fornire tutti gli hook ai framework\"\n        * Idea: Fornire tutti gli hook, ma includere errori in caso di uso improprio, se possibile.\n        * Idea: Mettere le API più sottili in uno spazio dei nomi `subtle`, simile a [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), per segnare la linea tra API necessarie per usi avanzati come implementare un framework o costruire dev tools e API più da sviluppo applicativo quotidiano come l’istanziazione di signals da usare con un framework.\n* Essere implementabile e utilizzabile con buone prestazioni -- l’API di superficie non deve causare troppo overhead\n    * Abilitare la sottoclassificazione, così che i framework possano aggiungere i propri metodi e campi, anche privati. Questo è importante per evitare la necessità di allocazioni aggiuntive a livello di framework. Vedi \"Gestione della memoria\" sotto.\n\n### Gestione della memoria\n\n* Se possibile: Un Signal computato dovrebbe poter essere raccolto dal garbage collector se non ci sono riferimenti vivi per futuri accessi, anche se è collegato in un grafo più ampio che resta vivo (ad esempio, leggendo uno stato che resta vivo).",
  "status": "ok"
}