{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Observableを、エフェクトによって使用されている場合のみ購読されるcomputed signalに変換する例を示す\n\nTODO: 状態に向けて行われたfetchの結果を表すcomputed signalの例を示す（キャンセルされる場合）\n\n### SSRのためのイントロスペクション\n\nTODO: シグナルグラフのシリアライズがどのように機能するかを示す\n\nTODO: いくつかのシグナルを使って、後から状態からcomputedに「ハイドレート」する方法を示す\n-->\n\n### 今回は省略\n\nこれらの機能は将来的に追加される可能性がありますが、現行のドラフトには含まれていません。省略の理由は、フレームワーク間で設計空間におけるコンセンサスが確立されていないことと、本ドキュメントで説明されているSignalsの仕組みの上にメカニズムを重ねることで、それらの機能の欠如を回避できることが示されているためです。しかし残念ながら、省略によってフレームワーク間の相互運用性の可能性が制限されています。本ドキュメントで説明されているSignalsのプロトタイプが作成されるにつれ、これらの省略が適切な判断であったかどうかを再検討する取り組みがなされます。\n\n* **Async**: このモデルにおけるSignalsは、常に同期的に評価可能です。しかし、特定の非同期プロセスによってsignalがセットされ、「ローディング中」である状態を認識することが有用な場合が多々あります。ローディング状態をモデル化する簡単な方法は例外を使うことです。また、computed signalの例外キャッシュ動作は、この手法とある程度合理的に組み合わせることができます。改良された手法については[Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30)で議論されています。\n* **Transactions**: ビュー間の遷移時には、「from」と「to」両方の状態をライブで保持することが有用な場合があります。「to」状態はバックグラウンドでレンダリングされ、準備ができたら切り替え（トランザクションのコミット）されますが、「from」状態は引き続きインタラクティブなままです。両方の状態を同時に保持するには、signalグラフの状態を「フォーク」する必要があり、複数の保留中の遷移を同時にサポートすることも有用かもしれません。詳細は[Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73)で議論されています。\n\nいくつかの[便利メソッド](https://github.com/proposal-signals/proposal-signals/issues/32)も省略されています。\n\n## ステータスと開発計画\n\nこの提案は、2024年4月のTC39アジェンダでStage 1として提出されています。現時点では「Stage 0」と考えてよいでしょう。\n\nこの提案のための[ポリフィル](https://github.com/proposal-signals/signal-polyfill)が利用可能で、いくつかの基本的なテストが用意されています。いくつかのフレームワークの作者が、このsignal実装の置き換え実験を始めていますが、この利用はまだ初期段階です。\n\nSignal提案のコラボレーターは、この提案を推進するにあたって特に**保守的**でありたいと考えています。これは、最終的に後悔し使われなくなるようなものが出荷される罠に陥らないためです。TC39プロセスで要求されていない以下の追加タスクを実施し、この提案が適切な軌道に乗っているかを確認する予定です。\n\nStage 2の提案前に以下を計画しています：\n- 複数のプロダクショングレードのポリフィル実装を開発し、それらが堅牢で十分にテストされていること（例：各種フレームワークやtest262スタイルのテストをパス）、およびパフォーマンス面でも競争力があること（シグナル/フレームワークのベンチマークセットで検証）。\n- 提案されているSignal APIを、ある程度代表的と考えられる多くのJSフレームワークに統合し、大規模なアプリケーションで動作することを確認。これらの文脈で効率的かつ正しく動作することをテスト。\n- APIの拡張の可能性について確かな理解を持ち、どの（もしあれば）拡張がこの提案に追加されるべきか結論を得る。\n\n## Signalアルゴリズム\n\nこのセクションでは、JavaScriptに公開される各APIについて、それらが実装するアルゴリズムの観点から説明します。これはプロト仕様と考えることができ、現時点では一つの意味論セットを確定するために記載されていますが、今後の変更にも柔軟に対応します。\n\nアルゴリズムのいくつかの側面：\n- computed内でのSignalの読み取り順序は重要であり、特定のコールバック（`Watcher`が呼ばれる順序、`equals`、`new Signal.Computed`の最初のパラメータ、`watched`/`unwatched`コールバック）の実行順序で観測可能です。つまり、computed Signalのソースは順序付きで保存する必要があります。\n- これら4つのコールバックはすべて例外をスローする可能性があり、例外は呼び出し元のJSコードに予測可能な方法で伝播されます。これらの例外によってこのアルゴリズムの実行が中断されたり、グラフが処理途中の状態で残されたりすることは*ありません*。Watcherの`notify`コールバックでスローされたエラーについては、その例外はそれをトリガーした`.set()`呼び出しに送られます（複数の例外がスローされた場合はAggregateErrorを使用）。その他（`watched`/`unwatched`など）はSignalの値に保存され、読み取り時に再スローされます。このような再スローSignalも通常の値を持つもの同様に`~clean~`とマークできます。\n- 「監視されていない」（Watcherによって観測されていない）computed signalの場合、循環参照を回避してsignalグラフの他の部分と独立してガーベジコレクト可能にするための配慮がなされています。内部的には、常に収集される世代番号のシステムで実装できます。最適化された実装では、ノードごとのローカル世代番号を含めることも、一部のwatched signalについて番号の追跡を省略することも可能です。\n\n### 隠れたグローバル状態\n\nSignalアルゴリズムは、特定のグローバル状態を参照する必要があります。この状態はスレッド、または「エージェント」全体でグローバルです。\n\n- `computing`: 現在`.get`または`.run`呼び出しによって再評価されている最も内側のcomputedまたはeffect Signal、あるいは`null`。初期値は`null`。\n- `frozen`: グラフの変更を許可しないコールバックが現在実行中かどうかを示すブール値。初期値は`false`。\n- `generation`: 0から始まる増加整数で、循環参照を回避しつつ値の新しさを追跡するのに使われます。\n\n### `Signal`名前空間\n\n`Signal`は、Signal関連のクラスと関数の名前空間として機能する通常のオブジェクトです。\n\n`Signal.subtle`も同様の内部名前空間オブジェクトです。\n\n### `Signal.State`クラス\n\n#### `Signal.State`の内部スロット\n\n- `value`: state signalの現在値\n- `equals`: 値変更時に使用する比較関数\n- `watched`: signalがeffectによって観測され始めたときに呼ばれるコールバック\n- `unwatched`: signalがeffectによって観測されなくなったときに呼ばれるコールバック\n- `sinks`: このsignalに依存するwatchされたsignalの集合\n\n#### コンストラクタ: `Signal.State(initialValue, options)`\n\n1. このSignalの`value`を`initialValue`に設定する。\n1. このSignalの`equals`をoptions?.equalsに設定する。\n1. このSignalの`watched`をoptions?.[Signal.subtle.watched]に設定する。\n1. このSignalの`unwatched`をoptions?.[Signal.subtle.unwatched]に設定する。\n1. このSignalの`sinks`を空集合に設定する。\n\n#### メソッド: `Signal.State.prototype.get()`\n\n1. `frozen`がtrueなら、例外を投げる。\n1. `computing`が`undefined`でなければ、このSignalを`computing`の`sources`セットに追加する。\n1. 注: Watcherによって監視されるまで、`computing`をこのSignalの`sinks`セットに追加しない。\n1. このSignalの`value`を返す。\n\n#### メソッド: `Signal.State.prototype.set(newValue)`\n\n1. 現在の実行コンテキストが`frozen`なら、例外を投げる。\n1. このSignalと値の第1引数で「Signal値のセット」アルゴリズムを実行する。\n1. そのアルゴリズムが`~clean~`を返した場合、undefinedを返す。\n1. このSignalのすべての`sinks`の`state`を（もしComputed Signalなら）以前がcleanなら`~dirty~`に、（Watcherなら）以前が`~watching~`なら`~pending~`にセットする。\n1. すべての`sinks`のComputed Signal依存先（再帰的に）の`state`を、以前が`~clean~`なら`~checked~`に（dirtyマーキングはそのまま）、Watcherについては以前が`~watching~`なら`~pending~`にセットする。\n1. その再帰探索で遭遇した、以前`~watching~`だったWatcherごとに、深さ優先順で、\n    1. `frozen`をtrueにセットする。\n    1. それらの`notify`コールバックを呼び出す（スローされた例外は保存し、`notify`の戻り値は無視）。\n    1. `frozen`をfalseに戻す。\n    1. Watcherの`state`を`~waiting~`にセットする。\n1. `notify`コールバックから例外がスローされた場合、すべての`notify`コールバック実行後に呼び出し元に伝播する。複数の例外がある場合は、AggregateErrorでまとめてスローする。\n1. undefinedを返す。\n\n### `Signal.Computed`クラス\n\n#### `Signal.Computed`ステートマシン",
  "status": "ok"
}