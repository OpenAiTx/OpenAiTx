# ğŸš¦ Proposta padrÃ£o de Signals em JavaScript ğŸš¦
<img align=right src="https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg" alt="Signals logo" width=100>

Stage 1 ([explicaÃ§Ã£o](https://tc39.es/process-document/))

Proponentes da proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg

Autores originais: Rob Eisenberg e Daniel Ehrenberg

Este documento descreve uma direÃ§Ã£o inicial comum para signals em JavaScript, similar ao esforÃ§o Promises/A+ que precedeu as Promises padronizadas pelo TC39 no ES2015. Experimente vocÃª mesmo, usando [um polyfill](https://github.com/proposal-signals/signal-polyfill).

De forma semelhante ao Promises/A+, este esforÃ§o foca em alinhar o ecossistema JavaScript. Se esse alinhamento for bem-sucedido, entÃ£o um padrÃ£o poderÃ¡ surgir, baseado nessa experiÃªncia. Diversos autores de frameworks estÃ£o colaborando aqui em um modelo comum que pode dar suporte ao nÃºcleo de reatividade deles. O rascunho atual Ã© baseado no design e contribuiÃ§Ãµes de autores/maintainers do [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), e maisâ€¦

Diferente do Promises/A+, nÃ£o estamos tentando resolver uma API comum voltada para desenvolvedores, mas sim as semÃ¢nticas centrais precisas do grafo de signals subjacente. Esta proposta inclui uma API totalmente concreta, mas a API nÃ£o Ã© direcionada Ã  maioria dos desenvolvedores de aplicaÃ§Ãµes. Em vez disso, a API de signals aqui apresentada Ã© mais adequada para que frameworks construam sobre ela, proporcionando interoperabilidade por meio de um grafo de signals comum e mecanismo de rastreamento automÃ¡tico.

O plano para esta proposta Ã© realizar prototipaÃ§Ã£o inicial significativa, incluindo integraÃ§Ã£o em vÃ¡rios frameworks, antes de avanÃ§ar alÃ©m do Stage 1. SÃ³ estamos interessados em padronizar Signals se eles forem adequados para uso prÃ¡tico em mÃºltiplos frameworks e proporcionarem benefÃ­cios reais em relaÃ§Ã£o aos signals fornecidos pelos frameworks. Esperamos que uma prototipaÃ§Ã£o inicial significativa nos forneÃ§a essas informaÃ§Ãµes. Veja "Status e plano de desenvolvimento" abaixo para mais detalhes.

## Contexto: Por que Signals?

Para desenvolver uma interface de usuÃ¡rio (UI) complicada, desenvolvedores de aplicaÃ§Ãµes JavaScript precisam armazenar, calcular, invalidar, sincronizar e enviar estado para a camada de visualizaÃ§Ã£o da aplicaÃ§Ã£o de maneira eficiente. UIs normalmente envolvem mais do que apenas gerenciar valores simples, frequentemente incluindo a renderizaÃ§Ã£o de estado computado que depende de uma Ã¡rvore complexa de outros valores ou estados que tambÃ©m sÃ£o computados. O objetivo dos Signals Ã© fornecer infraestrutura para gerenciar tal estado de aplicaÃ§Ã£o, permitindo que desenvolvedores foquem na lÃ³gica de negÃ³cio ao invÃ©s desses detalhes repetitivos.

Construtos semelhantes a signals tÃªm sido considerados Ãºteis de forma independente tambÃ©m em contextos nÃ£o relacionados a UI, especialmente em sistemas de build para evitar rebuilds desnecessÃ¡rios.

Signals sÃ£o usados em programaÃ§Ã£o reativa para eliminar a necessidade de gerenciar atualizaÃ§Ãµes em aplicaÃ§Ãµes.

> Um modelo de programaÃ§Ã£o declarativo para atualizaÃ§Ã£o com base em mudanÃ§as de estado.

de _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.

#### Exemplo - Um Contador em VanillaJS

Dado uma variÃ¡vel, `counter`, vocÃª deseja renderizar no DOM se o contador Ã© par ou Ã­mpar. Sempre que o `counter` muda, vocÃª quer atualizar o DOM com a Ãºltima paridade. Em Vanilla JS, vocÃª poderia ter algo assim:

```js
let counter = 0;
const setCounter = (value) => {
  counter = value;
  render();
};

const isEven = () => (counter & 1) == 0;
const parity = () => isEven() ? "even" : "odd";
const render = () => element.innerText = parity();

// Simular atualizaÃ§Ãµes externas ao counter...
setInterval(() => setCounter(counter + 1), 1000);
```
> [!NOTE]  
> Globais sÃ£o usados aqui apenas para fins de demonstraÃ§Ã£o. O gerenciamento adequado de estado possui muitas soluÃ§Ãµes, e os exemplos nesta proposta tÃªm a intenÃ§Ã£o de ser o mais mÃ­nimos possÃ­vel. Esta proposta nÃ£o incentiva o uso de variÃ¡veis globais.


Isto possui vÃ¡rios problemas...

* A configuraÃ§Ã£o do `counter` Ã© barulhenta e cheia de boilerplate.
* O estado de `counter` estÃ¡ fortemente acoplado ao sistema de renderizaÃ§Ã£o.
* Se o `counter` muda, mas `parity` nÃ£o (por exemplo, o contador vai de 2 para 4), entÃ£o fazemos uma computaÃ§Ã£o de paridade desnecessÃ¡ria e renderizaÃ§Ã£o desnecessÃ¡ria.
* E se outra parte da nossa UI quiser apenas renderizar quando o `counter` for atualizado?
* E se outra parte da nossa UI depender apenas de `isEven` ou `parity`?

Mesmo neste cenÃ¡rio relativamente simples, diversos problemas surgem rapidamente. PoderÃ­amos tentar contornar isso introduzindo pub/sub para o `counter`. Isso permitiria que consumidores adicionais do `counter` pudessem se inscrever para adicionar suas prÃ³prias reaÃ§Ãµes Ã s mudanÃ§as de estado.

No entanto, ainda estamos presos aos seguintes problemas:

* A funÃ§Ã£o de renderizaÃ§Ã£o, que depende apenas de `parity`, deve "saber" que, na verdade, precisa se inscrever no `counter`.
* NÃ£o Ã© possÃ­vel atualizar a UI com base apenas em `isEven` ou `parity`, sem interagir diretamente com `counter`.
* Aumentamos nosso boilerplate. Sempre que vocÃª estÃ¡ usando algo, nÃ£o Ã© apenas uma questÃ£o de chamar uma funÃ§Ã£o ou ler uma variÃ¡vel, mas sim de se inscrever e fazer atualizaÃ§Ãµes ali. Gerenciar a desinscriÃ§Ã£o tambÃ©m Ã© especialmente complicado.

Agora, poderÃ­amos resolver alguns problemas adicionando pub/sub nÃ£o apenas ao `counter`, mas tambÃ©m ao `isEven` e ao `parity`. TerÃ­amos entÃ£o que inscrever `isEven` no `counter`, `parity` em `isEven`, e `render` em `parity`. Infelizmente, nÃ£o apenas nosso cÃ³digo boilerplate aumentou muito, mas tambÃ©m estamos presos a uma tonelada de gerenciamento de inscriÃ§Ãµes, e um potencial desastre de vazamento de memÃ³ria se nÃ£o limpamos tudo corretamente. Portanto, resolvemos alguns problemas, mas criamos toda uma nova categoria de problemas e muito cÃ³digo. Para piorar, temos que passar por todo esse processo para cada pedaÃ§o de estado em nosso sistema.

### Apresentando Signals

AbstraÃ§Ãµes de data binding em UIs para o modelo e a visualizaÃ§Ã£o hÃ¡ muito tempo sÃ£o centrais para frameworks de UI em diversas linguagens de programaÃ§Ã£o, apesar da ausÃªncia de qualquer mecanismo desse tipo embutido no JS ou na plataforma web. Dentro de frameworks e bibliotecas JS, houve muita experimentaÃ§Ã£o em diferentes maneiras de representar esse binding, e a experiÃªncia mostrou o poder do fluxo de dados unidirecional em conjunto com um tipo de dado de primeira classe representando uma cÃ©lula de estado ou computaÃ§Ã£o derivada de outros dados, agora frequentemente chamado de "Signals".
Essa abordagem de valor reativo de primeira classe parece ter feito sua primeira apariÃ§Ã£o popular em frameworks web JavaScript de cÃ³digo aberto com o [Knockout](https://knockoutjs.com/) [em 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). Nos anos seguintes, muitas variaÃ§Ãµes e implementaÃ§Ãµes foram criadas. Nos Ãºltimos 3-4 anos, o primitivo Signal e abordagens relacionadas ganharam ainda mais forÃ§a, com praticamente todas as bibliotecas ou frameworks modernos de JavaScript tendo algo similar, sob um nome ou outro.

Para entender Signals, vejamos o exemplo acima, reimaginado com uma API de Signal mais detalhada abaixo.

#### Exemplo - Um Contador com Signals

```js
const counter = new Signal.State(0);
const isEven = new Signal.Computed(() => (counter.get() & 1) == 0);
const parity = new Signal.Computed(() => isEven.get() ? "even" : "odd");

// Uma biblioteca ou framework define efeitos com base em outros primitives de Signal
declare function effect(cb: () => void): (() => void);

effect(() => element.innerText = parity.get());

// Simular atualizaÃ§Ãµes externas ao counter...
setInterval(() => counter.set(counter.get() + 1), 1000);
```

HÃ¡ algumas coisas que podemos perceber imediatamente:
* Eliminamos o boilerplate barulhento em torno da variÃ¡vel `counter` do nosso exemplo anterior.
* Existe uma API unificada para lidar com valores, computaÃ§Ãµes e efeitos colaterais.
* NÃ£o hÃ¡ problema de referÃªncia circular ou dependÃªncias invertidas entre `counter` e `render`.
* NÃ£o hÃ¡ inscriÃ§Ãµes manuais, nem necessidade de gerenciamento.
* Existe um meio de controlar o tempo/agendamento de efeitos colaterais.

Signals nos oferecem muito mais do que pode ser visto superficialmente na API:
* **Rastreamento AutomÃ¡tico de DependÃªncias** - Um Signal computado descobre automaticamente quaisquer outros Signals dos quais depende, sejam esses Signals valores simples ou outros cÃ¡lculos.
* **AvaliaÃ§Ã£o PreguiÃ§osa (Lazy Evaluation)** - Os cÃ¡lculos nÃ£o sÃ£o avaliados de forma Ã¡vida quando sÃ£o declarados, nem sÃ£o imediatamente avaliados quando suas dependÃªncias mudam. Eles sÃ³ sÃ£o avaliados quando seu valor Ã© explicitamente solicitado.
* **MemoizaÃ§Ã£o** - Signals computados armazenam em cache seu Ãºltimo valor para que cÃ¡lculos cujas dependÃªncias nÃ£o mudaram nÃ£o precisem ser reavaliados, nÃ£o importa quantas vezes sejam acessados.

## MotivaÃ§Ã£o para padronizar Signals

#### Interoperabilidade

Cada implementaÃ§Ã£o de Signal tem seu prÃ³prio mecanismo de rastreamento automÃ¡tico, para acompanhar as fontes encontradas ao avaliar um Signal computado. Isso dificulta o compartilhamento de modelos, componentes e bibliotecas entre diferentes frameworks--eles tendem a vir com um falso acoplamento ao seu mecanismo de visualizaÃ§Ã£o (visto que Signals geralmente sÃ£o implementados como parte de frameworks JS).

Um objetivo desta proposta Ã© desacoplar totalmente o modelo reativo da visualizaÃ§Ã£o de renderizaÃ§Ã£o, permitindo que desenvolvedores migrem para novas tecnologias de renderizaÃ§Ã£o sem reescrever seu cÃ³digo nÃ£o relacionado Ã  interface, ou desenvolvam modelos reativos compartilhados em JS para serem implantados em diferentes contextos. Infelizmente, devido a versionamento e duplicidade, revelou-se impraticÃ¡vel alcanÃ§ar um forte nÃ­vel de compartilhamento via bibliotecas em JS--os built-ins oferecem uma garantia de compartilhamento mais forte.

#### Desempenho/Uso de memÃ³ria

Sempre hÃ¡ um pequeno potencial de ganho de desempenho ao embarcar menos cÃ³digo devido a bibliotecas comumente usadas serem internas, mas as implementaÃ§Ãµes de Signals geralmente sÃ£o bastante pequenas, entÃ£o nÃ£o esperamos que esse efeito seja muito grande.

Suspeitamos que implementaÃ§Ãµes nativas em C++ das estruturas de dados e algoritmos relacionados a Signal possam ser ligeiramente mais eficientes do que o que Ã© possÃ­vel em JS, por um fator constante. No entanto, nÃ£o sÃ£o antecipadas mudanÃ§as algorÃ­tmicas em relaÃ§Ã£o ao que estaria presente em um polyfill; nÃ£o se espera que os engines sejam mÃ¡gicos aqui, e os prÃ³prios algoritmos de reatividade serÃ£o bem definidos e inequÃ­vocos.

O grupo responsÃ¡vel espera desenvolver vÃ¡rias implementaÃ§Ãµes de Signals e usÃ¡-las para investigar essas possibilidades de desempenho.

#### DevTools

Com as bibliotecas de Signal existentes em JS, pode ser difÃ­cil rastrear coisas como:
* A stack de chamadas atravÃ©s de uma cadeia de Signals computados, mostrando a cadeia causal para um erro
* O grafo de referÃªncias entre Signals, quando um depende de outro -- importante ao depurar uso de memÃ³ria

Signals embutidos permitem que runtimes JS e DevTools tenham potencialmente um suporte aprimorado para inspecionar Signals, particularmente para depuraÃ§Ã£o ou anÃ¡lise de desempenho, seja isso integrado aos navegadores ou por meio de uma extensÃ£o compartilhada. Ferramentas existentes como o inspetor de elementos, snapshot de desempenho e analisadores de memÃ³ria poderiam ser atualizados para destacar especificamente Signals em sua apresentaÃ§Ã£o de informaÃ§Ãµes.

#### BenefÃ­cios secundÃ¡rios

##### BenefÃ­cios de uma biblioteca padrÃ£o

Em geral, o JavaScript tem uma biblioteca padrÃ£o relativamente mÃ­nima, mas uma tendÃªncia no TC39 tem sido tornar o JS uma linguagem mais "baterias incluÃ­das", com um conjunto de funcionalidades internas e de alta qualidade disponÃ­vel. Por exemplo, Temporal estÃ¡ substituindo o moment.js, e vÃ¡rios recursos pequenos, como `Array.prototype.flat` e `Object.groupBy`, estÃ£o substituindo muitos casos de uso do lodash. Os benefÃ­cios incluem tamanhos de bundle menores, maior estabilidade e qualidade, menos para aprender ao entrar em um novo projeto, e um vocabulÃ¡rio geralmente comum entre desenvolvedores JS.

##### IntegraÃ§Ã£o HTML/DOM (possibilidade futura)

Trabalhos atuais no W3C e por implementadores de navegadores buscam trazer templating nativo para HTML ([DOM Parts][wicg-pr-1023] e [Template Instantiation][wicg-propsal-template-instantiation]). AlÃ©m disso, o W3C Web Components CG estÃ¡ explorando a possibilidade de estender Web Components para oferecer uma API HTML totalmente declarativa. Para alcanÃ§ar ambos os objetivos, eventualmente serÃ¡ necessÃ¡rio um primitivo reativo no HTML. AlÃ©m disso, muitas melhorias ergonÃ´micas no DOM por meio da integraÃ§Ã£o de Signals podem ser imaginadas e jÃ¡ foram solicitadas pela comunidade.

[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023
[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md

> Nota: essa integraÃ§Ã£o seria um esforÃ§o separado para o futuro, nÃ£o faz parte desta proposta em si.

##### Troca de informaÃ§Ãµes no ecossistema (*nÃ£o* Ã© motivo para embarcar)

EsforÃ§os de padronizaÃ§Ã£o Ã s vezes podem ser Ãºteis apenas no nÃ­vel da "comunidade", mesmo sem mudanÃ§as nos navegadores. O esforÃ§o dos Signals estÃ¡ reunindo muitos autores de frameworks diferentes para uma discussÃ£o profunda sobre a natureza da reatividade, algoritmos e interoperabilidade. Isso jÃ¡ tem sido Ãºtil, mas nÃ£o justifica a inclusÃ£o em engines JS e navegadores; Signals sÃ³ devem ser adicionados ao padrÃ£o JavaScript se houver benefÃ­cios significativos *alÃ©m* da troca de informaÃ§Ãµes do ecossistema viabilizada.

## Objetivos de design para Signals

Acontece que as bibliotecas de Signal existentes nÃ£o sÃ£o tÃ£o diferentes umas das outras, em sua essÃªncia. Esta proposta visa se apoiar em seu sucesso, implementando as qualidades importantes de muitas dessas bibliotecas.

### Funcionalidades principais

* Um tipo Signal que representa estado, ou seja, Signal gravÃ¡vel. Este Ã© um valor que outros podem ler.
* Um tipo Signal computado/memo/derivado, que depende de outros e Ã© calculado de forma preguiÃ§osa e armazenado em cache.
    * O cÃ¡lculo Ã© preguiÃ§oso, ou seja, Signals computados nÃ£o sÃ£o calculados novamente por padrÃ£o quando uma de suas dependÃªncias muda, mas apenas executados se alguÃ©m realmente os ler.
    * O cÃ¡lculo Ã© "[livre de glitches](https://pt.wikipedia.org/wiki/ProgramaÃ§Ã£o_reativa#Glitches)", ou seja, nenhum cÃ¡lculo desnecessÃ¡rio Ã© realizado. Isso implica que, quando uma aplicaÃ§Ã£o lÃª um Signal computado, hÃ¡ uma ordenaÃ§Ã£o topolÃ³gica das partes potencialmente sujas do grafo a serem executadas, para eliminar duplicatas.
    * O cÃ¡lculo Ã© armazenado em cache, ou seja, se, apÃ³s a Ãºltima vez que uma dependÃªncia mudou, nenhuma dependÃªncia mudou, entÃ£o o Signal computado *nÃ£o* Ã© recalculado ao ser acessado.
    * ComparaÃ§Ãµes personalizadas sÃ£o possÃ­veis tanto para Signals computados quanto para Signals de estado, para indicar quando outros Signals computados que dependem deles devem ser atualizados.
* ReaÃ§Ãµes Ã  condiÃ§Ã£o em que um Signal computado tem uma de suas dependÃªncias (ou dependÃªncias aninhadas) tornando-se "suja" e mudando, significando que o valor do Signal pode estar desatualizado.
    * Esta reaÃ§Ã£o serve para agendar trabalhos mais significativos a serem realizados posteriormente.
    * Efeitos sÃ£o implementados em termos dessas reaÃ§Ãµes, mais agendamento em nÃ­vel de framework.
    * Signals computados precisam da capacidade de reagir a serem registrados como uma dependÃªncia (aninhada) de uma dessas reaÃ§Ãµes.
* Permitir que frameworks JS faÃ§am seu prÃ³prio agendamento. Nenhum agendamento embutido obrigatÃ³rio no estilo Promise.
    * ReaÃ§Ãµes sÃ­ncronas sÃ£o necessÃ¡rias para permitir o agendamento de trabalho posterior com base na lÃ³gica do framework.
    * Escritas sÃ£o sÃ­ncronas e tÃªm efeito imediato (um framework que faz batch das escritas pode implementar isso por cima).
    * Ã‰ possÃ­vel separar a verificaÃ§Ã£o se um efeito pode estar "sujo" de realmente rodar o efeito (permitindo um agendador de efeitos em dois estÃ¡gios).
* Capacidade de ler Signals *sem* acionar o registro de dependÃªncias (`untrack`)
* Possibilitar a composiÃ§Ã£o de diferentes bases de cÃ³digo que usam Signals/reatividade, por exemplo,
    * Usar mÃºltiplos frameworks juntos no que diz respeito ao rastreamento/reatividade em si (com ressalvas, veja abaixo)
    * Estruturas de dados reativas independentes de framework (por exemplo, proxy de store recursivamente reativo, Map e Set e Array reativos, etc.)

### Solidez

* Desencorajar/proibir o uso ingÃªnuo de reaÃ§Ãµes sÃ­ncronas.
    * Risco de solidez: pode expor "[glitches](https://pt.wikipedia.org/wiki/ProgramaÃ§Ã£o_reativa#Glitches)" se usado de forma inadequada: Se a renderizaÃ§Ã£o for feita imediatamente quando um Signal Ã© definido, pode expor um estado de aplicaÃ§Ã£o incompleto para o usuÃ¡rio final. Portanto, esse recurso deve ser usado apenas para agendar trabalho de forma inteligente para depois que a lÃ³gica da aplicaÃ§Ã£o estiver concluÃ­da.
    * SoluÃ§Ã£o: Proibir leitura e escrita de qualquer Signal de dentro de um callback de reaÃ§Ã£o sÃ­ncrona.
* Desencorajar `untrack` e marcar sua natureza nÃ£o sÃ³lida
    * Risco de solidez: permite a criaÃ§Ã£o de Signals computados cujo valor depende de outros Signals, mas que nÃ£o sÃ£o atualizados quando esses Signals mudam. Deve ser usado quando os acessos nÃ£o rastreados nÃ£o mudam o resultado do cÃ¡lculo.
    * SoluÃ§Ã£o: A API Ã© marcada como "unsafe" no nome.
* Nota: Esta proposta permite que signals sejam lidos e escritos tanto de signals computados quanto de efeito, sem restringir escritas que venham apÃ³s leituras, apesar do risco para a solidez. Essa decisÃ£o foi tomada para preservar flexibilidade e compatibilidade na integraÃ§Ã£o com frameworks.

### API de superfÃ­cie

* Deve ser uma base sÃ³lida para mÃºltiplos frameworks implementarem seus mecanismos de Signals/reatividade.
    * Deve ser uma boa base para proxies de store recursivos, reatividade baseada em decoradores em campos de classe, e APIs tanto no estilo `.value` quanto `[state, setState]`.
    * A semÃ¢ntica Ã© capaz de expressar os padrÃµes vÃ¡lidos habilitados por diferentes frameworks. Por exemplo, deve ser possÃ­vel que esses Signals sejam a base de escritas refletidas imediatamente ou escritas que sÃ£o agrupadas e aplicadas posteriormente.
* Seria interessante se essa API fosse utilizÃ¡vel diretamente por desenvolvedores JavaScript.
    * Se um recurso se alinha com um conceito do ecossistema, usar o vocabulÃ¡rio comum Ã© bom.
        * Contudo, Ã© importante nÃ£o literalmente copiar exatamente os mesmos nomes!
    * TensÃ£o entre "usabilidade por devs JS" e "oferecer todos os ganchos para frameworks"
        * Ideia: Oferecer todos os ganchos, mas incluir erros quando usados de forma inadequada, se possÃ­vel.
        * Ideia: Colocar APIs sutis em um namespace `subtle`, semelhante ao [`crypto.subtle`](https://developer.mozilla.org/pt-BR/docs/Web/API/Crypto/subtle), para marcar a linha entre APIs necessÃ¡rias para uso avanÃ§ado como implementaÃ§Ã£o de frameworks ou ferramentas de dev versus uso cotidiano como instanciar signals para uso com um framework.
* Ser implementÃ¡vel e utilizÃ¡vel com bom desempenho -- a API de superfÃ­cie nÃ£o causa overhead excessivo
    * Permitir subclassificaÃ§Ã£o, para que frameworks possam adicionar seus prÃ³prios mÃ©todos e campos, incluindo campos privados. Isso Ã© importante para evitar a necessidade de alocaÃ§Ãµes adicionais no nÃ­vel do framework. Veja "Gerenciamento de memÃ³ria" abaixo.

### Gerenciamento de memÃ³ria

* Se possÃ­vel: Um Signal computado deve ser coletÃ¡vel pelo garbage collector se nada vivo estiver referenciando-o para leituras futuras possÃ­veis, mesmo que ele esteja ligado em um grafo mais amplo que permaneÃ§a vivo (por exemplo, lendo um estado que permanece vivo).
* Observe que a maioria dos frameworks atualmente exige o descarte explÃ­cito de Signals computados se eles tiverem qualquer referÃªncia para ou de outro grafo de Signal que permaneÃ§a ativo.
* Isso acaba nÃ£o sendo tÃ£o ruim quando sua vida Ãºtil estÃ¡ atrelada Ã  vida Ãºtil de um componente de UI, e efeitos precisam ser descartados de qualquer forma.
* Se for muito caro executar com essa semÃ¢ntica, entÃ£o devemos adicionar descarte explÃ­cito (ou "desvinculaÃ§Ã£o") de Signals computados Ã  API abaixo, que atualmente nÃ£o possui isso.
* Um objetivo relacionado separado: Minimizar o nÃºmero de alocaÃ§Ãµes, por exemplo,
    * para criar um Signal gravÃ¡vel (evitar dois closures separados + array)
    * para implementar efeitos (evitar um closure para cada reaÃ§Ã£o individual)
    * Na API para observar mudanÃ§as de Signal, evitar a criaÃ§Ã£o de estruturas de dados temporÃ¡rias adicionais
    * SoluÃ§Ã£o: API baseada em classes permitindo o reuso de mÃ©todos e campos definidos em subclasses

## EsboÃ§o da API

Uma ideia inicial de uma API de Signal estÃ¡ abaixo. Observe que este Ã© apenas um rascunho inicial e antecipamos mudanÃ§as ao longo do tempo. Vamos comeÃ§ar com o `.d.ts` completo para ter uma ideia do formato geral e, em seguida, discutiremos os detalhes do que tudo isso significa.

```ts
interface Signal<T> {
    // ObtÃ©m o valor do signal
    get(): T;
}

namespace Signal {
    // Um Signal de leitura e escrita
    class State<T> implements Signal<T> {
        // Cria um Signal de estado iniciando com o valor t
        constructor(t: T, options?: SignalOptions<T>);

        // ObtÃ©m o valor do signal
        get(): T;

        // Define o valor do Signal de estado para t
        set(t: T): void;
    }

    // Um Signal que Ã© uma fÃ³rmula baseada em outros Signals
    class Computed<T = unknown> implements Signal<T> {
        // Cria um Signal que avalia para o valor retornado pelo callback.
        // O callback Ã© chamado com este signal como valor de this.
        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);

        // ObtÃ©m o valor do signal
        get(): T;
    }

    // Este namespace inclui recursos "avanÃ§ados" que sÃ£o melhores
    // deixar para autores de frameworks ao invÃ©s de desenvolvedores de aplicaÃ§Ãµes.
    // AnÃ¡logo a `crypto.subtle`
    namespace subtle {
        // Executa um callback com todo rastreamento desabilitado
        function untrack<T>(cb: () => T): T;

        // ObtÃ©m o signal computado atual que estÃ¡ rastreando leituras de qualquer signal, se houver
        function currentComputed(): Computed | null;

        // Retorna a lista ordenada de todos os signals que este referenciou
        // durante a Ãºltima vez em que foi avaliado.
        // Para um Watcher, lista o conjunto de signals que ele estÃ¡ observando.
        function introspectSources(s: Computed | Watcher): (State | Computed)[];

        // Retorna os Watchers nos quais este signal estÃ¡ contido, alÃ©m de quaisquer
        // Signals Computed que leram este signal da Ãºltima vez em que foram avaliados,
        // se esse signal computed estÃ¡ (recursivamente) sendo observado.
        function introspectSinks(s: State | Computed): (Computed | Watcher)[];

        // Verdadeiro se este signal estÃ¡ "ativo", ou seja, estÃ¡ sendo observado por um Watcher,
        // ou Ã© lido por um signal Computed que estÃ¡ (recursivamente) ativo.
        function hasSinks(s: State | Computed): boolean;

        // Verdadeiro se este elemento Ã© "reativo", ou seja, depende
        // de algum outro signal. Um Computed onde hasSources Ã© falso
        // sempre retornarÃ¡ a mesma constante.
        function hasSources(s: Computed | Watcher): boolean;

        class Watcher {
            // Quando uma fonte (recursiva) do Watcher Ã© escrita, chama este callback,
            // se ainda nÃ£o foi chamado desde a Ãºltima chamada de `watch`.
            // Nenhum signal pode ser lido ou escrito durante o notify.
            constructor(notify: (this: Watcher) => void);

            // Adiciona estes signals ao conjunto do Watcher e define o watcher para executar seu
            // callback notify na prÃ³xima vez que qualquer signal do conjunto (ou um de seus dependentes) mudar.
            // Pode ser chamado sem argumentos apenas para redefinir o estado "notificado", para que
            // o callback notify seja invocado novamente.
            watch(...s: Signal[]): void;

            // Remove estes signals do conjunto observado (ex.: para um efeito que foi descartado)
            unwatch(...s: Signal[]): void;

            // Retorna o conjunto de fontes no conjunto do Watcher que ainda estÃ£o sujas, ou Ã© um signal computed
            // com uma fonte que estÃ¡ suja ou pendente e ainda nÃ£o foi reavaliada
            getPending(): Signal[];
        }

        // Hooks para observar quando estÃ¡ sendo observado ou deixou de ser observado
        var watched: Symbol;
        var unwatched: Symbol;
    }

    interface SignalOptions<T> {
        // FunÃ§Ã£o de comparaÃ§Ã£o personalizada entre o valor antigo e o novo. PadrÃ£o: Object.is.
        // O signal Ã© passado como valor de this para contexto.
        equals?: (this: Signal<T>, t: T, t2: T) => boolean;
```ts
// Callback chamado quando isWatched se torna verdadeiro, se anteriormente era falso
[Signal.subtle.watched]?: (this: Signal<T>) => void;

// Callback chamado sempre que isWatched se torna falso, se anteriormente era verdadeiro
[Signal.subtle.unwatched]?: (this: Signal<T>) => void;
}
}
```

### Como funcionam os Signals

Um Signal representa uma cÃ©lula de dados que pode mudar ao longo do tempo. Signals podem ser do tipo "state" (apenas um valor definido manualmente) ou "computed" (uma fÃ³rmula baseada em outros Signals).

Signals computados funcionam rastreando automaticamente quais outros Signals sÃ£o lidos durante sua avaliaÃ§Ã£o. Quando um computed Ã© lido, ele verifica se alguma de suas dependÃªncias registradas anteriormente mudou e se reavalia se for o caso. Quando mÃºltiplos Signals computados sÃ£o aninhados, toda a atribuiÃ§Ã£o do rastreamento vai para o mais interno deles.

Signals computados sÃ£o lazy, ou seja, baseados em pull: eles sÃ³ sÃ£o reavaliados quando sÃ£o acessados, mesmo que uma de suas dependÃªncias tenha mudado antes.

O callback passado para Signals computados geralmente deve ser "puro", no sentido de ser uma funÃ§Ã£o determinÃ­stica e sem efeitos colaterais dos outros Signals que acessa. Ao mesmo tempo, o momento em que o callback Ã© chamado Ã© determinÃ­stico, permitindo que efeitos colaterais sejam usados com cuidado.

Signals possuem cache/memoizaÃ§Ã£o proeminente: tanto Signals de state quanto computados lembram seu valor atual, e sÃ³ disparam recÃ¡lculo de Signals computados que os referenciam se eles realmente mudarem. Uma comparaÃ§Ã£o repetida entre valores antigos e novos nem Ã© necessÃ¡riaâ€”a comparaÃ§Ã£o Ã© feita uma vez quando o Signal fonte Ã© redefinido/reavaliado, e o mecanismo do Signal mantÃ©m o controle de quais entidades que referenciam aquele Signal ainda nÃ£o atualizaram com base no novo valor. Internamente, isso geralmente Ã© representado por "graph coloring", como descrito no [post do blog do Milo](https://raw.githubusercontent.com/tc39/proposal-signals/main/Milo%27s%20blog%20post).

Signals computados rastreiam suas dependÃªncias dinamicamenteâ€”cada vez que sÃ£o executados, podem acabar dependendo de coisas diferentes, e esse conjunto de dependÃªncias preciso Ã© mantido atualizado no grafo de Signals. Isso significa que, se vocÃª tem uma dependÃªncia necessÃ¡ria em apenas um ramo, e o cÃ¡lculo anterior tomou o outro ramo, entÃ£o uma mudanÃ§a nesse valor temporariamente nÃ£o usado nÃ£o farÃ¡ com que o Signal computado seja recalculado, mesmo quando acessado.

Diferente de Promises do JavaScript, tudo em Signals Ã© executado de forma sÃ­ncrona:
- Definir um Signal para um novo valor Ã© sÃ­ncrono, e isso Ã© refletido imediatamente ao ler qualquer Signal computado que dependa dele em seguida. NÃ£o hÃ¡ agrupamento/batching embutido nessa mutaÃ§Ã£o.
- Ler Signals computados Ã© sÃ­ncronoâ€”seu valor estÃ¡ sempre disponÃ­vel.
- O callback `notify` em Watchers, como explicado abaixo, roda de forma sÃ­ncrona, durante a chamada `.set()` que o disparou (mas apÃ³s a coloraÃ§Ã£o do grafo estar completa).

Como as Promises, Signals podem representar um estado de erro: se o callback de um Signal computado lanÃ§ar uma exceÃ§Ã£o, esse erro Ã© armazenado em cache como qualquer outro valor, e relanÃ§ado toda vez que o Signal Ã© lido.

### Entendendo a classe Signal

Uma instÃ¢ncia de `Signal` representa a capacidade de ler um valor que muda dinamicamente e cujas atualizaÃ§Ãµes sÃ£o rastreadas ao longo do tempo. Ela tambÃ©m implicitamente inclui a capacidade de se inscrever no Signal, implicitamente por meio de um acesso rastreado de outro Signal computado.

A API aqui foi desenhada para corresponder ao consenso da comunidade entre grande parte das bibliotecas de Signal no uso de nomes como "signal", "computed" e "state". Entretanto, o acesso a Signals Computados e de State Ã© feito por meio do mÃ©todo `.get()`, o que difere de todas as APIs populares de Signal, que usam um acessor `.value` ou sintaxe de chamada `signal()`.

A API Ã© projetada para reduzir o nÃºmero de alocaÃ§Ãµes, tornando Signals adequados para serem incorporados em frameworks JavaScript, alcanÃ§ando desempenho igual ou melhor que Signals personalizados de frameworks existentes. Isso implica:
- Signals de State sÃ£o um Ãºnico objeto gravÃ¡vel, que pode ser tanto acessado quanto definido a partir da mesma referÃªncia. (Veja implicaÃ§Ãµes abaixo na seÃ§Ã£o "SeparaÃ§Ã£o de capacidades".)
- Tanto Signals de State quanto Computados sÃ£o projetados para serem subclassificados, facilitando que frameworks adicionem propriedades adicionais por meio de campos de classe pÃºblicos e privados (bem como mÃ©todos para usar esse estado).
- VÃ¡rios callbacks (por exemplo, `equals`, o callback de computed) sÃ£o chamados com o Signal relevante como valor de `this` para contexto, de modo que nÃ£o Ã© necessÃ¡rio criar um novo closure por Signal. Em vez disso, o contexto pode ser salvo em propriedades extras do prÃ³prio Signal.

Algumas condiÃ§Ãµes de erro aplicadas por esta API:
- Ã‰ um erro ler um computed recursivamente.
- O callback `notify` de um Watcher nÃ£o pode ler nem escrever nenhum signal.
- Se o callback de um Signal computado lanÃ§ar uma exceÃ§Ã£o, acessos subsequentes ao Signal relanÃ§am esse erro armazenado em cache, atÃ© que uma das dependÃªncias mude e ele seja recalculado.

Algumas condiÃ§Ãµes que *nÃ£o* sÃ£o aplicadas:
- Signals Computados podem escrever em outros Signals, de forma sÃ­ncrona dentro do seu callback.
- Trabalhos enfileirados pelo callback `notify` de um Watcher podem ler ou escrever signals, tornando possÃ­vel replicar [antipadrÃµes clÃ¡ssicos do React](https://react.dev/learn/you-might-not-need-an-effect) em termos de Signals!

### Implementando efeitos

A interface `Watcher` definida acima dÃ¡ a base para implementar APIs JS tÃ­picas para efeitos: callbacks que sÃ£o executados novamente quando outros Signals mudam, apenas por seu efeito colateral. A funÃ§Ã£o `effect` usada acima no exemplo inicial pode ser definida da seguinte forma:

```ts
// Esta funÃ§Ã£o normalmente viveria em uma biblioteca/framework, nÃ£o no cÃ³digo da aplicaÃ§Ã£o
// NOTA: Esta lÃ³gica de agendamento Ã© bÃ¡sica demais para ser Ãºtil. NÃ£o copie/cole.
let pending = false;

let w = new Signal.subtle.Watcher(() => {
    if (!pending) {
        pending = true;
        queueMicrotask(() => {
            pending = false;
            for (let s of w.getPending()) s.get();
            w.watch();
        });
    }
});

// Um Signal effect que avalia cb, que agenda uma leitura de
// si mesmo na fila de microtarefas sempre que uma de suas dependÃªncias pode mudar
export function effect(cb) {
    let destructor;
    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });
    w.watch(c);
    c.get();
    return () => { destructor?.(); w.unwatch(c) };
}
```

A API do Signal nÃ£o inclui nenhuma funÃ§Ã£o embutida como `effect`. Isso ocorre porque o agendamento de efeitos Ã© sutil e frequentemente se integra aos ciclos de renderizaÃ§Ã£o do framework e a outros estados ou estratÃ©gias especÃ­ficas de frameworks de alto nÃ­vel aos quais o JS nÃ£o tem acesso.

Percorrendo as diferentes operaÃ§Ãµes usadas aqui: o callback `notify` passado ao construtor de `Watcher` Ã© a funÃ§Ã£o chamada quando o Signal vai de um estado "clean" (onde sabemos que o cache estÃ¡ inicializado e vÃ¡lido) para um estado "checked" ou "dirty" (onde o cache pode ou nÃ£o ser vÃ¡lido porque pelo menos um dos estados dos quais depende recursivamente foi alterado).

Chamadas a `notify` sÃ£o, em Ãºltima instÃ¢ncia, disparadas por uma chamada a `.set()` em algum Signal de state. Essa chamada Ã© sÃ­ncrona: acontece antes de `.set` retornar. Mas nÃ£o hÃ¡ necessidade de se preocupar com esse callback observando o grafo de Signal em um estado parcialmente processado, porque durante um callback `notify`, nenhum Signal pode ser lido ou escrito, mesmo em uma chamada `untrack`. Como `notify` Ã© chamado durante `.set()`, ele interrompe outro fluxo de lÃ³gica, que pode nÃ£o estar completo. Para ler ou escrever Signals a partir de `notify`, agende o trabalho para rodar depois, por exemplo, escrevendo o Signal em uma lista para ser acessado posteriormente, ou com `queueMicrotask` como acima.

Note que Ã© perfeitamente possÃ­vel usar Signals de maneira eficaz sem `Signal.subtle.Watcher` ao agendar polling de Signals computados, como faz o Glimmer. Entretanto, muitos frameworks descobriram que Ã© frequentemente Ãºtil ter essa lÃ³gica de agendamento rodando de forma sÃ­ncrona, entÃ£o a API de Signals inclui isso.

Tanto Signals computados quanto de state sÃ£o coletados pelo garbage collector como qualquer valor JS. Mas Watchers tÃªm uma maneira especial de manter as coisas vivas: qualquer Signal observado por um Watcher serÃ¡ mantido vivo enquanto qualquer um dos estados subjacentes for acessÃ­vel, pois estes podem disparar uma futura chamada `notify` (e entÃ£o uma futura `.get()`). Por essa razÃ£o, lembre-se de chamar `Watcher.prototype.unwatch` para limpar efeitos.

### Um escape hatch nÃ£o seguro

`Signal.subtle.untrack` Ã© um escape hatch que permite ler Signals *sem* rastrear essas leituras. Essa capacidade Ã© insegura porque permite a criaÃ§Ã£o de Signals computados cujo valor depende de outros Signals, mas que nÃ£o sÃ£o atualizados quando esses Signals mudam. Deve ser usado quando os acessos nÃ£o rastreados nÃ£o irÃ£o alterar o resultado do cÃ¡lculo.

<!--
TODO: Mostrar exemplo onde faz sentido usar untrack

### Usando watched/unwatched
TODO: Mostrar exemplo de conversÃ£o de um Observable para um sinal computado, inscrito apenas quando usado por um efeito

TODO: Mostrar exemplo de um sinal computado que representa o resultado de um fetch direcionado a um estado, que Ã© cancelado

### IntrospecÃ§Ã£o para SSR

TODO: Mostrar como funciona a serializaÃ§Ã£o do grafo de sinais

TODO: Mostrar como vocÃª pode "hidratar" um sinal de estado para computado depois, usando alguns sinais.
-->

### Omitido por enquanto

Esses recursos podem ser adicionados posteriormente, mas nÃ£o estÃ£o incluÃ­dos no rascunho atual. Sua omissÃ£o se deve Ã  falta de consenso estabelecido no espaÃ§o de design entre frameworks, bem como Ã  capacidade demonstrada de contornar sua ausÃªncia com mecanismos baseados na noÃ§Ã£o de Sinais descrita neste documento. No entanto, infelizmente, a omissÃ£o limita o potencial de interoperabilidade entre frameworks. Ã€ medida que protÃ³tipos de Sinais, conforme descrito neste documento, forem produzidos, haverÃ¡ um esforÃ§o para reexaminar se essas omissÃµes foram a decisÃ£o adequada.

* **AssÃ­ncrono**: Os sinais estÃ£o sempre disponÃ­veis para avaliaÃ§Ã£o de forma sÃ­ncrona, neste modelo. No entanto, Ã© frequentemente Ãºtil ter certos processos assÃ­ncronos que levam a um sinal ser definido, e entender quando um sinal ainda estÃ¡ "carregando". Uma maneira simples de modelar o estado de carregamento Ã© com exceÃ§Ãµes, e o comportamento de cache de exceÃ§Ãµes dos sinais computados compÃµe razoavelmente com essa tÃ©cnica. TÃ©cnicas aprimoradas sÃ£o discutidas na [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).
* **TransaÃ§Ãµes**: Para transiÃ§Ãµes entre visualizaÃ§Ãµes, muitas vezes Ã© Ãºtil manter um estado ativo tanto para o estado "de" quanto para o "para". O estado "para" Ã© renderizado em segundo plano, atÃ© que esteja pronto para a troca (cometendo a transaÃ§Ã£o), enquanto o estado "de" permanece interativo. Manter ambos os estados ao mesmo tempo requer "forkar" o estado do grafo de sinais, e pode atÃ© ser Ãºtil suportar mÃºltiplas transiÃ§Ãµes pendentes ao mesmo tempo. DiscussÃ£o em [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).

Alguns possÃ­veis [mÃ©todos de conveniÃªncia](https://github.com/proposal-signals/proposal-signals/issues/32) tambÃ©m foram omitidos.

## Status e plano de desenvolvimento

Esta proposta estÃ¡ na agenda do TC39 de abril de 2024 para o EstÃ¡gio 1. Atualmente, pode ser considerada como "EstÃ¡gio 0".

[Um polyfill](https://github.com/proposal-signals/signal-polyfill) para esta proposta estÃ¡ disponÃ­vel, com alguns testes bÃ¡sicos. Alguns autores de frameworks comeÃ§aram a experimentar a substituiÃ§Ã£o desta implementaÃ§Ã£o de sinal, mas esse uso estÃ¡ em estÃ¡gio inicial.

Os colaboradores da proposta de Sinais querem ser especialmente **conservadores** em como avanÃ§am com esta proposta, para evitar cair na armadilha de aprovar algo que acabaremos nos arrependendo e nÃ£o usando de fato. Nosso plano Ã© realizar as seguintes tarefas extras, nÃ£o exigidas pelo processo do TC39, para garantir que esta proposta estÃ¡ no caminho certo:

Antes de propor para o EstÃ¡gio 2, planejamos:
- Desenvolver mÃºltiplas implementaÃ§Ãµes de polyfill de nÃ­vel de produÃ§Ã£o que sejam sÃ³lidas, bem testadas (por exemplo, passando testes de vÃ¡rios frameworks, bem como testes do estilo test262) e competitivas em termos de desempenho (como verificado com um conjunto abrangente de benchmarks de sinais/frameworks).
- Integrar a API de Sinais proposta em um grande nÃºmero de frameworks JS que consideramos representativos, e fazer com que algumas aplicaÃ§Ãµes grandes funcionem com essa base. Testar se ela funciona de forma eficiente e correta nesses contextos.
- Ter uma compreensÃ£o sÃ³lida do espaÃ§o de possÃ­veis extensÃµes da API, e concluir quais (se houver) devem ser adicionadas a esta proposta.

## Algoritmos de Sinal

Esta seÃ§Ã£o descreve cada uma das APIs expostas ao JavaScript, em termos dos algoritmos que implementam. Isso pode ser considerado como uma proto-especificaÃ§Ã£o, e estÃ¡ incluÃ­do neste ponto inicial para definir um possÃ­vel conjunto de semÃ¢nticas, estando muito aberto a mudanÃ§as.

Alguns aspectos do algoritmo:
- A ordem de leitura dos Sinais dentro de um computado Ã© significativa e Ã© observÃ¡vel na ordem em que certos callbacks (quando `Watcher` Ã© invocado, `equals`, o primeiro parÃ¢metro para `new Signal.Computed` e os callbacks `watched`/`unwatched`) sÃ£o executados. Isso significa que as fontes de um Sinal computado devem ser armazenadas ordenadas.
- Esses quatro callbacks podem lanÃ§ar exceÃ§Ãµes, e essas exceÃ§Ãµes sÃ£o propagadas de maneira previsÃ­vel para o cÃ³digo JS chamador. As exceÃ§Ãµes *nÃ£o* interrompem a execuÃ§Ã£o deste algoritmo nem deixam o grafo em um estado parcialmente processado. Para erros lanÃ§ados no callback `notify` de um Watcher, essa exceÃ§Ã£o Ã© enviada para a chamada `.set()` que a acionou, usando um AggregateError se vÃ¡rias exceÃ§Ãµes forem lanÃ§adas. As outras (incluindo `watched`/`unwatched`?) sÃ£o armazenadas no valor do Sinal, para serem relanÃ§adas quando lidas, e tal Sinal relanÃ§ado pode ser marcado como `~clean~` assim como qualquer outro com um valor normal.
- Cuidados sÃ£o tomados para evitar circularidades em casos de sinais computados que nÃ£o sÃ£o "observados" (sendo observados por algum Watcher), para que possam ser coletados pelo garbage collector de forma independente de outras partes do grafo de sinais. Internamente, isso pode ser implementado com um sistema de nÃºmeros de geraÃ§Ã£o que sÃ£o sempre coletados; observe que implementaÃ§Ãµes otimizadas tambÃ©m podem incluir nÃºmeros de geraÃ§Ã£o locais por nÃ³, ou evitar rastrear alguns nÃºmeros em sinais observados.

### Estado global oculto

Os algoritmos de Sinal precisam referenciar certos estados globais. Esse estado Ã© global para toda a thread, ou "agente".

- `computing`: O Sinal computado ou de efeito mais interno atualmente sendo reavaliado devido a uma chamada `.get` ou `.run`, ou `null`. Inicialmente `null`.
- `frozen`: Booleano que denota se hÃ¡ um callback atualmente em execuÃ§Ã£o que exige que o grafo nÃ£o seja modificado. Inicialmente `false`.
- `generation`: Um inteiro incremental, comeÃ§ando em 0, usado para rastrear quÃ£o atual Ã© um valor enquanto evita circularidades.

### O namespace `Signal`

`Signal` Ã© um objeto comum que serve como um namespace para classes e funÃ§Ãµes relacionadas a Sinais.

`Signal.subtle` Ã© um objeto de namespace interno semelhante.

### A classe `Signal.State`

#### Slots internos de `Signal.State`

- `value`: O valor atual do sinal de estado
- `equals`: A funÃ§Ã£o de comparaÃ§Ã£o usada ao alterar valores
- `watched`: O callback chamado quando o sinal passa a ser observado por um efeito
- `unwatched`: O callback chamado quando o sinal deixa de ser observado por um efeito
- `sinks`: Conjunto de sinais observados que dependem deste

#### Construtor: `Signal.State(initialValue, options)`

1. Defina o `value` deste Sinal como `initialValue`.
1. Defina o `equals` deste Sinal como options?.equals
1. Defina o `watched` deste Sinal como options?.[Signal.subtle.watched]
1. Defina o `unwatched` deste Sinal como options?.[Signal.subtle.unwatched]
1. Defina o `sinks` deste Sinal como o conjunto vazio

#### MÃ©todo: `Signal.State.prototype.get()`

1. Se `frozen` for true, lance uma exceÃ§Ã£o.
1. Se `computing` nÃ£o for `undefined`, adicione este Sinal ao conjunto `sources` de `computing`.
1. NOTA: NÃ£o adicionamos `computing` ao conjunto `sinks` deste Sinal atÃ© que ele seja observado por um Watcher.
1. Retorne o `value` deste Sinal.

#### MÃ©todo: `Signal.State.prototype.set(newValue)`

1. Se o contexto de execuÃ§Ã£o atual for `frozen`, lance uma exceÃ§Ã£o.
1. Execute o algoritmo "definir valor do Sinal" com este Sinal e o primeiro parÃ¢metro para o valor.
1. Se esse algoritmo retornar `~clean~`, entÃ£o retorne undefined.
1. Defina o `state` de todos os `sinks` deste Sinal como (se for um Sinal Computado) `~dirty~` se estavam previamente clean, ou (se for um Watcher) `~pending~` se estava previamente `~watching~`.
1. Defina o `state` de todas as dependÃªncias de Sinal Computado dos sinks (recursivamente) como `~checked~` se estavam previamente `~clean~` (ou seja, mantenha as marcaÃ§Ãµes de dirty), ou para Watchers, `~pending~` se previamente `~watching~`.
1. Para cada Watcher previamente `~watching~` encontrado nessa busca recursiva, em ordem de profundidade,
    1. Defina `frozen` como true.
    1. Chame seu callback `notify` (salvando separadamente qualquer exceÃ§Ã£o lanÃ§ada, mas ignorando o valor de retorno de `notify`).
    1. Restaure `frozen` para false.
    1. Defina o `state` do Watcher para `~waiting~`.
1. Se alguma exceÃ§Ã£o foi lanÃ§ada dos callbacks `notify`, propague-a para o chamador apÃ³s todos os callbacks `notify` terem sido executados. Se houver mÃºltiplas exceÃ§Ãµes, agrupe-as em um AggregateError e lance-o.
1. Retorne undefined.

### A classe `Signal.Computed`

#### MÃ¡quina de estados de `Signal.Computed`
O `state` de um Computed Signal pode ser um dos seguintes:

- `~clean~`: O valor do Signal estÃ¡ presente e sabe-se que nÃ£o estÃ¡ desatualizado.
- `~checked~`: Uma fonte (indireta) deste Signal foi alterada; este Signal tem um valor, mas ele _pode_ estar desatualizado. SÃ³ serÃ¡ possÃ­vel saber se estÃ¡ desatualizado quando todas as fontes imediatas forem avaliadas.
- `~computing~`: O callback deste Signal estÃ¡ sendo executado atualmente como efeito colateral de uma chamada `.get()`.
- `~dirty~`: Ou este Signal tem um valor que se sabe estar desatualizado, ou nunca foi avaliado.

O grafo de transiÃ§Ã£o Ã© o seguinte:

```mermaid
stateDiagram-v2
    [*] --> dirty
    dirty --> computing: [4]
    computing --> clean: [5]
    clean --> dirty: [2]
    clean --> checked: [3]
    checked --> clean: [6]
    checked --> dirty: [1]
```

As transiÃ§Ãµes sÃ£o:
| NÃºmero | De | Para | CondiÃ§Ã£o | Algoritmo |
| ------ | ---- | -- | --------- | --------- |
| 1 | `~checked~` | `~dirty~` | Uma fonte imediata deste signal, que Ã© um computed signal, foi avaliada e seu valor foi alterado. | Algoritmo: recalcular Signal computado dirty |
| 2 | `~clean~` | `~dirty~` | Uma fonte imediata deste signal, que Ã© um State, foi definida com um valor diferente do anterior. | MÃ©todo: `Signal.State.prototype.set(newValue)` |
| 3 | `~clean~` | `~checked~` | Uma fonte recursiva, mas nÃ£o imediata, deste signal, que Ã© um State, foi definida com um valor diferente do anterior. | MÃ©todo: `Signal.State.prototype.set(newValue)` |
| 4 | `~dirty~` | `~computing~` | Estamos prestes a executar o `callback`. | Algoritmo: recalcular Signal computado dirty |
| 5 | `~computing~` | `~clean~` | O `callback` terminou de ser avaliado e retornou um valor ou lanÃ§ou uma exceÃ§Ã£o. | Algoritmo: recalcular Signal computado dirty |
| 6 | `~checked~` | `~clean~` | Todas as fontes imediatas deste signal foram avaliadas e todas permaneceram inalteradas, entÃ£o agora sabemos que nÃ£o estÃ¡ desatualizado. | Algoritmo: recalcular Signal computado dirty |

#### Slots internos de `Signal.Computed`

- `value`: O valor em cache anterior do Signal, ou `~uninitialized~` para um Signal computado nunca lido. O valor pode ser uma exceÃ§Ã£o que Ã© relanÃ§ada quando o valor Ã© lido. Sempre `undefined` para effect signals.
- `state`: Pode ser `~clean~`, `~checked~`, `~computing~` ou `~dirty~`.
- `sources`: Um conjunto ordenado de Signals dos quais este Signal depende.
- `sinks`: Um conjunto ordenado de Signals que dependem deste Signal.
- `equals`: O mÃ©todo equals fornecido nas opÃ§Ãµes.
- `callback`: O callback chamado para obter o valor do Signal computado. Definido como o primeiro parÃ¢metro passado ao construtor.

#### Construtor de `Signal.Computed`

O construtor define
- `callback` como seu primeiro parÃ¢metro
- `equals` com base nas opÃ§Ãµes, padrÃ£o para `Object.is` se ausente
- `state` para `~dirty~`
- `value` para `~uninitialized~`

Com [AsyncContext](https://github.com/tc39/proposal-async-context), o callback passado para `new Signal.Computed` fecha sobre o snapshot do momento em que o construtor foi chamado, e restaura esse snapshot durante sua execuÃ§Ã£o.

#### MÃ©todo: `Signal.Computed.prototype.get`

1. Se o contexto de execuÃ§Ã£o atual estÃ¡ `frozen` ou se este Signal estÃ¡ no estado `~computing~`, ou se este signal Ã© um Watcher e estÃ¡ `computing` um Signal computado, lance uma exceÃ§Ã£o.
1. Se `computing` nÃ£o for `null`, adicione este Signal ao conjunto `sources` de `computing`.
1. NOTA: NÃ£o adicionamos `computing` ao conjunto `sinks` deste Signal atÃ© que ele seja observado por um Watcher.
1. Se o estado deste Signal for `~dirty~` ou `~checked~`: Repita os passos a seguir atÃ© que este Signal esteja `~clean~`:
    1. Recursivamente, suba via `sources` para encontrar a fonte recursiva mais profunda e Ã  esquerda (ou seja, a primeira observada) que seja um Computed Signal marcado como `~dirty~` (interrompendo a busca ao encontrar um Computed Signal `~clean~` e incluindo este Computed Signal como o Ãºltimo a ser buscado).
    1. Execute o algoritmo "recalcular Signal computado dirty" naquele Signal.
1. Neste ponto, o estado deste Signal serÃ¡ `~clean~` e nenhuma fonte recursiva estarÃ¡ `~dirty~` ou `~checked~`. Retorne o `value` do Signal. Se o valor for uma exceÃ§Ã£o, relance essa exceÃ§Ã£o.

### A classe `Signal.subtle.Watcher`

#### MÃ¡quina de estados de `Signal.subtle.Watcher`

O `state` de um Watcher pode ser um dos seguintes:

- `~waiting~`: O callback `notify` foi executado, ou o Watcher Ã© novo, mas nÃ£o estÃ¡ observando ativamente nenhum signal.
- `~watching~`: O Watcher estÃ¡ observando ativamente signals, mas nenhuma alteraÃ§Ã£o ocorreu que necessite de um callback `notify`.
- `~pending~`: Uma dependÃªncia do Watcher foi alterada, mas o callback `notify` ainda nÃ£o foi executado.

O grafo de transiÃ§Ã£o Ã© o seguinte:

```mermaid
stateDiagram-v2
    [*] --> waiting
    waiting --> watching: [1]
    watching --> waiting: [2]
    watching --> pending: [3]
    pending --> waiting: [4]
```

As transiÃ§Ãµes sÃ£o:
| NÃºmero | De | Para | CondiÃ§Ã£o | Algoritmo |
| ------ | ---- | -- | --------- | --------- |
| 1 | `~waiting~` | `~watching~` | O mÃ©todo `watch` do Watcher foi chamado. | MÃ©todo: `Signal.subtle.Watcher.prototype.watch(...signals)` |
| 2 | `~watching~` | `~waiting~` | O mÃ©todo `unwatch` do Watcher foi chamado e o Ãºltimo signal observado foi removido. | MÃ©todo: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |
| 3 | `~watching~` | `~pending~` | Um signal observado pode ter tido seu valor alterado. | MÃ©todo: `Signal.State.prototype.set(newValue)` |
| 4 | `~pending~` | `~waiting~` | O callback `notify` foi executado. | MÃ©todo: `Signal.State.prototype.set(newValue)` |

#### Slots internos de `Signal.subtle.Watcher`

- `state`: Pode ser `~watching~`, `~pending~` ou `~waiting~`
- `signals`: Um conjunto ordenado de Signals que este Watcher estÃ¡ observando
- `notifyCallback`: O callback chamado quando algo muda. Definido como o primeiro parÃ¢metro passado ao construtor.

#### Construtor: `new Signal.subtle.Watcher(callback)`

1. `state` Ã© definido como `~waiting~`.
1. Inicialize `signals` como um conjunto vazio.
1. `notifyCallback` Ã© definido como o parÃ¢metro callback.
Com [AsyncContext](https://github.com/tc39/proposal-async-context), o callback passado para `new Signal.subtle.Watcher` *nÃ£o* encerra o snapshot do momento em que o construtor foi chamado, para que informaÃ§Ãµes contextuais ao redor da gravaÃ§Ã£o fiquem visÃ­veis.

#### MÃ©todo: `Signal.subtle.Watcher.prototype.watch(...signals)`

1. Se `frozen` for true, lance uma exceÃ§Ã£o.
1. Se algum dos argumentos nÃ£o for um sinal, lance uma exceÃ§Ã£o.
1. Adicione todos os argumentos ao final do `signals` deste objeto.
1. Para cada sinal recÃ©m-observado, da esquerda para a direita,
    1. Adicione este watcher como um `sink` para esse sinal.
    1. Se este foi o primeiro sink, entÃ£o faÃ§a a recursÃ£o atÃ© as sources para adicionar esse sinal como sink.
    1. Defina `frozen` como true.
    1. Chame o callback `watched` se existir.
    1. Restaure `frozen` para false.
1. Se o `state` do Signal for `~waiting~`, entÃ£o defina como `~watching~`.

#### MÃ©todo: `Signal.subtle.Watcher.prototype.unwatch(...signals)`

1. Se `frozen` for true, lance uma exceÃ§Ã£o.
1. Se algum dos argumentos nÃ£o for um sinal, ou nÃ£o estiver sendo observado por este watcher, lance uma exceÃ§Ã£o.
1. Para cada sinal nos argumentos, da esquerda para a direita,
    1. Remova esse sinal do conjunto `signals` deste Watcher.
    1. Remova este Watcher do conjunto `sink` deste Signal.
    1. Se o conjunto `sink` desse Signal ficou vazio, remova esse Signal como sink de cada uma de suas sources.
    1. Defina `frozen` como true.
    1. Chame o callback `unwatched` se existir.
    1. Restaure `frozen` para false.
1. Se o watcher agora nÃ£o tiver `signals` e seu `state` for `~watching~`, entÃ£o defina como `~waiting~`.

#### MÃ©todo: `Signal.subtle.Watcher.prototype.getPending()`

1. Retorne um Array contendo o subconjunto de `signals` que sÃ£o Computed Signals nos estados `~dirty~` ou `~pending~`.

### MÃ©todo: `Signal.subtle.untrack(cb)`

1. Deixe `c` ser o estado atual de `computing` do contexto de execuÃ§Ã£o.
1. Defina `computing` como null.
1. Chame `cb`.
1. Restaure `computing` para `c` (mesmo se `cb` lanÃ§ar uma exceÃ§Ã£o).
1. Retorne o valor de retorno de `cb` (relanÃ§ando qualquer exceÃ§Ã£o).

Nota: untrack nÃ£o tira vocÃª do estado `frozen`, que Ã© mantido estritamente.

### MÃ©todo: `Signal.subtle.currentComputed()`

1. Retorne o valor atual de `computing`.

### Algoritmos comuns

##### Algoritmo: recalcular um Signal computed dirty

1. Limpe o conjunto `sources` deste Signal e remova-o dos conjuntos `sinks` dessas sources.
1. Salve o valor anterior de `computing` e defina `computing` como este Signal.
1. Defina o estado deste Signal como `~computing~`.
1. Execute o callback deste computed Signal, usando este Signal como valor de this. Salve o valor de retorno e, se o callback lanÃ§ar uma exceÃ§Ã£o, armazene-a para relanÃ§ar.
1. Restaure o valor anterior de `computing`.
1. Aplique o algoritmo "set Signal value" ao valor de retorno do callback.
2. Defina o estado deste Signal como `~clean~`.
1. Se esse algoritmo retornou `~dirty~`: marque todos os sinks deste Signal como `~dirty~` (anteriormente, os sinks poderiam estar misturados entre checked e dirty). (Ou, se este nÃ£o estiver sendo observado, entÃ£o adote um novo nÃºmero de geraÃ§Ã£o para indicar dirty, ou algo assim.)
1. Caso contrÃ¡rio, se o algoritmo retornou `~clean~`: nesse caso, para cada sink `~checked~` deste Signal, se todas as sources desse Signal agora estiverem limpas, entÃ£o marque esse Signal como `~clean~` tambÃ©m. Aplique essa etapa de limpeza recursivamente para sinks adicionais, para quaisquer Signals recÃ©m-limpos que tenham sinks checked. (Ou, se este nÃ£o estiver sendo observado, indique o mesmo de alguma forma, para que a limpeza possa ser feita de forma preguiÃ§osa.)

##### Algoritmo de atribuiÃ§Ã£o de valor do Signal

1. Se este algoritmo recebeu um valor (ao contrÃ¡rio de uma exceÃ§Ã£o para ser relanÃ§ada, do algoritmo de recalcular computed Signal dirty):
    1. Chame a funÃ§Ã£o `equals` deste Signal, passando como parÃ¢metros o valor atual, o novo valor e este Signal. Se uma exceÃ§Ã£o for lanÃ§ada, salve essa exceÃ§Ã£o (para relanÃ§ar quando lido) como o valor do Signal e continue como se o callback tivesse retornado false.
    1. Se essa funÃ§Ã£o retornar true, retorne `~clean~`.
1. Defina o `value` deste Signal como o parÃ¢metro.
1. Retorne `~dirty~`

## FAQ

**P**: NÃ£o Ã© um pouco cedo para padronizar algo relacionado a Signals, quando eles acabaram de se tornar populares em 2022? NÃ£o deverÃ­amos dar mais tempo para evoluÃ­rem e se estabilizarem?

**R**: O estado atual dos Signals em frameworks web Ã© resultado de mais de 10 anos de desenvolvimento contÃ­nuo. Ã€ medida que o investimento aumentou, como tem acontecido nos Ãºltimos anos, quase todos os frameworks web estÃ£o convergindo para um modelo central muito semelhante de Signals. Esta proposta Ã© resultado de um exercÃ­cio de design compartilhado entre um grande nÃºmero de lÃ­deres atuais em frameworks web, e nÃ£o avanÃ§arÃ¡ para padronizaÃ§Ã£o sem a validaÃ§Ã£o desse grupo de especialistas em diferentes contextos.

#### Como os Signals sÃ£o usados?

**P**: Signals nativos podem ser usados por frameworks, considerando sua integraÃ§Ã£o estreita com renderizaÃ§Ã£o e propriedade?

**R**: As partes mais especÃ­ficas de frameworks tendem a estar na Ã¡rea de efeitos, agendamento e propriedade/eliminaÃ§Ã£o, que esta proposta nÃ£o tenta resolver. Nossa prioridade inicial ao prototipar Signals no padrÃ£o Ã© validar que eles podem funcionar "por baixo" dos frameworks existentes de forma compatÃ­vel e com bom desempenho.

**P**: A API de Signal foi projetada para ser usada diretamente por desenvolvedores de aplicaÃ§Ãµes, ou envolvida por frameworks?

**R**: Embora esta API possa ser usada diretamente por desenvolvedores de aplicaÃ§Ãµes (pelo menos a parte que nÃ£o estÃ¡ no namespace `Signal.subtle`), ela nÃ£o foi projetada para ser especialmente ergonÃ´mica. Em vez disso, as necessidades de autores de bibliotecas/frameworks sÃ£o prioridade. Espera-se que a maioria dos frameworks envolva atÃ© mesmo as APIs bÃ¡sicas de `Signal.State` e `Signal.Computed` com algo que expresse sua abordagem ergonÃ´mica. Na prÃ¡tica, normalmente Ã© melhor usar Signals por meio de um framework, que gerencia recursos mais complexos (por exemplo, Watcher, `untrack`), bem como gerenciamento de propriedade e eliminaÃ§Ã£o (por exemplo, decidir quando os signals devem ser adicionados e removidos de watchers) e agendamento de renderizaÃ§Ã£o para o DOM â€” esta proposta nÃ£o tenta resolver esses problemas.

**P**: Preciso desmontar Signals relacionados a um widget quando esse widget Ã© destruÃ­do? Qual Ã© a API para isso?

**R**: A operaÃ§Ã£o de desmontagem relevante aqui Ã© `Signal.subtle.Watcher.prototype.unwatch`. Apenas Signals observados precisam ser limpos (desobservados), enquanto Signals nÃ£o observados podem ser coletados automaticamente pelo garbage collector.

**P**: Signals funcionam com VDOM ou diretamente com o DOM HTML subjacente?

**R**: Sim! Signals sÃ£o independentes da tecnologia de renderizaÃ§Ã£o. Frameworks JavaScript existentes que usam construÃ§Ãµes semelhantes a Signals integram-se com VDOM (por exemplo, Preact), DOM nativo (por exemplo, Solid) e uma combinaÃ§Ã£o (por exemplo, Vue). O mesmo serÃ¡ possÃ­vel com Signals nativos.

**P**: SerÃ¡ ergonÃ´mico usar Signals no contexto de frameworks baseados em classes como Angular e Lit? E quanto a frameworks baseados em compilador, como Svelte?

**R**: Campos de classe podem ser baseados em Signal com um simples decorator de acessor, como mostrado no [readme do polyfill de Signal](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals estÃ£o muito alinhados com as Runes do Svelte 5 â€” Ã© simples para um compilador transformar runes na API de Signal definida aqui, e de fato Ã© isso que o Svelte 5 faz internamente (mas com sua prÃ³pria biblioteca de Signals).

**P**: Signals funcionam com SSR? HidrataÃ§Ã£o? Resumibilidade?

**R**: Sim. Qwik usa Signals com bons resultados em ambas as propriedades, e outros frameworks tÃªm abordagens bem desenvolvidas para hidrataÃ§Ã£o com Signals e diferentes trade-offs. Achamos que Ã© possÃ­vel modelar os Signals resumÃ­veis do Qwik usando um State e um Computed signal conectados, e planejamos provar isso em cÃ³digo.
**Q**: Os Signals funcionam com fluxo de dados unidirecional, como o React?

**A**: Sim, Signals sÃ£o um mecanismo para fluxo de dados unidirecional. Frameworks de UI baseados em Signals permitem que vocÃª expresse sua visualizaÃ§Ã£o como uma funÃ§Ã£o do modelo (onde o modelo incorpora Signals). Um grafo de estado e Signals computados Ã© acÃ­clico por construÃ§Ã£o. TambÃ©m Ã© possÃ­vel recriar antipadrÃµes do React dentro dos Signals (!), por exemplo, o equivalente ao `setState` dentro do `useEffect` Ã© usar um Watcher para agendar uma escrita em um Signal de estado.

**Q**: Como os signals se relacionam com sistemas de gerenciamento de estado como Redux? Signals incentivam estado nÃ£o estruturado?

**A**: Signals podem formar uma base eficiente para abstraÃ§Ãµes de gerenciamento de estado semelhantes a stores. Um padrÃ£o comum encontrado em vÃ¡rios frameworks Ã© um objeto baseado em Proxy que internamente representa propriedades usando Signals, por exemplo, [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), ou [Solid stores](https://docs.solidjs.com/concepts/stores). Esses sistemas permitem o agrupamento flexÃ­vel do estado no nÃ­vel certo de abstraÃ§Ã£o para a aplicaÃ§Ã£o em questÃ£o.

**Q**: O que os Signals oferecem que o `Proxy` atualmente nÃ£o lida?

**A**: Proxies e Signals sÃ£o complementares e funcionam bem juntos. Proxies permitem interceptar operaÃ§Ãµes superficiais de objeto e signals coordenam um grafo de dependÃªncias (de cÃ©lulas). Usar um Proxy respaldado por Signals Ã© uma Ã³tima maneira de criar uma estrutura reativa aninhada com excelente ergonomia.

Neste exemplo, podemos usar um proxy para fazer com que o signal tenha uma propriedade getter e setter em vez de usar os mÃ©todos `get` e `set`:
```js
const a = new Signal.State(0);
const b = new Proxy(a, {
  get(target, property, receiver) {
    if (property === 'value') {
      return target.get():
    }
  }
  set(target, property, value, receiver) {
    if (property === 'value') {
      target.set(value)!
    }
  }
});

// uso em um contexto reativo hipotÃ©tico:
<template>
  {b.value}

  <button onclick={() => {
    b.value++;
  }}>change</button>
</template>
```
ao usar um renderizador que Ã© otimizado para reatividade de grÃ£o fino, clicar no botÃ£o farÃ¡ com que a cÃ©lula `b.value` seja atualizada.

Veja:
- exemplos de estruturas reativas aninhadas criadas com Signals e Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)
- exemplo de implementaÃ§Ãµes anteriores mostrando a relaÃ§Ã£o entre dados reativos e proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)
- [discussÃ£o](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).

#### Como os Signals funcionam?

**Q**: Signals sÃ£o baseados em push ou pull?

**A**: A avaliaÃ§Ã£o de Signals computados Ã© baseada em pull: Signals computados sÃ³ sÃ£o avaliados quando `.get()` Ã© chamado, mesmo que o estado subjacente tenha mudado muito antes. Ao mesmo tempo, mudar um Signal de estado pode imediatamente acionar o callback de um Watcher, "empurrando" a notificaÃ§Ã£o. Portanto, Signals podem ser considerados uma construÃ§Ã£o "push-pull".

**Q**: Signals introduzem nÃ£o determinismo na execuÃ§Ã£o do JavaScript?

**A**: NÃ£o. Para comeÃ§ar, todas as operaÃ§Ãµes de Signal tÃªm semÃ¢nticas e ordenaÃ§Ãµes bem definidas, e nÃ£o diferirÃ£o entre implementaÃ§Ãµes compatÃ­veis. Em um nÃ­vel mais alto, Signals seguem um certo conjunto de invariantes, em relaÃ§Ã£o aos quais sÃ£o "corretos". Um Signal computado sempre observa o grafo de Signals em um estado consistente, e sua execuÃ§Ã£o nÃ£o Ã© interrompida por outro cÃ³digo que muta Signals (exceto pelas chamadas dele prÃ³prio). Veja a descriÃ§Ã£o acima.

**Q**: Quando escrevo em um Signal de estado, quando a atualizaÃ§Ã£o do Signal computado Ã© agendada?

**A**: NÃ£o Ã© agendada! O Signal computado irÃ¡ se recalcular na prÃ³xima vez que alguÃ©m o ler. SÃ­ncronamente, o callback `notify` de um Watcher pode ser chamado, permitindo que frameworks agendem uma leitura no momento que acharem apropriado.

**Q**: Quando as escritas em Signals de estado tÃªm efeito? Imediatamente ou sÃ£o agrupadas?

**A**: Escritas em Signals de estado sÃ£o refletidas imediatamente â€” na prÃ³xima vez que um Signal computado que depende do Signal de estado for lido, ele se recalcularÃ¡ se necessÃ¡rio, mesmo que seja na linha de cÃ³digo imediatamente seguinte. No entanto, a preguiÃ§a inerente a esse mecanismo (de que Signals computados sÃ³ sÃ£o calculados quando lidos) significa que, na prÃ¡tica, os cÃ¡lculos podem ocorrer de forma agrupada.

**Q**: O que significa Signals possibilitarem execuÃ§Ã£o "livre de glitches"?

**A**: Modelos anteriores baseados em push para reatividade enfrentaram o problema de computaÃ§Ã£o redundante: se uma atualizaÃ§Ã£o em um Signal de estado faz com que o Signal computado execute imediatamente, isso pode acabar forÃ§ando uma atualizaÃ§Ã£o na UI. Mas essa escrita na UI pode ser prematura, se houver outra mudanÃ§a no Signal de estado original antes do prÃ³ximo frame. Ã€s vezes, valores intermediÃ¡rios imprecisos eram atÃ© mostrados aos usuÃ¡rios finais devido a esses [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals evitam essa dinÃ¢mica por serem baseados em pull, e nÃ£o em push: no momento em que o framework agenda o render da UI, ele irÃ¡ buscar as atualizaÃ§Ãµes apropriadas, evitando trabalho desperdiÃ§ado tanto na computaÃ§Ã£o quanto na escrita no DOM.

**Q**: O que significa Signals serem "lossy" (com perda)?

**A**: Esse Ã© o outro lado da execuÃ§Ã£o livre de glitches: Signals representam uma cÃ©lula de dados â€” apenas o valor atual imediato (que pode mudar), nÃ£o um fluxo de dados ao longo do tempo. EntÃ£o, se vocÃª escrever duas vezes seguidas em um Signal de estado, sem fazer mais nada, a primeira escrita Ã© "perdida" e nunca serÃ¡ vista por qualquer Signal computado ou efeito. Isso Ã© entendido como uma funcionalidade e nÃ£o um bug â€” outros construtos (por exemplo, iterÃ¡veis assÃ­ncronos, observables) sÃ£o mais apropriados para fluxos.

**Q**: Signals nativos serÃ£o mais rÃ¡pidos do que implementaÃ§Ãµes JS de Signals jÃ¡ existentes?

**A**: Esperamos que sim (por um pequeno fator constante), mas isso ainda precisa ser comprovado em cÃ³digo. Engines JS nÃ£o sÃ£o mÃ¡gicas, e no final precisarÃ£o implementar o mesmo tipo de algoritmos das implementaÃ§Ãµes JS de Signals. Veja a seÃ§Ã£o acima sobre performance.

#### Por que os Signals sÃ£o projetados desse jeito?

**Q**: Por que esta proposta nÃ£o inclui uma funÃ§Ã£o `effect()`, se efeitos sÃ£o necessÃ¡rios para qualquer uso prÃ¡tico de Signals?

**A**: Efeitos estÃ£o inerentemente ligados a agendamento e descarte, que sÃ£o gerenciados por frameworks e estÃ£o fora do escopo desta proposta. Em vez disso, esta proposta inclui a base para implementaÃ§Ã£o de efeitos atravÃ©s da API de mais baixo nÃ­vel `Signal.subtle.Watcher`.

**Q**: Por que as assinaturas sÃ£o automÃ¡ticas ao invÃ©s de fornecer uma interface manual?

**A**: A experiÃªncia mostrou que interfaces de assinatura manual para reatividade sÃ£o pouco ergonÃ´micas e propensas a erros. O rastreamento automÃ¡tico Ã© mais composicional e Ã© uma funcionalidade central dos Signals.

**Q**: Por que o callback do `Watcher` roda de forma sÃ­ncrona, e nÃ£o agendada em uma microtask?

**A**: Porque o callback nÃ£o pode ler ou escrever em Signals, nÃ£o hÃ¡ inconsistÃªncias causadas por chamÃ¡-lo de forma sÃ­ncrona. Um callback tÃ­pico irÃ¡ adicionar um Signal a um Array para ser lido depois, ou marcar um bit em algum lugar. NÃ£o Ã© necessÃ¡rio e seria impraticavelmente caro criar uma microtask separada para todas essas aÃ§Ãµes.

**Q**: EstÃ¡ faltando nesta API algumas coisas legais que meu framework favorito fornece, e que facilitam programar com Signals. Isso pode ser adicionado ao padrÃ£o tambÃ©m?

**A**: Talvez. VÃ¡rias extensÃµes ainda estÃ£o em consideraÃ§Ã£o. Por favor, abra uma issue para discutir qualquer funcionalidade que achar importante e que esteja faltando.

**Q**: Esta API pode ser reduzida em tamanho ou complexidade?

**A**: Definitivamente Ã© um objetivo manter esta API mÃ­nima, e tentamos fazer isso com o que foi apresentado acima. Se vocÃª tiver ideias de mais coisas que podem ser removidas, por favor, abra uma issue para discutir.

#### Como os Signals estÃ£o sendo padronizados?

**Q**: NÃ£o deverÃ­amos comeÃ§ar o trabalho de padronizaÃ§Ã£o nesta Ã¡rea com um conceito mais primitivo, como observables?
**A**: Observables podem ser uma boa ideia para algumas situaÃ§Ãµes, mas nÃ£o resolvem os problemas que os Signals buscam solucionar. Conforme descrito acima, observables ou outros mecanismos de publicaÃ§Ã£o/assinatura nÃ£o sÃ£o uma soluÃ§Ã£o completa para muitos tipos de programaÃ§Ã£o de UI, devido Ã  necessidade de configuraÃ§Ã£o propensa a erros pelos desenvolvedores e trabalho desperdiÃ§ado devido Ã  falta de preguiÃ§a (laziness), entre outros problemas.

**Q**: Por que os Signals estÃ£o sendo propostos no TC39 em vez do DOM, jÃ¡ que a maioria de suas aplicaÃ§Ãµes Ã© baseada na web?

**A**: Alguns coautores desta proposta tÃªm interesse em ambientes de UI fora da web como objetivo, mas atualmente, ambos os ambientes podem ser adequados para isso, jÃ¡ que APIs web estÃ£o sendo implementadas cada vez mais fora da web. Em Ãºltima anÃ¡lise, Signals nÃ£o precisam depender de nenhuma API do DOM, entÃ£o qualquer caminho funciona. Se alguÃ©m tiver um motivo forte para este grupo mudar, por favor, nos informe em uma issue. Por enquanto, todos os colaboradores assinaram os acordos de propriedade intelectual do TC39, e o plano Ã© apresentar isso ao TC39.

**Q**: Quanto tempo vai levar atÃ© que eu possa usar Signals padronizados?

**A**: JÃ¡ existe um polyfill disponÃ­vel, mas Ã© melhor nÃ£o depender de sua estabilidade, pois esta API evolui durante o processo de revisÃ£o. Em alguns meses ou em um ano, um polyfill estÃ¡vel, de alta qualidade e alto desempenho deve estar utilizÃ¡vel, mas ainda estarÃ¡ sujeito a revisÃµes do comitÃª e nÃ£o serÃ¡ padrÃ£o ainda. Seguindo a trajetÃ³ria tÃ­pica de uma proposta do TC39, espera-se que leve pelo menos 2-3 anos, no mÃ­nimo, para que os Signals estejam disponÃ­veis nativamente em todos os navegadores, mesmo em versÃµes anteriores, de modo que polyfills nÃ£o sejam mais necessÃ¡rios.

**Q**: Como vamos evitar padronizar o tipo errado de Signals muito cedo, assim como {{JS/web feature that you don't like}}?

**A**: Os autores desta proposta planejam ir alÃ©m com prototipagem e validaÃ§Ã£o antes de solicitar o avanÃ§o de estÃ¡gio no TC39. Veja "Status and development plan" acima. Se vocÃª identificar lacunas nesse plano ou oportunidades de melhoria, por favor, abra uma issue explicando.

---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-28

---