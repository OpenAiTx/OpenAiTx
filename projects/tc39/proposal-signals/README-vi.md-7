{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Với [AsyncContext](https://github.com/tc39/proposal-async-context), callback được truyền vào `new Signal.subtle.Watcher` *không* đóng gói (close over) snapshot tại thời điểm constructor được gọi, vì vậy thông tin ngữ cảnh xung quanh thao tác ghi sẽ được nhìn thấy.\n\n#### Phương thức: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Nếu `frozen` là true, ném ra một ngoại lệ.\n1. Nếu bất kỳ đối số nào không phải là một signal, ném ra một ngoại lệ.\n1. Thêm tất cả các đối số vào cuối thuộc tính `signals` của đối tượng này.\n1. Với mỗi signal mới được theo dõi, theo thứ tự từ trái sang phải,\n    1. Thêm watcher này như một `sink` vào signal đó.\n    1. Nếu đây là sink đầu tiên, thì đệ quy lên các source để thêm signal đó như một sink.\n    1. Đặt `frozen` thành true.\n    1. Gọi callback `watched` nếu nó tồn tại.\n    1. Khôi phục `frozen` về false.\n1. Nếu `state` của Signal là `~waiting~`, thì đặt thành `~watching~`.\n\n#### Phương thức: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Nếu `frozen` là true, ném ra một ngoại lệ.\n1. Nếu bất kỳ đối số nào không phải là một signal, hoặc không được watcher này theo dõi, ném ra một ngoại lệ.\n1. Với mỗi signal trong các đối số, theo thứ tự từ trái sang phải,\n    1. Loại bỏ signal đó khỏi tập `signals` của Watcher này.\n    1. Loại bỏ Watcher này khỏi tập `sink` của Signal đó.\n    1. Nếu tập `sink` của Signal đó trở nên trống, loại bỏ Signal đó như một sink khỏi từng source của nó.\n    1. Đặt `frozen` thành true.\n    1. Gọi callback `unwatched` nếu nó tồn tại.\n    1. Khôi phục `frozen` về false.\n1. Nếu watcher hiện tại không còn `signals` nào, và `state` là `~watching~`, thì đặt thành `~waiting~`.\n\n#### Phương thức: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Trả về một mảng chứa tập con của `signals` là các Computed Signal đang ở trạng thái `~dirty~` hoặc `~pending~`.\n\n### Phương thức: `Signal.subtle.untrack(cb)`\n\n1. Đặt `c` là trạng thái `computing` hiện tại của ngữ cảnh thực thi.\n1. Đặt `computing` thành null.\n1. Gọi `cb`.\n1. Khôi phục `computing` về giá trị `c` (ngay cả khi `cb` ném ra ngoại lệ).\n1. Trả về giá trị trả về của `cb` (ném lại bất kỳ ngoại lệ nào).\n\nLưu ý: untrack không đưa bạn ra khỏi trạng thái `frozen`, trạng thái này được duy trì nghiêm ngặt.\n\n### Phương thức: `Signal.subtle.currentComputed()`\n\n1. Trả về giá trị `computing` hiện tại.\n\n### Các thuật toán chung\n\n##### Thuật toán: tính lại Computed Signal bẩn (dirty)\n\n1. Xóa tập `sources` của Signal này, và loại bỏ nó khỏi các tập `sinks` của các source đó.\n1. Lưu giá trị `computing` trước đó và đặt `computing` thành Signal này.\n1. Đặt trạng thái của Signal này thành `~computing~`.\n1. Chạy callback của Computed Signal này, sử dụng Signal này làm giá trị this. Lưu giá trị trả về, và nếu callback ném ra ngoại lệ, lưu trữ ngoại lệ đó để ném lại.\n1. Khôi phục giá trị `computing` trước đó.\n1. Áp dụng thuật toán \"set Signal value\" với giá trị trả về của callback.\n2. Đặt trạng thái của Signal này thành `~clean~`.\n1. Nếu thuật toán đó trả về `~dirty~`: đánh dấu tất cả sinks của Signal này là `~dirty~` (trước đó, các sinks có thể là hỗn hợp giữa đã kiểm tra và bẩn). (Hoặc, nếu signal này không được theo dõi, hãy áp dụng một số generation number mới để chỉ ra trạng thái bẩn, hoặc một cách nào đó tương tự.)\n1. Nếu không, thuật toán đó trả về `~clean~`: Trong trường hợp này, với mỗi sink `~checked~` của Signal này, nếu tất cả các source của Signal đó hiện đã sạch, thì đánh dấu Signal đó là `~clean~`. Áp dụng bước dọn dẹp này cho các sinks tiếp theo một cách đệ quy, với bất kỳ Signals nào vừa trở nên sạch mà có sinks đã kiểm tra. (Hoặc, nếu signal này không được theo dõi, hãy chỉ ra điều tương tự để việc dọn dẹp có thể diễn ra một cách lười biếng.)\n\n##### Thuật toán đặt giá trị Signal (Set Signal value algorithm)\n\n1. Nếu thuật toán này nhận được một giá trị (trái ngược với một ngoại lệ để ném lại, từ thuật toán tính lại Computed Signal bẩn):\n    1. Gọi hàm `equals` của Signal này, truyền vào các tham số là `value` hiện tại, giá trị mới, và Signal này. Nếu một ngoại lệ được ném ra, lưu ngoại lệ đó (để ném lại khi đọc) làm giá trị của Signal và tiếp tục như thể callback trả về false.\n    1. Nếu hàm đó trả về true, trả về `~clean~`.\n1. Đặt `value` của Signal này thành giá trị tham số.\n1. Trả về `~dirty~`\n\n## Câu hỏi thường gặp (FAQ)\n\n**Hỏi**: Có phải hơi sớm để chuẩn hóa thứ gì đó liên quan đến Signals, khi chúng chỉ mới trở nên thịnh hành từ năm 2022? Có nên cho chúng thêm thời gian để phát triển và ổn định không?\n\n**Đáp**: Trạng thái hiện tại của Signals trong các framework web là kết quả của hơn 10 năm phát triển liên tục. Khi đầu tư tăng lên, như những năm gần đây, hầu như tất cả các framework web đều tiếp cận một mô hình Signals lõi rất giống nhau. Đề xuất này là kết quả của một bài tập thiết kế chung giữa một số lượng lớn các lãnh đạo hiện tại trong các framework web, và sẽ không được thúc đẩy chuẩn hóa nếu không có sự xác nhận của nhóm chuyên gia trong các ngữ cảnh khác nhau.\n\n#### Signals được sử dụng như thế nào?\n\n**Hỏi**: Liệu Signals tích hợp sẵn có thể được các framework sử dụng, với sự tích hợp chặt chẽ với rendering và ownership như vậy không?\n\n**Đáp**: Những phần mang tính framework hơn thường nằm ở khu vực effects, lập lịch (scheduling), và ownership/disposal, mà đề xuất này không cố giải quyết. Ưu tiên đầu tiên của chúng tôi với việc thử nghiệm Signals trong hướng tiêu chuẩn là xác thực rằng chúng có thể \"nằm bên dưới\" các framework hiện tại một cách tương thích và với hiệu năng tốt.\n\n**Hỏi**: Signal API có được thiết kế để các lập trình viên ứng dụng sử dụng trực tiếp, hay để các framework bao bọc lại?\n\n**Đáp**: Dù API này có thể được lập trình viên ứng dụng sử dụng trực tiếp (ít nhất là phần không thuộc không gian tên `Signal.subtle`), nó không được thiết kế để đặc biệt tiện dụng. Thay vào đó, nhu cầu của tác giả thư viện/framework được ưu tiên. Hầu hết các framework được kỳ vọng sẽ bao bọc ngay cả các API cơ bản như `Signal.State` và `Signal.Computed` với một cái gì đó thể hiện phong cách tiện dụng của họ. Trong thực tế, thường tốt nhất là sử dụng Signals thông qua một framework, framework sẽ quản lý các tính năng phức tạp hơn (ví dụ: Watcher, `untrack`), cũng như quản lý ownership và disposal (ví dụ: xác định khi nào signals nên được thêm vào và loại bỏ khỏi watcher), và lập lịch render tới DOM--đề xuất này không cố giải quyết các vấn đề đó.\n\n**Hỏi**: Tôi có phải gỡ bỏ Signals liên quan đến một widget khi widget đó bị hủy không? API cho việc đó là gì?\n\n**Đáp**: Thao tác teardown liên quan ở đây là `Signal.subtle.Watcher.prototype.unwatch`. Chỉ các Signals đang được theo dõi mới cần được dọn dẹp (bằng cách bỏ theo dõi), trong khi các Signals không được theo dõi có thể được thu gom rác tự động.\n\n**Hỏi**: Signals có hoạt động với VDOM, hay trực tiếp với HTML DOM gốc không?\n\n**Đáp**: Có! Signals độc lập với công nghệ render. Các framework JavaScript hiện tại sử dụng các cấu trúc tương tự Signal tích hợp với VDOM (ví dụ: Preact), DOM gốc (ví dụ: Solid) và cả kết hợp (ví dụ: Vue). Điều tương tự sẽ khả thi với Signals tích hợp sẵn.\n\n**Hỏi**: Việc sử dụng Signals trong các framework dựa trên class như Angular và Lit có tiện dụng không? Còn các framework dựa trên compiler như Svelte thì sao?\n\n**Đáp**: Các trường class có thể sử dụng Signal dễ dàng với một decorator accessor đơn giản, như trong [readme của Signal polyfill](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals rất gần với Runes của Svelte 5--rất đơn giản để một compiler chuyển đổi runes sang Signal API được định nghĩa ở đây, thực tế Svelte 5 làm điều này nội bộ (nhưng với thư viện Signals riêng của nó).\n\n**Hỏi**: Signals có hoạt động với SSR không? Hydration? Resumability?\n\n**Đáp**: Có. Qwik sử dụng Signals rất hiệu quả với cả hai thuộc tính này, và các framework khác cũng có các phương pháp phát triển tốt khác với Signals và các điểm đánh đổi khác nhau. Chúng tôi nghĩ rằng có thể mô hình hóa Signals có thể tiếp tục của Qwik bằng cách sử dụng một State và Computed signal được kết nối với nhau, và dự định sẽ chứng minh điều này bằng mã nguồn.",
  "status": "ok"
}