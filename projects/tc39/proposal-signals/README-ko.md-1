{
  "id": 1,
  "origin": "# 🚦 JavaScript Signals standard proposal🚦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and more…\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# 🚦 JavaScript Signals 표준 제안🚦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([설명](https://tc39.es/process-document/))\n\nTC39 제안 챔피언: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\n원저자: Rob Eisenberg, Daniel Ehrenberg\n\n이 문서는 JavaScript에서의 signals에 대한 초기 공통 방향을 설명하며, 이는 TC39가 ES2015에서 표준화한 Promises에 앞서 진행된 Promises/A+ 노력과 유사합니다. [폴리필](https://github.com/proposal-signals/signal-polyfill)을 사용하여 직접 시도해볼 수 있습니다.\n\nPromises/A+와 마찬가지로, 이 노력은 JavaScript 생태계의 정렬에 초점을 맞추고 있습니다. 이 정렬이 성공하면, 그 경험을 바탕으로 표준이 등장할 수 있습니다. 여러 프레임워크 저자들이 이곳에서 그들의 반응성 코어를 지원할 수 있는 공통 모델에 협력하고 있습니다. 현재 초안은 [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a) 등 다양한 프레임워크 저자 및 유지관리자들의 디자인 피드백을 바탕으로 작성되었습니다.\n\nPromises/A+와 다르게, 우리는 공통적인 개발자 대상의 표면 API를 해결하려는 것이 아니라, 신호 그래프의 근본적인 핵심 시맨틱을 정확하게 정의하려고 합니다. 이 제안에는 완전히 구체적인 API가 포함되어 있지만, 이 API는 대부분의 애플리케이션 개발자를 대상으로 하지 않습니다. 대신, 여기의 신호 API는 프레임워크가 그 위에 구축할 수 있도록 더 적합하며, 공통 신호 그래프 및 자동 추적 메커니즘을 통한 상호 운용성을 제공합니다.\n\n이 제안의 계획은 Stage 1을 넘어서기 전에, 여러 프레임워크에의 통합을 포함한 상당한 초기 프로토타이핑을 수행하는 것입니다. Signals가 여러 프레임워크에서 실제로 사용하기에 적합하고, 프레임워크 제공 신호 대비 실제 이점을 제공하는 경우에만 표준화에 관심이 있습니다. 상당한 초기 프로토타이핑을 통해 이러한 정보를 얻을 수 있기를 희망합니다. 자세한 내용은 아래 \"Status and development plan\"을 참조하세요.\n\n## 배경: 왜 Signals인가?\n\n복잡한 사용자 인터페이스(UI)를 개발하기 위해, JavaScript 애플리케이션 개발자는 애플리케이션의 뷰 계층에 상태를 효율적으로 저장, 계산, 무효화, 동기화, 푸시해야 합니다. UI는 단순한 값 관리 그 이상을 포함하는 경우가 많으며, 종종 다른 값이나 자체적으로 계산되는 상태의 복잡한 트리에 의존하는 계산된 상태의 렌더링이 필요합니다. Signals의 목표는 이러한 애플리케이션 상태를 관리할 인프라를 제공하여 개발자가 반복적인 세부사항이 아닌 비즈니스 로직에 집중할 수 있도록 하는 것입니다.\n\nSignal과 유사한 구조는 UI가 아닌 컨텍스트, 특히 빌드 시스템에서 불필요한 재빌드를 방지하기 위해 독립적으로 유용하다는 것이 입증되었습니다.\n\nSignals는 반응형 프로그래밍에서 애플리케이션의 업데이트 관리를 제거하기 위해 사용됩니다.\n\n> 상태 변경에 기반한 업데이트를 위한 선언적 프로그래밍 모델.\n\n출처: _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### 예제 - 바닐라JS 카운터\n\n`counter`라는 변수가 있다고 할 때, DOM에 카운터가 짝수인지 홀수인지 렌더링하고 싶습니다. `counter`가 변경될 때마다, 최신의 짝/홀 정보를 DOM에 업데이트해야 합니다. 바닐라 JS에서는 다음과 같이 작성할 수 있습니다:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> 글로벌 변수는 여기서 시연 목적을 위해 사용되었습니다. 적절한 상태 관리는 다양한 솔루션이 있으며, 이 제안의 예제는 가능한 한 최소화되었습니다. 이 제안은 글로벌 변수 사용을 권장하지 않습니다.\n\n이 방식에는 여러 가지 문제가 있습니다...\n\n* `counter` 설정이 복잡하고 보일러플레이트 코드가 많습니다.\n* `counter` 상태가 렌더링 시스템에 강하게 결합되어 있습니다.\n* `counter`가 변경되지만 `parity`가 변하지 않는 경우(예: 2에서 4로 증가), 불필요하게 짝/홀 계산 및 렌더링이 발생합니다.\n* UI의 다른 부분이 `counter` 업데이트만 렌더링하고 싶다면 어떻게 해야 할까요?\n* UI의 다른 부분이 `isEven` 또는 `parity`만을 의존한다면 어떻게 해야 할까요?\n\n상대적으로 단순한 이 시나리오에서도 많은 문제가 빠르게 발생합니다. 우리는 `counter`에 대해 pub/sub(발행/구독)를 도입하여 이러한 문제를 우회할 수 있습니다. 이렇게 하면, `counter`의 추가 소비자가 상태 변경에 자신의 반응을 추가로 구독할 수 있습니다.\n\n하지만, 여전히 다음과 같은 문제에 직면해 있습니다:\n\n* 오직 `parity`에만 의존하는 렌더 함수가 실제로는 `counter`를 구독해야 함을 \"알아야\" 합니다.\n* `isEven` 또는 `parity`만을 기반으로 UI를 업데이트하는 것이, `counter`에 직접 접근하지 않고는 불가능합니다.\n* 보일러플레이트가 증가했습니다. 무언가를 사용할 때마다 단순히 함수를 호출하거나 변수를 읽는 것이 아니라, 구독하고 그곳에서 업데이트해야 합니다. 구독 해제 관리도 특히 복잡해집니다.\n\n이제, 우리는 pub/sub을 `counter`뿐 아니라 `isEven`과 `parity`에도 추가하여 몇 가지 문제를 해결할 수 있습니다. 그러면, `isEven`을 `counter`에, `parity`를 `isEven`에, `render`를 `parity`에 각각 구독해야 합니다. 불행하게도, 보일러플레이트 코드가 폭증할 뿐만 아니라, 구독 관리에 많은 수작업이 필요하고, 제대로 정리하지 않으면 잠재적인 메모리 누수 위험도 있습니다. 결국, 몇 가지 문제를 해결했지만 완전히 새로운 범주의 문제와 많은 코드를 만들었습니다. 더욱이, 시스템 내 모든 상태에 대해 이 과정을 반복해야 합니다.\n\n### Signals 도입\n\nUI에서 모델과 뷰 간의 데이터 바인딩 추상화는 JS나 웹 플랫폼에 내장된 메커니즘이 없음에도 불구하고, 여러 프로그래밍 언어의 UI 프레임워크에서 오랫동안 핵심이었습니다. JS 프레임워크와 라이브러리 내부에서는 이 바인딩을 표현하는 다양한 방식에 대한 실험이 많이 이루어졌으며, 1급 상태 셀 또는 다른 데이터에서 파생된 계산을 나타내는 데이터 타입(즉, \"Signals\")과 단방향 데이터 흐름의 힘이 입증되었습니다.\n이 1급 반응형 값 접근법은 [Knockout](https://knockoutjs.com/)이 [2010년](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/)에 오픈소스 JavaScript 웹 프레임워크에서 처음 널리 등장한 것으로 보입니다. 그 후로 수많은 변형과 구현이 만들어졌습니다. 최근 3~4년 사이에 Signal 원시값과 관련 접근법이 더 큰 관심을 끌게 되었으며, 거의 모든 현대 JavaScript 라이브러리나 프레임워크가 이름은 다르지만 유사한 기능을 보유하게 되었습니다.\n\nSignals를 이해하기 위해, 위의 예제를 아래에 더 명확히 설명된 Signal API를 사용해 다시 살펴보겠습니다.\n\n#### 예제 - Signals 카운터\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\n여기서 바로 알 수 있는 몇 가지 사항이 있습니다:\n* 이전 예제에서 `counter` 변수에 관련된 복잡한 보일러플레이트가 제거되었습니다.\n* 값, 계산, 부수효과를 다루는 통합된 API가 있습니다.\n* `counter`와 `render` 간의 순환 참조 문제나 거꾸로 된 의존성이 없습니다.\n* 수동 구독이나 별도의 관리가 필요하지 않습니다.\n* 부수효과의 타이밍/스케줄링을 제어할 수 있는 수단이 있습니다.\n\nSignals는 API 표면에서 보이는 것 이상을 제공합니다:",
  "status": "ok"
}