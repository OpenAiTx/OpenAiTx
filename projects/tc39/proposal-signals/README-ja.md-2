{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **自動依存関係トラッキング** - 計算されたシグナルは、自動的に自分が依存している他のシグナル（それが単純な値であれ、他の計算であれ）を発見します。\n* **遅延評価** - 計算は宣言時に積極的に評価されることはなく、依存関係が変化したときにもすぐに評価されることはありません。値が明示的に要求されたときにのみ評価されます。\n* **メモ化** - 計算されたシグナルは前回の値をキャッシュするため、依存関係に変更がなければ、何度アクセスされても再評価する必要がありません。\n\n## シグナル標準化の動機\n\n#### 相互運用性\n\n各シグナル実装は、計算されたシグナルを評価する際に遭遇したソースを追跡する独自の自動トラッキングメカニズムを持っています。これにより、異なるフレームワーク間でモデル、コンポーネント、ライブラリを共有することが難しくなります——シグナルは通常JSフレームワークの一部として実装されるため、ビューエンジンに偽の結びつきが生じがちです。\n\nこの提案の目標の一つは、リアクティブモデルをレンダリングビューから完全に切り離し、開発者が非UIコードを書き直すことなく新しいレンダリング技術へ移行できるようにし、また異なるコンテキストで展開できる共有リアクティブモデルをJSで開発できるようにすることです。残念ながら、バージョニングや重複の問題により、JSレベルのライブラリによる強力な共有は非現実的であることが判明しており、組み込みの仕組みの方がより強力な共有保証を提供します。\n\n#### パフォーマンス／メモリ使用量\n\n一般的に使用されるライブラリが組み込まれていることで、コード量が減り、わずかなパフォーマンス向上が見込まれますが、シグナルの実装自体は比較的小さいため、この効果は大きくないと予想されます。\n\nシグナル関連のデータ構造やアルゴリズムのネイティブC++実装は、JSで実現可能なものよりも定数倍だけ効率的になる可能性があると考えています。ただし、ポリフィルで存在するものと比べてアルゴリズムの変更は想定されていません。エンジンが魔法のように高速になるわけではなく、リアクティブアルゴリズム自体は明確かつ一義的に定義されます。\n\nチャンピオングループはさまざまなシグナル実装を開発し、これらのパフォーマンスの可能性を調査する予定です。\n\n#### DevTools\n\n既存のJS言語のシグナルライブラリでは、次のようなことをトレースするのが難しい場合があります。\n* 計算されたシグナルのチェーンを跨ぐコールスタック（エラーの因果チェーンの表示）\n* シグナル間の参照グラフ（あるシグナルが別のシグナルに依存しているとき）——メモリ使用量のデバッグ時に重要\n\n組み込みのシグナルにより、JSランタイムおよびDevToolsはシグナルの検査に対して改善されたサポートを持つ可能性があります。特にデバッグやパフォーマンス解析のために、これはブラウザに組み込まれるか、共有拡張機能を通じて実現できます。既存の要素インスペクタ、パフォーマンススナップショット、メモリプロファイラなどのツールも、シグナルを特に強調して情報を提示できるように更新できます。\n\n#### 二次的な利点\n\n##### 標準ライブラリの利点\n\n一般にJavaScriptの標準ライブラリは最小限でしたが、TC39では高品質な組み込み機能セットを備えた「バッテリー同梱」言語への流れが強まっています。たとえば、Temporalはmoment.jsを置き換えつつあり、`Array.prototype.flat`や`Object.groupBy`のような小さな機能も多くのlodashの用途を置き換えています。これらの利点には、バンドルサイズの縮小、安定性と品質の向上、新規プロジェクト参加時の学習負荷の軽減、JS開発者間での共通語彙の形成などがあります。\n\n##### HTML/DOMとの統合（将来的な可能性）\n\n現在、W3Cやブラウザ実装者によるネイティブテンプレートのHTMLへの導入（[DOM Parts][wicg-pr-1023] および [Template Instantiation][wicg-propsal-template-instantiation]）が進められています。さらに、W3C Web Components CGは、Web Componentsを拡張して完全に宣言的なHTML APIを提供する可能性を模索しています。これらの目標を達成するには、最終的にHTMLにリアクティブなプリミティブが必要となります。また、シグナルとの統合によるDOMの多くの使い勝手の向上も想像でき、コミュニティから要望も寄せられています。\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> 注意：この統合は別の取り組みとして後から進められるものであり、本提案自体には含まれません。\n\n##### エコシステムの情報交換（*これ自体は標準化の理由ではない*）\n\n標準化の取り組みは、ブラウザの変更を伴わずとも「コミュニティ」レベルで役立つ場合があります。シグナルの取り組みは、多様なフレームワーク作者を集め、リアクティビティの本質・アルゴリズム・相互運用性について深い議論を促しています。これはすでに有用ですが、JSエンジンやブラウザへの組み込みを正当化するものではありません。シグナルはエコシステムの情報交換を超えた*大きな利点*がある場合にのみ、JavaScript標準に追加されるべきです。\n\n## シグナルの設計目標\n\n既存のシグナルライブラリは、その本質的な部分ではそれほど大きな違いはありません。本提案は、それら多くのライブラリの重要な特性を実装することで、成功例を活かすことを目指しています。\n\n### コア機能\n\n* 状態を表すシグナル型、つまり書き込み可能なシグナル。他から読み取ることができる値です。\n* 他のシグナルに依存し、遅延的に計算・キャッシュされる計算/メモ/派生シグナル型。\n    * 計算は遅延的であり、計算シグナルはデフォルトで依存先が変わったときに再計算されるのではなく、実際に誰かが読み取ったときのみ実行されます。\n    * 計算は「[グリッチ](https://ja.wikipedia.org/wiki/リアクティブプログラミング#グリッチ) フリー」であり、不要な計算は一切行われません。つまり、アプリケーションが計算シグナルを読む際、グラフの「汚れた」部分が重複しないようトポロジカルソートされます。\n    * 計算はキャッシュされます。つまり、前回依存関係が変更されて以降、何も依存先が変わっていなければ、計算シグナルはアクセスされても再計算されません。\n    * 計算シグナルや状態シグナルのためにカスタム比較も可能であり、それに依存する更なる計算シグナルがいつ更新されるべきかを判定できます。\n* 計算シグナルの依存先（またはネストした依存先）が「汚れる」ことで、そのシグナルの値が古くなっているかもしれないという条件に反応する仕組み。\n    * この反応は、より大きな作業を後でスケジューリングするためのものです。\n    * エフェクトはこれらの反応と、フレームワークレベルのスケジューリングによって実装されます。\n    * 計算シグナルは、自分がこれらの反応の（ネストした）依存として登録されているかどうかに反応できる必要があります。\n* JSフレームワークが独自のスケジューリングをできるようにする。Promiseスタイルの組み込みスケジューリングは強制しません。\n    * 後の作業をフレームワークロジックに基づいてスケジューリングできるよう、同期的な反応が必要です。\n    * 書き込みは同期的に即座に反映されます（フレームワークが書き込みをバッチ処理したい場合は、その上に構築できます）。\n    * エフェクトが「汚れている」かどうかの判定と、実際にエフェクトを実行する処理を分離可能（2段階のエフェクトスケジューラを実現可能）。\n* 依存関係の記録をトリガーせずにシグナルを読む（`untrack`）ことが可能\n* シグナル／リアクティビティを使う異なるコードベースの合成を可能にする。例：\n    * トラッキング／リアクティビティ自体に関して、複数のフレームワークを一緒に使う（ただし下記の制限あり）\n    * フレームワーク非依存のリアクティブデータ構造（例：再帰的なリアクティブストアプロキシ、リアクティブなMap・Set・Arrayなど）\n\n### 完全性（Soundness）\n\n* 同期反応の素朴な誤用を抑制／禁止する。\n    * 完全性リスク：不適切に使用すると「[グリッチ](https://ja.wikipedia.org/wiki/リアクティブプログラミング#グリッチ)」を露呈させる可能性があります。シグナルが設定された際に即座にレンダリングが行われると、ユーザーに不完全なアプリケーション状態が見えてしまうことがあります。したがって、この機能はアプリケーションロジックが完了した後に作業を賢くスケジューリングする場合のみ使用すべきです。\n    * 解決策：同期反応コールバック内でシグナルの読み書きを禁止する\n* `untrack` の使用を抑制し、その不完全性を明示する\n    * 完全性リスク：他のシグナルに依存するが、その変化で更新されない計算シグナルを作れてしまう。アン・トラックされたアクセスが計算結果に影響しない場合のみ使用すべきです。\n    * 解決策：API名に「unsafe」を含め、不安全であることを明示する。\n* 注意：この提案は、計算シグナルやエフェクトシグナルからシグナルの読み書きの両方を許可します。読み取り後の書き込みも制限しません（完全性リスクはありますが）。これは、フレームワークとの統合における柔軟性と互換性を保つための決定です。\n\n### 表面API\n\n* 複数のフレームワークがシグナル／リアクティビティの仕組みを実装するための堅実なベースであること\n    * 再帰的なストアプロキシ、デコレータベースのクラスフィールドリアクティビティ、`.value`や`[state, setState]`スタイルのAPIのベースとして適しているべきです。\n    * セマンティクスは、異なるフレームワークで有効なパターンを表現可能であるべきです。たとえば、即時反映される書き込みや、後からバッチ適用される書き込みのいずれにも基盤となるべきです。\n* 可能ならJS開発者が直接使えるAPIであることが望ましい。\n    * 機能がエコシステムの概念と一致する場合は、共通語彙を使うのが良い。\n        * ただし、全く同じ名前を直訳的に使うのは避けるべきです！\n    * 「JS開発者が使いやすいこと」と「フレームワーク向けの全フック提供」のバランス\n        * アイデア：全フックを提供し、誤用時には可能な範囲でエラーを出す。\n        * アイデア：[`crypto.subtle`](https://developer.mozilla.org/ja/docs/Web/API/Crypto/subtle)のように、微妙なAPIは`subtle`名前空間に入れ、フレームワークやDevツールのための上級用途と、一般的なアプリケーション開発用途との線引きを明示する。\n* 良好なパフォーマンスで実装・利用可能であること——表面APIが過度なオーバーヘッドを生まない\n    * サブクラス化を可能にし、フレームワークが独自のメソッドやフィールド（プライベートフィールド含む）を追加できるようにする。これにより、フレームワークレベルでの追加のアロケーションを避けることができます。詳細は「メモリ管理」参照。\n\n### メモリ管理\n\n* 可能であれば、計算シグナルは将来読み取られる可能性があるものとして参照されていなければ、より大きなグラフにリンクされていても（例えば、ライブな状態を読み取っている場合でも）ガベージコレクト可能であるべきです。",
  "status": "ok"
}