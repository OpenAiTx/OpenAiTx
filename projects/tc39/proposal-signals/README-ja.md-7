{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "[AsyncContext](https://github.com/tc39/proposal-async-context) を使用した場合、`new Signal.subtle.Watcher` に渡されたコールバックは、コンストラクタが呼ばれた時点でのスナップショットをクローズオーバー*しません*。そのため、書き込み時のコンテキスト情報が見えるようになります。\n\n#### メソッド: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. `frozen` が true の場合、例外を投げる。\n1. 引数のいずれかがシグナルでない場合、例外を投げる。\n1. すべての引数をこのオブジェクトの `signals` の末尾に追加する。\n1. 新たに監視される各シグナルについて、左から右の順に、\n    1. このウォッチャーをそのシグナルの `sink` として追加する。\n    1. これが最初の sink だった場合、ソースまで再帰的にたどり、そのシグナルを sink として追加する。\n    1. `frozen` を true に設定する。\n    1. `watched` コールバックが存在する場合は呼び出す。\n    1. `frozen` を false に戻す。\n1. Signal の `state` が `~waiting~` の場合、`~watching~` に設定する。\n\n#### メソッド: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. `frozen` が true の場合、例外を投げる。\n1. 引数のいずれかがシグナルでない場合、またはこのウォッチャーがそのシグナルを監視していない場合、例外を投げる。\n1. 引数の各シグナルについて、左から右の順に、\n    1. そのシグナルをこのウォッチャーの `signals` セットから削除する。\n    1. このウォッチャーをそのシグナルの `sink` セットから削除する。\n    1. そのシグナルの `sink` セットが空になった場合、そのシグナルを各ソースの sink から削除する。\n    1. `frozen` を true に設定する。\n    1. `unwatched` コールバックが存在する場合は呼び出す。\n    1. `frozen` を false に戻す。\n1. ウォッチャーが `signals` を持たず、かつ `state` が `~watching~` の場合、`~waiting~` に設定する。\n\n#### メソッド: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. `signals` のうち、状態が `~dirty~` または `~pending~` の Computed Signal のみを含む配列を返す。\n\n### メソッド: `Signal.subtle.untrack(cb)`\n\n1. `c` を実行コンテキストの現在の `computing` 状態とする。\n1. `computing` を null に設定する。\n1. `cb` を呼び出す。\n1. `cb` が例外を投げた場合でも `computing` を `c` に戻す。\n1. `cb` の戻り値を返す（例外があれば再スローする）。\n\n注: untrack は `frozen` 状態から抜け出すものではありません。`frozen` 状態は厳格に維持されます。\n\n### メソッド: `Signal.subtle.currentComputed()`\n\n1. 現在の `computing` の値を返す。\n\n### 共通アルゴリズム\n\n##### アルゴリズム: ダーティな Computed Signal の再計算\n\n1. この Signal の `sources` セットをクリアし、それらのソースの `sinks` セットからこの Signal を削除する。\n1. 以前の `computing` の値を保存し、`computing` をこの Signal に設定する。\n1. この Signal の状態を `~computing~` に設定する。\n1. この Computed Signal のコールバックを、this 値としてこの Signal を使って実行する。戻り値を保存し、コールバックが例外を投げた場合はそれを保存して再スロー用とする。\n1. 以前の `computing` の値を復元する。\n1. コールバックの戻り値に「Set Signal value アルゴリズム」を適用する。\n2. この Signal の状態を `~clean~` に設定する。\n1. そのアルゴリズムが `~dirty~` を返した場合：この Signal のすべての sink を `~dirty~` としてマークする（以前は sink が checked と dirty の混在だった可能性がある）。（または、これが監視されていなければ、新しい世代番号を採用してダーティ状態を示すなどの処理を行う。）\n1. それ以外で、そのアルゴリズムが `~clean~` を返した場合：この場合、この Signal の各 `~checked~` sink について、その Signal のすべてのソースがクリーンなら、その Signal も `~clean~` としてマークする。このクリーンアップステップを、checked sink を持つ新たにクリーンになった Signal すべてに再帰的に適用する。（または、これが監視されていなければ、同様のことを何らかの方法で示し、クリーンアップを遅延的に進める。）\n\n##### Set Signal value アルゴリズム\n\n1. このアルゴリズムに値（recalculate dirty computed Signal アルゴリズムからの再スロー用例外ではなく）が渡された場合：\n    1. この Signal の `equals` 関数を呼び出し、現在の `value`、新しい値、この Signal を引数として渡す。例外が投げられた場合、その例外を Signal の値として保存し（読み出し時に再スロー）、コールバックが false を返した場合と同様に続行する。\n    1. その関数が true を返した場合、`~clean~` を返す。\n1. この Signal の `value` を引数で渡された値に設定する。\n1. `~dirty~` を返す。\n\n## FAQ\n\n**Q**: シグナルに関連するものを標準化するには時期尚早では？シグナルが注目され始めたのは 2022 年からですよね？もっと進化と安定を待つべきでは？\n\n**A**: ウェブフレームワークにおけるシグナルの現状は、10年以上にわたる継続的な開発の成果です。近年のように投資が高まる中、ほぼすべてのウェブフレームワークが非常に似通ったコアモデルのシグナルへと収束しつつあります。この提案は、現行の多くのウェブフレームワークリーダーによる共同設計演習の成果であり、その分野の専門家グループによる検証なしに標準化に推し進めることはありません。\n\n#### シグナルはどのように使われるのか？\n\n**Q**: ビルトインのシグナルは、描画や所有権と密接に統合されているのに、フレームワークで本当に使えるの？\n\n**A**: フレームワーク固有の部分は、エフェクト、スケジューリング、所有権・廃棄処理の領域に集中していますが、これらは本提案の対象外です。標準化プロトタイピングの第一の優先事項は、既存フレームワークの下層でシグナルが互換性と良好なパフォーマンスで動作するかどうかの検証です。\n\n**Q**: Signal API はアプリケーション開発者が直接使うことを想定しているのですか？それともフレームワークがラップして使うものですか？\n\n**A**: この API（特に `Signal.subtle` 名前空間以外）は、アプリケーション開発者が直接使うことも可能ですが、特に使いやすく設計されているわけではありません。むしろ、ライブラリ／フレームワーク作者のニーズを優先しています。ほとんどのフレームワークは、`Signal.State` や `Signal.Computed` のような基本 API でさえ、独自の使いやすさを表現したものとしてラップすることが期待されます。実際には、Signals はフレームワークを通じて利用するのが最も適しており、より複雑な機能（例：Watcher, `untrack`）、および所有権や廃棄処理（例：いつシグナルをウォッチャーに追加・削除すべきかの判断）、DOMへの描画スケジューリングなども管理されます。これらは本提案の範囲外です。\n\n**Q**: ウィジェットが破棄されたときに、それに関連するシグナルも破棄しなければなりませんか？そのための API は何ですか？\n\n**A**: ここで該当する破棄操作は `Signal.subtle.Watcher.prototype.unwatch` です。監視されているシグナルのみを unwatch してクリーンアップする必要があり、監視されていないシグナルは自動的にガベージコレクションされます。\n\n**Q**: シグナルは VDOM や、直接 HTML DOM と連携できますか？\n\n**A**: はい！シグナルは描画技術に依存しません。Signal 的な仕組みを採用している既存 JavaScript フレームワークは、VDOM（例：Preact）、ネイティブ DOM（例：Solid）、その組み合わせ（例：Vue）と統合しています。ビルトイン Signals でも同様のことが可能です。\n\n**Q**: Angular や Lit のようなクラスベースのフレームワークでシグナルを使うのは使い勝手が悪くありませんか？Svelte のようなコンパイラベースのフレームワークでは？\n\n**A**: クラスフィールドは、[Signal polyfill の readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators) に示されているように、シンプルなアクセサデコレータで Signal ベースにできます。Signals は Svelte 5 の Runes と非常に密接に一致しており、コンパイラが runes をここで定義された Signal API に変換することは容易です。実際、Svelte 5 も内部的に（独自の Signals ライブラリで）このようにしています。\n\n**Q**: シグナルは SSR に対応していますか？ハイドレーションやレジューマビリティは？\n\n**A**: はい。Qwik はこれらの性質の両方でシグナルをうまく活用していますし、他のフレームワークも異なるトレードオフでシグナルを使ったハイドレーションのアプローチを持っています。Qwik のレジューマブルシグナルは、State シグナルと Computed シグナルを連結してモデル化できると考えており、これをコードで実証する計画です。",
  "status": "ok"
}