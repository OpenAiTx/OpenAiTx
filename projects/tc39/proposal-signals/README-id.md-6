{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "Status `state` dari Computed Signal dapat berupa salah satu dari berikut:\n\n- `~clean~`: Nilai Signal ada dan diketahui tidak usang.\n- `~checked~`: Sumber (tidak langsung) dari Signal ini telah berubah; Signal ini memiliki nilai tetapi _mungkin_ usang. Apakah nilainya usang atau tidak hanya akan diketahui setelah semua sumber langsung dievaluasi.\n- `~computing~`: Callback Signal ini sedang dieksekusi sebagai efek samping dari pemanggilan `.get()`.\n- `~dirty~`: Signal ini memiliki nilai yang diketahui usang, atau belum pernah dievaluasi.\n\nGraf transisi adalah sebagai berikut:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nTransisi-transisinya adalah:\n| Nomor | Dari | Ke | Kondisi | Algoritma |\n| ----- | ---- | -- | ------- | --------- |\n| 1 | `~checked~` | `~dirty~` | Sumber langsung dari signal ini, yang merupakan computed signal, telah dievaluasi, dan nilainya berubah. | Algoritma: hitung ulang dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | Sumber langsung dari signal ini, yang merupakan State, telah di-set, dengan nilai yang tidak sama dengan nilai sebelumnya. | Metode: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Sumber rekursif, tapi bukan langsung, dari signal ini, yang merupakan State, telah di-set, dengan nilai yang tidak sama dengan nilai sebelumnya. | Metode: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | Akan mengeksekusi `callback`. | Algoritma: hitung ulang dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | `callback` telah selesai dievaluasi dan mengembalikan nilai atau melempar exception. | Algoritma: hitung ulang dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | Semua sumber langsung dari signal ini telah dievaluasi, dan semuanya tidak berubah, sehingga sekarang diketahui tidak usang. | Algoritma: hitung ulang dirty computed Signal |\n\n#### Slot internal `Signal.Computed`\n\n- `value`: Nilai cache sebelumnya dari Signal, atau `~uninitialized~` untuk computed Signal yang belum pernah dibaca. Nilai bisa berupa exception yang akan dilempar ulang saat nilai dibaca. Selalu `undefined` untuk effect signals.\n- `state`: Dapat berupa `~clean~`, `~checked~`, `~computing~`, atau `~dirty~`.\n- `sources`: Set berurutan dari Signals yang menjadi dependensi Signal ini.\n- `sinks`: Set berurutan dari Signals yang bergantung pada Signal ini.\n- `equals`: Metode equals yang disediakan dalam opsi.\n- `callback`: Callback yang dipanggil untuk mendapatkan nilai computed Signal. Diatur ke parameter pertama yang diberikan ke konstruktor.\n\n#### Konstruktor `Signal.Computed`\n\nKonstruktor mengatur\n- `callback` ke parameter pertamanya\n- `equals` berdasarkan opsi, default ke `Object.is` jika tidak ada\n- `state` ke `~dirty~`\n- `value` ke `~uninitialized~`\n\nDengan [AsyncContext](https://github.com/tc39/proposal-async-context), callback yang diberikan ke `new Signal.Computed` menutup snapshot dari saat konstruktor dipanggil, dan mengembalikan snapshot ini selama eksekusinya.\n\n#### Metode: `Signal.Computed.prototype.get`\n\n1. Jika context eksekusi saat ini adalah `frozen` atau jika Signal ini memiliki state `~computing~`, atau jika signal ini adalah Watcher dan sedang `computing` sebuah computed Signal, lempar exception.\n1. Jika `computing` bukan `null`, tambahkan Signal ini ke set `sources` milik `computing`.\n1. CATATAN: Kita tidak menambahkan `computing` ke set `sinks` Signal ini sampai/selama belum menjadi watched oleh Watcher.\n1. Jika state Signal ini adalah `~dirty~` atau `~checked~`: Ulangi langkah berikut sampai Signal ini `~clean~`:\n    1. Rekursi ke atas melalui `sources` untuk menemukan sumber rekursif terdalam, paling kiri (yaitu yang diamati paling awal) yang merupakan Computed Signal bertanda `~dirty~` (hentikan pencarian saat menemukan Computed Signal `~clean~`, dan sertakan Computed Signal ini sebagai pencarian terakhir).\n    1. Lakukan algoritma \"hitung ulang dirty computed Signal\" pada Signal tersebut.\n1. Pada titik ini, state Signal ini akan `~clean~`, dan tidak ada sumber rekursif yang `~dirty~` atau `~checked~`. Kembalikan `value` Signal ini. Jika nilainya adalah exception, lempar ulang exception tersebut.\n\n### Kelas `Signal.subtle.Watcher`\n\n#### State machine `Signal.subtle.Watcher`\n\n`state` dari Watcher dapat berupa salah satu dari berikut:\n\n- `~waiting~`: Callback `notify` telah dijalankan, atau Watcher baru, namun belum secara aktif mengamati signal apapun.\n- `~watching~`: Watcher sedang aktif mengamati signals, namun belum ada perubahan yang memerlukan callback `notify`.\n- `~pending~`: Salah satu dependensi Watcher telah berubah, namun callback `notify` belum dijalankan.\n\nGraf transisi adalah sebagai berikut:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nTransisi-transisinya adalah:\n| Nomor | Dari | Ke | Kondisi | Algoritma |\n| ----- | ---- | -- | ------- | --------- |\n| 1 | `~waiting~` | `~watching~` | Metode `watch` milik Watcher telah dipanggil. | Metode: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Metode `unwatch` milik Watcher telah dipanggil, dan signal terakhir yang diamati telah dihapus. | Metode: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Signal yang diamati kemungkinan telah berubah nilai. | Metode: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | Callback `notify` telah dijalankan. | Metode: `Signal.State.prototype.set(newValue)` |\n\n#### Slot internal `Signal.subtle.Watcher`\n\n- `state`: Dapat berupa `~watching~`, `~pending~` atau `~waiting~`\n- `signals`: Set berurutan dari Signals yang sedang diamati oleh Watcher ini\n- `notifyCallback`: Callback yang dipanggil ketika ada perubahan. Diatur ke parameter pertama yang diberikan ke konstruktor.\n\n#### Konstruktor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` diatur ke `~waiting~`.\n1. Inisialisasi `signals` sebagai set kosong.\n1. `notifyCallback` diatur ke parameter callback.",
  "status": "ok"
}