{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "`Computed Signal` 的 `state` 可能为以下之一：\n\n- `~clean~`：该 Signal 的值已存在，并且已知不是过时的。\n- `~checked~`：该 Signal 的（间接）源已发生变化；该 Signal 有一个值，但它 _可能_ 是过时的。是否过时只有在所有直接源都被评估后才会知道。\n- `~computing~`：由于 `.get()` 调用的副作用，当前正在执行该 Signal 的回调。\n- `~dirty~`：该 Signal 的值已知为过时，或从未被评估过。\n\n状态转换图如下：\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\n转换如下：\n| 编号 | 从 | 到 | 条件 | 算法 |\n| ---- | -- | -- | ---- | ---- |\n| 1 | `~checked~` | `~dirty~` | 该信号的某个直接源（为 computed signal）已被评估，且其值已改变。 | 算法：重新计算 dirty 的 computed Signal |\n| 2 | `~clean~` | `~dirty~` | 该信号的某个直接源（为 State）已被设置，并且新值与之前的值不同。 | 方法：`Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | 该信号的某个递归但非直接源（为 State）已被设置，且新值与之前的值不同。 | 方法：`Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | 即将执行 `callback`。 | 算法：重新计算 dirty 的 computed Signal |\n| 5 | `~computing~` | `~clean~` | `callback` 已完成评估并返回值或抛出异常。 | 算法：重新计算 dirty 的 computed Signal |\n| 6 | `~checked~` | `~clean~` | 该信号的所有直接源均已评估，且均未发生变化，因此现在已知不是过时的。 | 算法：重新计算 dirty 的 computed Signal |\n\n#### `Signal.Computed` 内部插槽\n\n- `value`：Signal 之前缓存的值，或对于从未被读取过的 computed Signal 为 `~uninitialized~`。该值可能是一个异常，在读取值时会重新抛出。对于 effect signals 始终为 `undefined`。\n- `state`：可能为 `~clean~`、`~checked~`、`~computing~` 或 `~dirty~`。\n- `sources`：该 Signal 所依赖的 Signal 的有序集合。\n- `sinks`：依赖于该 Signal 的 Signal 的有序集合。\n- `equals`：选项中提供的 equals 方法。\n- `callback`：用于获取 computed Signal 值的回调。设置为构造函数传入的第一个参数。\n\n#### `Signal.Computed` 构造函数\n\n构造函数设置\n- `callback` 为第一个参数\n- `equals` 依据选项设置，若无则默认为 `Object.is`\n- `state` 为 `~dirty~`\n- `value` 为 `~uninitialized~`\n\n结合 [AsyncContext](https://github.com/tc39/proposal-async-context)，传递给 `new Signal.Computed` 的回调会捕获构造函数调用时的快照，并在执行期间恢复该快照。\n\n#### 方法：`Signal.Computed.prototype.get`\n\n1. 如果当前执行上下文为 `frozen`，或该 Signal 的状态为 `~computing~`，或该 signal 是 Watcher 且正在 `computing` 一个 computed Signal，则抛出异常。\n1. 如果 `computing` 不为 `null`，将该 Signal 添加到 `computing` 的 `sources` 集合中。\n1. 注意：在该 Signal 被 Watcher 观察之前，我们不会将 `computing` 添加到该 Signal 的 `sinks` 集合中。\n1. 如果该 Signal 的状态为 `~dirty~` 或 `~checked~`：重复以下步骤直到该 Signal 为 `~clean~`：\n    1. 通过 `sources` 递归向上，查找最深、最左（即最早被观察到的）的递归源，且该源为标记为 `~dirty~` 的 Computed Signal（遇到 `~clean~` 的 Computed Signal 则停止搜索，并将当前 Computed Signal 作为最后一个要搜索的对象）。\n    1. 对该 Signal 执行“重新计算 dirty 的 computed Signal”算法。\n1. 此时，该 Signal 的状态将为 `~clean~`，且没有递归源为 `~dirty~` 或 `~checked~`。返回 Signal 的 `value`。如果该值是异常，则重新抛出该异常。\n\n### `Signal.subtle.Watcher` 类\n\n#### `Signal.subtle.Watcher` 状态机\n\nWatcher 的 `state` 可能为以下之一：\n\n- `~waiting~`：`notify` 回调已被执行，或者 Watcher 是新建的，但未主动观察任何信号。\n- `~watching~`：Watcher 正在主动观察信号，但尚未发生任何需要执行 `notify` 回调的变化。\n- `~pending~`：Watcher 的依赖已发生变化，但尚未执行 `notify` 回调。\n\n状态转换图如下：\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\n转换如下：\n| 编号 | 从 | 到 | 条件 | 算法 |\n| ---- | -- | -- | ---- | ---- |\n| 1 | `~waiting~` | `~watching~` | 调用了 Watcher 的 `watch` 方法。 | 方法：`Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | 调用了 Watcher 的 `unwatch` 方法，且已移除最后一个被观察的信号。 | 方法：`Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | 被观察的信号可能已改变值。 | 方法：`Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | 已执行 `notify` 回调。 | 方法：`Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` 内部插槽\n\n- `state`：可能为 `~watching~`、`~pending~` 或 `~waiting~`\n- `signals`：该 Watcher 正在观察的 Signal 的有序集合\n- `notifyCallback`：当发生变化时调用的回调。设置为构造函数传入的第一个参数。\n\n#### 构造函数：`new Signal.subtle.Watcher(callback)`\n\n1. `state` 被设置为 `~waiting~`。\n1. 将 `signals` 初始化为空集合。\n1. `notifyCallback` 被设置为回调参数。",
  "status": "ok"
}