{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "Computed Signal의 `state`는 다음 중 하나일 수 있습니다:\n\n- `~clean~`: Signal의 값이 존재하며 오래되지 않았음이 확실합니다.\n- `~checked~`: 이 Signal의 (간접) 소스가 변경되었습니다. 이 Signal은 값을 갖고 있지만 _오래되었을 수도_ 있습니다. 실제로 오래되었는지 여부는 모든 즉각적인 소스가 평가될 때만 알 수 있습니다.\n- `~computing~`: 이 Signal의 콜백이 현재 `.get()` 호출의 부수 효과로 실행 중입니다.\n- `~dirty~`: 이 Signal의 값이 오래되었음이 확실하거나, 한 번도 평가된 적이 없습니다.\n\n전이 그래프는 다음과 같습니다:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\n전이 조건은 다음과 같습니다:\n| 번호 | From | To | 조건 | 알고리즘 |\n| ---- | ---- | -- | ---- | -------- |\n| 1 | `~checked~` | `~dirty~` | 이 Signal의 즉각적인 소스(계산된 Signal)가 평가되었고, 그 값이 변경됨. | 알고리즘: 오래된 계산 Signal 재계산 |\n| 2 | `~clean~` | `~dirty~` | 이 Signal의 즉각적인 소스(State)가 새 값으로 설정되었고, 그 값이 이전 값과 다름. | 메서드: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | 이 Signal의 재귀적(즉각적이지 않은) 소스(State)가 새 값으로 설정되었고, 그 값이 이전 값과 다름. | 메서드: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | `callback` 실행 직전. | 알고리즘: 오래된 계산 Signal 재계산 |\n| 5 | `~computing~` | `~clean~` | `callback` 평가가 완료되어 값이 반환되거나 예외가 발생함. | 알고리즘: 오래된 계산 Signal 재계산 |\n| 6 | `~checked~` | `~clean~` | 이 Signal의 모든 즉각적인 소스가 평가되었고, 모두 변경되지 않음이 확인됨. 이제 오래되지 않았음이 확실함. | 알고리즘: 오래된 계산 Signal 재계산 |\n\n#### `Signal.Computed` 내부 슬롯\n\n- `value`: Signal의 이전 캐시 값, 혹은 한 번도 읽히지 않은 계산 Signal의 경우 `~uninitialized~`. 값이 예외일 수 있으며, 이 경우 값을 읽을 때 예외가 재발생합니다. effect signals의 경우 항상 `undefined`.\n- `state`: `~clean~`, `~checked~`, `~computing~`, `~dirty~` 중 하나일 수 있습니다.\n- `sources`: 이 Signal이 의존하는 Signal들의 순서 있는 집합.\n- `sinks`: 이 Signal에 의존하는 Signal들의 순서 있는 집합.\n- `equals`: 옵션에서 제공된 equals 메서드.\n- `callback`: 계산 Signal의 값을 얻기 위해 호출되는 콜백. 생성자에 전달된 첫 번째 파라미터로 설정됩니다.\n\n#### `Signal.Computed` 생성자\n\n생성자는 다음을 설정합니다.\n- `callback`을 첫 번째 파라미터로 설정\n- 옵션에 따라 `equals`를 설정하며, 없으면 기본값은 `Object.is`\n- `state`를 `~dirty~`로 설정\n- `value`를 `~uninitialized~`로 설정\n\n[AsyncContext](https://github.com/tc39/proposal-async-context)와 함께, `new Signal.Computed`에 전달된 콜백은 생성자가 호출될 당시의 스냅샷을 클로저로 캡처하고, 실행 중에 이 스냅샷을 복원합니다.\n\n#### 메서드: `Signal.Computed.prototype.get`\n\n1. 현재 실행 컨텍스트가 `frozen`이거나 이 Signal의 상태가 `~computing~`인 경우, 또는 이 Signal이 Watcher이고 계산 Signal을 `computing` 중인 경우 예외를 발생시킵니다.\n1. `computing`이 `null`이 아니라면, 이 Signal을 `computing`의 `sources` 집합에 추가합니다.\n1. 참고: Watcher에 의해 관찰되기 전까지는 `computing`을 이 Signal의 `sinks` 집합에 추가하지 않습니다.\n1. 이 Signal의 상태가 `~dirty~` 또는 `~checked~`인 경우: 이 Signal이 `~clean~`이 될 때까지 다음 단계를 반복합니다:\n    1. `sources`를 따라 재귀적으로 올라가며, 가장 깊고(즉, 가장 먼저 관찰된) `~dirty~`로 표시된 계산 Signal을 찾습니다(`~clean~` 계산 Signal에 도달하면 탐색을 중단, 이 계산 Signal은 마지막에 탐색).\n    1. 해당 Signal에서 \"오래된 계산 Signal 재계산\" 알고리즘을 수행합니다.\n1. 이 시점에서 이 Signal의 상태는 `~clean~`이 되고, 재귀적 소스 중 `~dirty~` 또는 `~checked~`인 것은 없습니다. Signal의 `value`를 반환합니다. 값이 예외라면, 그 예외를 다시 발생시킵니다.\n\n### `Signal.subtle.Watcher` 클래스\n\n#### `Signal.subtle.Watcher` 상태 기계\n\nWatcher의 `state`는 다음 중 하나일 수 있습니다:\n\n- `~waiting~`: `notify` 콜백이 실행되었거나, Watcher가 새로 생성되었으나 현재 어떤 Signal도 적극적으로 관찰하지 않는 상태.\n- `~watching~`: Watcher가 Signal을 적극적으로 관찰 중이나, 아직 `notify` 콜백 실행이 필요한 변화가 없음.\n- `~pending~`: Watcher의 의존성이 변경되었으나, 아직 `notify` 콜백이 실행되지 않은 상태.\n\n전이 그래프는 다음과 같습니다:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\n전이 조건은 다음과 같습니다:\n| 번호 | From | To | 조건 | 알고리즘 |\n| ---- | ---- | -- | ---- | -------- |\n| 1 | `~waiting~` | `~watching~` | Watcher의 `watch` 메서드가 호출됨. | 메서드: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Watcher의 `unwatch` 메서드가 호출되고, 마지막 관찰 중인 Signal이 제거됨. | 메서드: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | 관찰 중인 Signal의 값이 변경될 수 있음. | 메서드: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | `notify` 콜백이 실행됨. | 메서드: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` 내부 슬롯\n\n- `state`: `~watching~`, `~pending~`, `~waiting~` 중 하나\n- `signals`: 이 Watcher가 관찰 중인 Signal들의 순서 있는 집합\n- `notifyCallback`: 변화가 감지될 때 호출되는 콜백. 생성자에 전달된 첫 번째 파라미터로 설정됨.\n\n#### 생성자: `new Signal.subtle.Watcher(callback)`\n\n1. `state`는 `~waiting~`으로 설정됩니다.\n1. `signals`는 빈 집합으로 초기화됩니다.\n1. `notifyCallback`은 콜백 파라미터로 설정됩니다.",
  "status": "ok"
}