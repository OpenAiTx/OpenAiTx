{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**V**: Werken Signals met een eenrichtingsdatastroom zoals React doet?\n\n**A**: Ja, Signals zijn een mechanisme voor een eenrichtingsdatastroom. Signal-gebaseerde UI-frameworks laten je je weergave uitdrukken als een functie van het model (waar het model Signals bevat). Een grafiek van state- en computed Signals is per constructie acyclisch. Het is ook mogelijk om React-antipatronen te recreëren binnen Signals (!), bijvoorbeeld het Signal-equivalent van een `setState` binnen `useEffect` is om een Watcher te gebruiken om een schrijfopdracht naar een State signal te plannen.\n\n**V**: Hoe verhouden signals zich tot state management systemen zoals Redux? Moedigen signals ongestructureerde state aan?\n\n**A**: Signals kunnen een efficiënte basis vormen voor winkelachtige state management abstracties. Een veelvoorkomend patroon in meerdere frameworks is een object gebaseerd op een Proxy die intern eigenschappen weergeeft met behulp van Signals, bijvoorbeeld [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), of [Solid stores](https://docs.solidjs.com/concepts/stores). Deze systemen maken flexibele groepering van state mogelijk op het juiste abstractieniveau voor de specifieke applicatie.\n\n**V**: Wat bieden Signals dat `Proxy` momenteel niet aankan?\n\n**A**: Proxies en Signals zijn complementair en werken goed samen. Proxies laten je oppervlakkige objectbewerkingen onderscheppen en signals coördineren een afhankelijkheidsgrafiek (van cellen). Een Proxy ondersteunen met Signals is een geweldige manier om een geneste reactieve structuur te maken met uitstekende ergonomie.\n\nIn dit voorbeeld kunnen we een proxy gebruiken om het signal een getter- en setter-eigenschap te geven in plaats van de `get`- en `set`-methoden te gebruiken:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// gebruik in een hypothetische reactieve context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>verander</button>\n</template>\n```\nwanneer je een renderer gebruikt die is geoptimaliseerd voor fijne reactiviteit, zal het klikken op de knop de `b.value`-cel bijwerken.\n\nZie:\n- voorbeelden van geneste reactieve structuren gemaakt met zowel Signals als Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- voorbeeld van eerdere implementaties die de relatie tonen tussen reactieve data en proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussie](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Hoe werken Signals?\n\n**V**: Zijn Signals push-based of pull-based?\n\n**A**: Evaluatie van computed Signals is pull-based: computed Signals worden alleen geëvalueerd wanneer `.get()` wordt aangeroepen, zelfs als de onderliggende state veel eerder is gewijzigd. Tegelijkertijd kan het wijzigen van een State signal onmiddellijk een Watcher-callback activeren, waarbij de notificatie \"gepusht\" wordt. Signals kunnen dus worden gezien als een \"push-pull\" constructie.\n\n**V**: Introduceren Signals non-determinisme in JavaScript-uitvoering?\n\n**A**: Nee. Ten eerste hebben alle Signal-operaties goed gedefinieerde semantiek en volgorde, en zullen ze niet verschillen tussen conforme implementaties. Op een hoger niveau volgen Signals een bepaald aantal invarianties, waarmee ze \"sound\" zijn. Een computed Signal observeert altijd de Signal-grafiek in een consistente toestand, en zijn uitvoering wordt niet onderbroken door andere Signal-mutatiecode (behalve voor dingen die het zelf aanroept). Zie de bovenstaande beschrijving.\n\n**V**: Wanneer ik naar een state Signal schrijf, wanneer wordt de update van het computed Signal gepland?\n\n**A**: Dat wordt niet gepland! Het computed Signal zal zichzelf opnieuw berekenen de volgende keer dat iemand het uitleest. Synchronously, een Watcher's `notify` callback kan worden aangeroepen, waardoor frameworks een uitlezing kunnen plannen op het moment dat zij dat gepast vinden.\n\n**V**: Wanneer worden schrijfbewerkingen naar state Signals van kracht? Onmiddellijk, of worden ze gebatcht?\n\n**A**: Schrijfbewerkingen naar state Signals worden onmiddellijk doorgevoerd—de volgende keer dat een computed Signal dat afhankelijk is van het state Signal wordt uitgelezen, zal het zichzelf opnieuw berekenen indien nodig, zelfs als dit in de direct volgende regel code is. De luiheid die inherent is aan dit mechanisme (dat computed Signals alleen worden berekend wanneer ze worden uitgelezen) betekent echter dat de berekeningen in de praktijk gebatcht kunnen plaatsvinden.\n\n**V**: Wat betekent het dat Signals \"glitch-free\" uitvoering mogelijk maken?\n\n**A**: Eerdere push-based modellen voor reactiviteit kenden het probleem van overbodige berekening: Als een update van een state Signal het computed Signal meteen laat draaien, kan dit uiteindelijk een update naar de UI pushen. Maar deze schrijfopdracht naar de UI kan voortijdig zijn, als er nog een andere wijziging aan het oorspronkelijke state Signal zou komen vóór het volgende frame. Soms werden onnauwkeurige tussenliggende waarden zelfs aan eindgebruikers getoond door zulke [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals vermijden deze dynamiek door pull-based te zijn, in plaats van push-based: Op het moment dat het framework de rendering van de UI plant, haalt het de juiste updates op, waardoor verspilde arbeid wordt voorkomen, zowel in berekening als in het schrijven naar de DOM.\n\n**V**: Wat betekent het dat Signals \"lossy\" zijn?\n\n**A**: Dit is de keerzijde van glitch-free uitvoering: Signals vertegenwoordigen een cel van data—alleen de directe actuele waarde (die kan veranderen), niet een stroom van data in de tijd. Dus als je twee keer achter elkaar naar een state Signal schrijft, zonder iets anders te doen, gaat de eerste schrijfopdracht \"verloren\" en wordt deze nooit gezien door een computed Signal of effect. Dit wordt gezien als een feature, niet als een bug—voor datastromen zijn andere constructen (zoals async iterables, observables) meer geschikt.\n\n**V**: Zullen native Signals sneller zijn dan bestaande JS Signal-implementaties?\n\n**A**: Hopelijk wel (met een kleine constante factor), maar dat moet nog bewezen worden in code. JS-engines zijn geen magie, en zullen uiteindelijk dezelfde soorten algoritmen moeten implementeren als JS-implementaties van Signals. Zie de bovenstaande sectie over prestaties.\n\n#### Waarom zijn Signals op deze manier ontworpen?\n\n**V**: Waarom bevat dit voorstel geen `effect()`-functie, terwijl effecten nodig zijn voor praktisch gebruik van Signals?\n\n**A**: Effecten zijn inherent verbonden aan scheduling en disposal, die door frameworks worden beheerd en buiten de scope van dit voorstel vallen. In plaats daarvan bevat dit voorstel de basis voor het implementeren van effecten via de meer low-level `Signal.subtle.Watcher` API.\n\n**V**: Waarom zijn abonnementen automatisch in plaats van een handmatige interface te bieden?\n\n**A**: Ervaring heeft geleerd dat handmatige abonnementsinterfaces voor reactiviteit onergonomisch en foutgevoelig zijn. Automatische tracking is meer composable en is een kernfunctie van Signals.\n\n**V**: Waarom wordt de callback van de `Watcher` synchronisch uitgevoerd, in plaats van gepland in een microtask?\n\n**A**: Omdat de callback geen Signals kan lezen of schrijven, ontstaat er geen inconsistentie door deze synchronisch aan te roepen. Een typische callback voegt een Signal toe aan een Array om later te lezen, of zet ergens een bit. Het is onnodig en onpraktisch duur om voor al deze acties een aparte microtask te maken.\n\n**V**: Deze API mist enkele mooie dingen die mijn favoriete framework biedt, waardoor het makkelijker wordt om met Signals te programmeren. Kan dat ook aan de standaard worden toegevoegd?\n\n**A**: Misschien. Diverse uitbreidingen worden nog overwogen. Dien gerust een issue in om een discussie te starten over een ontbrekende functie die je belangrijk vindt.\n\n**V**: Kan deze API in omvang of complexiteit worden verminderd?\n\n**A**: Het is zeker een doel om deze API minimaal te houden, en we hebben geprobeerd dat te doen met wat hierboven gepresenteerd is. Als je ideeën hebt voor zaken die verwijderd kunnen worden, dien dan een issue in om dit te bespreken.\n\n#### Hoe worden Signals gestandaardiseerd?\n\n**V**: Moeten we het standaardisatieproces op dit gebied niet beginnen met een primitiever concept, zoals observables?",
  "status": "ok"
}