{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Rastreamento Automático de Dependências** - Um Signal computado descobre automaticamente quaisquer outros Signals dos quais depende, sejam esses Signals valores simples ou outros cálculos.\n* **Avaliação Preguiçosa (Lazy Evaluation)** - Os cálculos não são avaliados de forma ávida quando são declarados, nem são imediatamente avaliados quando suas dependências mudam. Eles só são avaliados quando seu valor é explicitamente solicitado.\n* **Memoização** - Signals computados armazenam em cache seu último valor para que cálculos cujas dependências não mudaram não precisem ser reavaliados, não importa quantas vezes sejam acessados.\n\n## Motivação para padronizar Signals\n\n#### Interoperabilidade\n\nCada implementação de Signal tem seu próprio mecanismo de rastreamento automático, para acompanhar as fontes encontradas ao avaliar um Signal computado. Isso dificulta o compartilhamento de modelos, componentes e bibliotecas entre diferentes frameworks--eles tendem a vir com um falso acoplamento ao seu mecanismo de visualização (visto que Signals geralmente são implementados como parte de frameworks JS).\n\nUm objetivo desta proposta é desacoplar totalmente o modelo reativo da visualização de renderização, permitindo que desenvolvedores migrem para novas tecnologias de renderização sem reescrever seu código não relacionado à interface, ou desenvolvam modelos reativos compartilhados em JS para serem implantados em diferentes contextos. Infelizmente, devido a versionamento e duplicidade, revelou-se impraticável alcançar um forte nível de compartilhamento via bibliotecas em JS--os built-ins oferecem uma garantia de compartilhamento mais forte.\n\n#### Desempenho/Uso de memória\n\nSempre há um pequeno potencial de ganho de desempenho ao embarcar menos código devido a bibliotecas comumente usadas serem internas, mas as implementações de Signals geralmente são bastante pequenas, então não esperamos que esse efeito seja muito grande.\n\nSuspeitamos que implementações nativas em C++ das estruturas de dados e algoritmos relacionados a Signal possam ser ligeiramente mais eficientes do que o que é possível em JS, por um fator constante. No entanto, não são antecipadas mudanças algorítmicas em relação ao que estaria presente em um polyfill; não se espera que os engines sejam mágicos aqui, e os próprios algoritmos de reatividade serão bem definidos e inequívocos.\n\nO grupo responsável espera desenvolver várias implementações de Signals e usá-las para investigar essas possibilidades de desempenho.\n\n#### DevTools\n\nCom as bibliotecas de Signal existentes em JS, pode ser difícil rastrear coisas como:\n* A stack de chamadas através de uma cadeia de Signals computados, mostrando a cadeia causal para um erro\n* O grafo de referências entre Signals, quando um depende de outro -- importante ao depurar uso de memória\n\nSignals embutidos permitem que runtimes JS e DevTools tenham potencialmente um suporte aprimorado para inspecionar Signals, particularmente para depuração ou análise de desempenho, seja isso integrado aos navegadores ou por meio de uma extensão compartilhada. Ferramentas existentes como o inspetor de elementos, snapshot de desempenho e analisadores de memória poderiam ser atualizados para destacar especificamente Signals em sua apresentação de informações.\n\n#### Benefícios secundários\n\n##### Benefícios de uma biblioteca padrão\n\nEm geral, o JavaScript tem uma biblioteca padrão relativamente mínima, mas uma tendência no TC39 tem sido tornar o JS uma linguagem mais \"baterias incluídas\", com um conjunto de funcionalidades internas e de alta qualidade disponível. Por exemplo, Temporal está substituindo o moment.js, e vários recursos pequenos, como `Array.prototype.flat` e `Object.groupBy`, estão substituindo muitos casos de uso do lodash. Os benefícios incluem tamanhos de bundle menores, maior estabilidade e qualidade, menos para aprender ao entrar em um novo projeto, e um vocabulário geralmente comum entre desenvolvedores JS.\n\n##### Integração HTML/DOM (possibilidade futura)\n\nTrabalhos atuais no W3C e por implementadores de navegadores buscam trazer templating nativo para HTML ([DOM Parts][wicg-pr-1023] e [Template Instantiation][wicg-propsal-template-instantiation]). Além disso, o W3C Web Components CG está explorando a possibilidade de estender Web Components para oferecer uma API HTML totalmente declarativa. Para alcançar ambos os objetivos, eventualmente será necessário um primitivo reativo no HTML. Além disso, muitas melhorias ergonômicas no DOM por meio da integração de Signals podem ser imaginadas e já foram solicitadas pela comunidade.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Nota: essa integração seria um esforço separado para o futuro, não faz parte desta proposta em si.\n\n##### Troca de informações no ecossistema (*não* é motivo para embarcar)\n\nEsforços de padronização às vezes podem ser úteis apenas no nível da \"comunidade\", mesmo sem mudanças nos navegadores. O esforço dos Signals está reunindo muitos autores de frameworks diferentes para uma discussão profunda sobre a natureza da reatividade, algoritmos e interoperabilidade. Isso já tem sido útil, mas não justifica a inclusão em engines JS e navegadores; Signals só devem ser adicionados ao padrão JavaScript se houver benefícios significativos *além* da troca de informações do ecossistema viabilizada.\n\n## Objetivos de design para Signals\n\nAcontece que as bibliotecas de Signal existentes não são tão diferentes umas das outras, em sua essência. Esta proposta visa se apoiar em seu sucesso, implementando as qualidades importantes de muitas dessas bibliotecas.\n\n### Funcionalidades principais\n\n* Um tipo Signal que representa estado, ou seja, Signal gravável. Este é um valor que outros podem ler.\n* Um tipo Signal computado/memo/derivado, que depende de outros e é calculado de forma preguiçosa e armazenado em cache.\n    * O cálculo é preguiçoso, ou seja, Signals computados não são calculados novamente por padrão quando uma de suas dependências muda, mas apenas executados se alguém realmente os ler.\n    * O cálculo é \"[livre de glitches](https://pt.wikipedia.org/wiki/Programação_reativa#Glitches)\", ou seja, nenhum cálculo desnecessário é realizado. Isso implica que, quando uma aplicação lê um Signal computado, há uma ordenação topológica das partes potencialmente sujas do grafo a serem executadas, para eliminar duplicatas.\n    * O cálculo é armazenado em cache, ou seja, se, após a última vez que uma dependência mudou, nenhuma dependência mudou, então o Signal computado *não* é recalculado ao ser acessado.\n    * Comparações personalizadas são possíveis tanto para Signals computados quanto para Signals de estado, para indicar quando outros Signals computados que dependem deles devem ser atualizados.\n* Reações à condição em que um Signal computado tem uma de suas dependências (ou dependências aninhadas) tornando-se \"suja\" e mudando, significando que o valor do Signal pode estar desatualizado.\n    * Esta reação serve para agendar trabalhos mais significativos a serem realizados posteriormente.\n    * Efeitos são implementados em termos dessas reações, mais agendamento em nível de framework.\n    * Signals computados precisam da capacidade de reagir a serem registrados como uma dependência (aninhada) de uma dessas reações.\n* Permitir que frameworks JS façam seu próprio agendamento. Nenhum agendamento embutido obrigatório no estilo Promise.\n    * Reações síncronas são necessárias para permitir o agendamento de trabalho posterior com base na lógica do framework.\n    * Escritas são síncronas e têm efeito imediato (um framework que faz batch das escritas pode implementar isso por cima).\n    * É possível separar a verificação se um efeito pode estar \"sujo\" de realmente rodar o efeito (permitindo um agendador de efeitos em dois estágios).\n* Capacidade de ler Signals *sem* acionar o registro de dependências (`untrack`)\n* Possibilitar a composição de diferentes bases de código que usam Signals/reatividade, por exemplo,\n    * Usar múltiplos frameworks juntos no que diz respeito ao rastreamento/reatividade em si (com ressalvas, veja abaixo)\n    * Estruturas de dados reativas independentes de framework (por exemplo, proxy de store recursivamente reativo, Map e Set e Array reativos, etc.)\n\n### Solidez\n\n* Desencorajar/proibir o uso ingênuo de reações síncronas.\n    * Risco de solidez: pode expor \"[glitches](https://pt.wikipedia.org/wiki/Programação_reativa#Glitches)\" se usado de forma inadequada: Se a renderização for feita imediatamente quando um Signal é definido, pode expor um estado de aplicação incompleto para o usuário final. Portanto, esse recurso deve ser usado apenas para agendar trabalho de forma inteligente para depois que a lógica da aplicação estiver concluída.\n    * Solução: Proibir leitura e escrita de qualquer Signal de dentro de um callback de reação síncrona.\n* Desencorajar `untrack` e marcar sua natureza não sólida\n    * Risco de solidez: permite a criação de Signals computados cujo valor depende de outros Signals, mas que não são atualizados quando esses Signals mudam. Deve ser usado quando os acessos não rastreados não mudam o resultado do cálculo.\n    * Solução: A API é marcada como \"unsafe\" no nome.\n* Nota: Esta proposta permite que signals sejam lidos e escritos tanto de signals computados quanto de efeito, sem restringir escritas que venham após leituras, apesar do risco para a solidez. Essa decisão foi tomada para preservar flexibilidade e compatibilidade na integração com frameworks.\n\n### API de superfície\n\n* Deve ser uma base sólida para múltiplos frameworks implementarem seus mecanismos de Signals/reatividade.\n    * Deve ser uma boa base para proxies de store recursivos, reatividade baseada em decoradores em campos de classe, e APIs tanto no estilo `.value` quanto `[state, setState]`.\n    * A semântica é capaz de expressar os padrões válidos habilitados por diferentes frameworks. Por exemplo, deve ser possível que esses Signals sejam a base de escritas refletidas imediatamente ou escritas que são agrupadas e aplicadas posteriormente.\n* Seria interessante se essa API fosse utilizável diretamente por desenvolvedores JavaScript.\n    * Se um recurso se alinha com um conceito do ecossistema, usar o vocabulário comum é bom.\n        * Contudo, é importante não literalmente copiar exatamente os mesmos nomes!\n    * Tensão entre \"usabilidade por devs JS\" e \"oferecer todos os ganchos para frameworks\"\n        * Ideia: Oferecer todos os ganchos, mas incluir erros quando usados de forma inadequada, se possível.\n        * Ideia: Colocar APIs sutis em um namespace `subtle`, semelhante ao [`crypto.subtle`](https://developer.mozilla.org/pt-BR/docs/Web/API/Crypto/subtle), para marcar a linha entre APIs necessárias para uso avançado como implementação de frameworks ou ferramentas de dev versus uso cotidiano como instanciar signals para uso com um framework.\n* Ser implementável e utilizável com bom desempenho -- a API de superfície não causa overhead excessivo\n    * Permitir subclassificação, para que frameworks possam adicionar seus próprios métodos e campos, incluindo campos privados. Isso é importante para evitar a necessidade de alocações adicionais no nível do framework. Veja \"Gerenciamento de memória\" abaixo.\n\n### Gerenciamento de memória\n\n* Se possível: Um Signal computado deve ser coletável pelo garbage collector se nada vivo estiver referenciando-o para leituras futuras possíveis, mesmo que ele esteja ligado em um grafo mais amplo que permaneça vivo (por exemplo, lendo um estado que permanece vivo).",
  "status": "ok"
}