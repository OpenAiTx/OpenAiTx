{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **自動依賴追蹤** - 計算型 Signal 會自動發現它所依賴的其他 Signal，無論這些 Signal 是簡單值還是其他運算。\n* **延遲求值** - 計算不會在宣告時立即執行，也不會在其依賴變更時馬上執行。只有在明確要求其值時才會執行。\n* **記憶體快取** - 計算型 Signal 會快取其最後一次的值，因此只要其依賴沒有變更，無論被存取多少次，都不需要重新計算。\n\n## 將 Signals 標準化的動機\n\n#### 互通性\n\n每個 Signal 的實作都有自己的自動追蹤機制，用於記錄在評估計算型 Signal 時遇到的來源。這使得在不同框架間分享模型、元件和函式庫變得困難——它們往往會與其視圖引擎產生虛假的耦合（因為 Signals 通常是 JS 框架的一部分）。\n\n本提案的目標是徹底將響應式模型從渲染視圖中解耦，使開發人員能夠在不重寫非 UI 代碼的情況下，遷移到新的渲染技術，或是在 JS 中開發可在不同情境下部署的共用響應式模型。不幸的是，由於版本控制和重複問題，僅靠 JS 層級函式庫很難實現高度的共用——內建功能能提供更強的共用保證。\n\n#### 效能／記憶體使用\n\n由於常用函式庫內建後能減少傳送的程式碼，理論上總會有些微效能提升，但 Signals 的實作通常相當精簡，因此我們不預期這個效益會很大。\n\n我們推測，Signal 相關資料結構和演算法的原生 C++ 實作在效率上可略勝於 JS 實作，差異為常數因子。然而，預期不會有任何演算法上的變動，與 polyfill 實作無異；引擎不會在這裡有「魔法」，響應式的演算法本身將被明確且無歧義地定義。\n\n冠軍小組預計會開發多種 Signal 實作，並用來探討這些效能的可能性。\n\n#### 開發工具（DevTools）\n\n在現有的 JS 語言 Signal 函式庫中，追蹤以下事項可能會很困難：\n* 一連串計算型 Signal 的呼叫堆疊，顯示錯誤的因果鏈\n* Signal 之間的參考圖——當一個依賴於另一個時，這在偵錯記憶體使用時很重要\n\n內建的 Signal 可使 JS 執行環境與開發工具有機會更好地支援 Signal 的檢查，特別是在除錯或效能分析時，不論是內建於瀏覽器還是透過共用擴充。現有的工具如元素檢查器、效能快照和記憶體分析器都可以更新，專門在資訊展示時高亮顯示 Signal。\n\n#### 次要效益\n\n##### 標準函式庫的好處\n\n一般而言，JavaScript 的標準函式庫相當精簡，但 TC39 的趨勢是讓 JS 成為一個「內建電池」的語言，提供高品質、內建的功能。例如 Temporal 取代 moment.js，還有許多小功能，如 `Array.prototype.flat` 和 `Object.groupBy`，取代了許多 lodash 的用例。好處包括更小的 bundle 大小、提升的穩定性與品質、加入新專案時需要學習的東西更少，以及 JS 開發者之間更通用的詞彙。\n\n##### HTML/DOM 整合（未來的可能性）\n\n目前 W3C 及瀏覽器實作者正在致力於將原生樣板引入 HTML（[DOM Parts][wicg-pr-1023] 及 [Template Instantiation][wicg-propsal-template-instantiation]）。此外，W3C Web Components CG 也在探索將 Web Components 擴展為完全宣告式 HTML API 的可能性。要實現這兩個目標，HTML 最終都需要一個響應式原語。此外，社群也提出了許多透過 Signal 整合提升 DOM 易用性的想像與需求。\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> 注意，此整合將會是之後的獨立工作，並不包含在本提案內。\n\n##### 生態資訊交流（*並非* 推出標準的理由）\n\n標準化的努力有時即使不改變瀏覽器，也能在「社群」層面帶來幫助。Signals 的討論已經匯聚了許多不同框架的作者，深入討論了響應式本質、演算法與互通性。這已經帶來益處，但這不足以成為 JS 引擎和瀏覽器納入的理由；只有當 Signals 帶來超越生態資訊交流的重大效益時，才應加入 JavaScript 標準。\n\n## Signals 的設計目標\n\n事實證明，現有的 Signal 函式庫在核心設計上大同小異。本提案旨在建立在這些成功之上，實現許多函式庫的重要特性。\n\n### 核心功能\n\n* 一個代表狀態的 Signal 類型，即可寫入的 Signal。這是一個可供他人讀取的值。\n* 一個計算型／記憶型／派生型 Signal 類型，依賴於其他 Signal，並以延遲計算和快取方式運作。\n    * 計算是延遲的，這代表計算型 Signal 預設不會在其依賴變動時立即重新計算，只有在被讀取時才會執行。\n    * 計算是「[無故障](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)」的，代表永遠不會執行不必要的計算。這表示，當應用程式讀取計算型 Signal 時，會對圖中可能髒掉的部分做拓撲排序，消除重複運算。\n    * 計算會快取，如果自上次依賴變更後，沒有任何依賴變動，那麼計算型 Signal 在被存取時*不會*重新計算。\n    * 無論是計算型 Signal 還是狀態型 Signal，都可以自訂比對方式，用來決定依賴它們的進一步計算型 Signal 是否需要更新。\n* 對於計算型 Signal 的依賴（或巢狀依賴）「髒掉」並變更，導致該 Signal 的值可能過時時，能夠做出反應。\n    * 這個反應用來安排日後需執行的更重要工作。\n    * Effect 是以這些反應加上框架層級的排程來實作。\n    * 計算型 Signal 需要能夠反應自己是否被註冊為這些反應的（巢狀）依賴。\n* 允許 JS 框架自訂排程。沒有強制 Promise 風格的內建排程。\n    * 需要同步反應，以便根據框架邏輯安排日後的工作。\n    * 寫入是同步且立即生效的（框架若要批次寫入可在其上層實作）。\n    * 可以將檢查 effect 是否「髒掉」與實際執行 effect 分開（允許兩階段 effect 排程器）。\n* 能夠在*不*觸發依賴記錄的情況下讀取 Signal（`untrack`）\n* 允許組合使用不同 codebase 的 Signal／響應式機制，例如：\n    * 就追蹤／響應式本身而言，能一起使用多個框架（但有例外，見下文）\n    * 與框架無關的響應式資料結構（如遞迴響應式 store proxy、響應式 Map、Set、Array 等）\n\n### 健全性（Soundness）\n\n* 勸阻或禁止對同步反應的天真濫用。\n    * 健全性風險：若使用不當，可能暴露「[故障](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)」：若在設定 Signal 時立即渲染，最終用戶可能會看到不完整的應用狀態。因此，此功能應僅用於在應用邏輯完成後，智慧地安排後續工作。\n    * 解決方案：禁止在同步反應回呼中讀寫任何 Signal\n* 勸阻 `untrack` 的使用並標示其不健全性\n    * 健全性風險：允許建立其值依賴於其他 Signal 的計算型 Signal，但當這些 Signal 變動時卻不會更新。應僅在未追蹤的存取不會影響運算結果時使用。\n    * 解決方案：API 在名稱上標記為「unsafe」。\n* 注意：本提案允許在計算型和 effect Signal 中讀寫 Signal，且不限制讀之後的寫，儘管有健全性風險。這樣決定是為了在與框架整合時保留彈性和相容性。\n\n### 外部 API\n\n* 必須是一個穩固的基礎，能讓多個框架實作其 Signal／響應式機制。\n    * 應能作為遞迴 store proxy、基於裝飾器的類別欄位響應式，以及 `.value` 與 `[state, setState]` 風格 API 的良好基礎。\n    * 語意能表達不同框架啟用的有效模式。例如，這些 Signal 應能作為即時反映寫入或寫入後批次套用的基礎。\n* 若此 API 能被 JavaScript 開發者直接使用會更好。\n    * 若某功能與生態系概念相符，使用通用詞彙較佳。\n        * 但重要的是不要完全照搬相同名稱！\n    * 在「JS 開發者可用性」與「提供框架所有介面」間取得平衡\n        * 構想：提供所有介面，但盡可能在誤用時加上錯誤提示。\n        * 構想：將細微 API 放在 `subtle` 命名空間，類似 [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle)，區分實作框架或開發工具等進階用途的 API 與日常應用開發用來實例化 Signal 的 API。\n* 必須能以良好效能實作與使用——外部 API 不會造成太多額外負擔\n    * 允許子類化，讓框架能加上自己的方法和欄位，包括私有欄位。這對避免框架層級多餘配置很重要。詳見下方「記憶體管理」。\n\n### 記憶體管理\n\n* 若可行：若沒有任何活動引用會在未來讀取，計算型 Signal 應能被垃圾回收，即使它連結在仍存活的更大圖中（例如，讀取了一個仍存活的狀態）。",
  "status": "ok"
}