{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Bir Observable'ın, yalnızca bir etki tarafından kullanıldığında abone olunan, hesaplanan bir signale dönüştürülmesi örneğini gösterin\n\nTODO: Bir duruma yönlendirilen bir fetch'in sonucunu temsil eden ve iptal edilen bir hesaplanan signal örneğini gösterin\n\n### SSR için İçgörü\n\nTODO: Signal grafiğinin serileştirilmesinin nasıl çalıştığını gösterin\n\nTODO: Birkaç signal kullanarak bir signal'in daha sonra duruma ya da hesaplanana \"hidrate\" edilebileceğini gösterin.\n-->\n\n### Şimdilik Atlananlar\n\nBu özellikler daha sonra eklenebilir, ancak mevcut taslakta yer almamaktadır. Atlanmalarının nedeni, tasarım alanında frameworkler arasında yerleşik bir uzlaşmanın olmaması ve ayrıca bu belgede açıklanan Signal kavramının üzerine inşa edilen mekanizmalarla yokluklarının etrafından dolaşılabilmesidir. Ancak ne yazık ki, bu eksiklik frameworkler arası birlikte çalışabilirliğin potansiyelini sınırlar. Bu belgede tanımlanan Signal prototipleri üretildikçe, bu atlamaların uygun bir karar olup olmadığını yeniden değerlendirme çabası olacaktır.\n\n* **Async**: Bu modelde, signal'lar her zaman eşzamanlı olarak değerlendirmeye hazırdır. Ancak, bir signal'in ayarlanmasına yol açan belirli eşzamansız süreçlere sahip olmak ve bir signal'in hâlâ \"yükleniyor\" olup olmadığını anlamak genellikle faydalıdır. Yüklenme durumunu modellemenin basit bir yolu istisnalarla çalışmaktır ve hesaplanan signal'lerin istisna önbellekleme davranışı bu teknikle bir ölçüde makul şekilde birleşir. Geliştirilmiş teknikler [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30) adresinde tartışılmıştır.\n* **Transactions**: Görünümler arasında geçişler için, hem \"from\" hem de \"to\" durumlarının canlı durumunu korumak çoğu zaman faydalıdır. \"To\" durumu arka planda işlenir, takas edilene (işlemi tamamlayana) kadar, bu sırada \"from\" durumu etkileşimli olarak kalır. Her iki durumu aynı anda korumak, signal grafiğinin durumunun \"forklanmasını\" gerektirir ve aynı anda birden fazla beklemede geçişi desteklemek de faydalı olabilir. Tartışma [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73) adresindedir.\n\nBazı olası [kolaylık yöntemleri](https://github.com/proposal-signals/proposal-signals/issues/32) de atlanmıştır.\n\n## Durum ve Geliştirme Planı\n\nBu teklif, Nisan 2024 TC39 gündeminde Aşama 1 için yer almaktadır. Şu anda \"Aşama 0\" olarak düşünülebilir.\n\n[Bir polyfill](https://github.com/proposal-signals/signal-polyfill) bu teklif için mevcuttur ve bazı temel testlerle birlikte gelir. Bazı framework yazarları bu signal uygulamasını ikame etmek üzerinde denemelere başlamıştır, ancak bu kullanım erken bir aşamadadır.\n\nSignal teklifi üzerinde çalışan işbirlikçiler, bu teklifi nasıl ilerleteceğimiz konusunda özellikle **temkinli** olmak istiyorlar, böylece sonunda pişman olacağımız ve aslında kullanmayacağımız bir şeyin yayımlanması tuzağına düşmeyelim. Planımız, bu teklifin yolunda olduğundan emin olmak için TC39 süreci tarafından gerekmeyen aşağıdaki ekstra görevleri yapmak:\n\nAşama 2 için teklif vermeden önce şunları yapmayı planlıyoruz:\n- Sağlam, iyi test edilmiş (örneğin, çeşitli frameworklerden alınan testleri ve test262 tarzı testleri geçen), performans açısından rekabetçi (kapsamlı bir signal/framework kıyaslama seti ile doğrulanmış) birden fazla üretim kalitesinde polyfill uygulamaları geliştirmek.\n- Önerilen Signal API'sini, bize bir ölçüde temsil edici görünen çok sayıda JS framework'e entegre etmek ve bazı büyük uygulamaların bu temelle çalışmasını sağlamak. Bu bağlamlarda verimli ve doğru şekilde çalıştığını test etmek.\n- API'ye yapılabilecek olası genişletmelerin alanında sağlam bir anlayışa sahip olmak ve bunlardan hangilerinin (varsa) bu teklife eklenmesi gerektiğine karar vermiş olmak.\n\n## Signal algoritmaları\n\nBu bölüm, JavaScript'e açığa çıkan her bir API'yi, uyguladıkları algoritmalar açısından açıklar. Bu, bir proto-şartname olarak düşünülebilir ve olası bir anlamlar kümesini belirlemek için bu erken aşamada dahil edilmiştir, ancak değişikliklere çok açıktır.\n\nAlgoritmanın bazı yönleri:\n- Bir hesaplananda Signal'ların okunma sırası önemlidir ve bazı geri çağırımların (örneğin `Watcher`'ın tetiklenme sırası, `equals`, `new Signal.Computed`'a ilk parametre ve `watched`/`unwatched` geri çağırımları) yürütülme sırası ile gözlemlenebilir. Bu, bir hesaplanan Signal'ın kaynaklarının sıralı depolanması gerektiği anlamına gelir.\n- Bu dört geri çağırımın hepsi istisna fırlatabilir ve bu istisnalar öngörülebilir şekilde çağıran JS koduna iletilir. İstisnalar, bu algoritmanın yürütülmesini durdurmaz veya grafiği yarı işlenmiş bir durumda bırakmaz. Bir Watcher'ın `notify` geri çağırımında fırlatılan hatalar için, bu istisna, onu tetikleyen `.set()` çağrısına iletilir, eğer birden fazla istisna fırlatıldıysa bunlar AggregateError ile paketlenir. Diğerleri (dahil `watched`/`unwatched`?) Signal'in değerinde saklanır, okunurken tekrar fırlatılır ve böyle tekrar fırlatan bir Signal, normal bir değeri olanlar gibi `~clean~` olarak işaretlenebilir.\n- \"Watched\" olmayan (herhangi bir Watcher tarafından gözlemlenmeyen) hesaplanan signal'lerde döngüselliği önlemek için özen gösterilir, böylece bunlar signal grafiğinin diğer bölümlerinden bağımsız olarak garbage collection ile toplanabilir. Dahili olarak, bu her zaman toplanan nesil numaraları sistemiyle uygulanabilir; optimize edilmiş uygulamalarda yerel düğüm başına nesil numaraları da bulunabilir veya izlenen signal'larda bazı numaraların izlenmesinden kaçınılabilir.\n\n### Gizli Global Durum\n\nSignal algoritmalarının bazı global durumlara başvurması gerekir. Bu durum, tüm thread ya da \"ajan\" için globaldir.\n\n- `computing`: Şu anda bir `.get` veya `.run` çağrısı nedeniyle yeniden değerlendirilen en içteki hesaplanan ya da etki signal'ı, ya da `null`. Başlangıçta `null`.\n- `frozen`: Grafiğin değiştirilmemesini gerektiren bir geri çağırım şu anda yürütülüyorsa boolean. Başlangıçta `false`.\n- `generation`: Döngüsellikten kaçınırken bir değerin ne kadar güncel olduğunu izlemek için kullanılan, 0'dan başlayan artan bir tam sayı.\n\n### `Signal` Ad Alanı\n\n`Signal`, Signal ile ilgili sınıf ve fonksiyonlar için ad alanı olarak görev yapan sıradan bir nesnedir.\n\n`Signal.subtle` ise benzer bir iç ad alanı nesnesidir.\n\n### `Signal.State` Sınıfı\n\n#### `Signal.State` dahili slotları\n\n- `value`: Durum signal'ının mevcut değeri\n- `equals`: Değer değiştirildiğinde kullanılan karşılaştırma fonksiyonu\n- `watched`: Signal bir etki tarafından gözlemlendiğinde çağrılacak geri çağırım\n- `unwatched`: Signal artık bir etki tarafından gözlemlenmediğinde çağrılacak geri çağırım\n- `sinks`: Buna bağlı olan izlenen signal'lar kümesi\n\n#### Kurucu: `Signal.State(initialValue, options)`\n\n1. Bu Signal'ın `value` değerini `initialValue` olarak ayarla.\n1. Bu Signal'ın `equals` değerini options?.equals olarak ayarla\n1. Bu Signal'ın `watched` değerini options?.[Signal.subtle.watched] olarak ayarla\n1. Bu Signal'ın `unwatched` değerini options?.[Signal.subtle.unwatched] olarak ayarla\n1. Bu Signal'ın `sinks` değerini boş küme olarak ayarla\n\n#### Metot: `Signal.State.prototype.get()`\n\n1. Eğer `frozen` true ise, bir istisna fırlat.\n1. Eğer `computing` tanımsız değilse, bu Signal'ı `computing`'in `sources` kümesine ekle.\n1. NOT: Bu Signal'ın `sinks` kümesine, bir Watcher tarafından izlenene kadar `computing` eklemiyoruz.\n1. Bu Signal'ın `value` değerini döndür.\n\n#### Metot: `Signal.State.prototype.set(newValue)`\n\n1. Mevcut yürütme bağlamı `frozen` ise, bir istisna fırlat.\n1. Bu Signal ve değer için \"Signal değeri ayarla\" algoritmasını çalıştır.\n1. Bu algoritma `~clean~` döndürdüyse, undefined döndür.\n1. Bu Signal'ın tüm `sinks`'lerinin durumunu (eğer bir Hesaplanan Signal ise) önceden temizse `~dirty~`, (eğer bir Watcher ise) önceden `~watching~` ise `~pending~` olarak ayarla.\n1. Tüm sinks'lerin Hesaplanan Signal bağımlılıklarının (özyinelemeli olarak) durumunu önceden `~clean~` ise `~checked~` olarak ayarla (yani, kirli işaretleri olduğu gibi bırak), Watcher'lar için ise önceden `~watching~` ise `~pending~` olarak ayarla.\n1. Bu özyinelemeli aramada karşılaşılan her önceki `~watching~` Watcher için, daha sonra derinlik öncelikli sırayla,\n    1. `frozen`'ı true olarak ayarla.\n    1. `notify` geri çağırımını çağır (fırlatılan istisnayı kenara kaydet, ancak `notify`'ın dönüş değerini yoksay).\n    1. `frozen`'ı false olarak geri yükle.\n    1. Watcher'ın durumunu `~waiting~` olarak ayarla.\n1. `notify` geri çağırımlarından herhangi birinde istisna fırlatıldıysa, tüm `notify` geri çağırımları çalıştıktan sonra onu çağırana ilet. Birden fazla istisna varsa, bunları AggregateError ile paketle ve öyle fırlat.\n1. undefined döndür.\n\n### `Signal.Computed` Sınıfı\n\n#### `Signal.Computed` Durum Makinesi",
  "status": "ok"
}