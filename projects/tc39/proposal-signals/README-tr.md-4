{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// isWatched true olduğunda, eğer önceden false ise çağrılan geri çağırma fonksiyonu\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// isWatched false olduğunda, eğer önceden true ise çağrılan geri çağırma fonksiyonu\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Sinyaller Nasıl Çalışır\n\nBir Signal (Sinyal), zaman içinde değişebilen bir veri hücresini temsil eder. Sinyaller ya \"durum\" (manuel olarak ayarlanan bir değer) ya da \"hesaplanmış\" (diğer Sinyallere dayalı bir formül) olabilir.\n\nHesaplanmış Sinyaller, değerlendirmeleri sırasında hangi diğer Sinyallerin okunduğunu otomatik olarak takip ederek çalışır. Bir hesaplanmış Sinyal okunduğunda, daha önce kaydedilmiş bağımlılıklarından herhangi birinin değişip değişmediğini kontrol eder ve eğer değişmişse kendini yeniden değerlendirir. Birden fazla hesaplanmış Sinyal iç içe olduğunda, tüm izleme işleminin atfedilmesi en içteki Sinyale gider.\n\nHesaplanmış Sinyaller tembel, yani çekme tabanlıdır: Yalnızca erişildiklerinde yeniden değerlendirilirler, bir bağımlılıkları daha önce değişmiş olsa bile.\n\nHesaplanmış Sinyallere geçirilen geri çağırma fonksiyonu genellikle, eriştiği diğer Sinyallerin deterministik, yan etkisiz bir fonksiyonu anlamında \"saf\" olmalıdır. Aynı zamanda, geri çağırma fonksiyonunun ne zaman çağrılacağı deterministiktir ve bu da yan etkilerin dikkatlice kullanılmasına olanak tanır.\n\nSinyaller belirgin bir önbellekleme/memoizasyon özelliğine sahiptir: Hem durum hem de hesaplanmış Sinyaller mevcut değerlerini hatırlar ve yalnızca gerçekten değiştiklerinde kendilerine referans veren hesaplanmış Sinyallerin yeniden hesaplanmasını tetikler. Eski ve yeni değerlerin tekrar tekrar karşılaştırılmasına bile gerek yoktur—karşılaştırma, kaynak Sinyal sıfırlandığında/yeniden değerlendirildiğinde bir kez yapılır ve Sinyal mekanizması, o Sinyali referans alan hangi şeylerin yeni değere göre henüz güncellenmediğini takip eder. Dahili olarak, bu genellikle (Milo'nun blog yazısında) açıklandığı gibi \"grafik renklendirme\" ile temsil edilir.\n\nHesaplanmış Sinyaller, bağımlılıklarını dinamik olarak takip eder—her çalıştırıldıklarında, farklı şeylere bağımlı hale gelebilirler ve bu kesin bağımlılık kümesi Sinyal grafiğinde güncel tutulur. Bu, yalnızca bir dalda ihtiyaç duyulan bir bağımlılığınız varsa ve önceki hesaplama diğer dalı aldıysa, geçici olarak kullanılmayan bu değerdeki bir değişikliğin, çekildiğinde bile hesaplanmış Sinyalin yeniden hesaplanmasına neden olmayacağı anlamına gelir.\n\nJavaScript Promiselerinin aksine, Sinyallerdeki her şey senkron olarak çalışır:\n- Bir Sinyali yeni bir değere ayarlamak senkroniktir ve bu, sonrasında ona bağımlı olan herhangi bir hesaplanmış Sinyal okunduğunda hemen yansır. Bu mutasyonun yerleşik bir toplu işleme (batching) özelliği yoktur.\n- Hesaplanmış Sinyalleri okumak senkroniktir—değerleri her zaman kullanılabilir durumdadır.\n- Aşağıda açıklanan Watcher'lardaki `notify` geri çağırma fonksiyonu, onu tetikleyen `.set()` çağrısı sırasında senkron olarak çalışır (ancak grafik renklendirme tamamlandıktan sonra).\n\nPromiseler gibi, Sinyaller bir hata durumunu temsil edebilir: Bir hesaplanmış Sinyalin geri çağırma fonksiyonu hata fırlatırsa, bu hata başka bir değer gibi önbelleğe alınır ve Sinyal her okunduğunda tekrar fırlatılır.\n\n### Signal Sınıfını Anlamak\n\nBir `Signal` örneği, güncellemeleri zaman içinde takip edilen dinamik olarak değişen bir değeri okuma yeteneğini temsil eder. Ayrıca, başka bir hesaplanmış Sinyal tarafından izlenen bir erişim yoluyla dolaylı olarak Sinyale abone olma yeteneğini de içerir.\n\nBuradaki API, Signal kütüphanelerinin büyük bir kısmında \"signal\", \"computed\" ve \"state\" gibi isimlerin kullanımı konusunda ortaya çıkan kabaca ekosistem uzlaşısına uyacak şekilde tasarlanmıştır. Ancak, Hesaplanmış ve Durum Sinyallerine erişim `.get()` yöntemiyle sağlanır; bu, popüler Signal API'lerinin tümüyle çelişir, çünkü onlar ya `.value` tarzı bir erişici ya da `signal()` çağrı sözdizimi kullanır.\n\nAPI, tahsisat (allocation) sayısını azaltacak şekilde tasarlanmıştır, böylece Sinyaller, JavaScript framework'lerine gömülmeye uygun olur ve mevcut framework-özelleştirilmiş Sinyallerden aynı veya daha iyi performansa ulaşır. Bu şunları gerektirir:\n- Durum Sinyalleri, aynı referanstan hem erişilebilen hem de ayarlanabilen tek bir yazılabilir nesnedir. (Aşağıdaki \"Yetenek ayrımı\" bölümünde sonuçlarına bakınız.)\n- Hem Durum hem de Hesaplanmış Sinyaller, framework'lerin hem public hem de private sınıf alanlarıyla (ve o durumu kullanmak için yöntemlerle) ek özellikler eklemesini kolaylaştırmak için alt sınıf (subclass) oluşturulabilir şekilde tasarlanmıştır.\n- Çeşitli geri çağırma fonksiyonları (ör. `equals`, hesaplanmış geri çağırma), bağlam için ilgili Sinyal'i `this` değeri olarak alır, böylece her Sinyal için yeni bir closure oluşturmak gerekmez. Bunun yerine, bağlam sinyalin kendisinde ek özelliklerde saklanabilir.\n\nBu API tarafından zorunlu kılınan bazı hata durumları:\n- Bir hesaplanmış Sinyali özyinelemeli (recursive) olarak okumak hatadır.\n- Bir Watcher'ın `notify` geri çağırma fonksiyonu hiçbir sinyali okuyamaz veya yazamaz.\n- Bir hesaplanmış Sinyalin geri çağırma fonksiyonu hata fırlatırsa, Sinyalin sonraki erişimlerinde bu önbelleğe alınmış hata tekrar fırlatılır; ta ki bağımlılıklardan biri değişip yeniden hesaplanana kadar.\n\nZorunlu *olmayan* bazı koşullar:\n- Hesaplanmış Sinyaller, geri çağırma fonksiyonları içinde senkron olarak diğer Sinyallere yazabilir.\n- Bir Watcher'ın `notify` geri çağırma fonksiyonu tarafından kuyruğa alınan işler sinyalleri okuyabilir veya yazabilir, bu da Sinyaller bağlamında [klasik React antipatternlerinin](https://react.dev/learn/you-might-not-need-an-effect) çoğaltılmasını mümkün kılar!\n\n### Etkilerin (Effect) Uygulanması\n\nYukarıda tanımlanan `Watcher` arayüzü, tipik JS efekt API'lerinin uygulanması için temel sağlar: Diğer Sinyaller değiştiğinde yalnızca yan etkileri için tekrar çalışan geri çağırma fonksiyonları. Başlangıç örneğinde kullanılan `effect` fonksiyonu aşağıdaki gibi tanımlanabilir:\n\n```ts\n// Bu fonksiyon genellikle bir kütüphane/framework'te yer alır, uygulama kodunda değil\n// NOT: Bu zamanlama mantığı faydalı olacak kadar gelişmiş değildir. Kopyalayıp yapıştırmayın.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Bir efekt Signal'i—cb'ye değerlendirilir, bağımlılıklarından biri değiştiğinde\n// kendisini mikro görev kuyruğunda tekrar okuma işlemini zamanlar\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nSignal API'si, yerleşik olarak `effect` gibi bir fonksiyon içermez. Bunun nedeni, efekt zamanlamasının hassas olması ve genellikle framework'lerin render döngüleri ve JS'nin erişimi olmayan yüksek seviyeli framework'e özgü durum veya stratejilerle bağlantılı olmasıdır.\n\nBurada kullanılan farklı işlemleri inceleyelim: `Watcher` yapıcısına geçirilen `notify` geri çağırma fonksiyonu, Sinyal \"temiz\" bir durumdan (önbelleğin başlatıldığının ve geçerli olduğunun bilindiği yer) \"kontrol edilmiş\" veya \"kirli\" bir duruma geçtiğinde (bu Sinyalin özyinelemeli olarak bağlı olduğu en az bir durum değiştiği için önbelleğin geçerli olup olmadığının bilinmediği yer) çağrılan fonksiyondur.\n\n`notify` çağrıları nihayetinde bir durum Sinyali üzerinde `.set()` çağrısı ile tetiklenir. Bu çağrı senkroniktir: `.set` döndürülmeden önce gerçekleşir. Ancak bu geri çağırmanın Signal grafiğini yarım işlenmiş bir durumda gözlemlemesinden endişe etmeye gerek yoktur, çünkü bir `notify` geri çağırma sırasında, hatta bir `untrack` çağrısında bile hiçbir Sinyal okunamaz veya yazılamaz. Çünkü `notify`, `.set()` sırasında çağrıldığından, başka bir mantık akışını kesintiye uğratır ve bu akış tamamlanmamış olabilir. `notify`'dan Sinyalleri okumak veya yazmak için işi daha sonra çalışacak şekilde zamanlayın; örneğin, Sinyali daha sonra erişilecek bir listeye yazarak veya yukarıdaki gibi `queueMicrotask` ile.\n\nSinyalleri etkili bir şekilde kullanmak için `Signal.subtle.Watcher` kullanmak şart değildir; Glimmer'ın yaptığı gibi hesaplanmış Sinyallerin yoklanmasını zamanlamak mümkündür. Ancak, birçok framework bu zamanlama mantığını senkron olarak çalıştırmanın çoğu zaman faydalı olduğunu bulmuştur, bu nedenle Sinyal API'si bunu içerir.\n\nHem hesaplanmış hem de durum Sinyalleri, diğer JS değerleri gibi çöp toplayıcı (garbage collector) tarafından toplanır. Ancak Watcher'ların özel bir şekilde nesneleri canlı tutma yöntemi vardır: Bir Watcher tarafından izlenen herhangi bir Sinyal, temel durumların herhangi biri erişilebilir olduğu sürece canlı tutulur, çünkü bunlar gelecekte bir `notify` çağrısını (ve ardından bir `.get()`) tetikleyebilir. Bu nedenle, efektleri temizlemek için `Watcher.prototype.unwatch` çağırmayı unutmayın.\n\n### Güvensiz Bir Kaçış Kapısı\n\n`Signal.subtle.untrack`, Sinyalleri *takip etmeden* okumaya izin veren bir kaçış kapısıdır. Bu yetenek güvensizdir çünkü diğer Sinyallere bağlı olan, ancak bu Sinyaller değiştiğinde güncellenmeyen hesaplanmış Sinyallerin oluşturulmasına olanak tanır. Takipsiz erişimlerin hesaplamanın sonucunu değiştirmeyeceği durumlarda kullanılmalıdır.\n\n<!--\nTODO: untrack kullanımının iyi bir fikir olduğu bir örnek göster\n\n### watched/unwatched Kullanımı",
  "status": "ok"
}