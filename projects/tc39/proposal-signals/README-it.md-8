{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**D**: I segnali funzionano con il flusso di dati unidirezionale come fa React?\n\n**R**: Sì, i segnali sono un meccanismo per il flusso di dati unidirezionale. I framework UI basati sui segnali ti permettono di esprimere la tua vista come una funzione del modello (dove il modello incorpora i segnali). Un grafo di segnali di stato e calcolati è aciclico per costruzione. È anche possibile ricreare antipattern di React all’interno dei segnali (!), ad esempio, l’equivalente di un `setState` dentro `useEffect` nei segnali è usare un Watcher per schedulare una scrittura su un segnale di stato.\n\n**D**: Come si relazionano i segnali ai sistemi di gestione dello stato come Redux? I segnali incoraggiano uno stato non strutturato?\n\n**R**: I segnali possono costituire una base efficiente per astrazioni di gestione dello stato simili agli store. Un pattern comune in diversi framework è un oggetto basato su un Proxy che internamente rappresenta le proprietà usando i segnali, ad esempio [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), o [Solid stores](https://docs.solidjs.com/concepts/stores). Questi sistemi permettono un raggruppamento flessibile dello stato al giusto livello di astrazione per la particolare applicazione.\n\n**D**: Cosa offrono i segnali che un `Proxy` attualmente non gestisce?\n\n**R**: Proxy e segnali sono complementari e funzionano bene insieme. I proxy ti permettono di intercettare operazioni superficiali sugli oggetti e i segnali coordinano un grafo di dipendenze (di celle). Usare un proxy basato su segnali è un ottimo modo per creare una struttura reattiva annidata con ottima ergonomia.\n\nIn questo esempio, possiamo usare un proxy per far sì che il segnale abbia una proprietà getter e setter invece di usare i metodi `get` e `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// utilizzo in un ipotetico contesto reattivo:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>cambia</button>\n</template>\n```\nutilizzando un renderer ottimizzato per la reattività granulare, cliccando il bottone verrà aggiornata la cella `b.value`.\n\nVedi:\n- esempi di strutture reattive annidate create con segnali e proxy: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- esempio di implementazioni precedenti che mostrano la relazione tra dati reattivi e proxy: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussione](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Come funzionano i segnali?\n\n**D**: I segnali sono basati su push o su pull?\n\n**R**: La valutazione dei segnali calcolati è basata su pull: i segnali calcolati vengono valutati solo quando viene chiamato `.get()`, anche se lo stato sottostante è cambiato molto prima. Allo stesso tempo, cambiare un segnale di stato può immediatamente attivare la callback di un Watcher, \"spingendo\" la notifica. Quindi i segnali possono essere considerati una costruzione \"push-pull\".\n\n**D**: I segnali introducono non-determinismo nell’esecuzione di JavaScript?\n\n**R**: No. Per cominciare, tutte le operazioni sui segnali hanno semantiche e ordinamenti ben definiti, e non differiranno tra implementazioni conformi. A un livello superiore, i segnali seguono un certo insieme di invarianti, rispetto ai quali sono \"sicuri\". Un segnale calcolato osserva sempre il grafo dei segnali in uno stato consistente, e la sua esecuzione non viene interrotta da altro codice che modifica segnali (eccetto per le cose che chiama direttamente). Vedi la descrizione sopra.\n\n**D**: Quando scrivo su un segnale di stato, quando viene programmato l’aggiornamento del segnale calcolato?\n\n**R**: Non viene programmato! Il segnale calcolato si ricalcolerà la prossima volta che qualcuno lo leggerà. In modo sincrono, può essere chiamata la callback `notify` di un Watcher, permettendo ai framework di schedulare una lettura nel momento che ritengono opportuno.\n\n**D**: Quando hanno effetto le scritture sui segnali di stato? Immediatamente, o sono raggruppate?\n\n**R**: Le scritture sui segnali di stato sono riflesse immediatamente: la prossima volta che un segnale calcolato che dipende dal segnale di stato viene letto, si ricalcolerà se necessario, anche nella riga di codice immediatamente successiva. Tuttavia, la pigrizia insita in questo meccanismo (i segnali calcolati sono calcolati solo quando letti) significa che, in pratica, i calcoli possono avvenire in modo raggruppato.\n\n**D**: Cosa significa che i segnali abilitano un’esecuzione \"senza glitch\"?\n\n**R**: I precedenti modelli reattivi basati su push affrontavano il problema del calcolo ridondante: se un aggiornamento a un segnale di stato fa sì che il segnale calcolato venga eseguito con entusiasmo, ciò può infine portare a un aggiornamento della UI. Ma questa scrittura sulla UI può essere prematura, se ci fosse un altro cambiamento al segnale di stato originale prima del prossimo frame. Talvolta, valori intermedi inaccurati venivano persino mostrati agli utenti finali a causa di tali [glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). I segnali evitano questa dinamica essendo basati su pull, invece che su push: al momento in cui il framework programma il rendering della UI, tirerà gli aggiornamenti appropriati, evitando lavoro sprecato sia nel calcolo che nella scrittura sul DOM.\n\n**D**: Cosa significa che i segnali sono \"lossy\"?\n\n**R**: Questo è il rovescio della medaglia dell’esecuzione senza glitch: i segnali rappresentano una cella di dati--solo il valore corrente immediato (che può cambiare), non un flusso di dati nel tempo. Quindi, se scrivi su un segnale di stato due volte di seguito, senza fare altro, la prima scrittura viene \"persa\" e non viene mai vista da segnali calcolati o effetti. Questo è considerato una caratteristica e non un bug--altri costrutti (ad es. async iterables, observable) sono più appropriati per i flussi.\n\n**D**: I segnali nativi saranno più veloci delle implementazioni JS di segnali esistenti?\n\n**R**: Lo speriamo (di un piccolo fattore costante), ma deve ancora essere dimostrato nel codice. I motori JS non sono magici, e dovranno comunque implementare gli stessi tipi di algoritmi delle implementazioni JS dei segnali. Vedi la sezione sopra sulle prestazioni.\n\n#### Perché i segnali sono progettati così?\n\n**D**: Perché questa proposta non include una funzione `effect()`, quando gli effetti sono necessari per un utilizzo pratico dei segnali?\n\n**R**: Gli effetti si legano intrinsecamente a scheduling e disposal, che sono gestiti dai framework e sono fuori dallo scopo di questa proposta. Invece, questa proposta include la base per implementare effetti tramite la più a basso livello `Signal.subtle.Watcher` API.\n\n**D**: Perché le sottoscrizioni sono automatiche invece di fornire un’interfaccia manuale?\n\n**R**: L’esperienza ha mostrato che le interfacce di sottoscrizione manuale per la reattività sono poco ergonomiche e soggette a errori. Il tracking automatico è più componibile ed è una caratteristica centrale dei segnali.\n\n**D**: Perché la callback del `Watcher` viene eseguita in modo sincrono, invece che programmata in un microtask?\n\n**R**: Poiché la callback non può leggere o scrivere segnali, non c’è alcuna insicurezza introdotta dal chiamarla in modo sincrono. Una tipica callback aggiungerà un segnale a un array da leggere più tardi, o segnerà un bit da qualche parte. È inutile e troppo costoso creare un microtask separato per tutte queste azioni.\n\n**D**: Questa API manca di alcune cose utili che il mio framework preferito offre e che facilitano la programmazione con i segnali. Possono essere aggiunte anche allo standard?\n\n**R**: Forse. Varie estensioni sono ancora in fase di valutazione. Per favore, apri una issue per avviare una discussione su qualsiasi funzionalità mancante che ritieni importante.\n\n**D**: Questa API può essere ridotta in dimensioni o complessità?\n\n**R**: Mantenere questa API minimale è sicuramente un obiettivo, e abbiamo cercato di farlo con quanto presentato sopra. Se hai idee su altre cose che possono essere rimosse, per favore apri una issue per discuterne.\n\n#### Come vengono standardizzati i segnali?\n\n**D**: Non dovremmo iniziare il lavoro di standardizzazione in quest’area con un concetto più primitivo, come gli observable?",
  "status": "ok"
}