{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Observable을 effect에서 사용될 때에만 구독하도록, Observable을 computed signal로 변환하는 예제 보여주기\n\nTODO: 상태에 지정된 fetch 결과를 나타내는 computed signal의 예시 보여주기, 취소되는 경우 포함\n\n### SSR을 위한 내부 구조 점검\n\nTODO: 시그널 그래프를 직렬화하는 방법 보여주기\n\nTODO: 몇 개의 시그널을 사용하여, 나중에 상태에서 computed로 \"hydrate\"할 수 있는 방법 보여주기\n-->\n\n### 현재 생략됨\n\n이 기능들은 추후에 추가될 수 있지만, 현재 초안에는 포함되어 있지 않습니다. 이러한 생략은 프레임워크 간의 설계 공간에서 충분한 합의가 이루어지지 않았고, 본 문서에서 설명한 Signals 개념 위에 메커니즘을 덧붙여서 부재를 우회하는 것이 가능함이 입증되었기 때문입니다. 하지만 아쉽게도, 이러한 생략은 프레임워크 간 상호 운용성의 잠재력을 제한합니다. 본 문서에서 설명한 Signals의 프로토타입이 제작됨에 따라, 이러한 생략이 적절한 결정이었는지 재검토하려는 노력이 있을 것입니다.\n\n* **비동기(Async)**: 이 모델에서 시그널은 항상 동기적으로 평가 가능합니다. 그러나, 특정 비동기 프로세스가 시그널을 설정하게 되는 경우와, 시그널이 아직 \"로딩 중\"인지 파악하는 것이 자주 유용합니다. 로딩 상태를 모델링하는 한 가지 간단한 방법은 예외를 사용하는 것이며, computed signal의 예외 캐시 동작은 이 기법과 어느 정도 합리적으로 결합됩니다. 향상된 기법은 [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30)에서 논의됩니다.\n* **트랜잭션(Transactions)**: 뷰 간 전환에서는 \"from\" 상태와 \"to\" 상태 모두에 대해 라이브 상태를 유지하는 것이 종종 유용합니다. \"to\" 상태는 백그라운드에서 렌더링되다가 준비가 되면 스왑(트랜잭션 커밋)되고, \"from\" 상태는 상호작용이 가능합니다. 두 상태를 동시에 유지하려면 시그널 그래프의 상태를 \"포크\"해야 하며, 여러 개의 보류 중인 전환을 동시에 지원하는 것도 유용할 수 있습니다. 논의는 [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73)에서 다루고 있습니다.\n\n몇몇 [편의 메서드](https://github.com/proposal-signals/proposal-signals/issues/32)도 생략되어 있습니다.\n\n## 현황 및 개발 계획\n\n이 제안은 2024년 4월 TC39 의제에서 Stage 1에 올라가 있습니다. 현재는 \"Stage 0\"으로 볼 수 있습니다.\n\n이 제안을 위한 [폴리필](https://github.com/proposal-signals/signal-polyfill)이 기본적인 테스트와 함께 제공됩니다. 일부 프레임워크 작성자들은 이 시그널 구현체로 대체하는 실험을 시작했지만, 아직 초기 단계입니다.\n\n시그널 제안의 협업자들은, 우리가 실제로 사용하지 않게 되어 후회하게 될 뭔가가 출시되는 함정에 빠지지 않기 위해, 이 제안을 추진하는 데 있어 특별히 **보수적**이고자 합니다. 우리의 계획은 TC39 프로세스에서 요구하지 않는 다음의 추가 작업을 수행하여, 이 제안이 올바른 방향에 있는지 확인하는 것입니다:\n\nStage 2를 제안하기 전에, 우리는 다음을 계획합니다:\n- 견고하고, 잘 테스트되었으며(예: 다양한 프레임워크의 테스트와 test262 스타일의 테스트를 통과), 성능 면에서 경쟁력 있는(철저한 시그널/프레임워크 벤치마크 세트로 검증) 여러 개의 프로덕션급 폴리필 구현체를 개발합니다.\n- 제안된 Signal API를 우리가 다소 대표적이라고 생각하는 다수의 JS 프레임워크에 통합하고, 일부 대형 애플리케이션에서 이 기반으로 작동하도록 합니다. 해당 컨텍스트에서 효율적이고 올바르게 동작하는지 테스트합니다.\n- API의 확장 가능성에 대한 견고한 이해를 바탕으로, (있다면) 어떤 확장이 본 제안에 추가되어야 하는지 결론을 내립니다.\n\n## 시그널 알고리즘\n\n이 섹션에서는 각 API가 구현하는 알고리즘 측면에서 JavaScript에 노출되는 API를 설명합니다. 이는 일종의 프로토-명세로 볼 수 있으며, 가능한 의미 집합을 고정시키기 위해 이른 시점에 포함되었으나, 변경에 매우 열려 있습니다.\n\n알고리즘의 일부 측면:\n- computed 내에서 시그널을 읽는 순서는 중요하며, 특정 콜백(예: `Watcher` 호출, `equals`, `new Signal.Computed`의 첫 번째 매개변수, `watched`/`unwatched` 콜백)이 실행되는 순서로 관찰 가능합니다. 이는 computed Signal의 소스가 순서대로 저장되어야 함을 의미합니다.\n- 이 네 가지 콜백은 모두 예외를 throw할 수 있으며, 이 예외는 예측 가능한 방식으로 JS 호출 코드에 전파됩니다. 예외는 이 알고리즘의 실행을 중단시키거나 그래프를 반쯤 처리된 상태로 남기지 *않습니다*. Watcher의 `notify` 콜백에서 발생한 오류는 이를 유발한 `.set()` 호출에 전달되며, 여러 예외가 발생하면 AggregateError로 포장됩니다. 다른 경우(`watched`/`unwatched` 포함?)에는 시그널의 값에 저장되어 읽을 때 다시 throw되며, 이처럼 다시 throw되는 시그널도 일반 값과 마찬가지로 `~clean~`으로 표시될 수 있습니다.\n- \"감시(watched)\"되지 않는(Watcher가 관찰하지 않는) computed signal의 경우, 순환 참조를 피하기 위해 주의가 필요하며, 이로 인해 시그널 그래프의 다른 부분과 독립적으로 가비지 컬렉션될 수 있습니다. 내부적으로는 항상 수집되는 세대 번호(generation number) 시스템으로 구현할 수 있으며, 최적화된 구현에서는 노드별 세대 번호를 추가하거나, 감시되는 시그널의 일부 번호 추적을 생략할 수 있습니다.\n\n### 숨겨진 전역 상태\n\n시그널 알고리즘은 특정 전역 상태를 참조해야 합니다. 이 상태는 전체 스레드 또는 \"에이전트\"에 대해 전역적입니다.\n\n- `computing`: `.get` 또는 `.run` 호출로 인해 현재 다시 평가 중인 가장 안쪽의 computed 또는 effect Signal, 또는 `null`. 최초에는 `null`.\n- `frozen`: 그래프가 수정되어서는 안 되는 콜백이 현재 실행 중임을 나타내는 Boolean. 최초에는 `false`.\n- `generation`: 0부터 시작하는 증가하는 정수로, 순환 참조를 피하면서 값이 최신인지 추적하는 데 사용됩니다.\n\n### `Signal` 네임스페이스\n\n`Signal`은 Signal 관련 클래스와 함수의 네임스페이스 역할을 하는 일반 객체입니다.\n\n`Signal.subtle`도 유사한 내부 네임스페이스 객체입니다.\n\n### `Signal.State` 클래스\n\n#### `Signal.State` 내부 슬롯\n\n- `value`: 상태 시그널의 현재 값\n- `equals`: 값 변경 시 사용할 비교 함수\n- `watched`: 시그널이 effect에 의해 관찰될 때 호출되는 콜백\n- `unwatched`: 시그널이 더 이상 effect에 의해 관찰되지 않을 때 호출되는 콜백\n- `sinks`: 이 시그널에 의존하는 감시 중(watched) 시그널의 집합\n\n#### 생성자: `Signal.State(initialValue, options)`\n\n1. 이 시그널의 `value`를 `initialValue`로 설정합니다.\n1. 이 시그널의 `equals`를 options?.equals로 설정합니다.\n1. 이 시그널의 `watched`를 options?.[Signal.subtle.watched]로 설정합니다.\n1. 이 시그널의 `unwatched`를 options?.[Signal.subtle.unwatched]로 설정합니다.\n1. 이 시그널의 `sinks`를 빈 집합으로 설정합니다.\n\n#### 메서드: `Signal.State.prototype.get()`\n\n1. `frozen`이 true이면 예외를 throw합니다.\n1. `computing`이 `undefined`가 아니면, 이 시그널을 `computing`의 `sources` 집합에 추가합니다.\n1. 참고: Watcher에 의해 감시될 때까지 이 시그널의 `sinks` 집합에 `computing`을 추가하지 않습니다.\n1. 이 시그널의 `value`를 반환합니다.\n\n#### 메서드: `Signal.State.prototype.set(newValue)`\n\n1. 현재 실행 컨텍스트가 `frozen`이면 예외를 throw합니다.\n1. 이 시그널과 첫 번째 매개변수의 값을 사용하여 \"set Signal value\" 알고리즘을 실행합니다.\n1. 해당 알고리즘이 `~clean~`을 반환하면, undefined를 반환합니다.\n1. 이 시그널의 모든 `sinks`의 `state`를 (Computed Signal일 경우) 이전에 clean이었다면 `~dirty~`로, (Watcher일 경우) 이전에 `~watching~`이었다면 `~pending~`으로 설정합니다.\n1. 모든 sink의 Computed Signal 의존성(재귀적으로)의 `state`를 이전에 `~clean~`이었다면 `~checked~`로 설정합니다(즉, dirty 표시는 그대로 둡니다). Watcher의 경우 이전에 `~watching~`이었다면 `~pending~`으로 설정합니다.\n1. 그 재귀 탐색에서 만난, 이전에 `~watching~`이었던 각 Watcher에 대해, 깊이 우선 순서로,\n    1. `frozen`을 true로 설정합니다.\n    1. 해당 Watcher의 `notify` 콜백을 호출합니다(예외 발생 시 저장하되, 반환값은 무시).\n    1. `frozen`을 false로 복원합니다.\n    1. Watcher의 `state`를 `~waiting~`으로 설정합니다.\n1. `notify` 콜백에서 예외가 발생한 경우, 모든 `notify` 콜백이 실행된 후 호출자에게 예외를 전파합니다. 여러 예외가 있으면 AggregateError로 패키징하여 throw합니다.\n1. undefined를 반환합니다.\n\n### `Signal.Computed` 클래스\n\n#### `Signal.Computed` 상태 기계",
  "status": "ok"
}