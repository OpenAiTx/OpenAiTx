{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **ردیابی خودکار وابستگی‌ها** - یک سیگنال محاسباتی به طور خودکار هر سیگنال دیگری را که به آن وابسته است، چه آن سیگنال‌ها مقادیر ساده باشند یا محاسبات دیگر، کشف می‌کند.\n* **ارزیابی تنبل (Lazy Evaluation)** - محاسبات هنگام اعلام شدن به صورت پیش‌دستانه ارزیابی نمی‌شوند و همچنین زمانی که وابستگی‌های آن‌ها تغییر می‌کند فوراً ارزیابی نمی‌شوند. آن‌ها فقط زمانی ارزیابی می‌شوند که مقدارشان به طور صریح درخواست شود.\n* **حافظه‌سازی (Memoization)** - سیگنال‌های محاسباتی آخرین مقدار خود را ذخیره می‌کنند تا در صورتی که وابستگی‌هایشان تغییری نکرده باشد، محاسبه مجدد لازم نباشد، فارغ از این‌که چند بار به آن دسترسی پیدا شود.\n\n## انگیزه برای استانداردسازی سیگنال‌ها\n\n#### همکاری‌پذیری (Interoperability)\n\nهر پیاده‌سازی سیگنال سازوکار ردیابی خودکار مخصوص به خود را دارد تا منابعی را که هنگام ارزیابی یک سیگنال محاسباتی مشاهده می‌شوند، ثبت کند. این موضوع اشتراک‌گذاری مدل‌ها، کامپوننت‌ها و کتابخانه‌ها بین فریمورک‌های مختلف را دشوار می‌کند—چرا که معمولاً به موتور نمایشی خود وابسته هستند (زیرا سیگنال‌ها اغلب به عنوان بخشی از فریمورک‌های JS پیاده‌سازی می‌شوند).\n\nیکی از اهداف این پیشنهاد، جداسازی کامل مدل واکنشی از نمای رندرینگ است، تا توسعه‌دهندگان بتوانند بدون بازنویسی کدهای غیر UI خود به فناوری‌های رندرینگ جدید مهاجرت کنند، یا مدل‌های واکنشی مشترک در JS را برای استقرار در زمینه‌های مختلف توسعه دهند. متأسفانه به دلیل نسخه‌بندی و تکرار، رسیدن به سطح بالایی از اشتراک‌گذاری از طریق کتابخانه‌های سطح JS عملی نبوده است—ساختارهای داخلی (built-in) تضمین اشتراک‌گذاری قوی‌تری ارائه می‌دهند.\n\n#### عملکرد/مصرف حافظه\n\nهمیشه این امکان وجود دارد که با داخلی شدن کتابخانه‌های پرکاربرد، کد کمتری ارسال شود و افزایش عملکرد کمی رخ دهد، اما معمولاً پیاده‌سازی‌های سیگنال بسیار کوچک‌اند، بنابراین انتظار نداریم این اثر خیلی بزرگ باشد.\n\nما گمان می‌کنیم پیاده‌سازی‌های بومی C++ برای ساختار داده‌ها و الگوریتم‌های مرتبط با سیگنال می‌تواند کمی بهینه‌تر از آن چیزی باشد که در JS قابل دستیابی است (در حد یک ضریب ثابت). با این حال، هیچ تغییری در الگوریتم نسبت به آنچه که در polyfill خواهد بود، پیش‌بینی نمی‌شود؛ انتظار نمی‌رود موتور‌ها اینجا جادو کنند و الگوریتم‌های واکنشی نیز دقیق و بدون ابهام تعریف خواهند شد.\n\nگروه راهبری انتظار دارد که پیاده‌سازی‌های مختلفی از سیگنال‌ها را توسعه دهد و از آن‌ها برای بررسی این امکان‌های عملکردی استفاده کند.\n\n#### ابزارهای توسعه (DevTools)\n\nدر کتابخانه‌های سیگنال مبتنی بر زبان JS فعلی، ردیابی مواردی مانند موارد زیر دشوار است:\n* پشته فراخوانی (callstack) در زنجیره‌ای از سیگنال‌های محاسباتی، که زنجیره علّی برای یک خطا را نشان می‌دهد\n* نمودار ارجاع بین سیگنال‌ها، وقتی یکی به دیگری وابسته است—مهم هنگام اشکال‌زدایی مصرف حافظه\n\nسیگنال‌های داخلی این امکان را برای محیط‌های اجرایی JS و ابزارهای توسعه فراهم می‌کنند تا پشتیبانی بهتری برای بازرسی سیگنال‌ها داشته باشند، به ویژه برای اشکال‌زدایی یا تحلیل عملکرد، چه این امکان در مرورگرها تعبیه شده باشد یا از طریق افزونه مشترک. ابزارهای موجود مانند بازرس المنت، عکس‌برداری عملکرد و پروفایلرهای حافظه می‌توانند به‌روزرسانی شوند تا سیگنال‌ها را به طور خاص در ارائه اطلاعات برجسته کنند.\n\n#### مزایای ثانویه\n\n##### مزایای یک کتابخانه استاندارد\n\nبه طور کلی، کتابخانه استاندارد جاوااسکریپت نسبتاً مینیمال بوده است، اما روندی در TC39 وجود دارد که JS را به زبانی \"همراه با باتری\" (batteries-included) تبدیل کند، با مجموعه‌ای با کیفیت بالا و داخلی از قابلیت‌ها. به عنوان مثال، Temporal جایگزین moment.js شده است و تعدادی ویژگی کوچک مانند `Array.prototype.flat` و `Object.groupBy` بسیاری از کاربردهای lodash را جایگزین کرده‌اند. مزایا شامل اندازه بسته‌های کوچکتر، ثبات و کیفیت بهتر، یادگیری کمتر هنگام ورود به پروژه جدید و واژگان مشترک در بین توسعه‌دهندگان JS است.\n\n##### یکپارچگی با HTML/DOM (یک امکان آینده)\n\nکار فعلی در W3C و توسعه‌دهندگان مرورگر به دنبال آوردن قالب‌بندی بومی به HTML است ([DOM Parts][wicg-pr-1023] و [Template Instantiation][wicg-propsal-template-instantiation]). همچنین، گروه کامپوننت‌های وب W3C در حال بررسی امکان گسترش کامپوننت‌های وب برای ارائه یک API کاملاً اعلامی HTML است. برای دستیابی به هر دوی این اهداف، در نهایت یک عنصر اولیه واکنشی توسط HTML مورد نیاز خواهد بود. همچنین بسیاری از بهبودهای ارگونومیک برای DOM از طریق یکپارچگی سیگنال‌ها قابل تصور است و توسط جامعه درخواست شده است.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> توجه داشته باشید، این یکپارچگی تلاشی جداگانه خواهد بود که بعداً انجام می‌شود و بخشی از این پیشنهاد نیست.\n\n##### تبادل اطلاعات اکوسیستم (دلیلی برای عرضه نیست)\n\nتلاش‌های استانداردسازی گاهی می‌تواند صرفاً در سطح \"جامعه\" مفید باشد، حتی بدون تغییر در مرورگرها. تلاش برای سیگنال‌ها بسیاری از نویسندگان فریمورک‌های مختلف را برای بحث عمیق درباره ماهیت واکنش‌پذیری، الگوریتم‌ها و همکاری‌پذیری گرد هم آورده است. این موضوع تا کنون مفید بوده است، اما دلیلی برای اضافه شدن به موتورهای JS و مرورگرها محسوب نمی‌شود؛ سیگنال‌ها باید فقط در صورت داشتن مزایای قابل توجه *فراتر از* تبادل اطلاعات اکوسیستم به استاندارد جاوااسکریپت افزوده شوند.\n\n## اهداف طراحی برای سیگنال‌ها\n\nمشخص شده است که کتابخانه‌های سیگنال فعلی در هسته خود تفاوت چندانی با یکدیگر ندارند. این پیشنهاد قصد دارد با پیاده‌سازی ویژگی‌های مهم بسیاری از آن کتابخانه‌ها، بر موفقیت آن‌ها بنا نهد.\n\n### ویژگی‌های اصلی\n\n* یک نوع سیگنال که حالت را نمایش می‌دهد، یعنی سیگنال قابل نوشتن. این مقداری است که سایرین می‌توانند بخوانند.\n* یک نوع سیگنال محاسباتی/حافظه‌ای/مشتق‌شده که به دیگران وابسته است و به صورت تنبل محاسبه و ذخیره می‌شود.\n    * محاسبه تنبل است، به این معنی که سیگنال‌های محاسباتی به طور پیش‌فرض زمانی که یکی از وابستگی‌هایشان تغییر می‌کند دوباره محاسبه نمی‌شوند، بلکه فقط زمانی اجرا می‌شوند که کسی واقعاً آن‌ها را بخواند.\n    * محاسبه بدون \"[گلیچ](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" است، به این معنی که هیچ محاسبه غیرضروری انجام نمی‌شود. این بدین معناست که وقتی یک برنامه یک سیگنال محاسباتی را می‌خواند، بخش‌های بالقوه آلوده نمودار به صورت توپولوژیکی مرتب می‌شوند تا هیچ تکراری اجرا نشود.\n    * محاسبه ذخیره می‌شود، یعنی اگر پس از آخرین تغییر وابستگی، دیگر هیچ وابستگی تغییر نکرده باشد، آنگاه سیگنال محاسباتی هنگام دسترسی مجدد محاسبه نمی‌شود.\n    * مقایسه‌های سفارشی هم برای سیگنال‌های محاسباتی و هم سیگنال‌های حالت امکان‌پذیر است تا تشخیص داده شود چه زمانی سیگنال‌های محاسباتی دیگر که به آن‌ها وابسته هستند باید به‌روزرسانی شوند.\n* واکنش به وضعیتی که یک سیگنال محاسباتی یکی از وابستگی‌هایش (یا وابستگی‌های تو در تو) \"آلوده\" شده و تغییر می‌کند، یعنی ممکن است مقدار سیگنال منسوخ شده باشد.\n    * این واکنش برای زمان‌بندی انجام کارهای مهم‌تر در آینده در نظر گرفته شده است.\n    * افکت‌ها بر اساس این واکنش‌ها و زمان‌بندی در سطح فریمورک پیاده‌سازی می‌شوند.\n    * سیگنال‌های محاسباتی باید بتوانند به ثبت شدن به عنوان یک وابستگی (تو در تو) یکی از این واکنش‌ها واکنش نشان دهند.\n* امکان دادن به فریمورک‌های JS برای انجام زمان‌بندی خودشان. هیچ زمان‌بندی اجباری به سبک Promise به صورت داخلی وجود ندارد.\n    * واکنش‌های همزمان لازم است تا امکان زمان‌بندی کارهای بعدی بر اساس منطق فریمورک فراهم شود.\n    * نوشتن‌ها همزمان است و بلافاصله اثر می‌گذارد (یک فریمورک که می‌خواهد نوشتن‌ها را دسته‌ای انجام دهد می‌تواند این کار را روی آن انجام دهد).\n    * امکان جدا کردن بررسی اینکه آیا یک افکت ممکن است \"آلوده\" باشد از اجرای واقعی افکت وجود دارد (امکان زمان‌بندی افکت دو مرحله‌ای).\n* امکان خواندن سیگنال‌ها *بدون* ثبت شدن به عنوان وابستگی (`untrack`)\n* امکان ترکیب کدبیس‌های مختلف که از سیگنال‌ها/واکنش‌پذیری استفاده می‌کنند، مثلاً،\n    * استفاده از چندین فریمورک به طور همزمان از نظر ردیابی/واکنش‌پذیری (با استثناهای ذکر شده)\n    * ساختارهای داده واکنشی مستقل از فریمورک (مثلاً پراکسی فروشگاه بازگشتی، Map و Set و Array واکنشی و غیره)\n\n### اعتبار (Soundness)\n\n* جلوگیری/ممنوعیت استفاده نادرست از واکنش‌های همزمان.\n    * ریسک اعتبار: ممکن است \"[گلیچ](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" ایجاد کند اگر به درستی استفاده نشود: اگر رندرینگ بلافاصله هنگام ست شدن سیگنال انجام شود، ممکن است وضعیت ناقص برنامه به کاربر نهایی نشان داده شود. بنابراین این ویژگی فقط باید برای زمان‌بندی هوشمندانه کارها برای بعد، زمانی که منطق برنامه به پایان رسیده، استفاده شود.\n    * راه‌حل: خواندن و نوشتن هر سیگنال از داخل callback واکنش همزمان ممنوع شود.\n* discourages `untrack` و نشانه‌گذاری ماهیت ناامن آن\n    * ریسک اعتبار: اجازه می‌دهد سیگنال‌های محاسباتی‌ای ساخته شود که مقدارشان به سیگنال‌های دیگر وابسته است اما هنگام تغییر آن سیگنال‌ها به‌روزرسانی نمی‌شوند. باید زمانی استفاده شود که دسترسی‌های بدون ردیابی نتیجه محاسبه را تغییر نمی‌دهد.\n    * راه‌حل: API با نام \"unsafe\" علامت‌گذاری می‌شود.\n* توجه: این پیشنهاد اجازه می‌دهد سیگنال‌ها هم از سیگنال‌های محاسباتی و هم افکت خوانده و نوشته شوند، بدون محدودیت روی نوشتن‌هایی که پس از خواندن انجام می‌شوند، با وجود ریسک اعتبار. این تصمیم برای حفظ انعطاف و سازگاری با فریمورک‌ها اتخاذ شده است.\n\n### رابط کاربری سطحی (Surface API)\n\n* باید پایه‌ای محکم برای پیاده‌سازی سازوکارهای سیگنال/واکنش‌پذیری توسط چندین فریمورک باشد.\n    * باید پایه خوبی برای پراکسی‌های فروشگاه بازگشتی، واکنش‌پذیری فیلد کلاس مبتنی بر دکوریتور و APIهای سبک `.value` و `[state, setState]` باشد.\n    * معناشناسی باید الگوهای معتبری که توسط فریمورک‌های مختلف فعال می‌شوند را بیان کند. مثلاً باید ممکن باشد این سیگنال‌ها مبنای نوشتن‌های فوراً منعکس‌شونده یا نوشتن‌هایی باشند که بعداً به صورت دسته‌ای اعمال می‌شوند.\n* خوب است اگر این API مستقیماً توسط توسعه‌دهندگان جاوااسکریپت قابل استفاده باشد.\n    * اگر یک ویژگی با مفهومی در اکوسیستم مطابقت دارد، استفاده از واژگان مشترک خوب است.\n        * با این حال، مهم است که دقیقاً از همان نام‌ها استفاده نشود!\n    * تنش بین \"قابلیت استفاده توسط توسعه‌دهندگان JS\" و \"فراهم کردن همه hookها برای فریمورک‌ها\"\n        * ایده: همه hookها فراهم شود اما در صورت استفاده نادرست، خطا صادر شود اگر ممکن باشد.\n        * ایده: APIهای ظریف در یک فضای نام `subtle` قرار گیرند، مشابه [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle)، تا مرز بین APIهای لازم برای استفاده پیشرفته مثل پیاده‌سازی فریمورک یا ابزار توسعه با استفاده روزمره مثل ساخت سیگنال برای استفاده با یک فریمورک مشخص شود.\n* باید پیاده‌سازی و استفاده با عملکرد خوب ممکن باشد—رابط کاربری سطحی نباید سربار زیادی ایجاد کند\n    * امکان زیرکلاس‌گیری فراهم شود تا فریمورک‌ها بتوانند متدها و فیلدهای خود، از جمله فیلدهای خصوصی را اضافه کنند. این موضوع برای جلوگیری از تخصیص‌های اضافی در سطح فریمورک مهم است. به بخش \"مدیریت حافظه\" در ادامه مراجعه کنید.\n\n### مدیریت حافظه\n\n* اگر ممکن باشد: یک سیگنال محاسباتی باید در صورتی که هیچ ارجاع زنده‌ای برای خواندن‌های آینده به آن وجود ندارد، حتی اگر در یک گراف گسترده‌تر باقی بماند که زنده است (مثلاً با خواندن یک state که زنده مانده است)، قابل جمع‌آوری توسط garbage collector باشد.",
  "status": "ok"
}