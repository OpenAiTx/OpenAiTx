{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO：展示将 Observable 转换为计算信号的示例，仅在被 effect 使用时订阅\n\nTODO：展示一个计算信号的示例，该信号表示针对某个状态发起的 fetch 结果，并且该 fetch 可以被取消\n\n### SSR 的自省能力\n\nTODO：展示信号图序列化的工作方式\n\nTODO：展示如何使用少量信号将信号从 state “注水”到 computed\n\n-->\n\n### 当前省略的内容\n\n这些功能可能会在之后添加，但当前草案中未包含。它们被省略的原因在于各框架在设计空间上尚未达成一致共识，以及目前已经有办法通过本文档中描述的 Signals 概念之上的机制来规避这些缺失。然而，不幸的是，这些省略限制了框架间互操作性的潜力。随着本文档中描述的 Signals 原型的产生，将会努力重新审视这些省略是否为适当的决定。\n\n* **异步（Async）**：在本模型中，Signal 总是可以同步求值。然而，经常有某些异步过程导致信号被设置，并且需要了解信号当前是否还处于“加载中”。用异常来建模加载状态是一种简单方式，且计算信号的异常缓存行为与这一技术有一定的组合能力。改进的技术在 [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30) 中有讨论。\n* **事务（Transactions）**：在视图切换时，通常需要同时维护“from”和“to”状态的实时状态。“to”状态在后台渲染，直到可以切换（提交事务），而“from”状态依然可交互。要同时维护两个状态，需要对信号图的状态进行“分叉”，甚至可能需要同时支持多个待处理的切换。详见 [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73)。\n\n一些可能的[便捷方法](https://github.com/proposal-signals/proposal-signals/issues/32)也被省略。\n\n## 状态与开发计划\n\n本提案已列入 2024 年 4 月 TC39 Stage 1 议程。目前可以将其视为“Stage 0”。\n\n[本提案的 polyfill](https://github.com/proposal-signals/signal-polyfill) 已经可用，并带有一些基础测试。一些框架作者已经开始尝试用该信号实现进行替换，但仍处于早期阶段。\n\nSignal 提案的协作者们在推动本提案进展时希望特别**保守**，以避免最终发布了我们后悔且实际上并未广泛使用的功能。我们的计划是完成以下 TC39 流程未要求的额外任务，以确保提案方向正确：\n\n在提出 Stage 2 之前，我们计划：\n- 开发多个面向生产的 polyfill 实现，这些实现要健壮、经过良好测试（例如能通过各种框架的测试以及 test262 风格的测试），并在性能上具有竞争力（通过全面的信号/框架基准测试集验证）。\n- 将提议的 Signal API 集成到我们认为具有代表性的众多 JS 框架中，并有一些大型应用基于此工作。在这些场景下测试其高效性与正确性。\n- 对 API 可能的扩展空间有充分理解，并明确哪些（如果有的话）应被加入本提案。\n\n## Signal 算法\n\n本节以算法的形式描述了暴露给 JavaScript 的每个 API。可以将其视为初步规范，在这一早期阶段用于确定一组可能的语义，同时对更改持开放态度。\n\n算法的一些方面：\n- 在计算信号中读取 Signal 的顺序是重要的，这在某些回调（如 `Watcher` 被调用、`equals`、`new Signal.Computed` 的第一个参数、`watched`/`unwatched` 回调）的执行顺序中是可观察的。这意味着计算信号的源必须有序存储。\n- 这四个回调都可能抛出异常，这些异常会以可预测的方式传递给调用的 JS 代码。这些异常*不会*中断算法执行，也不会让信号图处于半处理状态。对于 Watcher 的 `notify` 回调中抛出的错误，该异常会传递到触发它的 `.set()` 调用，如果有多个异常，则使用 AggregateError 打包。其他异常（包括 `watched`/`unwatched`？）会存储在 Signal 的值中，在读取时重新抛出，并且这样的重新抛出信号可以像普通值一样被标记为 `~clean~`。\n- 针对未被“观察”（未被任何 Watcher 观察）的计算信号，为避免循环引用，采取了措施使其能独立于信号图的其它部分被垃圾回收。在内部可以通过始终可收集的代数（generation numbers）系统实现；需要注意的是，优化实现可能还会包括每节点本地的代数，或对已被观察的信号避免跟踪某些数字。\n\n### 隐含的全局状态\n\nSignal 算法需要引用某些全局状态。这些状态在整个线程或“代理（agent）”中全局唯一。\n\n- `computing`：当前由于 `.get` 或 `.run` 调用而正在重新计算的最内层计算或 effect Signal，或为 `null`。初始为 `null`。\n- `frozen`：布尔值，表示当前是否有回调在执行且要求信号图不可被修改。初始为 `false`。\n- `generation`：递增整数，从 0 开始，用于在避免循环时追踪值的时效性。\n\n### `Signal` 命名空间\n\n`Signal` 是一个普通对象，用作 Signal 相关类和函数的命名空间。\n\n`Signal.subtle` 是类似的内部命名空间对象。\n\n### `Signal.State` 类\n\n#### `Signal.State` 内部槽\n\n- `value`：状态信号的当前值\n- `equals`：更改值时使用的比较函数\n- `watched`：当信号被 effect 观察时调用的回调\n- `unwatched`：当信号不再被 effect 观察时调用的回调\n- `sinks`：依赖于此信号的已被观察信号集合\n\n#### 构造函数：`Signal.State(initialValue, options)`\n\n1. 将此 Signal 的 `value` 设为 `initialValue`。\n1. 将此 Signal 的 `equals` 设为 options?.equals\n1. 将此 Signal 的 `watched` 设为 options?.[Signal.subtle.watched]\n1. 将此 Signal 的 `unwatched` 设为 options?.[Signal.subtle.unwatched]\n1. 将此 Signal 的 `sinks` 设为空集合\n\n#### 方法：`Signal.State.prototype.get()`\n\n1. 如果 `frozen` 为 true，抛出异常。\n1. 如果 `computing` 不为 `undefined`，将此 Signal 加入 `computing` 的 `sources` 集合。\n1. 注：仅当此信号被 Watcher 观察时，才会将 `computing` 加入此信号的 `sinks` 集合。\n1. 返回此 Signal 的 `value`。\n\n#### 方法：`Signal.State.prototype.set(newValue)`\n\n1. 如果当前执行上下文为 `frozen`，抛出异常。\n1. 使用此 Signal 和第一个参数的值运行“设置 Signal 值”算法。\n1. 如果该算法返回 `~clean~`，则返回 undefined。\n1. 将此 Signal 所有 `sinks` 的 `state` 设置为（如果是 Computed Signal）`~dirty~`（若之前为 clean），或（如果是 Watcher）`~pending~`（若之前为 `~watching~`）。\n1. 递归地将所有 sinks 的 Computed Signal 依赖的 `state` 设置为 `~checked~`（若之前为 `~clean~`，即保留 dirty 标记），或对于 Watcher，若之前为 `~watching~` 则设为 `~pending~`。\n1. 对于在递归过程中遇到的每个先前为 `~watching~` 的 Watcher，按照深度优先顺序：\n    1. 设 `frozen` 为 true。\n    1. 调用其 `notify` 回调（保存抛出的异常，但忽略 `notify` 的返回值）。\n    1. 恢复 `frozen` 为 false。\n    1. 将 Watcher 的 `state` 设为 `~waiting~`。\n1. 如果有任何 `notify` 回调抛出异常，在所有 `notify` 回调执行完后将异常传递给调用者。如有多个异常，则使用 AggregateError 打包后抛出。\n1. 返回 undefined。\n\n### `Signal.Computed` 类\n\n#### `Signal.Computed` 状态机",
  "status": "ok"
}