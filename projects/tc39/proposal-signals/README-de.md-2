{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Automatische Abhängigkeitsverfolgung** – Ein berechnetes Signal erkennt automatisch alle anderen Signale, von denen es abhängig ist, unabhängig davon, ob es sich dabei um einfache Werte oder andere Berechnungen handelt.\n* **Träge Auswertung (Lazy Evaluation)** – Berechnungen werden nicht sofort beim Deklarieren ausgeführt, noch werden sie sofort ausgewertet, wenn sich ihre Abhängigkeiten ändern. Sie werden nur dann ausgewertet, wenn ihr Wert explizit angefordert wird.\n* **Memoisierung** – Berechnete Signale speichern ihren letzten Wert im Cache, sodass Berechnungen, deren Abhängigkeiten sich nicht geändert haben, nicht erneut ausgewertet werden müssen, egal wie oft darauf zugegriffen wird.\n\n## Motivation für die Standardisierung von Signals\n\n#### Interoperabilität\n\nJede Signal-Implementierung hat ihren eigenen Mechanismus zur automatischen Verfolgung, um die Quellen nachzuhalten, die beim Auswerten eines berechneten Signals angetroffen werden. Dies erschwert das Teilen von Modellen, Komponenten und Bibliotheken zwischen verschiedenen Frameworks—sie sind häufig fälschlich an ihre View-Engine gekoppelt (da Signale meist als Teil von JS-Frameworks implementiert sind).\n\nEin Ziel dieses Vorschlags ist es, das reaktive Modell vollständig von der Rendering-Ansicht zu entkoppeln, sodass Entwickler auf neue Rendering-Technologien migrieren können, ohne ihren Nicht-UI-Code neu schreiben zu müssen, oder geteilte reaktive Modelle in JS zu entwickeln, die in verschiedenen Kontexten eingesetzt werden können. Leider hat sich wegen Versionierung und Duplizierung herausgestellt, dass ein hohes Maß an Teilbarkeit über JS-Bibliotheken praktisch nicht erreichbar ist—Built-ins bieten eine stärkere Teilungsgarantie.\n\n#### Performance/Speichernutzung\n\nEs ist immer ein kleiner potentieller Performance-Vorteil, weniger Code auszuliefern, da häufig genutzte Bibliotheken als Built-in vorhanden sind, aber die Implementierungen von Signals sind generell recht klein, sodass dieser Effekt nicht sehr groß ausfallen dürfte.\n\nWir vermuten, dass native C++-Implementierungen von Signal-bezogenen Datenstrukturen und Algorithmen geringfügig effizienter sein können als das, was in JS erreichbar ist, und zwar um einen konstanten Faktor. Allerdings werden keine algorithmischen Änderungen gegenüber dem erwartet, was in einem Polyfill vorhanden wäre; von Engines wird hier keine Magie erwartet, und die Reaktivitätsalgorithmen selbst werden klar und eindeutig definiert.\n\nDie Champion-Gruppe erwartet, verschiedene Implementierungen von Signals zu entwickeln und damit diese Performance-Möglichkeiten zu untersuchen.\n\n#### DevTools\n\nMit bestehenden JS-Signal-Bibliotheken ist es schwierig, Dinge wie Folgendes nachzuvollziehen:\n* Den Callstack über eine Kette von berechneten Signalen hinweg, um die Kausalkette eines Fehlers zu zeigen\n* Den Referenzgraphen zwischen Signalen, wenn eines von einem anderen abhängt – wichtig beim Debuggen von Speicherverbrauch\n\nEingebaute Signals ermöglichen es JS-Runtimes und DevTools, potenziell eine bessere Unterstützung für die Inspektion von Signals zu bieten, insbesondere für Debugging oder Performance-Analysen, sei es direkt in Browsern oder durch eine gemeinsame Erweiterung. Bestehende Tools wie der Elementinspektor, Performance-Snapshot und Speicher-Profiler könnten aktualisiert werden, um Signals in ihrer Darstellung speziell hervorzuheben.\n\n#### Sekundäre Vorteile\n\n##### Vorteile einer Standardbibliothek\n\nJavaScript hatte im Allgemeinen eine relativ minimale Standardbibliothek, aber ein Trend im TC39 ist es, JS zu einer „batteries included“-Sprache zu machen, mit einer hochwertigen, eingebauten Funktionssammlung. Beispielsweise ersetzt Temporal moment.js, und eine Reihe kleiner Features, z. B. `Array.prototype.flat` und `Object.groupBy`, ersetzen viele lodash-Anwendungsfälle. Vorteile sind kleinere Bundle-Größen, verbesserte Stabilität und Qualität, weniger zu lernen beim Einstieg in ein neues Projekt und ein allgemein gemeinsamer Wortschatz unter JS-Entwicklern.\n\n##### HTML/DOM-Integration (eine mögliche Zukunft)\n\nAktuelle Arbeiten im W3C und von Browser-Implementierern zielen darauf ab, natives Templating in HTML zu bringen ([DOM Parts][wicg-pr-1023] und [Template Instantiation][wicg-propsal-template-instantiation]). Zusätzlich untersucht die W3C Web Components CG die Möglichkeit, Web Components um eine voll deklarative HTML-API zu erweitern. Um beide Ziele zu erreichen, wird HTML irgendwann ein reaktives Primitive benötigen. Zusätzlich sind viele ergonomische Verbesserungen für das DOM durch die Integration von Signals vorstellbar und wurden bereits von der Community gewünscht.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Hinweis: Diese Integration wäre eine separate, später folgende Initiative und nicht Teil dieses Vorschlags selbst.\n\n##### Informationsaustausch im Ökosystem (*kein* Grund für die Standardisierung)\n\nStandardisierungsbemühungen können manchmal auch auf „Community“-Ebene hilfreich sein, selbst ohne Änderungen in Browsern. Die Signals-Initiative bringt viele verschiedene Framework-Autoren für eine intensive Diskussion über die Natur von Reaktivität, Algorithmen und Interoperabilität zusammen. Das war bereits nützlich, rechtfertigt aber nicht die Aufnahme in JS-Engines und Browser; Signals sollten nur dann in den JavaScript-Standard aufgenommen werden, wenn es signifikante Vorteile *über* den durch den Informationsaustausch ermöglichten Ökosystemnutzen hinaus gibt.\n\n## Designziele für Signals\n\nEs stellt sich heraus, dass bestehende Signal-Bibliotheken im Kern gar nicht so unterschiedlich sind. Dieser Vorschlag will auf deren Erfolg aufbauen, indem er die wichtigen Qualitäten vieler dieser Bibliotheken implementiert.\n\n### Zentrale Eigenschaften\n\n* Ein Signal-Typ, der Zustand repräsentiert, d. h. ein beschreibbares Signal. Dies ist ein Wert, den andere lesen können.\n* Ein berechneter/memoisierter/abgeleiteter Signal-Typ, der von anderen abhängt und träge berechnet und zwischengespeichert wird.\n    * Die Berechnung ist träge, d. h. berechnete Signale werden nicht erneut berechnet, wenn eine ihrer Abhängigkeiten sich ändert, sondern nur, wenn tatsächlich jemand sie liest.\n    * Die Berechnung ist \"[glitch](https://de.wikipedia.org/wiki/Reaktives_Programmieren#Glitches)-frei\", d. h. es werden niemals unnötige Berechnungen durchgeführt. Das bedeutet, dass beim Lesen eines berechneten Signals eine topologische Sortierung der potenziell „verschmutzten“ Teile des Graphen durchgeführt wird, um Duplikate auszuschließen.\n    * Die Berechnung ist zwischengespeichert, d. h. wenn sich nach der letzten Änderung einer Abhängigkeit keine weitere Abhängigkeit ändert, wird das berechnete Signal beim Zugriff *nicht* neu berechnet.\n    * Benutzerdefinierte Vergleiche sind sowohl für berechnete als auch für Zustands-Signale möglich, um festzustellen, wann weitere berechnete Signale, die von ihnen abhängen, aktualisiert werden sollten.\n* Reaktionen auf den Zustand, bei dem ein berechnetes Signal eine seiner Abhängigkeiten (oder verschachtelte Abhängigkeiten) „dirty“ und geändert hat, was bedeutet, dass der Wert des Signals möglicherweise veraltet ist.\n    * Diese Reaktion soll ermöglichen, später größere Arbeiten einzuplanen.\n    * Effekte werden in Bezug auf diese Reaktionen sowie Framework-internes Scheduling implementiert.\n    * Berechnete Signale müssen erkennen können, ob sie als (verschachtelte) Abhängigkeit einer dieser Reaktionen registriert sind.\n* Ermöglicht JS-Frameworks, ihr eigenes Scheduling zu betreiben. Kein Promise-ähnliches, verpflichtendes Built-in-Scheduling.\n    * Synchrone Reaktionen sind notwendig, um späteres Scheduling auf Basis von Framework-Logik zu ermöglichen.\n    * Schreiboperationen sind synchron und wirken sofort (ein Framework, das Schreibvorgänge bündelt, kann das darauf aufbauend umsetzen).\n    * Es ist möglich, das Prüfen, ob ein Effekt „dirty“ sein könnte, von der tatsächlichen Ausführung des Effekts zu trennen (ermöglicht einen zweistufigen Effekt-Scheduler).\n* Möglichkeit, Signals *ohne* Erfassung von Abhängigkeiten zu lesen (`untrack`)\n* Ermöglicht die Komposition verschiedener Codebasen, die Signals/Reaktivität verwenden, z. B.\n    * Nutzung mehrerer Frameworks im Hinblick auf Tracking/Reaktivität (mit Einschränkungen, siehe unten)\n    * Framework-unabhängige reaktive Datenstrukturen (z. B. rekursiver reaktiver Store-Proxy, reaktive Map, Set und Array usw.)\n\n### Korrektheit (Soundness)\n\n* Naive Fehlanwendung synchroner Reaktionen verhindern/unterbinden.\n    * Risiko für Korrektheit: Es können \"[Glitches](https://de.wikipedia.org/wiki/Reaktives_Programmieren#Glitches)\" auftreten, wenn sie unsachgemäß verwendet werden: Wenn das Rendern sofort beim Setzen eines Signals erfolgt, kann dem Endnutzer ein unvollständiger Anwendungszustand angezeigt werden. Daher sollte dieses Feature nur dazu dienen, Arbeiten für später intelligent einzuplanen, nachdem die Anwendungslogik abgeschlossen ist.\n    * Lösung: Das Lesen und Schreiben von beliebigen Signalen innerhalb eines synchronen Reaktions-Callbacks verbieten.\n* `untrack` entmutigen und seine unsichere Natur kennzeichnen\n    * Risiko für Korrektheit: Erlaubt die Erstellung von berechneten Signalen, deren Wert von anderen Signalen abhängt, die aber nicht aktualisiert werden, wenn sich diese Signale ändern. Es sollte verwendet werden, wenn ungetrackte Zugriffe das Berechnungsergebnis nicht verändern.\n    * Lösung: Die API wird im Namen als \"unsafe\" gekennzeichnet.\n* Hinweis: Dieser Vorschlag erlaubt es, dass Signale sowohl aus berechneten als auch aus Effekt-Signalen gelesen und geschrieben werden, ohne Schreibvorgänge nach Lesevorgängen einzuschränken, trotz des Korrektheitsrisikos. Diese Entscheidung wurde getroffen, um Flexibilität und Kompatibilität bei der Integration mit Frameworks zu bewahren.\n\n### Oberflächen-API\n\n* Muss eine solide Grundlage für mehrere Frameworks bieten, um ihre Signals-/Reaktivitätsmechanismen zu implementieren.\n    * Sollte eine gute Basis für rekursive Store-Proxys, dekorator-basierte Klassenfeld-Reaktivität und sowohl `.value`- als auch `[state, setState]`-APIs sein.\n    * Die Semantik muss die gültigen Muster abbilden können, die durch verschiedene Frameworks ermöglicht werden. Beispielsweise sollte es möglich sein, dass diese Signals entweder die Grundlage für sofort reflektierte oder später gebündelte Schreibvorgänge sind.\n* Es wäre wünschenswert, wenn diese API direkt von JavaScript-Entwicklern genutzt werden könnte.\n    * Wenn ein Feature mit einem Ökosystem-Konzept übereinstimmt, ist es gut, eine gemeinsame Terminologie zu verwenden.\n        * Allerdings ist es wichtig, nicht exakt dieselben Namen zu verwenden!\n    * Spannungsfeld zwischen „Nutzbarkeit für JS-Entwickler“ und „Bereitstellung aller Hooks für Frameworks“.\n        * Idee: Alle Hooks bereitstellen, aber Fehler einbauen, wenn sie falsch verwendet werden.\n        * Idee: Subtile APIs in einen `subtle`-Namespace legen, ähnlich wie [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), um die Trennung zwischen APIs für fortgeschrittene Nutzung (Framework-Implementierung, Dev-Tools) und für alltägliche Entwicklung (Signale instanziieren) zu markieren.\n* Muss mit guter Performance implementierbar und nutzbar sein – die Oberflächen-API darf nicht zu viel Overhead verursachen.\n    * Subklassifizierung ermöglichen, damit Frameworks eigene Methoden und Felder (auch private Felder) hinzufügen können. Das ist wichtig, um zusätzliche Allokationen auf Framework-Ebene zu vermeiden. Siehe „Speicherverwaltung“ unten.\n\n### Speicherverwaltung\n\n* Wenn möglich: Ein berechnetes Signal sollte vom Garbage Collector entsorgt werden können, wenn es von nichts Lebendigem mehr für zukünftige Lesevorgänge referenziert wird, selbst wenn es in einen größeren Graphen eingebunden ist, der weiterlebt (z. B. durch das Lesen eines weiterhin lebendigen States).",
  "status": "ok"
}