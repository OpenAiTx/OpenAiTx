{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback appelé lorsque isWatched devient vrai, s'il était auparavant faux\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback appelé chaque fois que isWatched devient faux, s'il était auparavant vrai\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Fonctionnement des Signaux\n\nUn Signal représente une cellule de données qui peut changer au fil du temps. Les Signaux peuvent être soit de \"state\" (juste une valeur définie manuellement), soit \"computed\" (une formule basée sur d'autres Signaux).\n\nLes Signaux calculés fonctionnent en suivant automatiquement les autres Signaux qui sont lus lors de leur évaluation. Lorsqu'un signal calculé est lu, il vérifie si l'une de ses dépendances précédemment enregistrées a changé, et se réévalue le cas échéant. Lorsque plusieurs signaux calculés sont imbriqués, toute l’attribution du suivi revient au signal le plus interne.\n\nLes Signaux calculés sont paresseux, c’est-à-dire en mode \"pull\" : ils ne sont réévalués que lorsqu’ils sont accédés, même si l’une de leurs dépendances a changé auparavant.\n\nLe callback passé dans les Signaux calculés doit généralement être \"pur\" au sens d’une fonction déterministe, sans effets de bord, des autres Signaux auxquels il accède. En même temps, le moment où le callback est appelé est déterministe, permettant d’utiliser les effets de bord avec précaution.\n\nLes Signaux mettent fortement en avant le cache/mémoïsation : les Signaux d’état et les Signaux calculés mémorisent leur valeur actuelle, et ne déclenchent la réévaluation des Signaux calculés qui les référencent que s'ils changent effectivement. Une comparaison répétée de l’ancienne et de la nouvelle valeur n’est même pas nécessaire : la comparaison est effectuée une fois lorsque le Signal source est réinitialisé/réévalué, et le mécanisme de Signal garde une trace des éléments qui n’ont pas encore été mis à jour en fonction de la nouvelle valeur. En interne, cela est généralement représenté par la \"coloration de graphe\", comme décrit dans [l’article de blog de Milo](https://raw.githubusercontent.com/tc39/proposal-signals/main/blog/graph-coloring.md).\n\nLes Signaux calculés suivent dynamiquement leurs dépendances : à chaque exécution, ils peuvent finir par dépendre de choses différentes, et cet ensemble précis de dépendances est maintenu à jour dans le graphe de Signaux. Cela signifie que si vous avez une dépendance nécessaire dans une seule branche, et que le calcul précédent a pris l’autre branche, alors un changement de cette valeur temporairement inutilisée ne provoquera pas la réévaluation du Signal calculé, même lors d'une demande de sa valeur.\n\nContrairement aux Promesses JavaScript, tout dans les Signaux s’exécute de manière synchrone :\n- La définition d’un Signal à une nouvelle valeur est synchrone, et cela se reflète immédiatement lors de la lecture de tout Signal calculé qui en dépend par la suite. Il n’y a pas de regroupement (\"batching\") intégré de cette mutation.\n- La lecture des Signaux calculés est synchrone : leur valeur est toujours disponible.\n- Le callback `notify` dans les Watchers, comme expliqué ci-dessous, s’exécute de manière synchrone, lors de l’appel à `.set()` qui l’a déclenché (mais après la complétion de la coloration du graphe).\n\nComme les Promesses, les Signaux peuvent représenter un état d’erreur : si le callback d’un Signal calculé lève une exception, alors cette erreur est mémorisée comme une valeur, et relancée à chaque lecture du Signal.\n\n### Comprendre la classe Signal\n\nUne instance de `Signal` représente la capacité de lire une valeur qui change dynamiquement et dont les mises à jour sont suivies dans le temps. Elle inclut également implicitement la capacité de s’abonner au Signal, implicitement via un accès suivi depuis un autre Signal calculé.\n\nL’API ici est conçue pour correspondre au consensus assez large de l’écosystème entre de nombreuses bibliothèques de Signaux concernant l’utilisation de noms comme \"signal\", \"computed\" et \"state\". Cependant, l’accès aux Signaux calculés et d’état se fait via une méthode `.get()`, ce qui diffère de toutes les API populaires de Signaux, qui utilisent soit un accesseur de style `.value`, soit une syntaxe d’appel `signal()`.\n\nL’API est conçue pour réduire le nombre d’allocations, afin de rendre les Signaux adaptés à l’intégration dans des frameworks JavaScript tout en atteignant des performances similaires ou supérieures aux Signaux personnalisés des frameworks existants. Cela implique :\n- Les Signaux d’état sont un unique objet inscriptible, qui peut être à la fois accédé et modifié à partir de la même référence. (Voir les implications ci-dessous dans la section \"Séparation des capacités\".)\n- Les Signaux d’état et calculés sont conçus pour pouvoir être sous-classés, afin de faciliter l’ajout par les frameworks de propriétés supplémentaires via des champs de classe publics/privés (ainsi que des méthodes pour utiliser cet état).\n- Divers callbacks (par exemple, `equals`, le callback de computed) sont appelés avec le Signal concerné en tant que valeur de `this` pour le contexte, de sorte qu’une nouvelle closure n’est pas nécessaire par Signal. À la place, le contexte peut être sauvegardé dans des propriétés supplémentaires du signal lui-même.\n\nCertaines conditions d’erreur imposées par cette API :\n- Il est interdit de lire un Signal calculé de façon récursive.\n- Le callback `notify` d’un Watcher ne peut ni lire ni écrire de signaux.\n- Si le callback d’un Signal calculé lève une exception, les accès ultérieurs à ce Signal relanceront cette erreur mémorisée, jusqu’à ce qu’une des dépendances change et qu’il soit recalculé.\n\nCertaines conditions qui ne sont *pas* imposées :\n- Les Signaux calculés peuvent écrire dans d’autres Signaux, de façon synchrone dans leur callback.\n- Le travail mis en file d’attente par le callback `notify` d’un Watcher peut lire ou écrire des signaux, ce qui permet de reproduire [des anti-patterns React classiques](https://react.dev/learn/you-might-not-need-an-effect) en termes de Signaux !\n\n### Implémentation des effets\n\nL’interface `Watcher` définie ci-dessus sert de base à l’implémentation des API JS classiques pour les effets : des callbacks réexécutés lorsque d’autres Signaux changent, uniquement pour leurs effets de bord. La fonction `effect` utilisée plus haut dans l’exemple initial peut être définie comme suit :\n\n```ts\n// Cette fonction vivrait généralement dans une bibliothèque/framework, pas dans le code applicatif\n// REMARQUE : Cette logique de planification est trop simple pour être utile. Ne pas copier/coller.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Un Signal d’effet qui évalue cb, qui programme une lecture de lui-même dans la file de micro-tâches chaque fois qu’une de ses dépendances peut changer\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nL’API Signal n’inclut pas de fonction intégrée comme `effect`. En effet, la planification des effets est subtile et s’intègre souvent dans les cycles de rendu des frameworks et d’autres états ou stratégies spécifiques de haut niveau, auxquels JS n’a pas accès.\n\nDécomposons les différentes opérations utilisées ici : le callback `notify` passé au constructeur de `Watcher` est la fonction appelée lorsque le Signal passe d’un état \"propre\" (où l’on sait que le cache est initialisé et valide) à un état \"checked\" ou \"dirty\" (où le cache peut ne plus être valide car au moins un des états dont il dépend récursivement a changé).\n\nLes appels à `notify` sont finalement déclenchés par un appel à `.set()` sur un Signal d’état. Cet appel est synchrone : il a lieu avant que `.set` ne retourne. Mais il n’est pas nécessaire de s’inquiéter que ce callback observe le graphe de Signaux dans un état partiellement traité, car pendant un callback `notify`, aucun Signal ne peut être lu ou écrit, même dans un appel à `untrack`. Comme `notify` est appelé pendant `.set()`, il interrompt un autre flux logique, qui pourrait ne pas être terminé. Pour lire ou écrire des Signaux depuis `notify`, programmez le travail pour plus tard, par exemple en enregistrant le Signal dans une liste à traiter plus tard, ou avec `queueMicrotask` comme ci-dessus.\n\nNotez qu’il est parfaitement possible d’utiliser efficacement les Signaux sans `Signal.subtle.Watcher` en planifiant des interrogations (\"polling\") de Signaux calculés, comme le fait Glimmer. Cependant, de nombreux frameworks ont constaté qu’il est très souvent utile d’exécuter cette logique de planification de façon synchrone, c’est pourquoi l’API Signals l’inclut.\n\nLes Signaux calculés et d’état sont tous deux collectés par le ramasse-miettes comme n’importe quelle valeur JS. Mais les Watchers disposent d’un mécanisme spécial pour maintenir des objets vivants : tout Signal surveillé par un Watcher sera maintenu vivant tant qu’un des états sous-jacents reste accessible, car ceux-ci peuvent déclencher un futur appel à `notify` (et ensuite un futur `.get()`). Pour cette raison, pensez à appeler `Watcher.prototype.unwatch` pour nettoyer les effets.\n\n### Une échappatoire dangereuse\n\n`Signal.subtle.untrack` est une échappatoire permettant de lire des Signaux *sans* suivre ces lectures. Cette capacité est dangereuse car elle permet de créer des Signaux calculés dont la valeur dépend d’autres Signaux, mais qui ne sont pas mis à jour lorsque ces Signaux changent. Elle doit être utilisée uniquement lorsque les accès non suivis ne changent pas le résultat du calcul.\n\n<!--\nTODO: Montrer un exemple où il est pertinent d’utiliser untrack\n\n### Utilisation de watched/unwatched",
  "status": "ok"
}