{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Dengan [AsyncContext](https://github.com/tc39/proposal-async-context), callback yang diberikan ke `new Signal.subtle.Watcher` *tidak* menutup snapshot dari saat konstruktor dipanggil, sehingga informasi kontekstual di sekitar penulisan dapat terlihat.\n\n#### Metode: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Jika `frozen` bernilai true, lemparkan sebuah exception.\n1. Jika salah satu argumen bukan sebuah signal, lemparkan sebuah exception.\n1. Tambahkan semua argumen ke akhir `signals` objek ini.\n1. Untuk setiap signal yang baru dipantau, dari kiri ke kanan,\n    1. Tambahkan watcher ini sebagai `sink` ke signal tersebut.\n    1. Jika ini adalah sink pertama, lakukan rekursi ke sumber untuk menambahkan signal itu sebagai sink.\n    1. Setel `frozen` ke true.\n    1. Panggil callback `watched` jika ada.\n    1. Kembalikan `frozen` ke false.\n1. Jika `state` Signal adalah `~waiting~`, maka setel menjadi `~watching~`.\n\n#### Metode: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Jika `frozen` bernilai true, lemparkan sebuah exception.\n1. Jika salah satu argumen bukan sebuah signal, atau tidak sedang dipantau oleh watcher ini, lemparkan sebuah exception.\n1. Untuk setiap signal dalam argumen, dari kiri ke kanan,\n    1. Hapus signal tersebut dari set `signals` milik Watcher ini.\n    1. Hapus Watcher ini dari set `sink` milik Signal tersebut.\n    1. Jika set `sink` milik Signal itu menjadi kosong, hapus Signal itu sebagai sink dari setiap sumbernya.\n    1. Setel `frozen` ke true.\n    1. Panggil callback `unwatched` jika ada.\n    1. Kembalikan `frozen` ke false.\n1. Jika watcher sekarang tidak memiliki `signals`, dan `state`-nya adalah `~watching~`, maka setel menjadi `~waiting~`.\n\n#### Metode: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Kembalikan sebuah Array yang berisi subset dari `signals` yang merupakan Computed Signals dalam state `~dirty~` atau `~pending~`.\n\n### Metode: `Signal.subtle.untrack(cb)`\n\n1. Biarkan `c` sebagai state `computing` saat ini dari context eksekusi.\n1. Setel `computing` ke null.\n1. Panggil `cb`.\n1. Kembalikan `computing` ke `c` (meskipun `cb` melempar exception).\n1. Kembalikan nilai return dari `cb` (melempar ulang exception jika ada).\n\nCatatan: untrack tidak membuatmu keluar dari state `frozen`, yang dijaga secara ketat.\n\n### Metode: `Signal.subtle.currentComputed()`\n\n1. Kembalikan nilai `computing` saat ini.\n\n### Algoritma umum\n\n##### Algoritma: menghitung ulang Signal computed yang dirty\n\n1. Kosongkan set `sources` milik Signal ini, dan hapus Signal ini dari set `sinks` milik sumber-sumber tersebut.\n1. Simpan nilai `computing` sebelumnya dan setel `computing` ke Signal ini.\n1. Setel state Signal ini menjadi `~computing~`.\n1. Jalankan callback Signal computed ini, menggunakan Signal ini sebagai nilai this. Simpan nilai return-nya, dan jika callback melempar exception, simpan exception tersebut untuk dilempar ulang.\n1. Kembalikan nilai `computing` sebelumnya.\n1. Terapkan algoritma \"set Signal value\" pada nilai return callback.\n2. Setel state Signal ini menjadi `~clean~`.\n1. Jika algoritma itu mengembalikan `~dirty~`: tandai semua sink dari Signal ini sebagai `~dirty~` (sebelumnya, sink bisa jadi campuran antara checked dan dirty). (Atau, jika ini tidak dipantau, adopsi nomor generasi baru untuk menandai kekotoran, atau sesuatu seperti itu.)\n1. Jika tidak, algoritma itu mengembalikan `~clean~`: Dalam kasus ini, untuk setiap sink `~checked~` dari Signal ini, jika semua sumber Signal itu sekarang bersih, maka tandai Signal itu sebagai `~clean~` juga. Terapkan langkah pembersihan ini ke sink lebih lanjut secara rekursif, ke Signal yang baru saja bersih yang memiliki sink checked. (Atau, jika ini tidak dipantau, berikan indikasi yang sama, sehingga pembersihan dapat dilakukan secara lazy.)\n\n##### Algoritma set Signal value\n\n1. Jika algoritma ini diberikan sebuah nilai (bukan exception untuk dilempar ulang, dari algoritma recalculate dirty computed Signal):\n    1. Panggil fungsi `equals` milik Signal ini, dengan parameter `value` saat ini, nilai baru, dan Signal ini. Jika terjadi exception, simpan exception tersebut (untuk dilempar saat dibaca) sebagai nilai Signal dan lanjutkan seolah-olah callback mengembalikan false.\n    1. Jika fungsi tersebut mengembalikan true, kembalikan `~clean~`.\n1. Setel `value` dari Signal ini ke parameter.\n1. Kembalikan `~dirty~`\n\n## FAQ\n\n**T:** Bukankah terlalu cepat untuk melakukan standarisasi sesuatu yang berkaitan dengan Signals, padahal mereka baru mulai populer pada tahun 2022? Bukankah sebaiknya kita memberi mereka lebih banyak waktu untuk berkembang dan stabil?\n\n**J:** Keadaan Signals saat ini di framework web adalah hasil dari lebih dari 10 tahun pengembangan berkelanjutan. Seiring meningkatnya investasi, seperti yang terjadi dalam beberapa tahun terakhir, hampir semua framework web mendekati model inti Signals yang sangat mirip. Proposal ini adalah hasil dari latihan desain bersama antara banyak pemimpin framework web saat ini, dan tidak akan didorong ke proses standarisasi tanpa validasi dari kelompok pakar domain tersebut di berbagai konteks.\n\n#### Bagaimana Signals digunakan?\n\n**T:** Apakah Signals bawaan bahkan bisa digunakan oleh framework, mengingat integrasi mereka yang erat dengan rendering dan kepemilikan?\n\n**J:** Bagian yang lebih spesifik framework cenderung berada di area efek, penjadwalan, dan kepemilikan/penghapusan, yang tidak dicoba untuk dipecahkan oleh proposal ini. Prioritas utama kami dengan prototipe Signals standar adalah memvalidasi bahwa mereka dapat duduk \"di bawah\" framework yang ada secara kompatibel dan dengan performa baik.\n\n**T:** Apakah API Signal memang dimaksudkan untuk digunakan langsung oleh pengembang aplikasi, atau dibungkus oleh framework?\n\n**J:** Meski API ini bisa digunakan langsung oleh pengembang aplikasi (setidaknya bagian yang tidak berada di namespace `Signal.subtle`), ia tidak didesain agar sangat ergonomis. Sebaliknya, kebutuhan penulis library/framework menjadi prioritas. Sebagian besar framework diharapkan membungkus bahkan API dasar seperti `Signal.State` dan `Signal.Computed` dengan sesuatu yang lebih ergonomis menurut gaya mereka. Dalam praktiknya, biasanya terbaik menggunakan Signals melalui framework, yang mengelola fitur yang lebih rumit (misal, Watcher, `untrack`), serta mengatur kepemilikan dan penghapusan (misal, menentukan kapan signals harus ditambahkan dan dihapus dari watcher), dan penjadwalan rendering ke DOM—proposal ini tidak berusaha menyelesaikan masalah-masalah tersebut.\n\n**T:** Apakah saya harus membongkar Signals yang terkait dengan sebuah widget ketika widget itu dihancurkan? Apa API-nya untuk itu?\n\n**J:** Operasi teardown yang relevan di sini adalah `Signal.subtle.Watcher.prototype.unwatch`. Hanya Signals yang dipantau yang perlu dibersihkan (dengan unwatch), sementara Signals yang tidak dipantau bisa di-garbage collect secara otomatis.\n\n**T:** Apakah Signals bekerja dengan VDOM, atau langsung dengan HTML DOM yang mendasarinya?\n\n**J:** Ya! Signals independen dari teknologi rendering. Framework JavaScript yang sudah ada dan menggunakan konstruksi seperti Signal dapat terintegrasi dengan VDOM (misal, Preact), native DOM (misal, Solid) dan kombinasi (misal, Vue). Hal yang sama juga akan mungkin dengan Signals bawaan.\n\n**T:** Apakah akan ergonomis menggunakan Signals dalam konteks framework berbasis kelas seperti Angular dan Lit? Bagaimana dengan framework berbasis compiler seperti Svelte?\n\n**J:** Field pada class bisa dibuat berbasis Signal dengan decorator accessor sederhana, seperti yang ditunjukkan dalam [readme Signal polyfill](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals sangat selaras dengan Runes di Svelte 5—sangat mudah bagi compiler untuk mengubah runes menjadi API Signal yang didefinisikan di sini, dan faktanya itulah yang dilakukan Svelte 5 secara internal (tetapi dengan library Signals milik mereka sendiri).\n\n**T:** Apakah Signals bekerja dengan SSR? Hydration? Resumability?\n\n**J:** Ya. Qwik menggunakan Signals dengan baik untuk kedua properti ini, dan framework lain memiliki pendekatan lain yang juga sudah matang untuk hydration dengan Signals dengan berbagai trade-off. Kami yakin bahwa memungkinkan untuk memodelkan Signals Qwik yang resumable menggunakan State dan Computed signal yang dihubungkan bersama, dan berencana membuktikannya dalam kode.",
  "status": "ok"
}