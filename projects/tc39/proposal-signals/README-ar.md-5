{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: عرض مثال لتحويل كائن Observable إلى إشارة محسوبة، يتم الاشتراك بها فقط عند استخدامها من قبل تأثير\n\nTODO: عرض مثال لإشارة محسوبة تمثل نتيجة عملية جلب fetch موجهة إلى حالة، يتم إلغاؤها\n\n### الاستبطان لخوادم SSR\n\nTODO: عرض كيفية عمل تسلسل رسم الإشارة (signal graph)\n\nTODO: عرض كيفية \"إحياء\" إشارة من حالة إلى محسوبة لاحقًا، باستخدام بعض الإشارات.\n-->\n\n### تم الاستبعاد حاليًا\n\nقد تتم إضافة هذه الميزات لاحقًا، لكنها غير مدرجة في المسودة الحالية. سبب الاستبعاد هو عدم وجود إجماع راسخ في مساحة التصميم بين الأطر البرمجية، بالإضافة إلى القدرة المثبتة على إيجاد حلول بديلة لغيابها باستخدام آليات مبنية فوق مفهوم الإشارات (Signals) الموضح في هذا المستند. ومع ذلك، للأسف، فإن هذا الاستبعاد يحد من إمكانيات التوافق البيني بين الأطر. مع إنتاج نماذج أولية للإشارات كما هو موضح في هذا المستند، ستكون هناك محاولة لإعادة تقييم ما إذا كان هذا الاستبعاد هو القرار المناسب.\n\n* **غير المتزامن (Async)**: الإشارات متوفرة دائمًا بشكل متزامن للتقييم في هذا النموذج. ومع ذلك، غالبًا ما يكون من المفيد وجود عمليات غير متزامنة معينة تؤدي إلى تعيين قيمة لإشارة ما، وفهم متى تكون الإشارة لا تزال \"قيد التحميل\". إحدى الطرق البسيطة لنمذجة حالة التحميل هي باستخدام الاستثناءات، ويكوّن سلوك التخزين المؤقت للاستثناءات في الإشارات المحسوبة مع هذه التقنية بشكل معقول إلى حد ما. تم مناقشة تقنيات محسنة في [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **المعاملات (Transactions)**: من المفيد غالبًا أثناء الانتقال بين العروض الاحتفاظ بحالة نشطة لكل من حالتي \"من\" و\"إلى\". يتم عرض الحالة \"إلى\" في الخلفية حتى تصبح جاهزة للتبديل (الالتزام بالمعاملة)، بينما تبقى الحالة \"من\" تفاعلية. يتطلب الحفاظ على كلتا الحالتين في نفس الوقت \"تفريع\" حالة رسم الإشارات، وقد يكون من المفيد حتى دعم عدة انتقالات معلقة في وقت واحد. مناقشة في [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nتم أيضًا استبعاد بعض [طرق الراحة](https://github.com/proposal-signals/proposal-signals/issues/32) المحتملة.\n\n## الحالة وخطة التطوير\n\nهذا الاقتراح مدرج في جدول أعمال TC39 لشهر أبريل 2024 للمرحلة 1. ويمكن اعتباره حاليًا في \"المرحلة 0\".\n\n[هناك polyfill](https://github.com/proposal-signals/signal-polyfill) متاح لهذا الاقتراح، مع بعض الاختبارات الأساسية. بدأ بعض مؤلفي الأطر البرمجية بالفعل في تجربة استبدال هذه الإشارة في تطبيقاتهم، لكن هذا الاستخدام لا يزال في مرحلة مبكرة.\n\nيرغب المتعاونون على اقتراح الإشارة في أن يكونوا **محافظين** للغاية في كيفية دفع هذا الاقتراح للأمام، حتى لا نقع في فخ شحن شيء نندم عليه في النهاية ولا نستخدمه فعليًا. خطتنا هي القيام بالمهام الإضافية التالية، غير المطلوبة من قبل عملية TC39، للتأكد من أن هذا الاقتراح على المسار الصحيح:\n\nقبل التقدم للمرحلة 2، نخطط إلى:\n- تطوير عدة تطبيقات polyfill بمستوى إنتاجي قوية، ومختبرة جيدًا (مثلاً، اجتياز اختبارات من أطر مختلفة بالإضافة إلى اختبارات بأسلوب test262)، وتنافسية من حيث الأداء (كما يتم التحقق من ذلك من خلال مجموعة اختبارات شاملة للإشارات/الأطر).\n- دمج واجهة برمجة تطبيقات الإشارة المقترحة في عدد كبير من أطر عمل JavaScript التي نعتبرها تمثيلية إلى حد ما، وأن تعمل بعض التطبيقات الكبيرة على هذا الأساس. اختبار أنها تعمل بكفاءة وبشكل صحيح في هذه السياقات.\n- الحصول على فهم راسخ لمجال الامتدادات الممكنة لواجهة برمجة التطبيقات، والتوصل إلى أي منها (إن وجدت) يجب إضافته إلى هذا الاقتراح.\n\n## خوارزميات الإشارة\n\nيصف هذا القسم كل واجهة برمجة التطبيقات التي يتم كشفها لجافاسكريبت، من حيث الخوارزميات التي تنفذها. يمكن اعتبار ذلك بمثابة مواصفات أولية، وتم تضمينها في هذه المرحلة المبكرة لتثبيت مجموعة ممكنة من الدلالات، مع الانفتاح التام على التغييرات.\n\nبعض جوانب الخوارزمية:\n- ترتيب قراءات الإشارات داخل المحسوبة مهم، ويمكن ملاحظته في ترتيب تنفيذ بعض callbacks (مثل استدعاء `Watcher`، و`equals`، والمعامل الأول لـ `new Signal.Computed`، وCallbacks `watched`/`unwatched`). هذا يعني أن مصادر إشارة محسوبة يجب أن يتم تخزينها بترتيب.\n- هذه callbacks الأربعة قد ترمي جميعها استثناءات، وتنتقل هذه الاستثناءات بطريقة متوقعة إلى كود جافاسكريبت المنادي. الاستثناءات *لا* توقف تنفيذ هذه الخوارزمية أو تترك الرسم البياني في حالة نصف معالجة. بالنسبة للأخطاء التي تحدث في استدعاء notify الخاص بـ Watcher، يتم إرسال هذا الاستثناء إلى استدعاء `.set()` الذي تسبب به، باستخدام AggregateError إذا تم رمي عدة استثناءات. أما البقية (بما في ذلك `watched`/`unwatched`؟) فيتم تخزينها في قيمة الإشارة، ليتم رميها مرة أخرى عند القراءة، ويمكن تمييز مثل هذه الإشارة التي تم إعادة رميها كـ `~clean~` مثل أي إشارة أخرى بقيمة عادية.\n- يتم اتخاذ الحيطة لتجنب الدوائر المغلقة في حالات الإشارات المحسوبة التي لا تتم \"مشاهدتها\" (أي غير مراقبة من قبل أي Watcher)، بحيث يمكن جمعها تلقائيًا بشكل مستقل عن أجزاء أخرى من رسم الإشارات. داخليًا، يمكن تنفيذ ذلك باستخدام نظام أرقام أجيال يتم جمعها دائمًا؛ لاحظ أن التطبيقات المحسنة قد تتضمن أيضًا أرقام أجيال محلية لكل عقدة، أو تتجنب تتبع بعض الأرقام على الإشارات المشاهدة.\n\n### الحالة العالمية المخفية\n\nتحتاج خوارزميات الإشارة إلى الإشارة إلى حالة عالمية معينة. هذه الحالة عالمية لكامل الخيط thread، أو \"الوكيل agent\".\n\n- `computing`: أعمق إشارة محسوبة أو تأثير يتم إعادة تقييمها حاليًا بسبب استدعاء `.get` أو `.run`، أو `null`. في البداية تكون `null`.\n- `frozen`: قيمة منطقية تدل على ما إذا كان هناك Callback يتم تنفيذه حاليًا يتطلب عدم تعديل الرسم البياني. في البداية `false`.\n- `generation`: عدد صحيح متزايد، يبدأ من 0، يُستخدم لتعقب مدى حداثة القيمة أثناء تجنب الدوائر المغلقة.\n\n### فضاء الاسم `Signal`\n\n`Signal` هو كائن عادي يعمل كفضاء اسم للفئات والدوال المتعلقة بالإشارة.\n\n`Signal.subtle` هو كائن مماثل كفضاء اسم داخلي.\n\n### فئة `Signal.State`\n\n#### الخانات الداخلية لـ `Signal.State`\n\n- `value`: القيمة الحالية لإشارة الحالة\n- `equals`: دالة المقارنة المستخدمة عند تغيير القيم\n- `watched`: Callback يتم استدعاؤه عند مراقبة الإشارة من قبل تأثير\n- `unwatched`: Callback يتم استدعاؤه عند توقف الإشارة عن أن تكون مراقبة من قبل تأثير\n- `sinks`: مجموعة من الإشارات المشاهدة التي تعتمد على هذه الإشارة\n\n#### الباني: `Signal.State(initialValue, options)`\n\n1. عيّن قيمة `value` لهذه الإشارة إلى `initialValue`.\n1. عيّن قيمة `equals` إلى options?.equals\n1. عيّن قيمة `watched` إلى options?.[Signal.subtle.watched]\n1. عيّن قيمة `unwatched` إلى options?.[Signal.subtle.unwatched]\n1. عيّن قيمة `sinks` إلى مجموعة فارغة\n\n#### طريقة: `Signal.State.prototype.get()`\n\n1. إذا كانت `frozen` تساوي true، ارمي استثناءً.\n1. إذا كانت `computing` ليست `undefined`، أضف هذه الإشارة إلى مجموعة `sources` الخاصة بـ `computing`.\n1. ملاحظة: لا نضيف `computing` إلى مجموعة `sinks` لهذه الإشارة حتى تتم مراقبتها من قبل Watcher.\n1. أرجع قيمة `value` لهذه الإشارة.\n\n#### طريقة: `Signal.State.prototype.set(newValue)`\n\n1. إذا كان سياق التنفيذ الحالي هو `frozen`، ارمي استثناءً.\n1. نفذ خوارزمية \"تعيين قيمة الإشارة\" مع هذه الإشارة والمعامل الأول للقيمة.\n1. إذا أعادت تلك الخوارزمية `~clean~`، أرجع undefined.\n1. عيّن حالة جميع `sinks` لهذه الإشارة إلى (إذا كانت إشارة محسوبة) `~dirty~` إذا كانت نظيفة سابقًا، أو (إذا كانت Watcher) `~pending~` إذا كانت سابقًا `~watching~`.\n1. عيّن حالة جميع تبعيات الإشارات المحسوبة لـ sinks (بشكل متكرر) إلى `~checked~` إذا كانت نظيفة سابقًا (أي، اترك العلامات المتسخة كما هي)، أو بالنسبة لـ Watchers، `~pending~` إذا كانت سابقًا `~watching~`.\n1. لكل Watcher كان سابقًا في حالة `~watching~` تم العثور عليه في ذلك البحث المتكرر، ثم بترتيب العمق أولاً (depth-first):\n    1. عيّن `frozen` إلى true.\n    1. استدعِ Callback `notify` الخاص بهم (مع حفظ أي استثناء تم رميه، ولكن تجاهل القيمة المرجعة لـ `notify`).\n    1. أعد `frozen` إلى false.\n    1. عيّن حالة الـ Watcher إلى `~waiting~`.\n1. إذا تم رمي أي استثناء من Callbacks `notify`، مرره إلى المنادي بعد تنفيذ جميع Callbacks `notify`. إذا كان هناك عدة استثناءات، اجمعها في AggregateError وارمه.\n1. أرجع undefined.\n\n### فئة `Signal.Computed`\n\n#### آلة الحالة لـ `Signal.Computed`",
  "status": "ok"
}