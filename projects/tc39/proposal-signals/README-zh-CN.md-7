{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "使用 [AsyncContext](https://github.com/tc39/proposal-async-context) 时，传递给 `new Signal.subtle.Watcher` 的回调*不会*闭包化构造函数调用时的快照，因此写入时的上下文信息是可见的。\n\n#### 方法：`Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. 如果 `frozen` 为 true，抛出异常。\n1. 如果任何参数不是信号，抛出异常。\n1. 将所有参数追加到该对象的 `signals` 末尾。\n1. 对于每一个新被监视的信号，按从左到右的顺序，\n    1. 将此监视器作为该信号的 `sink` 添加。\n    1. 如果这是第一个 sink，则递归向上到源头，将该信号添加为 sink。\n    1. 将 `frozen` 设为 true。\n    1. 如果存在 `watched` 回调则调用它。\n    1. 恢复 `frozen` 为 false。\n1. 如果 Signal 的 `state` 为 `~waiting~`，则将其设为 `~watching~`。\n\n#### 方法：`Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. 如果 `frozen` 为 true，抛出异常。\n1. 如果任何参数不是信号，或未被该监视器监视，抛出异常。\n1. 对于参数中的每个信号，按从左到右的顺序，\n    1. 从此 Watcher 的 `signals` 集合中移除该信号。\n    1. 从该 Signal 的 `sink` 集合中移除此 Watcher。\n    1. 如果该 Signal 的 `sink` 集合已为空，则从其每个源中移除该 Signal 作为 sink。\n    1. 将 `frozen` 设为 true。\n    1. 如果存在 `unwatched` 回调则调用它。\n    1. 恢复 `frozen` 为 false。\n1. 如果该监视器现在没有 `signals`，且其 `state` 为 `~watching~`，则将其设为 `~waiting~`。\n\n#### 方法：`Signal.subtle.Watcher.prototype.getPending()`\n\n1. 返回一个数组，包含 `signals` 中处于 `~dirty~` 或 `~pending~` 状态的计算信号的子集。\n\n### 方法：`Signal.subtle.untrack(cb)`\n\n1. 令 `c` 为执行上下文当前的 `computing` 状态。\n1. 设置 `computing` 为 null。\n1. 调用 `cb`。\n1. 恢复 `computing` 为 `c`（即使 `cb` 抛出异常也要恢复）。\n1. 返回 `cb` 的返回值（如有异常则重新抛出）。\n\n注意：untrack 并不会使你脱离 `frozen` 状态，该状态会被严格维护。\n\n### 方法：`Signal.subtle.currentComputed()`\n\n1. 返回当前的 `computing` 值。\n\n### 通用算法\n\n##### 算法：重新计算 dirty 的计算信号\n\n1. 清空此 Signal 的 `sources` 集合，并从这些源的 `sinks` 集合中移除此信号。\n1. 保存之前的 `computing` 值，并设置 `computing` 为此 Signal。\n1. 将此 Signal 的状态设为 `~computing~`。\n1. 运行此计算 Signal 的回调，使用此 Signal 作为 this 值。保存返回值，如果回调抛出异常，则存储该异常以便重抛。\n1. 恢复之前的 `computing` 值。\n1. 对回调的返回值应用“设置 Signal 值”算法。\n2. 将此 Signal 的状态设为 `~clean~`。\n1. 如果该算法返回 `~dirty~`：将此 Signal 的所有 sinks 标记为 `~dirty~`（之前，这些 sinks 可能是 checked 和 dirty 的混合）。（或者，如果此信号未被监视，则采用新的 generation number 来表示 dirty，或类似方式。）\n1. 否则，该算法返回 `~clean~`：此时，对于此 Signal 的每一个 `~checked~` sink，如果该 Signal 的所有源现在都为 clean，则也将该 Signal 标记为 `~clean~`。对进一步的 sinks 递归应用此清理步骤，对任何新变为 clean 且有 checked sinks 的信号也进行清理。（或者，如果此信号未被监视，则以某种方式表示相同状态，以便清理可以惰性进行。）\n\n##### 设置 Signal 值算法\n\n1. 如果此算法传入的是值（而不是来自重新计算 dirty 计算信号算法的异常）：\n    1. 调用此 Signal 的 `equals` 函数，参数为当前 `value`、新值和此 Signal。如果抛出异常，则保存该异常（在读取时重新抛出）为 Signal 的值，并继续就像回调返回 false 一样。\n    1. 如果该函数返回 true，返回 `~clean~`。\n1. 将此 Signal 的 `value` 设为参数值。\n1. 返回 `~dirty~`\n\n## 常见问题\n\n**问**：现在就对 Signals 相关内容进行标准化是不是有点早？它们才在 2022 年开始流行，是否应该给它们更多时间进化和稳定？\n\n**答**：Web 框架中 Signals 的现状是十多年持续开发的结果。随着近几年投资的增加，几乎所有 Web 框架都在趋向非常相似的 Signals 核心模型。本提案是众多当前 Web 框架领导者共同设计的成果，只有在该领域专家在多种场景下验证后才会推进标准化。\n\n#### Signals 是如何被使用的？\n\n**问**：内置的 Signals 框架真的能用吗？考虑到它们与渲染和所有权紧密集成。\n\n**答**：更具框架特性的部分通常集中在副作用、调度和所有权/销毁领域，本提案并未试图解决这些问题。我们首要验证的是标准化的 Signals 能否兼容地、且具备良好性能地“底层”支撑现有框架。\n\n**问**：Signal API 是打算直接让应用开发者使用，还是由框架封装后使用？\n\n**答**：虽然此 API 可以直接被应用开发者使用（至少不是在 `Signal.subtle` 命名空间下的部分），但它并未设计为特别易用。相反，更优先考虑库/框架作者的需求。多数框架预计会对基础的 `Signal.State` 和 `Signal.Computed` API 进行封装，以体现其易用性。在实际中，最好通过框架来使用 Signals，这样可以管理更复杂的特性（如 Watcher、`untrack`），以及所有权和销毁的管理（如何时将信号添加到监视器或移除），以及 DOM 渲染调度——本提案不试图解决这些问题。\n\n**问**：当组件销毁时，我是否必须清除与该组件相关的 Signals？API 如何？\n\n**答**：这里相关的清理操作是 `Signal.subtle.Watcher.prototype.unwatch`。只需对被监视的 Signals 进行清理（通过 unwatch），未被监视的 Signals 可以自动被垃圾回收。\n\n**问**：Signals 能与 VDOM 或直接与底层 HTML DOM 配合使用吗？\n\n**答**：可以！Signals 独立于渲染技术。现有使用类似 Signal 构造的 JavaScript 框架可与 VDOM（如 Preact）、原生 DOM（如 Solid）及混合方式（如 Vue）集成。内置 Signals 也将支持同样的能力。\n\n**问**：在像 Angular 和 Lit 这样的类框架中使用 Signals 是否友好？编译器型框架如 Svelte 呢？\n\n**答**：类字段可以通过简单的访问器装饰器变为基于 Signal，如[Signal polyfill 的说明文档](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators)所示。Signals 与 Svelte 5 的 Runes 非常契合——编译器可以轻松将 runes 转换为本提案定义的 Signal API，事实上 Svelte 5 内部就是这样做的（但用的是自己的 Signals 库）。\n\n**问**：Signals 支持 SSR、Hydration、Resumability 吗？\n\n**答**：支持。Qwik 在这两方面都有效地利用了 Signals，其它框架也有不同权衡的成熟 hydration 方案。我们认为可以通过用 State 和 Computed 信号互相连接来建模 Qwik 的 resumable Signals，并计划在代码中进行验证。",
  "status": "ok"
}