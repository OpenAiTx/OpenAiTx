{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* 请注意，目前大多数框架在计算型 Signal 与其他仍然存活的 Signal 图存在任何引用时，都需要显式释放这些计算型 Signal。\n* 当它们的生命周期与 UI 组件的生命周期绑定，并且副作用本身也需要被释放时，这种情况其实并不糟糕。\n* 如果以这种语义执行的代价太高，那么我们应该在下方的 API 中添加对计算型 Signal 的显式释放（或“解除链接”）操作，目前该 API 尚未包含此功能。\n* 一个相关但独立的目标：最小化分配次数，例如：\n    * 创建可写 Signal（避免两个独立的闭包 + 数组）\n    * 实现副作用（避免为每个反应创建闭包）\n    * 在用于观察 Signal 变化的 API 中，避免创建额外的临时数据结构\n    * 解决方案：基于类的 API，允许子类重用已定义的方法和字段\n\n## API 草图\n\n下面是 Signal API 的初步设想。请注意，这只是一个早期草案，我们预计未来会有变化。我们先从完整的 `.d.ts` 入手，了解整体结构，然后再讨论各部分的详细含义。\n\n```ts\ninterface Signal<T> {\n    // 获取信号的值\n    get(): T;\n}\n\nnamespace Signal {\n    // 可读写的 Signal\n    class State<T> implements Signal<T> {\n        // 创建一个以 t 作为初始值的 state Signal\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // 获取信号的值\n        get(): T;\n\n        // 设置 state Signal 的值为 t\n        set(t: T): void;\n    }\n\n    // 基于其他 Signal 的公式型 Signal\n    class Computed<T = unknown> implements Signal<T> {\n        // 创建一个 Signal，其值由回调函数返回。\n        // 回调函数以该 signal 作为 this 上下文调用。\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // 获取信号的值\n        get(): T;\n    }\n\n    // 此命名空间包含更“高级”的功能，建议框架作者使用，\n    // 而非应用开发者。类似于 `crypto.subtle`\n    namespace subtle {\n        // 以禁用所有追踪的方式运行回调\n        function untrack<T>(cb: () => T): T;\n\n        // 获取当前正在追踪任何 signal 读取的计算型 signal（如果有的话）\n        function currentComputed(): Computed | null;\n\n        // 返回上次评估时，该信号引用的所有信号的有序列表。\n        // 对于 Watcher，列出它正在监听的 signal 集合。\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // 返回包含该信号的 Watchers，以及上次评估时读取该信号的\n        // Computed 信号（如果该 computed 信号（递归地）被监听）。\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // 如果该信号是“存活”的，即被 Watcher 监听，\n        // 或被（递归地）存活的 Computed 信号读取，则返回 true。\n        function hasSinks(s: State | Computed): boolean;\n\n        // 如果该元素是“响应式”的，即它依赖于其他 signal，则返回 true。\n        // 如果 Computed 的 hasSources 为 false，则其总是返回同一个常量。\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // 当 Watcher 的（递归）源被写入时，调用该回调，\n            // 如果自上次 `watch` 调用以来还未调用过。\n            // 在 notify 期间，不允许读取或写入任何 signal。\n            constructor(notify: (this: Watcher) => void);\n\n            // 将这些 signal 添加到 Watcher 的集合中，并设置 watcher，\n            // 使其在集合中的任一 signal（或其依赖项）发生变化时，下次运行 notify 回调。\n            // 可不带参数调用，仅用于重置“已通知”状态，以便再次调用 notify 回调。\n            watch(...s: Signal[]): void;\n\n            // 从监听集合中移除这些 signal（例如，用于已释放的副作用）\n            unwatch(...s: Signal[]): void;\n\n            // 返回 Watcher 集合中仍为 dirty 的源 signal 集合，\n            // 或者是具有 dirty 或 pending 源、尚未重新评估的 Computed signal\n            getPending(): Signal[];\n        }\n\n        // 观察 signal 被监听或不再被监听的钩子\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // 自定义旧值与新值的比较函数。默认：Object.is。\n        // signal 作为 this 上下文传入。\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}