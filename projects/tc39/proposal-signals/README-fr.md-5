{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO : Montrer un exemple de conversion d’un Observable en signal calculé, abonné uniquement lorsqu’il est utilisé par un effet\n\nTODO : Montrer un exemple d’un signal calculé représentant le résultat d’un fetch dirigé vers un état, qui est annulé\n\n### Introspection pour le SSR\n\nTODO : Montrer comment fonctionne la sérialisation du graphe de signaux\n\nTODO : Montrer comment « hydrater » un signal d’un état vers un calculé plus tard, en utilisant quelques signaux.\n-->\n\n### Ommis pour l’instant\n\nCes fonctionnalités pourront être ajoutées ultérieurement, mais elles ne sont pas incluses dans la version actuelle du projet. Leur omission est due à l’absence de consensus établi dans le domaine de conception entre les frameworks, ainsi qu’à la capacité démontrée de contourner leur absence avec des mécanismes supplémentaires basés sur la notion de Signals décrite dans ce document. Cependant, malheureusement, cette omission limite le potentiel d’interopérabilité entre frameworks. Lorsque des prototypes de Signals tels que décrits dans ce document seront produits, un effort sera fait pour réexaminer si ces omissions étaient la bonne décision.\n\n* **Async** : Les signaux sont toujours disponibles de manière synchrone pour l’évaluation, dans ce modèle. Cependant, il est souvent utile d’avoir certains processus asynchrones qui mènent à la modification d’un signal, et de savoir quand un signal est encore en « chargement ». Une façon simple de modéliser l’état de chargement est d’utiliser des exceptions, et le comportement de mise en cache des exceptions des signaux calculés se compose raisonnablement avec cette technique. Des techniques améliorées sont discutées dans [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions** : Pour les transitions entre vues, il est souvent utile de maintenir un état actif à la fois pour les états « de » et « vers ». L’état « vers » s’affiche en arrière-plan, jusqu’à ce qu’il soit prêt à prendre la relève (commit de la transaction), tandis que l’état « de » reste interactif. Maintenir les deux états en même temps nécessite de « forker » l’état du graphe de signaux, et il peut même être utile de prendre en charge plusieurs transitions en attente simultanément. Discussion dans [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nCertaines [méthodes utilitaires](https://github.com/proposal-signals/proposal-signals/issues/32) possibles sont également omises.\n\n## Statut et plan de développement\n\nCette proposition figure à l’agenda d’avril 2024 du TC39 pour l’étape 1. Elle peut actuellement être considérée comme « étape 0 ».\n\n[Un polyfill](https://github.com/proposal-signals/signal-polyfill) pour cette proposition est disponible, avec quelques tests basiques. Certains auteurs de frameworks ont commencé à expérimenter avec le remplacement de cette implémentation de signal, mais cette utilisation en est à un stade précoce.\n\nLes collaborateurs sur la proposition Signal souhaitent être particulièrement **prudents** dans la façon de faire avancer cette proposition, afin d’éviter de se retrouver piégés avec quelque chose qui serait publié, mais que l’on regretterait et n’utiliserait finalement pas. Notre plan est d’effectuer les tâches supplémentaires suivantes, non requises par le processus TC39, afin de s’assurer que cette proposition est sur la bonne voie :\n\nAvant de proposer pour l’étape 2, nous prévoyons de :\n- Développer plusieurs implémentations polyfill de niveau production, solides, bien testées (par exemple, réussissant les tests de divers frameworks ainsi que des tests de type test262) et performantes (comme vérifié par un ensemble de benchmarks signal/framework complet).\n- Intégrer l’API Signal proposée dans un grand nombre de frameworks JS que nous considérons comme représentatifs, et quelques grandes applications fonctionnant avec cette base. Tester son efficacité et sa correction dans ces contextes.\n- Avoir une compréhension solide de l’espace des extensions possibles à l’API, et avoir conclu lesquelles (le cas échéant) doivent être ajoutées à cette proposition.\n\n## Algorithmes de Signal\n\nCette section décrit chacune des API exposées à JavaScript, en termes des algorithmes qu’elles implémentent. On peut la considérer comme une proto-spécification, et elle est incluse à ce stade précoce pour fixer un ensemble possible de sémantiques, tout en restant très ouvert aux changements.\n\nCertains aspects de l’algorithme :\n- L’ordre de lecture des Signaux à l’intérieur d’un calculé est significatif, et il est observable dans l’ordre d’exécution de certains callbacks (`Watcher` invoqué, `equals`, le premier paramètre de `new Signal.Computed`, et les callbacks `watched`/`unwatched`). Cela signifie que les sources d’un Signal calculé doivent être stockées de manière ordonnée.\n- Ces quatre callbacks peuvent tous lancer des exceptions, et ces exceptions sont propagées de manière prévisible au code JS appelant. Les exceptions ne *stoppent pas* l’exécution de cet algorithme et ne laissent pas le graphe dans un état partiellement traité. Pour les erreurs levées dans le callback `notify` d’un Watcher, cette exception est transmise à l’appel `.set()` qui l’a déclenchée, en utilisant un AggregateError si plusieurs exceptions sont levées. Les autres (y compris `watched`/`unwatched` ?) sont stockées dans la valeur du Signal, pour être relancées lors de la lecture, et un Signal relançant ainsi une exception peut être marqué `~clean~` comme n’importe quel autre ayant une valeur normale.\n- Des précautions sont prises pour éviter les circularités dans le cas de signaux calculés qui ne sont pas « observés » (surveillés par un Watcher), afin qu’ils puissent être collectés séparément des autres parties du graphe de signaux. En interne, cela peut être implémenté avec un système de numéros de génération toujours collectés ; notez que les implémentations optimisées peuvent aussi inclure des numéros de génération locaux par nœud, ou éviter de suivre certains numéros sur les signaux surveillés.\n\n### État global caché\n\nLes algorithmes de Signal doivent référencer certains états globaux. Cet état est global pour tout le thread, ou « agent ».\n\n- `computing` : Le signal calculé ou d’effet le plus interne actuellement réévalué suite à un appel `.get` ou `.run`, ou `null`. Initialement `null`.\n- `frozen` : Booléen indiquant si un callback s’exécute actuellement et nécessite que le graphe ne soit pas modifié. Initialement `false`.\n- `generation` : Un entier incrémental, commençant à 0, utilisé pour suivre l’actualité d’une valeur tout en évitant les circularités.\n\n### L’espace de noms `Signal`\n\n`Signal` est un objet ordinaire servant d’espace de noms pour les classes et fonctions liées aux Signaux.\n\n`Signal.subtle` est un objet espace de noms interne similaire.\n\n### La classe `Signal.State`\n\n#### Slots internes de `Signal.State`\n\n- `value` : La valeur actuelle du signal d’état\n- `equals` : La fonction de comparaison utilisée lors des changements de valeur\n- `watched` : Le callback appelé quand le signal devient observé par un effet\n- `unwatched` : Le callback appelé quand le signal n’est plus observé par un effet\n- `sinks` : Ensemble des signaux surveillés dépendant de celui-ci\n\n#### Constructeur : `Signal.State(initialValue, options)`\n\n1. Définit la propriété `value` de ce Signal sur `initialValue`.\n1. Définit la propriété `equals` de ce Signal sur options?.equals\n1. Définit la propriété `watched` de ce Signal sur options?.[Signal.subtle.watched]\n1. Définit la propriété `unwatched` de ce Signal sur options?.[Signal.subtle.unwatched]\n1. Définit la propriété `sinks` de ce Signal comme ensemble vide\n\n#### Méthode : `Signal.State.prototype.get()`\n\n1. Si `frozen` est vrai, lancer une exception.\n1. Si `computing` n’est pas `undefined`, ajouter ce Signal à l’ensemble `sources` de `computing`.\n1. REMARQUE : On n’ajoute pas `computing` à l’ensemble `sinks` de ce Signal tant qu’il n’est pas surveillé par un Watcher.\n1. Retourner la valeur de ce Signal.\n\n#### Méthode : `Signal.State.prototype.set(newValue)`\n\n1. Si le contexte d’exécution courant est `frozen`, lancer une exception.\n1. Exécuter l’algorithme « set Signal value » avec ce Signal et la première valeur passée en paramètre.\n1. Si cet algorithme a retourné `~clean~`, retourner undefined.\n1. Mettre à jour la propriété `state` de tous les `sinks` de ce Signal à (si c’est un Signal Calculé) `~dirty~` s’ils étaient auparavant propres, ou (si c’est un Watcher) à `~pending~` s’il était auparavant `~watching~`.\n1. Mettre à jour la propriété `state` de toutes les dépendances de type Signal Calculé (récursivement) des sinks à `~checked~` si elles étaient auparavant `~clean~` (c’est-à-dire, laisser les marquages dirty en place), ou pour les Watchers, à `~pending~` si auparavant `~watching~`.\n1. Pour chaque Watcher précédemment `~watching~` rencontré lors de cette recherche récursive, puis en ordre de profondeur :\n    1. Définir `frozen` à true.\n    1. Appeler leur callback `notify` (en sauvegardant toute exception levée, mais en ignorant la valeur de retour de `notify`).\n    1. Restaurer `frozen` à false.\n    1. Définir l’état du Watcher à `~waiting~`.\n1. Si une exception a été levée depuis les callbacks `notify`, la propager à l’appelant après l’exécution de tous les callbacks `notify`. S’il y a plusieurs exceptions, les regrouper dans un AggregateError et les lancer.\n1. Retourner undefined.\n\n### La classe `Signal.Computed`\n\n#### Machine à états de `Signal.Computed`",
  "status": "ok"
}