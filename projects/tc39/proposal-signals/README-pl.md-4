{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback called when isWatched becomes true, if it was previously false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback called whenever isWatched becomes false, if it was previously true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Jak działają sygnały\n\nSygnał (Signal) reprezentuje komórkę danych, która może zmieniać się w czasie. Sygnały mogą być typu „state” (po prostu wartość ustawiana ręcznie) lub „computed” (formuła oparta na innych sygnałach).\n\nSygnały obliczane (computed) działają poprzez automatyczne śledzenie, które inne sygnały są odczytywane podczas ich ewaluacji. Gdy sygnał obliczany jest odczytywany, sprawdza, czy którykolwiek z wcześniej zarejestrowanych zależności uległ zmianie i, jeśli tak, dokonuje ponownej ewaluacji. Gdy wiele sygnałów obliczanych jest zagnieżdżonych, cała atrybucja śledzenia przypada temu najbardziej wewnętrznemu.\n\nSygnały obliczane są leniwe, tj. oparte na „pull”: są ponownie ewaluowane tylko wtedy, gdy są odczytywane, nawet jeśli jeden z ich zależności zmienił się wcześniej.\n\nFunkcja przekazana do sygnałów obliczanych powinna być zazwyczaj „czysta” w sensie deterministycznej, pozbawionej efektów ubocznych funkcji innych sygnałów, do których uzyskuje dostęp. Jednocześnie czas wywołania tej funkcji jest deterministyczny, co pozwala z ostrożnością używać efektów ubocznych.\n\nSygnały posiadają wyraźny mechanizm cache’owania/memoizacji: zarówno sygnały „state”, jak i „computed” zapamiętują swoją bieżącą wartość i wywołują ponowną kalkulację odwołujących się do nich sygnałów obliczanych tylko wtedy, gdy rzeczywiście się zmienią. Powtarzane porównanie starej i nowej wartości nie jest nawet potrzebne—porównanie następuje raz przy resetowaniu/ponownej ewaluacji źródłowego sygnału, a mechanizm sygnałów śledzi, które elementy odwołujące się do tego sygnału jeszcze nie zostały zaktualizowane na podstawie nowej wartości. Wewnętrznie jest to zazwyczaj reprezentowane przez „kolorowanie grafu”, jak opisano w (blogu Milo).\n\nSygnały obliczane dynamicznie śledzą swoje zależności—za każdym razem, gdy są uruchamiane, mogą zależeć od innych elementów, a dokładny zestaw zależności jest na bieżąco utrzymywany w grafie sygnałów. Oznacza to, że jeśli masz zależność potrzebną tylko w jednej gałęzi, a poprzednia kalkulacja wybrała inną gałąź, zmiana tej tymczasowo nieużywanej wartości nie spowoduje ponownej kalkulacji sygnału obliczanego, nawet przy jego odczycie.\n\nW przeciwieństwie do obietnic JavaScript (Promises), wszystko w sygnałach działa synchronicznie:\n- Ustawienie sygnału na nową wartość jest synchroniczne i od razu znajduje odzwierciedlenie przy odczycie dowolnego sygnału obliczanego, który od niego zależy. Nie ma wbudowanego batchowania tej mutacji.\n- Odczytywanie sygnałów obliczanych jest synchroniczne—wartość jest zawsze dostępna.\n- Callback `notify` w Watcherach, jak wyjaśniono poniżej, działa synchronicznie podczas wywołania `.set()`, które go wywołało (ale po zakończeniu kolorowania grafu).\n\nPodobnie jak Promises, sygnały mogą reprezentować stan błędu: jeśli callback sygnału obliczanego zgłosi wyjątek, błąd jest cache’owany jak każda inna wartość i zgłaszany ponownie przy każdym odczycie sygnału.\n\n### Zrozumienie klasy Signal\n\nInstancja `Signal` reprezentuje możliwość odczytu dynamicznie zmieniającej się wartości, której aktualizacje są śledzone w czasie. Zawiera także pośrednio możliwość subskrypcji sygnału, pośrednio poprzez śledzony dostęp z innego sygnału obliczanego.\n\nAPI zostało zaprojektowane, by odpowiadać z grubsza konsensusowi ekosystemu wśród dużej części bibliotek sygnałów w używaniu nazw takich jak „signal”, „computed” i „state”. Jednak dostęp do sygnałów obliczanych i stanowych odbywa się przez metodę `.get()`, co różni się od wszystkich popularnych API sygnałów, które używają albo akcesora `.value`, albo składni wywołania `signal()`.\n\nAPI zostało zaprojektowane tak, by zmniejszyć liczbę alokacji, czyniąc sygnały odpowiednimi do użycia w ramach JavaScriptowych z wydajnością dorównującą lub przewyższającą istniejące, frameworkowe sygnały. Oznacza to:\n- Sygnały „state” są pojedynczym obiektem zapisywalnym, który można zarówno odczytywać, jak i ustawiać z tego samego odniesienia. (Zobacz konsekwencje poniżej, w sekcji „Oddzielenie możliwości”.)\n- Zarówno sygnały „state”, jak i „computed” są projektowane tak, aby można je było dziedziczyć, co ułatwia frameworkom dodawanie dodatkowych właściwości przez publiczne i prywatne pola klas (jak również metody korzystające z tego stanu).\n- Różne callbacki (np. `equals`, callback obliczający) są wywoływane z odpowiednim sygnałem jako wartością `this` w kontekście, dzięki czemu nie jest potrzebna nowa domknięcie dla każdego sygnału. Zamiast tego kontekst można przechowywać w dodatkowych właściwościach samego sygnału.\n\nNiektóre warunki błędów wymuszane przez to API:\n- Błędem jest rekurencyjny odczyt sygnału obliczanego.\n- Callback `notify` Watchera nie może odczytywać ani zapisywać żadnych sygnałów.\n- Jeśli callback sygnału obliczanego zgłosi wyjątek, kolejne odczyty sygnału ponownie zgłaszają ten cache’owany błąd, dopóki nie zmieni się jedna z zależności i nie nastąpi ponowna kalkulacja.\n\nNiektóre warunki, które *nie* są wymuszane:\n- Sygnały obliczane mogą zapisywać do innych sygnałów, synchronicznie w ramach swojego callbacka.\n- Praca zakolejkowana przez callback `notify` Watchera może odczytywać lub zapisywać sygnały, co umożliwia odtworzenie [klasycznych antywzorców Reacta](https://react.dev/learn/you-might-not-need-an-effect) w kategoriach sygnałów!\n\n### Implementacja efektów\n\nInterfejs `Watcher` zdefiniowany powyżej stanowi podstawę do implementacji typowych JS-owych API dla efektów: callbacków, które są ponownie uruchamiane, gdy inne sygnały się zmienią, wyłącznie dla efektu ubocznego. Funkcja `effect` używana wyżej w początkowym przykładzie może być zdefiniowana w następujący sposób:\n\n```ts\n// Ta funkcja zwykle byłaby w bibliotece/frameworku, nie w kodzie aplikacji\n// UWAGA: Ta logika kolejkowania jest zbyt uproszczona, by była użyteczna. Nie kopiuj/wklejaj.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Efektowy sygnał, który ewaluowany do cb, planuje odczyt\n// samego siebie w mikro-kolejce za każdym razem, gdy może zmienić się jedna z zależności\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nAPI sygnałów nie zawiera żadnej wbudowanej funkcji typu `effect`. Wynika to z faktu, że planowanie efektów jest subtelne i często powiązane z cyklami renderowania frameworka oraz innymi, specyficznymi dla frameworka stanami czy strategiami, do których JS nie ma dostępu.\n\nOmówienie poszczególnych operacji użytych tutaj: Callback `notify` przekazany do konstruktora `Watcher` to funkcja, która jest wywoływana, gdy sygnał przechodzi ze stanu „clean” (gdzie wiemy, że cache jest zainicjowany i ważny) do stanu „checked” lub „dirty” (gdzie cache może, ale nie musi być ważny, bo przynajmniej jeden ze stanów, od których rekurencyjnie zależy, został zmieniony).\n\nWywołania `notify` są ostatecznie wywoływane przez `.set()` na jakimś sygnale „state”. To wywołanie jest synchroniczne: dzieje się przed zakończeniem `.set`. Nie trzeba się jednak martwić, że ten callback zobaczy graf sygnałów w stanie pośrednim, ponieważ podczas callbacka `notify` żaden sygnał nie może być odczytywany ani zapisywany, nawet w wywołaniu `untrack`. Ponieważ `notify` jest wywoływany podczas `.set()`, przerywa inny wątek logiki, który może nie być zakończony. Aby odczytać lub zapisać sygnały z `notify`, zaplanuj pracę do późniejszego wykonania, np. zapisując sygnał na liście do późniejszego dostępu lub przez `queueMicrotask`, jak powyżej.\n\nZwróć uwagę, że całkowicie możliwe jest skuteczne używanie sygnałów bez `Signal.subtle.Watcher`, planując odpytywanie sygnałów obliczanych, jak robi to Glimmer. Jednak wiele frameworków uznało, że często przydatne jest uruchamianie tej logiki planowania synchronicznie, dlatego API sygnałów to umożliwia.\n\nZarówno sygnały obliczane, jak i stanowe podlegają garbage collection jak każde wartości JS. Jednak Watchery mają specjalny sposób utrzymywania rzeczy przy życiu: wszystkie sygnały obserwowane przez Watchera będą utrzymywane przy życiu tak długo, jak długo jakiekolwiek z bazowych stanów są osiągalne, bo mogą one wywołać przyszłe `notify` (a potem przyszłe `.get()`). Z tego powodu pamiętaj, by wywoływać `Watcher.prototype.unwatch`, aby wyczyścić efekty.\n\n### Niespójna furtka\n\n`Signal.subtle.untrack` to furtka pozwalająca na odczytywanie sygnałów *bez* śledzenia tych odczytów. Ta możliwość jest niebezpieczna, ponieważ pozwala tworzyć sygnały obliczane, których wartość zależy od innych sygnałów, ale które nie są aktualizowane, gdy te sygnały się zmieniają. Powinna być używana wtedy, gdy nieśledzone odczyty nie wpłyną na wynik obliczenia.\n\n<!--\nTODO: Pokazać przykład, gdzie użycie untrack jest dobrym pomysłem\n\n### Używanie watched/unwatched",
  "status": "ok"
}