{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **تتبع التبعيات التلقائي** - يقوم الـ Signal المحسوب باكتشاف أي Signals أخرى يعتمد عليها بشكل تلقائي، سواء كانت تلك الـ Signals قيم بسيطة أو عمليات حسابية أخرى.\n* **التقييم الكسول (Lazy Evaluation)** - لا يتم تقييم العمليات الحسابية بشكل متعجل عند إعلانها، ولا يتم تقييمها مباشرة عند تغير التبعيات الخاصة بها. يتم تقييمها فقط عندما يُطلب قيمتها صراحة.\n* **تخزين النتائج (Memoization)** - تقوم Signals المحسوبة بتخزين آخر قيمة لها بحيث لا يتم إعادة تقييم العمليات الحسابية التي لم تتغير تبعياتها، بغض النظر عن عدد مرات الوصول إليها.\n\n## الدوافع وراء توحيد الـ Signals\n\n#### قابلية التشغيل البيني\n\nكل تنفيذ للـ Signal لديه آلية تتبع تلقائي خاصة به، لتتبع المصادر التي يتم الوصول إليها عند تقييم Signal محسوب. هذا يصعب مشاركة النماذج والمكونات والمكتبات بين أطر العمل المختلفة—حيث تميل إلى أن تأتي مع اقتران خاطئ بمحرك العرض الخاص بها (نظرًا لأن Signals غالبًا ما يتم تنفيذها كجزء من أطر عمل JS).\n\nأحد أهداف هذا الاقتراح هو فك الارتباط الكامل بين النموذج التفاعلي (reactive model) وعرض البيانات (rendering view)، مما يتيح للمطورين الانتقال إلى تقنيات عرض جديدة بدون إعادة كتابة كود غير واجهة المستخدم، أو تطوير نماذج تفاعلية مشتركة في JS ليتم نشرها في سياقات مختلفة. للأسف، بسبب الإصدارات والتكرار، اتضح أن الوصول إلى مستوى مشاركة قوي من خلال مكتبات على مستوى JS أمر غير عملي—توفر المدمجات (built-ins) ضمان مشاركة أقوى.\n\n#### الأداء/استخدام الذاكرة\n\nهناك دائمًا إمكانية لتعزيز الأداء من خلال شحن كود أقل بسبب وجود مكتبات مستخدمة بشكل شائع مدمجة، لكن تنفيذات Signals عادةً ما تكون صغيرة جدًا، لذلك لا نتوقع أن يكون هذا التأثير كبيرًا.\n\nنحن نعتقد أن تنفيذات C++ الأصلية لهياكل البيانات والخوارزميات المتعلقة بـ Signal يمكن أن تكون أكثر كفاءة قليلاً مما هو ممكن في JS، بعامل ثابت فقط. ومع ذلك، لا يُتوقع حدوث تغييرات خوارزمية مقابل ما يمكن أن يوجد في polyfill؛ ولا يُتوقع من المحركات أن تقدم سحرًا هنا، وستكون خوارزميات التفاعلية نفسها محددة جيدًا وواضحة.\n\nتتوقع مجموعة الأبطال تطوير عدة تنفيذات لـ Signals، واستخدامها لاستكشاف هذه الاحتمالات المتعلقة بالأداء.\n\n#### أدوات المطورين (DevTools)\n\nمع مكتبات Signals الحالية في لغة JS، قد يكون من الصعب تتبع أشياء مثل:\n* مكدس الاستدعاء عبر سلسلة Signals المحسوبة، لإظهار سلسلة السببية لخطأ ما\n* رسم بياني للمرجع بين Signals، عندما يعتمد أحدها على الآخر—وهو أمر مهم عند تصحيح استخدام الذاكرة\n\nتمكن Signals المدمجة بيئات تشغيل JS وأدوات المطورين من دعم محسّن لفحص Signals، خاصة لأغراض التصحيح أو تحليل الأداء، سواء تم تضمين هذا الدعم في المتصفحات أو من خلال امتداد مشترك. يمكن تحديث الأدوات الحالية مثل مفتش العناصر، ولقطات الأداء، وأدوات تحليل الذاكرة لتسليط الضوء بشكل خاص على Signals في عرض المعلومات.\n\n#### الفوائد الثانوية\n\n##### فوائد مكتبة قياسية\n\nبشكل عام، كانت مكتبة JavaScript القياسية محدودة إلى حد ما، لكن هناك اتجاه في TC39 لجعل JS لغة أكثر \"شمولية\" مع مجموعة مدمجة عالية الجودة من الوظائف المتاحة. على سبيل المثال، Temporal تحل محل moment.js، وعدد من الميزات الصغيرة مثل `Array.prototype.flat` و`Object.groupBy` تحل محل العديد من استخدامات lodash. تشمل الفوائد تقليل حجم الحزم، وتحسين الاستقرار والجودة، وتقليل الحاجة للتعلم عند الانضمام إلى مشروع جديد، وتوفير مفردات شائعة بين مطوري JS.\n\n##### تكامل مع HTML/DOM (احتمال مستقبلي)\n\nالعمل الحالي في W3C ومن قبل مطوري المتصفحات يسعى لجلب القوالب الأصلية إلى HTML ([DOM Parts][wicg-pr-1023] و[Template Instantiation][wicg-propsal-template-instantiation]). بالإضافة إلى ذلك، تستكشف مجموعة W3C Web Components إمكانية توسيع Web Components لتقديم واجهة HTML تصريحيه بالكامل. لتحقيق كلا الهدفين، سيحتاج HTML في النهاية إلى بدائية تفاعلية. بالإضافة إلى ذلك، يمكن تخيل العديد من التحسينات العملية لـ DOM من خلال تكامل Signals وقد طلبها المجتمع بالفعل.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> ملاحظة، هذا التكامل سيكون جهدًا منفصلًا يأتي لاحقًا، وليس جزءًا من هذا الاقتراح نفسه.\n\n##### تبادل المعلومات في النظام البيئي (وليس سببًا للإطلاق)\n\nيمكن أن تكون جهود التوحيد القياسي مفيدة أحيانًا فقط على مستوى \"المجتمع\"، حتى بدون تغييرات في المتصفحات. يجمع جهد Signals العديد من مؤلفي الأطر المختلفين لمناقشة عميقة حول طبيعة التفاعلية والخوارزميات وقابلية التشغيل البيني. كان هذا مفيدًا بالفعل، لكنه لا يبرر تضمينه في محركات JS والمتصفحات؛ يجب إضافة Signals إلى معيار JavaScript فقط إذا كانت هناك فوائد كبيرة *تتجاوز* مجرد تبادل المعلومات بين الأنظمة.\n\n## أهداف التصميم للـ Signals\n\nيتضح أن مكتبات Signal الحالية ليست مختلفة كثيرًا عن بعضها في جوهرها. يهدف هذا الاقتراح إلى البناء على نجاحها من خلال تنفيذ الصفات المهمة للعديد من تلك المكتبات.\n\n### الميزات الأساسية\n\n* نوع Signal يمثل الحالة، أي Signal قابلة للكتابة. هذه قيمة يمكن للآخرين قراءتها.\n* نوع Signal محسوب/مخزن/مشتق، يعتمد على الآخرين ويتم حسابه وتخزينه بشكل كسول.\n    * الحساب كسول، أي أن Signals المحسوبة لا يتم حسابها مرة أخرى بشكل افتراضي عندما تتغير إحدى تبعياتها، بل يتم التشغيل فقط إذا قرأها أحد.\n    * الحساب \"[خالي من الأعطال (glitch)](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\"، أي لا يتم إجراء حسابات غير ضرورية أبدًا. وهذا يعني أنه عند قراءة تطبيق ما لـ Signal محسوب، يكون هناك ترتيب طوبولوجي للأجزاء القابلة للتغيير المحتمل في الرسم البياني ليتم تشغيلها، لإزالة أي تكرارات.\n    * الحساب مخزن، أي إذا لم تتغير أي تبعيات منذ آخر مرة تغيرت فيها التبعيات، فلن يتم إعادة حساب Signal المحسوبة عند الوصول إليها.\n    * المقارنات المخصصة ممكنة لكل من Signals المحسوبة وSignals الحالة، لتحديد متى يجب تحديث Signals المحسوبة الأخرى التي تعتمد عليها.\n* ردود فعل على الحالة التي يصبح فيها أحد تبعيات Signal المحسوبة (أو التبعيات المتداخلة) \"متسخًا\" ويتغير، مما يعني أن قيمة Signal قد تكون قديمة.\n    * يهدف هذا التفاعل إلى جدولة عمل أكثر أهمية ليتم تنفيذه لاحقًا.\n    * يتم تنفيذ التأثيرات من حيث هذه التفاعلات، بالإضافة إلى جدولة على مستوى الإطار.\n    * Signals المحسوبة تحتاج إلى القدرة على التفاعل مع ما إذا كانت مسجلة كتبعيات (متداخلة) لإحدى هذه التفاعلات.\n* تمكين أطر عمل JS من تنفيذ جدولة خاصة بها. لا يوجد جدولة مدمجة إجبارية على غرار Promise.\n    * هناك حاجة إلى تفاعلات متزامنة لتمكين جدولة العمل لاحقًا بناءً على منطق الإطار.\n    * الكتابة متزامنة وتصبح سارية المفعول فورًا (يمكن للإطار الذي يجمع الكتابات أن يفعل ذلك فوق ذلك).\n    * من الممكن فصل التحقق مما إذا كان التأثير قد يكون \"متسخًا\" عن تشغيل التأثير نفسه (مما يمكّن مجدول تأثير من مرحلتين).\n* إمكانية قراءة Signals *دون* تفعيل تسجيل التبعيات (`untrack`)\n* تمكين تركيب قواعد كود مختلفة تستخدم Signals/التفاعلية، على سبيل المثال،\n    * استخدام أطر متعددة معًا فيما يتعلق بالتتبع/التفاعلية (مع وجود استثناءات، انظر أدناه)\n    * هياكل بيانات تفاعلية مستقلة عن الإطار (مثل مخزن تفاعلي بشكل متكرر، Map وSet وArray تفاعلية، إلخ)\n\n### السلامة\n\n* تثبيط/منع سوء استخدام التفاعلات المتزامنة بشكل ساذج.\n    * مخاطر السلامة: قد تعرض \"[الأعطال (glitches)](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" إذا استخدمت بشكل غير صحيح: إذا تم العرض فور تعيين Signal، فقد تعرض حالة تطبيق غير مكتملة للمستخدم النهائي. لذلك، يجب استخدام هذه الميزة فقط لجدولة العمل بذكاء لاحقًا، بمجرد الانتهاء من منطق التطبيق.\n    * الحل: منع القراءة والكتابة لأي Signal من داخل رد نداء التفاعل المتزامن.\n* تثبيط استخدام `untrack` وبيان طبيعته غير الآمنة\n    * مخاطر السلامة: يسمح بإنشاء Signals محسوبة تعتمد قيمتها على Signals أخرى، ولكنها لا يتم تحديثها عند تغير تلك الـ Signals. يجب استخدامه عندما لا تؤثر عمليات الوصول غير المتعقبة على نتيجة الحساب.\n    * الحل: يتم تمييز الـ API بأنه \"غير آمن\" في الاسم.\n* ملاحظة: يسمح هذا الاقتراح بقراءة وكتابة signals من signals المحسوبة والتأثير، دون تقييد الكتابات التي تأتي بعد القراءات، على الرغم من خطر السلامة. تم اتخاذ هذا القرار للحفاظ على المرونة والتوافق في التكامل مع الأطر.\n\n### واجهة البرمجة السطحية (Surface API)\n\n* يجب أن تكون أساسًا قويًا لعدة أطر عمل لتنفيذ آليات Signals/التفاعلية الخاصة بها.\n    * يجب أن تكون قاعدة جيدة لمخازن proxies التفاعلية المتكررة، وتفاعلية الحقول في الفئات المعتمدة على الزخرفة (decorator)، وواجهات برمجة التطبيقات بأسلوب `.value` و`[state, setState]`.\n    * يجب أن تكون الدلالات قادرة على التعبير عن الأنماط الصالحة الممكنة بواسطة أطر العمل المختلفة. على سبيل المثال، يجب أن يكون من الممكن أن تكون هذه Signals أساسًا إما للكتابات المنعكسة فورًا أو الكتابات المجمعة التي يتم تطبيقها لاحقًا.\n* من الجيد أن يكون هذا الـ API قابلاً للاستخدام مباشرة من قبل مطوري JavaScript.\n    * إذا كانت ميزة ما تتطابق مع مفهوم في النظام البيئي، فاستخدام مفردات شائعة أمر جيد.\n        * مع ذلك، من المهم عدم نسخ نفس الأسماء حرفيًا!\n    * هناك توتر بين \"قابلية الاستخدام من قبل مطوري JS\" و\"توفير جميع الخطافات للأطر\"\n        * فكرة: توفير جميع الخطافات، لكن تضمين أخطاء عند سوء الاستخدام إذا أمكن.\n        * فكرة: وضع واجهات برمجة التطبيقات الدقيقة في مساحة اسم `subtle`، على غرار [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle)، للفصل بين الواجهات اللازمة للاستخدامات المتقدمة مثل تنفيذ إطار عمل أو بناء أدوات مطورين مقابل الاستخدام اليومي لتطبيقات البرمجة مثل إنشاء signals لاستخدامها مع إطار عمل.\n* يجب أن تكون قابلة للتنفيذ والاستخدام بأداء جيد—أي لا تسبب واجهة البرمجة السطحية عبئًا زائدًا كبيرًا\n    * تمكين الوراثة، بحيث يمكن للأطر إضافة طرقها وحقولها الخاصة، بما في ذلك الحقول الخاصة. هذا مهم لتجنب الحاجة لتخصيصات إضافية على مستوى الإطار. راجع \"إدارة الذاكرة\" أدناه.\n\n### إدارة الذاكرة\n\n* إذا أمكن: يجب أن يكون من الممكن جمع Signal محسوب بواسطة جامع القمامة إذا لم يكن هناك أي مرجع حي يشير إليه لغرض القراءة المحتملة في المستقبل، حتى لو كان مرتبطًا برسم بياني أوسع يظل حيًا (مثلاً، من خلال قراءة حالة تظل حية).",
  "status": "ok"
}