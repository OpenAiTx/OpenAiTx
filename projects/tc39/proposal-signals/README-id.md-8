{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q**: Apakah Signals bekerja dengan alur data satu arah seperti React?\n\n**A**: Ya, Signals adalah mekanisme untuk alur data satu arah. Framework UI berbasis Signal memungkinkan Anda mengekspresikan tampilan sebagai fungsi dari model (di mana model menggabungkan Signals). Grafik dari state dan computed Signals bersifat asiklik secara konstruksi. Juga memungkinkan untuk mereplikasi antipola React di dalam Signals (!), misalnya, padanan Signal dari `setState` di dalam `useEffect` adalah menggunakan Watcher untuk menjadwalkan penulisan ke signal State.\n\n**Q**: Bagaimana hubungan signals dengan sistem manajemen state seperti Redux? Apakah signals mendorong state yang tidak terstruktur?\n\n**A**: Signals dapat menjadi basis yang efisien untuk abstraksi manajemen state seperti store. Pola umum yang ditemukan di beberapa framework adalah objek berbasis Proxy yang secara internal merepresentasikan properti menggunakan Signals, misalnya [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), atau [Solid stores](https://docs.solidjs.com/concepts/stores). Sistem-sistem ini memungkinkan pengelompokan state yang fleksibel pada tingkat abstraksi yang tepat sesuai aplikasi tertentu.\n\n**Q**: Apa yang ditawarkan Signals yang saat ini tidak dapat ditangani oleh `Proxy`?\n\n**A**: Proxy dan Signals bersifat saling melengkapi dan sangat cocok digunakan bersama. Proxy memungkinkan Anda mencegat operasi objek secara dangkal, dan signals mengoordinasikan grafik dependensi (sel). Menggunakan Signals sebagai backend Proxy adalah cara yang bagus untuk membuat struktur reaktif bersarang dengan ergonomi yang baik.\n\nPada contoh ini, kita dapat menggunakan proxy untuk membuat signal memiliki properti getter dan setter daripada menggunakan metode `get` dan `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// penggunaan dalam konteks reaktif hipotetis:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nketika menggunakan renderer yang dioptimalkan untuk reaktivitas granular, menekan tombol akan menyebabkan sel `b.value` diperbarui.\n\nLihat:\n- contoh struktur reaktif bersarang yang dibuat dengan Signals dan Proxy: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- contoh implementasi sebelumnya yang menunjukkan hubungan antara data reaktif dan proxy: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [diskusi](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Bagaimana cara kerja Signals?\n\n**Q**: Apakah Signals berbasis push atau pull?\n\n**A**: Evaluasi computed Signals bersifat pull-based: computed Signals hanya dievaluasi saat `.get()` dipanggil, meskipun state dasarnya telah berubah jauh lebih awal. Pada saat yang sama, mengubah state signal dapat langsung memicu callback Watcher, \"mendorong\" notifikasi. Jadi Signals bisa dianggap sebagai konstruksi \"push-pull\".\n\n**Q**: Apakah Signals memperkenalkan nondeterminisme ke dalam eksekusi JavaScript?\n\n**A**: Tidak. Pertama, semua operasi Signal memiliki semantik dan urutan yang terdefinisi dengan baik, dan tidak akan berbeda di antara implementasi yang sesuai. Pada tingkat yang lebih tinggi, Signals mengikuti sejumlah invarian tertentu, yang terhadapnya mereka \"sound\". Sebuah computed Signal selalu mengamati grafik Signal dalam keadaan konsisten, dan eksekusinya tidak terganggu oleh kode lain yang memodifikasi Signal (kecuali hal-hal yang dipanggil oleh dirinya sendiri). Lihat deskripsi di atas.\n\n**Q**: Ketika saya menulis ke state Signal, kapan update ke computed Signal dijadwalkan?\n\n**A**: Tidak dijadwalkan! Computed Signal akan menghitung ulang sendiri saat berikutnya seseorang membacanya. Secara sinkron, callback `notify` Watcher dapat dipanggil, sehingga framework dapat menjadwalkan pembacaan pada waktu yang dianggap sesuai.\n\n**Q**: Kapan penulisan ke state Signals berlaku? Langsung, atau dikelompokkan (batched)?\n\n**A**: Penulisan ke state Signals langsung tercermin—pada saat berikutnya computed Signal yang bergantung pada state Signal tersebut dibaca, ia akan menghitung ulang dirinya sendiri jika diperlukan, bahkan jika pada baris kode berikutnya. Namun, sifat lazy dari mekanisme ini (bahwa computed Signals hanya dihitung saat dibaca) berarti bahwa, dalam praktiknya, perhitungan dapat terjadi secara batched.\n\n**Q**: Apa arti Signals memungkinkan eksekusi \"bebas-glitch\"?\n\n**A**: Model reaktivitas berbasis push sebelumnya menghadapi masalah komputasi berulang: Jika update pada state Signal menyebabkan computed Signal langsung dijalankan, pada akhirnya ini dapat mendorong update ke UI. Tapi penulisan ke UI ini bisa saja terlalu dini, jika akan ada perubahan lain pada state Signal asal sebelum frame berikutnya. Kadang, nilai antara yang tidak akurat bahkan ditampilkan ke pengguna karena [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches) semacam itu. Signals menghindari dinamika ini dengan menjadi pull-based, bukan push-based: Pada saat framework menjadwalkan rendering UI, ia akan menarik update yang sesuai, menghindari pekerjaan yang sia-sia baik dalam komputasi maupun penulisan ke DOM.\n\n**Q**: Apa arti Signals bersifat \"lossy\"?\n\n**A**: Ini adalah sisi lain dari eksekusi bebas-glitch: Signals merepresentasikan sel data—hanya nilai saat ini (yang dapat berubah), bukan aliran data seiring waktu. Jadi, jika Anda menulis ke state Signal dua kali berturut-turut, tanpa melakukan apa pun, penulisan pertama akan \"hilang\" dan tidak pernah terlihat oleh computed Signals atau efek apa pun. Ini dianggap sebagai fitur, bukan bug—konstruk lain (misalnya, async iterable, observable) lebih cocok untuk aliran data.\n\n**Q**: Apakah Signals native akan lebih cepat daripada implementasi Signal JS yang ada?\n\n**A**: Kami berharap demikian (dengan faktor konstan yang kecil), tetapi ini masih perlu dibuktikan dalam kode. Mesin JS bukanlah sihir, dan pada akhirnya harus mengimplementasikan algoritma yang sama seperti implementasi JS dari Signals. Lihat bagian di atas tentang performa.\n\n#### Mengapa Signals dirancang seperti ini?\n\n**Q**: Mengapa proposal ini tidak menyertakan fungsi `effect()`, padahal efek diperlukan untuk penggunaan Signals yang praktis?\n\n**A**: Efek secara inheren berkaitan dengan penjadwalan dan pembuangan, yang dikelola oleh framework dan di luar cakupan proposal ini. Sebagai gantinya, proposal ini menyertakan dasar untuk mengimplementasikan efek melalui API tingkat rendah `Signal.subtle.Watcher`.\n\n**Q**: Mengapa langganan bersifat otomatis dan tidak menyediakan antarmuka manual?\n\n**A**: Pengalaman telah menunjukkan bahwa antarmuka langganan manual untuk reaktivitas tidak ergonomis dan rawan kesalahan. Pelacakan otomatis lebih dapat dikomposisi dan menjadi fitur inti dari Signals.\n\n**Q**: Mengapa callback `Watcher` dijalankan secara sinkron, bukan dijadwalkan dalam microtask?\n\n**A**: Karena callback tidak dapat membaca atau menulis Signals, tidak ada ketidakkonsistenan yang muncul dengan memanggilnya secara sinkron. Callback tipikal akan menambahkan Signal ke Array untuk dibaca nanti, atau menandai bit di suatu tempat. Tidak perlu dan tidak praktis untuk membuat microtask terpisah untuk semua tindakan semacam ini.\n\n**Q**: API ini kurang beberapa hal menarik yang disediakan framework favorit saya, yang membuat pemrograman dengan Signals lebih mudah. Bisakah itu juga ditambahkan ke standar?\n\n**A**: Mungkin. Berbagai ekstensi masih sedang dipertimbangkan. Silakan buat issue untuk mendiskusikan fitur yang Anda anggap penting jika tidak ada di sini.\n\n**Q**: Bisakah API ini diperkecil ukuran atau kompleksitasnya?\n\n**A**: Menjaga API ini tetap minimal memang menjadi tujuan, dan kami telah mencoba melakukannya seperti yang dipresentasikan di atas. Jika Anda punya ide untuk hal lain yang bisa dihapus, silakan buat issue untuk didiskusikan.\n\n#### Bagaimana proses standarisasi Signals?\n\n**Q**: Bukankah kita sebaiknya memulai pekerjaan standarisasi di area ini dengan konsep yang lebih primitif, seperti observables?",
  "status": "ok"
}