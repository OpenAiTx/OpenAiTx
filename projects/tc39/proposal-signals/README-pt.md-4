{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback chamado quando isWatched se torna verdadeiro, se anteriormente era falso\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback chamado sempre que isWatched se torna falso, se anteriormente era verdadeiro\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Como funcionam os Signals\n\nUm Signal representa uma célula de dados que pode mudar ao longo do tempo. Signals podem ser do tipo \"state\" (apenas um valor definido manualmente) ou \"computed\" (uma fórmula baseada em outros Signals).\n\nSignals computados funcionam rastreando automaticamente quais outros Signals são lidos durante sua avaliação. Quando um computed é lido, ele verifica se alguma de suas dependências registradas anteriormente mudou e se reavalia se for o caso. Quando múltiplos Signals computados são aninhados, toda a atribuição do rastreamento vai para o mais interno deles.\n\nSignals computados são lazy, ou seja, baseados em pull: eles só são reavaliados quando são acessados, mesmo que uma de suas dependências tenha mudado antes.\n\nO callback passado para Signals computados geralmente deve ser \"puro\", no sentido de ser uma função determinística e sem efeitos colaterais dos outros Signals que acessa. Ao mesmo tempo, o momento em que o callback é chamado é determinístico, permitindo que efeitos colaterais sejam usados com cuidado.\n\nSignals possuem cache/memoização proeminente: tanto Signals de state quanto computados lembram seu valor atual, e só disparam recálculo de Signals computados que os referenciam se eles realmente mudarem. Uma comparação repetida entre valores antigos e novos nem é necessária—a comparação é feita uma vez quando o Signal fonte é redefinido/reavaliado, e o mecanismo do Signal mantém o controle de quais entidades que referenciam aquele Signal ainda não atualizaram com base no novo valor. Internamente, isso geralmente é representado por \"graph coloring\", como descrito no [post do blog do Milo](https://raw.githubusercontent.com/tc39/proposal-signals/main/Milo%27s%20blog%20post).\n\nSignals computados rastreiam suas dependências dinamicamente—cada vez que são executados, podem acabar dependendo de coisas diferentes, e esse conjunto de dependências preciso é mantido atualizado no grafo de Signals. Isso significa que, se você tem uma dependência necessária em apenas um ramo, e o cálculo anterior tomou o outro ramo, então uma mudança nesse valor temporariamente não usado não fará com que o Signal computado seja recalculado, mesmo quando acessado.\n\nDiferente de Promises do JavaScript, tudo em Signals é executado de forma síncrona:\n- Definir um Signal para um novo valor é síncrono, e isso é refletido imediatamente ao ler qualquer Signal computado que dependa dele em seguida. Não há agrupamento/batching embutido nessa mutação.\n- Ler Signals computados é síncrono—seu valor está sempre disponível.\n- O callback `notify` em Watchers, como explicado abaixo, roda de forma síncrona, durante a chamada `.set()` que o disparou (mas após a coloração do grafo estar completa).\n\nComo as Promises, Signals podem representar um estado de erro: se o callback de um Signal computado lançar uma exceção, esse erro é armazenado em cache como qualquer outro valor, e relançado toda vez que o Signal é lido.\n\n### Entendendo a classe Signal\n\nUma instância de `Signal` representa a capacidade de ler um valor que muda dinamicamente e cujas atualizações são rastreadas ao longo do tempo. Ela também implicitamente inclui a capacidade de se inscrever no Signal, implicitamente por meio de um acesso rastreado de outro Signal computado.\n\nA API aqui foi desenhada para corresponder ao consenso da comunidade entre grande parte das bibliotecas de Signal no uso de nomes como \"signal\", \"computed\" e \"state\". Entretanto, o acesso a Signals Computados e de State é feito por meio do método `.get()`, o que difere de todas as APIs populares de Signal, que usam um acessor `.value` ou sintaxe de chamada `signal()`.\n\nA API é projetada para reduzir o número de alocações, tornando Signals adequados para serem incorporados em frameworks JavaScript, alcançando desempenho igual ou melhor que Signals personalizados de frameworks existentes. Isso implica:\n- Signals de State são um único objeto gravável, que pode ser tanto acessado quanto definido a partir da mesma referência. (Veja implicações abaixo na seção \"Separação de capacidades\".)\n- Tanto Signals de State quanto Computados são projetados para serem subclassificados, facilitando que frameworks adicionem propriedades adicionais por meio de campos de classe públicos e privados (bem como métodos para usar esse estado).\n- Vários callbacks (por exemplo, `equals`, o callback de computed) são chamados com o Signal relevante como valor de `this` para contexto, de modo que não é necessário criar um novo closure por Signal. Em vez disso, o contexto pode ser salvo em propriedades extras do próprio Signal.\n\nAlgumas condições de erro aplicadas por esta API:\n- É um erro ler um computed recursivamente.\n- O callback `notify` de um Watcher não pode ler nem escrever nenhum signal.\n- Se o callback de um Signal computado lançar uma exceção, acessos subsequentes ao Signal relançam esse erro armazenado em cache, até que uma das dependências mude e ele seja recalculado.\n\nAlgumas condições que *não* são aplicadas:\n- Signals Computados podem escrever em outros Signals, de forma síncrona dentro do seu callback.\n- Trabalhos enfileirados pelo callback `notify` de um Watcher podem ler ou escrever signals, tornando possível replicar [antipadrões clássicos do React](https://react.dev/learn/you-might-not-need-an-effect) em termos de Signals!\n\n### Implementando efeitos\n\nA interface `Watcher` definida acima dá a base para implementar APIs JS típicas para efeitos: callbacks que são executados novamente quando outros Signals mudam, apenas por seu efeito colateral. A função `effect` usada acima no exemplo inicial pode ser definida da seguinte forma:\n\n```ts\n// Esta função normalmente viveria em uma biblioteca/framework, não no código da aplicação\n// NOTA: Esta lógica de agendamento é básica demais para ser útil. Não copie/cole.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Um Signal effect que avalia cb, que agenda uma leitura de\n// si mesmo na fila de microtarefas sempre que uma de suas dependências pode mudar\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nA API do Signal não inclui nenhuma função embutida como `effect`. Isso ocorre porque o agendamento de efeitos é sutil e frequentemente se integra aos ciclos de renderização do framework e a outros estados ou estratégias específicas de frameworks de alto nível aos quais o JS não tem acesso.\n\nPercorrendo as diferentes operações usadas aqui: o callback `notify` passado ao construtor de `Watcher` é a função chamada quando o Signal vai de um estado \"clean\" (onde sabemos que o cache está inicializado e válido) para um estado \"checked\" ou \"dirty\" (onde o cache pode ou não ser válido porque pelo menos um dos estados dos quais depende recursivamente foi alterado).\n\nChamadas a `notify` são, em última instância, disparadas por uma chamada a `.set()` em algum Signal de state. Essa chamada é síncrona: acontece antes de `.set` retornar. Mas não há necessidade de se preocupar com esse callback observando o grafo de Signal em um estado parcialmente processado, porque durante um callback `notify`, nenhum Signal pode ser lido ou escrito, mesmo em uma chamada `untrack`. Como `notify` é chamado durante `.set()`, ele interrompe outro fluxo de lógica, que pode não estar completo. Para ler ou escrever Signals a partir de `notify`, agende o trabalho para rodar depois, por exemplo, escrevendo o Signal em uma lista para ser acessado posteriormente, ou com `queueMicrotask` como acima.\n\nNote que é perfeitamente possível usar Signals de maneira eficaz sem `Signal.subtle.Watcher` ao agendar polling de Signals computados, como faz o Glimmer. Entretanto, muitos frameworks descobriram que é frequentemente útil ter essa lógica de agendamento rodando de forma síncrona, então a API de Signals inclui isso.\n\nTanto Signals computados quanto de state são coletados pelo garbage collector como qualquer valor JS. Mas Watchers têm uma maneira especial de manter as coisas vivas: qualquer Signal observado por um Watcher será mantido vivo enquanto qualquer um dos estados subjacentes for acessível, pois estes podem disparar uma futura chamada `notify` (e então uma futura `.get()`). Por essa razão, lembre-se de chamar `Watcher.prototype.unwatch` para limpar efeitos.\n\n### Um escape hatch não seguro\n\n`Signal.subtle.untrack` é um escape hatch que permite ler Signals *sem* rastrear essas leituras. Essa capacidade é insegura porque permite a criação de Signals computados cujo valor depende de outros Signals, mas que não são atualizados quando esses Signals mudam. Deve ser usado quando os acessos não rastreados não irão alterar o resultado do cálculo.\n\n<!--\nTODO: Mostrar exemplo onde faz sentido usar untrack\n\n### Usando watched/unwatched",
  "status": "ok"
}