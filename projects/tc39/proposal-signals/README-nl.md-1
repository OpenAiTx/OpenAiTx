{
  "id": 1,
  "origin": "# ðŸš¦ JavaScript Signals standard proposalðŸš¦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and moreâ€¦\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# ðŸš¦ JavaScript Signals standaardvoorstel ðŸš¦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nFase 1 ([uitleg](https://tc39.es/process-document/))\n\nTC39 voorstel-champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOorspronkelijke auteurs: Rob Eisenberg en Daniel Ehrenberg\n\nDit document beschrijft een vroege gemeenschappelijke richting voor signals in JavaScript, vergelijkbaar met de Promises/A+ inspanning die voorafging aan de door TC39 gestandaardiseerde Promises in ES2015. Probeer het zelf uit met [een polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nNet als Promises/A+, richt deze inspanning zich op het op Ã©Ã©n lijn brengen van het JavaScript-ecosysteem. Als deze afstemming succesvol is, kan er een standaard ontstaan op basis van die ervaring. Verschillende framework-auteurs werken hier samen aan een gemeenschappelijk model dat hun reactiviteitskern kan ondersteunen. Het huidige concept is gebaseerd op ontwerpinput van de auteurs/beheerders van [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), en meerâ€¦\n\nIn tegenstelling tot Promises/A+ proberen we niet een gemeenschappelijke API voor ontwikkelaars te creÃ«ren, maar juist de precieze kerneigenschappen van de onderliggende signal-graph te definiÃ«ren. Dit voorstel bevat wel een volledig concrete API, maar die is niet bedoeld voor de meeste applicatieontwikkelaars. In plaats daarvan is de signal-API hier beter geschikt voor frameworks om op voort te bouwen, en biedt het interoperabiliteit via een gemeenschappelijke signal-graph en auto-tracking mechanisme.\n\nHet plan voor dit voorstel is om in een vroeg stadium veel te prototypen, inclusief integratie in verschillende frameworks, voordat we verder gaan dan Fase 1. We zijn alleen geÃ¯nteresseerd in het standaardiseren van Signals als ze daadwerkelijk geschikt zijn voor gebruik in de praktijk in meerdere frameworks, en echte voordelen bieden boven door frameworks geleverde signals. We hopen dat intensief vroegtijdig prototypen ons deze informatie zal verschaffen. Zie \"Status en ontwikkelplan\" hieronder voor meer details.\n\n## Achtergrond: Waarom Signals?\n\nOm een complexe gebruikersinterface (UI) te ontwikkelen, moeten JavaScript-applicatieontwikkelaars op een efficiÃ«nte manier status opslaan, berekenen, ongeldig maken, synchroniseren en doorgeven aan de viewlaag van de applicatie. UIâ€™s gaan meestal verder dan het beheren van simpele waarden, en omvatten vaak het renderen van berekende status die afhankelijk is van een complexe boom van andere waarden of status die ook zelf berekend wordt. Het doel van Signals is om infrastructuur te bieden voor het beheren van dergelijke applicatiestatus zodat ontwikkelaars zich kunnen richten op de businesslogica in plaats van deze repetitieve details.\n\nSignal-achtige constructies zijn onafhankelijk ook nuttig gebleken in niet-UI-contexten, met name in buildsysteemomgevingen om onnodige herbouw te voorkomen.\n\nSignals worden gebruikt in reactieve programmering om het beheer van updates in applicaties te vereenvoudigen.\n\n> Een declaratief programmeermodel voor updates op basis van veranderingen in status.\n\nuit _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Voorbeeld - Een VanillaJS Counter\n\nGegeven een variabele, `counter`, wil je in de DOM weergeven of de counter even of oneven is. Telkens wanneer de `counter` verandert, wil je de DOM updaten met de nieuwste pariteit. In Vanilla JS zou je zoiets kunnen hebben:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simuleer externe updates aan counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!LET OP]  \n> Globals worden hier alleen voor demonstratiedoeleinden gebruikt. Voor goed statusbeheer zijn er veel oplossingen, en de voorbeelden in dit voorstel zijn bedoeld om zo minimaal mogelijk te zijn. Dit voorstel moedigt geen globale variabelen aan.\n\n\nDit heeft een aantal problemen...\n\n* De `counter`-opzet is omslachtig en bevat veel boilerplate.\n* De `counter`-status is sterk gekoppeld aan het renderingsysteem.\n* Als de `counter` verandert maar `parity` niet (bijvoorbeeld als counter van 2 naar 4 gaat), dan doen we onnodige berekening van de pariteit en onnodige rendering.\n* Wat als een ander deel van onze UI alleen wil renderen als de `counter` wordt bijgewerkt?\n* Wat als een ander deel van onze UI alleen afhankelijk is van `isEven` of `parity`?\n\nZelfs in dit relatief eenvoudige scenario ontstaan er snel verschillende problemen. We zouden dit kunnen proberen op te lossen door pub/sub in te voeren voor de `counter`. Hierdoor kunnen extra afnemers van de `counter` zich abonneren om hun eigen reacties toe te voegen aan statuswijzigingen.\n\nWe zitten echter nog steeds met de volgende problemen:\n\n* De renderfunctie, die alleen afhankelijk is van `parity`, moet nu eigenlijk â€œwetenâ€ dat hij op `counter` moet abonneren.\n* Het is niet mogelijk de UI bij te werken op basis van alleen `isEven` of `parity`, zonder direct met `counter` te werken.\n* We hebben meer boilerplate toegevoegd. Elke keer dat je iets gebruikt, is het niet gewoon een functie aanroepen of een variabele lezen, maar moet je je abonneren en daar updates uitvoeren. Het beheer van afmeldingen is ook bijzonder ingewikkeld.\n\nNu zouden we enkele problemen kunnen oplossen door niet alleen pub/sub toe te voegen aan `counter`, maar ook aan `isEven` en `parity`. We zouden dan `isEven` moeten abonneren op `counter`, `parity` op `isEven`, en `render` op `parity`. Helaas is niet alleen onze boilerplate-code geÃ«xplodeerd, maar zitten we ook met enorm veel administratie van abonnementen en een potentieel geheugenlek als we niet alles op de juiste manier opruimen. Dus we hebben een paar problemen opgelost, maar een hele nieuwe categorie problemen en veel code gecreÃ«erd. En het ergste is dat we dit hele proces moeten doorlopen voor elk stukje status in ons systeem.\n\n### Introductie van Signals\n\nDatabindingsabstraheringen in UIâ€™s voor het model en de view zijn al lang kernonderdelen van UI-frameworks in meerdere programmeertalen, ondanks het ontbreken van een dergelijk mechanisme in JS of het webplatform zelf. Binnen JS-frameworks en -bibliotheken is er veel geÃ«xperimenteerd met verschillende manieren om deze binding te representeren, en de ervaring heeft de kracht getoond van eenrichtingsdatastromen in combinatie met een eersteklas datatype dat een cel van status of berekening uit andere data vertegenwoordigt, tegenwoordig vaak â€œSignalsâ€ genoemd.\nDeze eersteklas reactieve waarde-benadering lijkt zijn eerste populaire verschijning in open-source JavaScript webframeworks te hebben gemaakt met [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In de jaren daarna zijn er vele variaties en implementaties ontstaan. In de afgelopen 3-4 jaar heeft het Signal-principe en aanverwante benaderingen verder aan terrein gewonnen, waarbij vrijwel elke moderne JavaScript-bibliotheek of -framework iets soortgelijks heeft, onder welke naam dan ook.\n\nOm Signals te begrijpen, bekijken we het bovenstaande voorbeeld, opnieuw vormgegeven met een Signal-API die hieronder verder wordt uitgewerkt.\n\n#### Voorbeeld - Een Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// Een bibliotheek of framework definieert effecten gebaseerd op andere Signal-primitieven\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simuleer externe updates aan counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nEr zijn een paar dingen die direct opvallen:\n* We hebben de omslachtige boilerplate rond de `counter`-variabele uit het vorige voorbeeld geÃ«limineerd.\n* Er is een uniforme API om waarden, berekeningen en neveneffecten af te handelen.\n* Er is geen probleem met circulaire verwijzingen of omgekeerde afhankelijkheden tussen `counter` en `render`.\n* Er zijn geen handmatige abonnementen nodig, noch boekhouding hiervoor.\n* Er is een manier om timing/scheduling van neveneffecten te regelen.\n\nSignals bieden ons veel meer dan alleen wat aan de oppervlakte van de API te zien is:",
  "status": "ok"
}