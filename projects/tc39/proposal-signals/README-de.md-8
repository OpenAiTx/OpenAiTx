{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**F**: Funktionieren Signals mit einseitigem Datenfluss, wie es React tut?\n\n**A**: Ja, Signals sind ein Mechanismus für einen einseitigen Datenfluss. UI-Frameworks, die auf Signals basieren, ermöglichen es Ihnen, Ihre Ansicht als Funktion des Modells auszudrücken (wobei das Modell Signals einbezieht). Ein Graph aus State- und berechneten Signals ist konstruktionsbedingt azyklisch. Es ist auch möglich, React-Antipatterns mit Signals nachzubilden (!), z. B. das Signal-Äquivalent eines `setState` innerhalb von `useEffect` besteht darin, einen Watcher zu verwenden, um einen Schreibvorgang an ein State-Signal zu terminieren.\n\n**F**: Wie stehen Signals im Verhältnis zu State-Management-Systemen wie Redux? Fördern Signals unstrukturierten State?\n\n**A**: Signals können eine effiziente Grundlage für speicherähnliche State-Management-Abstraktionen bilden. Ein gängiges Muster, das in mehreren Frameworks zu finden ist, ist ein Objekt, das auf einem Proxy basiert und intern Eigenschaften mithilfe von Signals darstellt, z. B. [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive) oder [Solid stores](https://docs.solidjs.com/concepts/stores). Diese Systeme ermöglichen eine flexible Gruppierung von State auf dem richtigen Abstraktionsniveau für die jeweilige Anwendung.\n\n**F**: Was bieten Signals, was `Proxy` derzeit nicht abdeckt?\n\n**A**: Proxies und Signals ergänzen sich und funktionieren gut zusammen. Proxies ermöglichen es Ihnen, flache Objektoperationen abzufangen, und Signals koordinieren einen Abhängigkeitsgraphen (von Zellen). Einen Proxy mit Signals zu hinterlegen ist eine großartige Möglichkeit, eine verschachtelte reaktive Struktur mit hoher Ergonomie zu schaffen.\n\nIn diesem Beispiel können wir einen Proxy verwenden, um das Signal mit einer Getter- und Setter-Eigenschaft zu versehen, anstatt die Methoden `get` und `set` zu verwenden:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// Verwendung in einem hypothetischen reaktiven Kontext:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>ändern</button>\n</template>\n```\nWenn ein Renderer verwendet wird, der für feinkörnige Reaktivität optimiert ist, führt das Klicken auf den Button dazu, dass die `b.value`-Zelle aktualisiert wird.\n\nSiehe:\n- Beispiele für verschachtelte reaktive Strukturen, die mit sowohl Signals als auch Proxies erstellt wurden: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- Beispiel für frühere Implementierungen, die die Beziehung zwischen reaktiven Daten und Proxies zeigen: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [Diskussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Wie funktionieren Signals?\n\n**F**: Sind Signals push-basiert oder pull-basiert?\n\n**A**: Die Auswertung von berechneten Signals ist pull-basiert: Berechnete Signals werden nur ausgewertet, wenn `.get()` aufgerufen wird, selbst wenn sich der zugrunde liegende State bereits früher geändert hat. Gleichzeitig kann eine Änderung eines State-Signals sofort den Callback eines Watchers auslösen, also die Benachrichtigung „pushen“. Signals können daher als eine \"Push-Pull\"-Konstruktion betrachtet werden.\n\n**F**: Führen Signals zu Nichtdeterminismus in der JavaScript-Ausführung?\n\n**A**: Nein. Zum einen haben alle Signal-Operationen wohldefinierte Semantik und Reihenfolge und unterscheiden sich nicht zwischen konformen Implementierungen. Auf einer höheren Ebene folgen Signals einer Reihe von Invarianten, hinsichtlich derer sie „sound“ sind. Ein berechnetes Signal beobachtet den Signal-Graphen immer in einem konsistenten Zustand und seine Ausführung wird nicht durch anderen Signal-verändernden Code unterbrochen (außer durch Dinge, die es selbst aufruft). Siehe die obige Beschreibung.\n\n**F**: Wann wird beim Schreiben auf ein State-Signal das zugehörige berechnete Signal aktualisiert?\n\n**A**: Es wird nicht terminiert! Das berechnete Signal berechnet sich beim nächsten Lesen neu. Synchron kann ein Watcher-`notify`-Callback aufgerufen werden, wodurch Frameworks ein Lesen zu einem passenden Zeitpunkt terminieren können.\n\n**F**: Wann werden Schreibvorgänge an State-Signals wirksam? Sofort oder werden sie gebündelt?\n\n**A**: Schreibvorgänge an State-Signals werden sofort widergespiegelt – das nächste Mal, wenn ein berechnetes Signal, das von diesem State-Signal abhängt, gelesen wird, wird es sich bei Bedarf neu berechnen, sogar wenn dies in der unmittelbar folgenden Codezeile geschieht. Allerdings bedeutet die inhärente Faulheit dieses Mechanismus (dass berechnete Signals nur beim Lesen berechnet werden), dass die Berechnungen in der Praxis gebündelt ablaufen können.\n\n**F**: Was bedeutet es, dass Signals eine „glitchfreie“ Ausführung ermöglichen?\n\n**A**: Frühere push-basierte Modelle für Reaktivität hatten das Problem redundanter Berechnungen: Wenn eine Änderung an einem State-Signal dazu führt, dass ein berechnetes Signal eifrig ausgeführt wird, kann dies letztlich ein Update an die UI pushen. Dieses Schreiben in die UI könnte jedoch verfrüht sein, wenn vor dem nächsten Frame eine weitere Änderung am ursprünglichen State-Signal erfolgt. Manchmal wurden Endnutzern durch solche [Glitches](https://de.wikipedia.org/wiki/Reaktives_Programmieren#Glitches) sogar ungenaue Zwischenwerte angezeigt. Signals vermeiden diese Dynamik, indem sie pull-basiert und nicht push-basiert sind: Zum Zeitpunkt der geplanten UI-Renderings zieht das Framework die passenden Updates und vermeidet so unnötige Arbeit sowohl bei Berechnungen als auch beim Schreiben in das DOM.\n\n**F**: Was bedeutet es, dass Signals „lossy“ sind?\n\n**A**: Dies ist die Kehrseite der glitchfreien Ausführung: Signals repräsentieren eine Datenzelle – nur den aktuellen Wert (der sich ändern kann), nicht einen Datenstrom über die Zeit. Wenn Sie also zweimal hintereinander auf ein State-Signal schreiben, ohne sonst etwas zu tun, geht der erste Schreibvorgang „verloren“ und wird nie von berechneten Signals oder Effekten gesehen. Dies wird als Feature und nicht als Bug verstanden – andere Konstrukte (z. B. asynchrone Iterables, Observables) sind für Datenströme besser geeignet.\n\n**F**: Werden native Signals schneller sein als bestehende JS-Signal-Implementierungen?\n\n**A**: Das hoffen wir (um einen kleinen konstanten Faktor), aber das muss sich erst noch im Code beweisen. JS-Engines sind keine Magie und müssen letztlich die gleichen Arten von Algorithmen implementieren wie JS-Implementierungen von Signals. Siehe obigen Abschnitt zur Performance.\n\n#### Warum sind Signals so konzipiert?\n\n**F**: Warum enthält dieser Vorschlag keine `effect()`-Funktion, obwohl Effekte für jede praktische Nutzung von Signals notwendig sind?\n\n**A**: Effekte sind inhärent mit Terminierung und Entsorgung verbunden, die von Frameworks verwaltet werden und außerhalb des Umfangs dieses Vorschlags liegen. Stattdessen beinhaltet dieser Vorschlag die Grundlage zur Implementierung von Effekten über die Low-Level-API `Signal.subtle.Watcher`.\n\n**F**: Warum sind Subscriptions automatisch, anstatt eine manuelle Schnittstelle bereitzustellen?\n\n**A**: Die Erfahrung hat gezeigt, dass manuelle Subscription-Schnittstellen für Reaktivität unergonomisch und fehleranfällig sind. Automatisches Tracking ist besser zusammensetzbar und ein zentrales Merkmal von Signals.\n\n**F**: Warum läuft der Callback des `Watcher` synchron, anstatt in einer Microtask terminiert zu werden?\n\n**A**: Weil der Callback keine Signals lesen oder schreiben kann, entsteht durch den synchronen Aufruf keine Unsicherheit. Ein typischer Callback fügt ein Signal einem Array hinzu, das später gelesen wird, oder markiert irgendwo ein Bit. Es ist unnötig und unpraktisch teuer, für all diese Aktionen jeweils eine eigene Microtask zu erstellen.\n\n**F**: Diese API fehlt einige nette Dinge, die mein Lieblingsframework bietet und die die Programmierung mit Signals erleichtern. Kann das auch in den Standard aufgenommen werden?\n\n**A**: Vielleicht. Verschiedene Erweiterungen werden noch geprüft. Bitte reichen Sie ein Issue ein, um eine Diskussion zu jedem fehlenden wichtigen Feature anzustoßen.\n\n**F**: Kann diese API in Größe oder Komplexität reduziert werden?\n\n**A**: Es ist definitiv ein Ziel, diese API minimal zu halten, und wir haben versucht, das mit dem oben Gezeigten zu tun. Wenn Sie Ideen für Dinge haben, die entfernt werden könnten, reichen Sie bitte ein Issue zur Diskussion ein.\n\n#### Wie werden Signals standardisiert?\n\n**F**: Sollten wir mit der Standardisierung in diesem Bereich nicht mit einem primitiveren Konzept wie Observables beginnen?",
  "status": "ok"
}