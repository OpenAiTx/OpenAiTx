{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Con [AsyncContext](https://github.com/tc39/proposal-async-context), il callback passato a `new Signal.subtle.Watcher` *non* chiude lo snapshot del momento in cui il costruttore è stato chiamato, in modo che le informazioni contestuali relative alla scrittura siano visibili.\n\n#### Metodo: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Se `frozen` è true, genera un'eccezione.\n1. Se uno qualsiasi degli argomenti non è un segnale, genera un'eccezione.\n1. Aggiungi tutti gli argomenti alla fine dell'array `signals` di questo oggetto.\n1. Per ciascun nuovo segnale osservato, in ordine da sinistra a destra,\n    1. Aggiungi questo watcher come `sink` a quel segnale.\n    1. Se questo era il primo sink, ricorri alle sorgenti per aggiungere quel segnale come sink.\n    1. Imposta `frozen` a true.\n    1. Chiama il callback `watched` se esiste.\n    1. Ripristina `frozen` a false.\n1. Se lo `state` del Signal è `~waiting~`, impostalo su `~watching~`.\n\n#### Metodo: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Se `frozen` è true, genera un'eccezione.\n1. Se uno qualsiasi degli argomenti non è un segnale, o non è osservato da questo watcher, genera un'eccezione.\n1. Per ciascun segnale negli argomenti, in ordine da sinistra a destra,\n    1. Rimuovi quel segnale dall'insieme `signals` di questo Watcher.\n    1. Rimuovi questo Watcher dall'insieme `sink` di quel Signal.\n    1. Se l'insieme `sink` di quel Signal è diventato vuoto, rimuovi quel Signal come sink da ciascuna delle sue sorgenti.\n    1. Imposta `frozen` a true.\n    1. Chiama il callback `unwatched` se esiste.\n    1. Ripristina `frozen` a false.\n1. Se ora il watcher non ha più segnali in `signals`, e il suo stato è `~watching~`, allora impostalo su `~waiting~`.\n\n#### Metodo: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Restituisce un array contenente il sottoinsieme di `signals` che sono Computed Signal negli stati `~dirty~` o `~pending~`.\n\n### Metodo: `Signal.subtle.untrack(cb)`\n\n1. Lascia che `c` sia lo stato corrente di `computing` del contesto di esecuzione.\n1. Imposta `computing` su null.\n1. Chiama `cb`.\n1. Ripristina `computing` a `c` (anche se `cb` lancia un'eccezione).\n1. Restituisce il valore di ritorno di `cb` (rilanciando eventuali eccezioni).\n\nNota: untrack non fa uscire dallo stato `frozen`, che viene mantenuto rigorosamente.\n\n### Metodo: `Signal.subtle.currentComputed()`\n\n1. Restituisce il valore corrente di `computing`.\n\n### Algoritmi comuni\n\n##### Algoritmo: ricalcolare un Computed Signal dirty\n\n1. Svuota l'insieme `sources` di questo Signal e rimuovilo dagli insiemi `sinks` di quelle sorgenti.\n1. Salva il valore precedente di `computing` e imposta `computing` su questo Signal.\n1. Imposta lo stato di questo Signal su `~computing~`.\n1. Esegui il callback di questo Computed Signal, usando questo Signal come valore di `this`. Salva il valore di ritorno e, se il callback lancia un'eccezione, memorizzala per rilanciarla.\n1. Ripristina il valore precedente di `computing`.\n1. Applica l'algoritmo \"imposta valore Signal\" al valore di ritorno del callback.\n2. Imposta lo stato di questo Signal su `~clean~`.\n1. Se quell'algoritmo ha restituito `~dirty~`: marca tutti i sinks di questo Signal come `~dirty~` (in precedenza i sinks potevano essere un mix di checked e dirty). (Oppure, se questo non è osservato, adotta un nuovo numero di generazione per indicare la sporcizia, o qualcosa di simile.)\n1. Altrimenti, se l'algoritmo ha restituito `~clean~`: in questo caso, per ogni sink `~checked~` di questo Signal, se tutte le sorgenti di quel Signal ora sono clean, allora marca anche quel Signal come `~clean~`. Applica ricorsivamente questo passaggio di pulizia ai sinks ulteriori, a qualsiasi nuovo Signal pulito che abbia sinks checked. (Oppure, se questo non è osservato, indica comunque lo stesso, in modo che la pulizia possa procedere in modo lazy.)\n\n##### Algoritmo imposta valore Signal\n\n1. Se a questo algoritmo è stato passato un valore (invece di un'eccezione da rilanciare, dall'algoritmo di ricalcolo Computed Signal dirty):\n    1. Chiama la funzione `equals` di questo Signal, passando come parametri il valore corrente, il nuovo valore e questo Signal. Se viene lanciata un'eccezione, salva quell'eccezione (da rilanciare quando letto) come valore del Signal e continua come se il callback avesse restituito false.\n    1. Se la funzione restituisce true, restituisci `~clean~`.\n1. Imposta il valore di questo Signal sul parametro.\n1. Restituisci `~dirty~`.\n\n## FAQ\n\n**D**: Non è un po' presto per standardizzare qualcosa relativo ai Signals, visto che sono diventati popolari solo nel 2022? Non dovremmo dargli più tempo per evolversi e stabilizzarsi?\n\n**R**: Lo stato attuale dei Signals nei framework web è il risultato di oltre 10 anni di sviluppo continuo. Con l'aumento degli investimenti degli ultimi anni, quasi tutti i framework web stanno convergendo verso un modello di Signals molto simile. Questa proposta è il risultato di un esercizio di design condiviso tra un ampio numero di leader attuali nei framework web, e non sarà portata avanti verso la standardizzazione senza la validazione di quel gruppo di esperti di dominio nei vari contesti.\n\n#### Come vengono usati i Signals?\n\n**D**: I Signals integrati possono essere usati dai framework, data la loro forte integrazione con rendering e ownership?\n\n**R**: Le parti più specifiche dei framework tendono a essere nell'area degli effetti, scheduling e ownership/disposal, che questa proposta non cerca di risolvere. La nostra prima priorità con la prototipazione degli standard-track Signals è validare che possano essere usati \"sotto\" i framework esistenti in modo compatibile e con buone prestazioni.\n\n**D**: L'API Signal è pensata per essere usata direttamente dagli sviluppatori di applicazioni, o incapsulata dai framework?\n\n**R**: Anche se questa API potrebbe essere usata direttamente dagli sviluppatori di applicazioni (almeno la parte che non rientra nel namespace `Signal.subtle`), non è progettata per essere particolarmente ergonomica. Invece, le esigenze degli autori di librerie/framework sono prioritarie. Ci si aspetta che la maggior parte dei framework incapsuli anche le API base `Signal.State` e `Signal.Computed` con qualcosa che esprima la propria ergonomia. In pratica, è tipicamente meglio usare i Signals tramite un framework, che gestisce le funzionalità più complesse (es. Watcher, `untrack`), oltre a gestire ownership e disposal (es. decidere quando i signals devono essere aggiunti e rimossi dai watcher), e lo scheduling del rendering sul DOM--questa proposta non cerca di risolvere questi problemi.\n\n**D**: Devo smontare i Signals relativi a un widget quando quel widget viene distrutto? Qual è l'API per farlo?\n\n**R**: L'operazione di teardown rilevante qui è `Signal.subtle.Watcher.prototype.unwatch`. Solo i Signals osservati devono essere puliti (tramite unwatch), mentre i Signals non osservati possono essere raccolti automaticamente dal garbage collector.\n\n**D**: I Signals funzionano con VDOM, o direttamente con l'HTML DOM sottostante?\n\n**R**: Sì! I Signals sono indipendenti dalla tecnologia di rendering. I framework JavaScript esistenti che usano costrutti simili ai Signals si integrano con il VDOM (es. Preact), il DOM nativo (es. Solid) e una combinazione (es. Vue). Lo stesso sarà possibile con i Signals integrati.\n\n**D**: Sarà ergonomico usare i Signals nel contesto di framework basati su classi come Angular e Lit? E nei framework basati su compilatore come Svelte?\n\n**R**: I campi delle classi possono essere resi Signal-based con un semplice decorator per gli accessor, come mostrato nel [readme del polyfill Signal](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). I Signals sono molto allineati con i Runes di Svelte 5--è semplice per un compilatore trasformare i runes nell'API Signal definita qui, e infatti è quello che Svelte 5 fa internamente (ma con la propria libreria Signals).\n\n**D**: I Signals funzionano con SSR? Hydration? Resumability?\n\n**R**: Sì. Qwik usa i Signals con ottimi risultati con entrambe queste proprietà, e altri framework hanno approcci ben sviluppati all'hydration con Signals con diversi compromessi. Pensiamo che sia possibile modellare i Signals resumable di Qwik usando un Signal State e uno Computed collegati insieme, e abbiamo in programma di dimostrarlo nel codice.",
  "status": "ok"
}