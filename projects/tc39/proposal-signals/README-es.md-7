{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Con [AsyncContext](https://github.com/tc39/proposal-async-context), el callback pasado a `new Signal.subtle.Watcher` *no* captura el snapshot del momento en que se llamó al constructor, de modo que la información contextual alrededor de la escritura sea visible.\n\n#### Método: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Si `frozen` es true, lanza una excepción.\n1. Si alguno de los argumentos no es una señal, lanza una excepción.\n1. Añade todos los argumentos al final del array `signals` de este objeto.\n1. Para cada señal recién observada, en orden de izquierda a derecha,\n    1. Añade este watcher como un `sink` a esa señal.\n    1. Si este fue el primer sink, entonces recursivamente sube a las fuentes para añadir esa señal como sink.\n    1. Establece `frozen` en true.\n    1. Llama al callback `watched` si existe.\n    1. Restaura `frozen` a false.\n1. Si el `state` de la Signal es `~waiting~`, entonces establécelo a `~watching~`.\n\n#### Método: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Si `frozen` es true, lanza una excepción.\n1. Si alguno de los argumentos no es una señal, o no está siendo observada por este watcher, lanza una excepción.\n1. Para cada señal en los argumentos, en orden de izquierda a derecha,\n    1. Elimina esa señal del conjunto `signals` de este Watcher.\n    1. Elimina este Watcher del conjunto `sink` de esa Signal.\n    1. Si el conjunto `sink` de esa Signal se ha quedado vacío, elimina esa Signal como sink de cada una de sus fuentes.\n    1. Establece `frozen` en true.\n    1. Llama al callback `unwatched` si existe.\n    1. Restaura `frozen` a false.\n1. Si el watcher ahora no tiene `signals`, y su `state` es `~watching~`, entonces establécelo a `~waiting~`.\n\n#### Método: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Devuelve un Array que contiene el subconjunto de `signals` que son Computed Signals en los estados `~dirty~` o `~pending~`.\n\n### Método: `Signal.subtle.untrack(cb)`\n\n1. Deja que `c` sea el estado `computing` actual del contexto de ejecución.\n1. Establece `computing` a null.\n1. Llama a `cb`.\n1. Restaura `computing` a `c` (incluso si `cb` lanzó una excepción).\n1. Devuelve el valor de retorno de `cb` (relanzando cualquier excepción).\n\nNota: untrack no te saca del estado `frozen`, el cual se mantiene estrictamente.\n\n### Método: `Signal.subtle.currentComputed()`\n\n1. Devuelve el valor actual de `computing`.\n\n### Algoritmos comunes\n\n##### Algoritmo: recalcular una Signal computada dirty\n\n1. Limpia el conjunto `sources` de esta Signal y elimínala de los conjuntos `sinks` de esas fuentes.\n1. Guarda el valor anterior de `computing` y establece `computing` a esta Signal.\n1. Establece el estado de esta Signal a `~computing~`.\n1. Ejecuta el callback de esta Signal computada, usando esta Signal como valor de this. Guarda el valor de retorno y, si el callback lanzó una excepción, almacénala para relanzarla.\n1. Restaura el valor anterior de `computing`.\n1. Aplica el algoritmo \"set Signal value\" al valor de retorno del callback.\n2. Establece el estado de esta Signal a `~clean~`.\n1. Si ese algoritmo devolvió `~dirty~`: marca todos los sinks de esta Signal como `~dirty~` (anteriormente, los sinks podían estar mezclados entre checked y dirty). (O, si no está siendo observada, entonces adopta un nuevo número de generación para indicar suciedad, o algo así.)\n1. De lo contrario, si el algoritmo devolvió `~clean~`: En este caso, para cada sink `~checked~` de esta Signal, si todas las fuentes de esa Signal están ahora limpias, marca también esa Signal como `~clean~`. Aplica este paso de limpieza a sinks adicionales recursivamente, a cualquier Signal recién limpia que tenga sinks marcados como checked. (O, si no está siendo observada, indica lo mismo de alguna manera, para que la limpieza pueda proceder de forma perezosa.)\n\n##### Algoritmo para establecer el valor de una Signal\n\n1. Si a este algoritmo se le pasó un valor (en vez de una excepción para relanzar, del algoritmo de recalcular Signal computada dirty):\n    1. Llama a la función `equals` de esta Signal, pasando como parámetros el `value` actual, el nuevo valor y esta Signal. Si se lanza una excepción, guarda esa excepción (para relanzar al leer) como el valor de la Signal y continúa como si el callback hubiese devuelto false.\n    1. Si esa función devolvió true, devuelve `~clean~`.\n1. Establece el `value` de esta Signal al parámetro.\n1. Devuelve `~dirty~`\n\n## FAQ\n\n**P**: ¿No es un poco pronto para estandarizar algo relacionado con Signals, cuando acaban de empezar a ser lo nuevo en 2022? ¿No deberíamos darles más tiempo para evolucionar y estabilizarse?\n\n**R**: El estado actual de las Signals en los frameworks web es el resultado de más de 10 años de desarrollo continuo. A medida que aumenta la inversión, como ha ocurrido en los últimos años, casi todos los frameworks web se están acercando a un modelo central de Signals muy similar. Esta propuesta es el resultado de un ejercicio de diseño compartido entre un gran número de líderes actuales en frameworks web, y no se impulsará hacia la estandarización sin la validación de ese grupo de expertos en diversos contextos.\n\n#### ¿Cómo se usan las Signals?\n\n**P**: ¿Las Signals integradas pueden siquiera ser usadas por frameworks, dado su estrecha integración con el renderizado y la propiedad?\n\n**R**: Las partes que son más específicas del framework suelen estar en el área de efectos, scheduling y ownership/disposal, que esta propuesta no intenta resolver. Nuestra primera prioridad con la prototipación de Signals en proceso de estandarización es validar que puedan operar \"por debajo\" de los frameworks existentes de manera compatible y con buen rendimiento.\n\n**P**: ¿La API de Signal está pensada para ser usada directamente por desarrolladores de aplicaciones, o envuelta por frameworks?\n\n**R**: Aunque esta API podría ser utilizada directamente por desarrolladores de aplicaciones (al menos la parte que no está en el namespace `Signal.subtle`), no está diseñada para ser especialmente ergonómica. En su lugar, las necesidades de los autores de librerías/frameworks son prioritarias. Se espera que la mayoría de los frameworks envuelvan incluso las APIs básicas `Signal.State` y `Signal.Computed` con algo que exprese su propio enfoque ergonómico. En la práctica, normalmente es mejor usar Signals a través de un framework, que gestione las características más complejas (por ejemplo, Watcher, `untrack`), así como el ownership y disposal (por ejemplo, determinar cuándo las signals deben ser añadidas o eliminadas de los watchers), y programando el renderizado al DOM; esta propuesta no intenta resolver esos problemas.\n\n**P**: ¿Tengo que destruir las Signals relacionadas con un widget cuando ese widget se destruye? ¿Cuál es la API para eso?\n\n**R**: La operación de desmontaje relevante aquí es `Signal.subtle.Watcher.prototype.unwatch`. Solo las Signals observadas necesitan ser limpiadas (desobservando), mientras que las Signals no observadas pueden ser recolectadas automáticamente por el garbage collector.\n\n**P**: ¿Las Signals funcionan con VDOM o directamente con el HTML DOM subyacente?\n\n**R**: ¡Sí! Las Signals son independientes de la tecnología de renderizado. Los frameworks de JavaScript existentes que usan construcciones similares a Signals se integran con VDOM (por ejemplo, Preact), el DOM nativo (por ejemplo, Solid) y una combinación (por ejemplo, Vue). Lo mismo será posible con las Signals integradas.\n\n**P**: ¿Será ergonómico usar Signals en el contexto de frameworks basados en clases como Angular y Lit? ¿Y qué pasa con los frameworks basados en compiladores como Svelte?\n\n**R**: Los campos de clase pueden ser basados en Signal usando un simple decorador de accessors, como se muestra en [el readme del polyfill de Signal](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Las Signals están muy alineadas con los Runes de Svelte 5—es sencillo para un compilador transformar runes a la API de Signal definida aquí, y de hecho esto es lo que hace Svelte 5 internamente (aunque con su propia librería de Signals).\n\n**P**: ¿Las Signals funcionan con SSR? ¿Con Hydration? ¿Con Resumability?\n\n**R**: Sí. Qwik utiliza Signals con buenos resultados en ambas propiedades, y otros frameworks tienen enfoques bien desarrollados para la hidratación con Signals y distintos tradeoffs. Creemos que es posible modelar las Signals resumibles de Qwik usando una señal State y una Computed conectadas, y planeamos demostrarlo en código.",
  "status": "ok"
}