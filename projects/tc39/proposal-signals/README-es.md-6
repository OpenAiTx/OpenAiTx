{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "El `state` de una Señal Computada puede ser uno de los siguientes:\n\n- `~clean~`: El valor de la Señal está presente y se sabe que no está obsoleto.\n- `~checked~`: Una fuente (indirecta) de esta Señal ha cambiado; esta Señal tiene un valor pero _puede_ estar obsoleto. Solo se sabrá si está obsoleto cuando todas las fuentes inmediatas hayan sido evaluadas.\n- `~computing~`: El callback de esta Señal se está ejecutando actualmente como efecto secundario de una llamada a `.get()`.\n- `~dirty~`: O bien esta Señal tiene un valor que se sabe que está obsoleto, o nunca ha sido evaluada.\n\nEl gráfico de transición es el siguiente:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nLas transiciones son:\n| Número | De | A | Condición | Algoritmo |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | Una fuente inmediata de esta señal, que es una señal computada, ha sido evaluada y su valor ha cambiado. | Algoritmo: recalcular señal computada dirty |\n| 2 | `~clean~` | `~dirty~` | Una fuente inmediata de esta señal, que es un Estado, ha sido establecida con un valor que no es igual a su valor anterior. | Método: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Una fuente recursiva, pero no inmediata, de esta señal, que es un Estado, ha sido establecida con un valor que no es igual a su valor anterior. | Método: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | Estamos a punto de ejecutar el `callback`. | Algoritmo: recalcular señal computada dirty |\n| 5 | `~computing~` | `~clean~` | El `callback` ha terminado de evaluarse y ha retornado un valor o lanzado una excepción. | Algoritmo: recalcular señal computada dirty |\n| 6 | `~checked~` | `~clean~` | Todas las fuentes inmediatas de esta señal han sido evaluadas, y todas se han descubierto sin cambios, por lo que ahora se sabe que no está obsoleta. | Algoritmo: recalcular señal computada dirty |\n\n#### Slots internos de `Signal.Computed`\n\n- `value`: El valor almacenado previamente en caché de la Señal, o `~uninitialized~` para una señal computada nunca leída. El valor puede ser una excepción que se relanza cuando se lee el valor. Siempre es `undefined` para señales de efecto.\n- `state`: Puede ser `~clean~`, `~checked~`, `~computing~`, o `~dirty~`.\n- `sources`: Un conjunto ordenado de Señales de las que depende esta Señal.\n- `sinks`: Un conjunto ordenado de Señales que dependen de esta Señal.\n- `equals`: El método equals proporcionado en las opciones.\n- `callback`: El callback que se llama para obtener el valor de la señal computada. Se establece con el primer parámetro pasado al constructor.\n\n#### Constructor de `Signal.Computed`\n\nEl constructor asigna\n- `callback` a su primer parámetro\n- `equals` según las opciones, usando por defecto `Object.is` si está ausente\n- `state` a `~dirty~`\n- `value` a `~uninitialized~`\n\nCon [AsyncContext](https://github.com/tc39/proposal-async-context), el callback pasado a `new Signal.Computed` se cierra sobre el snapshot del momento en que fue llamado el constructor, y restaura este snapshot durante su ejecución.\n\n#### Método: `Signal.Computed.prototype.get`\n\n1. Si el contexto de ejecución actual está `frozen` o si esta Señal tiene el estado `~computing~`, o si esta señal es un Watcher y está `computing` una señal computada, lanzar una excepción.\n1. Si `computing` no es `null`, añadir esta Señal al conjunto `sources` de `computing`.\n1. NOTA: No añadimos `computing` al conjunto `sinks` de esta Señal hasta que/no sea observada por un Watcher.\n1. Si el estado de esta Señal es `~dirty~` o `~checked~`: Repetir los siguientes pasos hasta que esta Señal esté `~clean~`:\n    1. Recorrer hacia arriba vía `sources` para encontrar la fuente recursiva más profunda y más a la izquierda (es decir, la primera observada) que sea una Señal Computada marcada como `~dirty~` (deteniendo la búsqueda al encontrar una Señal Computada `~clean~`, e incluyendo esta Señal Computada como lo último a buscar).\n    1. Ejecutar el algoritmo \"recalcular señal computada dirty\" en esa Señal.\n1. En este punto, el estado de esta Señal será `~clean~`, y ninguna fuente recursiva estará `~dirty~` ni `~checked~`. Retornar el `value` de la Señal. Si el valor es una excepción, relanzar esa excepción.\n\n### La clase `Signal.subtle.Watcher`\n\n#### Máquina de estados de `Signal.subtle.Watcher`\n\nEl `state` de un Watcher puede ser uno de los siguientes:\n\n- `~waiting~`: El callback `notify` ha sido ejecutado, o el Watcher es nuevo, pero no está observando activamente ninguna señal.\n- `~watching~`: El Watcher está observando señales activamente, pero aún no han ocurrido cambios que requieran una llamada al callback `notify`.\n- `~pending~`: Una dependencia del Watcher ha cambiado, pero el callback `notify` aún no ha sido ejecutado.\n\nEl gráfico de transición es el siguiente:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nLas transiciones son:\n| Número | De | A | Condición | Algoritmo |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | Se ha llamado al método `watch` del Watcher. | Método: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Se ha llamado al método `unwatch` del Watcher y se ha eliminado la última señal observada. | Método: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Una señal observada puede haber cambiado de valor. | Método: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | El callback `notify` ha sido ejecutado. | Método: `Signal.State.prototype.set(newValue)` |\n\n#### Slots internos de `Signal.subtle.Watcher`\n\n- `state`: Puede ser `~watching~`, `~pending~` o `~waiting~`\n- `signals`: Un conjunto ordenado de Señales que este Watcher está observando\n- `notifyCallback`: El callback que se llama cuando algo cambia. Se establece con el primer parámetro pasado al constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. El `state` se establece en `~waiting~`.\n1. Inicializar `signals` como un conjunto vacío.\n1. `notifyCallback` se establece al parámetro callback.",
  "status": "ok"
}