{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "De `state` van een Computed Signal kan een van de volgende zijn:\n\n- `~clean~`: De waarde van het Signaal is aanwezig en bekend als niet verouderd.\n- `~checked~`: Een (indirecte) bron van dit Signaal is gewijzigd; dit Signaal heeft een waarde maar deze _kan_ verouderd zijn. Of het verouderd is, zal pas bekend zijn nadat alle directe bronnen zijn geëvalueerd.\n- `~computing~`: De callback van dit Signaal wordt momenteel uitgevoerd als een neveneffect van een `.get()`-aanroep.\n- `~dirty~`: Ofwel heeft dit Signaal een waarde waarvan bekend is dat deze verouderd is, of het is nooit geëvalueerd.\n\nDe overgangsgrafiek is als volgt:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nDe overgangen zijn:\n| Nummer | Van | Naar | Voorwaarde | Algoritme |\n| ------ | --- | ---- | ---------- | --------- |\n| 1 | `~checked~` | `~dirty~` | Een directe bron van dit signaal, die een computed signaal is, is geëvalueerd en zijn waarde is gewijzigd. | Algoritme: herbereken dirty computed Signaal |\n| 2 | `~clean~` | `~dirty~` | Een directe bron van dit signaal, die een State is, is ingesteld op een waarde die niet gelijk is aan de vorige waarde. | Methode: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Een recursieve, maar niet directe, bron van dit signaal, die een State is, is ingesteld op een waarde die niet gelijk is aan de vorige waarde. | Methode: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We staan op het punt om de `callback` uit te voeren. | Algoritme: herbereken dirty computed Signaal |\n| 5 | `~computing~` | `~clean~` | De `callback` is klaar met evalueren en heeft een waarde geretourneerd of een uitzondering gegooid. | Algoritme: herbereken dirty computed Signaal |\n| 6 | `~checked~` | `~clean~` | Alle directe bronnen van dit signaal zijn geëvalueerd en zijn allemaal onveranderd gebleken, dus nu weten we dat het niet verouderd is. | Algoritme: herbereken dirty computed Signaal |\n\n#### `Signal.Computed` Interne slots\n\n- `value`: De vorige gecachte waarde van het Signaal, of `~uninitialized~` voor een nooit-gelezen computed Signaal. De waarde kan een uitzondering zijn die opnieuw wordt gegooid wanneer de waarde wordt gelezen. Altijd `undefined` voor effect-signalen.\n- `state`: Kan `~clean~`, `~checked~`, `~computing~` of `~dirty~` zijn.\n- `sources`: Een geordende set van Signaleren waarvan dit Signaal afhankelijk is.\n- `sinks`: Een geordende set van Signaleren die afhankelijk zijn van dit Signaal.\n- `equals`: De equals-methode geleverd in de opties.\n- `callback`: De callback die wordt aangeroepen om de waarde van het computed Signaal te verkrijgen. Ingesteld op de eerste parameter doorgegeven aan de constructor.\n\n#### `Signal.Computed` Constructor\n\nDe constructor stelt in\n- `callback` op zijn eerste parameter\n- `equals` op basis van opties, standaard `Object.is` als afwezig\n- `state` op `~dirty~`\n- `value` op `~uninitialized~`\n\nMet [AsyncContext](https://github.com/tc39/proposal-async-context) sluit de callback die aan `new Signal.Computed` wordt doorgegeven over de snapshot van wanneer de constructor werd aangeroepen, en herstelt deze snapshot tijdens de uitvoering.\n\n#### Methode: `Signal.Computed.prototype.get`\n\n1. Als de huidige uitvoeringscontext `frozen` is of als dit Signaal de status `~computing~` heeft, of als dit signaal een Watcher is en `computing` een computed Signaal, gooi een uitzondering.\n1. Als `computing` niet `null` is, voeg dit Signaal toe aan de `sources` set van `computing`.\n1. OPMERKING: We voegen `computing` niet toe aan de `sinks` set van dit Signaal totdat/tenzij het bekeken wordt door een Watcher.\n1. Als de status van dit Signaal `~dirty~` of `~checked~` is: Herhaal de volgende stappen totdat dit Signaal `~clean~` is:\n    1. Ga recursief omhoog via `sources` om de diepste, meest linkse (d.w.z. vroegst waargenomen) recursieve bron te vinden die een Computed Signal is gemarkeerd als `~dirty~` (stop de zoektocht bij een `~clean~` Computed Signal, en neem dit Computed Signal mee als laatste om te doorzoeken).\n    1. Voer het algoritme \"herbereken dirty computed Signaal\" uit op dat Signaal.\n1. Op dit punt zal de status van dit Signaal `~clean~` zijn, en zullen er geen recursieve bronnen `~dirty~` of `~checked~` zijn. Retourneer de `value` van het Signaal. Als de waarde een uitzondering is, gooi die uitzondering opnieuw.\n\n### De `Signal.subtle.Watcher` klasse\n\n#### `Signal.subtle.Watcher` Statusmachine\n\nDe `state` van een Watcher kan een van de volgende zijn:\n\n- `~waiting~`: De `notify` callback is uitgevoerd, of de Watcher is nieuw, maar bekijkt nog geen signalen actief.\n- `~watching~`: De Watcher bekijkt actief signalen, maar er zijn nog geen wijzigingen geweest die een `notify` callback noodzakelijk maken.\n- `~pending~`: Een afhankelijkheid van de Watcher is gewijzigd, maar de `notify` callback is nog niet uitgevoerd.\n\nDe overgangsgrafiek is als volgt:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nDe overgangen zijn:\n| Nummer | Van | Naar | Voorwaarde | Algoritme |\n| ------ | --- | ---- | ---------- | --------- |\n| 1 | `~waiting~` | `~watching~` | De `watch` methode van de Watcher is aangeroepen. | Methode: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | De `unwatch` methode van de Watcher is aangeroepen, en het laatst bekeken signaal is verwijderd. | Methode: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Een bekeken signaal kan een nieuwe waarde hebben gekregen. | Methode: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | De `notify` callback is uitgevoerd. | Methode: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` interne slots\n\n- `state`: Kan `~watching~`, `~pending~` of `~waiting~` zijn\n- `signals`: Een geordende set van Signaleren die deze Watcher bekijkt\n- `notifyCallback`: De callback die wordt aangeroepen wanneer iets verandert. Ingesteld op de eerste parameter doorgegeven aan de constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` wordt ingesteld op `~waiting~`.\n1. Initialiseer `signals` als een lege set.\n1. `notifyCallback` wordt ingesteld op de callback parameter.",
  "status": "ok"
}