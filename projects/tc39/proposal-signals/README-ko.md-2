{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **자동 의존성 추적** - 계산된 시그널(Computed Signal)은 자신이 의존하고 있는 다른 시그널(단순 값이든, 다른 연산이든)을 자동으로 발견합니다.\n* **지연 평가(Lazy Evaluation)** - 계산은 선언 시 즉시 평가되지 않으며, 의존성이 변경되어도 즉시 평가되지 않습니다. 오직 값이 명시적으로 요청될 때만 평가됩니다.\n* **메모이제이션(Memoization)** - 계산된 시그널은 마지막 값을 캐싱하여, 의존성이 변경되지 않은 경우에는 접근이 몇 번 이루어지더라도 다시 평가할 필요가 없습니다.\n\n## Signals 표준화의 동기\n\n#### 상호 운용성(Interoperability)\n\n각 시그널 구현체는 계산된 시그널을 평가할 때 만나는 소스들을 추적하기 위한 자체적인 자동 추적 메커니즘을 가지고 있습니다. 이로 인해 모델, 컴포넌트, 라이브러리를 서로 다른 프레임워크 간에 공유하기 어렵습니다. 보통 시그널은 JS 프레임워크의 일부로 구현되기 때문에 뷰 엔진에 잘못된 결합이 생기게 됩니다.\n\n이 제안의 목표는 반응형 모델을 렌더링 뷰와 완전히 분리시켜, 개발자가 비 UI 코드를 재작성하지 않고 새로운 렌더링 기술로 마이그레이션하거나, 다양한 컨텍스트에서 배포할 수 있는 JS 기반의 공유 반응형 모델을 개발할 수 있도록 하는 것입니다. 그러나 버전 관리와 중복 문제로 인해, JS 레벨의 라이브러리를 통한 강력한 공유는 실질적으로 어렵다는 것이 밝혀졌습니다. 빌트인(Built-in) 기능은 더 강력한 공유 보장을 제공합니다.\n\n#### 성능/메모리 사용\n\n자주 사용되는 라이브러리가 내장되어 있으면 적은 코드를 전달할 수 있어 잠재적인 성능 향상이 있지만, 시그널 구현체 자체는 상당히 작기 때문에 이 효과가 크지는 않을 것으로 예상합니다.\n\n우리는 네이티브 C++로 구현된 시그널 관련 자료구조 및 알고리즘이 JS로 구현된 것보다 상수 배수만큼 약간 더 효율적일 수 있다고 생각합니다. 그러나 폴리필에 들어갈 수 있는 것과 비교해 알고리즘 자체의 변화는 예상하지 않습니다. 엔진이 마법처럼 더 빠를 것으로 기대하지 않으며, 반응형 알고리즘은 명확하고 일관되게 정의될 것입니다.\n\n챔피언 그룹은 다양한 시그널 구현체를 개발하고, 이를 통해 성능 가능성을 조사할 예정입니다.\n\n#### 개발자 도구(DevTools)\n\n기존 JS 시그널 라이브러리에서는 다음과 같은 것을 추적하기 어렵습니다:\n* 계산된 시그널 체인에 걸친 호출 스택, 즉 오류의 인과적 연쇄\n* 한 시그널이 다른 시그널에 의존할 때의 참조 그래프 — 메모리 사용을 디버깅할 때 중요\n\n빌트인 시그널은 JS 런타임과 개발자 도구가 시그널을 검사하는 데 있어, 특히 디버깅이나 성능 분석 시 더 나은 지원을 가능하게 합니다(이것이 브라우저에 내장되든, 공유 확장 프로그램을 통해 제공되든 관계없음). 기존의 요소 검사기, 성능 스냅샷, 메모리 프로파일러 등도 시그널을 강조하여 정보 표시를 개선할 수 있습니다.\n\n#### 2차적 이점\n\n##### 표준 라이브러리의 이점\n\n일반적으로 JavaScript는 꽤 미니멀한 표준 라이브러리를 가져왔지만, TC39에서는 JS를 \"배터리 포함\" 언어로 만들어 고품질의 내장 기능을 제공하려는 추세가 있습니다. 예를 들어, Temporal이 moment.js를 대체하고, `Array.prototype.flat`, `Object.groupBy` 등 많은 lodash 사용 사례를 대체하고 있습니다. 그 이점으로는 더 작은 번들 크기, 개선된 안정성과 품질, 새로운 프로젝트에 합류할 때 배워야 할 것이 줄어들고, JS 개발자 간에 공통 어휘를 쓸 수 있다는 점이 있습니다.\n\n##### HTML/DOM 통합(향후 가능성)\n\n현재 W3C와 브라우저 구현체들은 HTML에 네이티브 템플릿 기능([DOM Parts][wicg-pr-1023], [Template Instantiation][wicg-propsal-template-instantiation])을 도입하려는 작업을 하고 있습니다. 또한 W3C Web Components CG에서는 Web Components를 확장하여 완전히 선언적인 HTML API를 제공할 가능성을 탐구하고 있습니다. 이 두 목표를 달성하려면 궁극적으로 HTML에서 사용할 반응형 원시값이 필요합니다. 또한 시그널을 DOM에 통합함으로써 사용자 경험을 개선할 수 있는 다양한 기능이 상상되고 있으며, 이미 커뮤니티에서 요청된 바 있습니다.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> 참고: 이 통합은 본 제안과는 별도의 후속 작업으로, 이 제안서의 일부가 아닙니다.\n\n##### 생태계 정보 교환(*출시의 이유는 아님*)\n\n표준화 노력은 브라우저의 변화 없이도 \"커뮤니티\" 수준에서 도움이 될 때가 있습니다. Signals 표준화는 다양한 프레임워크 저자들이 반응성의 본질, 알고리즘, 상호 운용성에 대해 심도 깊게 논의하게 만들었습니다. 이는 이미 유용했지만, JS 엔진과 브라우저에 포함될 정당성은 되지 않습니다. Signals는 생태계 정보 교환 이상의 중요한 이점이 있을 때에만 JavaScript 표준에 추가되어야 합니다.\n\n## Signals의 설계 목표\n\n기존의 시그널 라이브러리들은 핵심적으로 크게 다르지 않다는 것이 밝혀졌습니다. 본 제안은 이들 라이브러리의 성공을 바탕으로, 중요한 특성들을 구현하는 것을 목표로 합니다.\n\n### 핵심 기능\n\n* 상태를 나타내는 Signal 타입(쓰기 가능한 Signal). 이는 다른 곳에서 읽을 수 있는 값입니다.\n* 다른 시그널에 의존하고, 지연 계산 및 캐싱되는 계산/메모/파생 Signal 타입.\n    * 계산은 지연(Lazy) 방식으로, 의존성이 변경될 때마다 자동으로 다시 계산되지 않고, 실제로 누군가 읽을 때만 계산이 수행됩니다.\n    * 계산은 \"[글리치(glitch)](https://en.wikipedia.org/wiki/Reactive_programming#Glitches) 프리\"해야 하며, 불필요한 계산이 절대 수행되지 않아야 합니다. 즉, 애플리케이션이 계산된 시그널을 읽을 때, 변경 가능성이 있는 그래프의 부분을 위상 정렬하여 중복을 제거합니다.\n    * 계산 결과는 캐싱되며, 마지막으로 의존성이 변경된 이후 의존성에 변화가 없으면, 접근 시 다시 계산되지 않습니다.\n    * 계산된 시그널뿐만 아니라 상태 시그널에도 커스텀 비교 함수가 가능하여, 해당 값을 참조하는 추가 계산 시그널의 갱신 여부를 결정할 수 있습니다.\n* 계산된 시그널의 의존성(또는 중첩 의존성)이 \"더러워지고(dirty)\" 변경될 때 반응하는 기능.\n    * 이 반응은 더 중요한 작업을 나중에 예약하기 위한 것입니다.\n    * 이펙트(Effect)는 이러한 반응과 프레임워크 수준의 스케줄링으로 구현됩니다.\n    * 계산 시그널은 자신이 이러한 반응의 (중첩) 의존성으로 등록되었는지 여부에 따라 반응할 수 있어야 합니다.\n* JS 프레임워크가 자체적으로 스케줄링을 할 수 있도록 지원. Promise 스타일의 내장 강제 스케줄링은 제공하지 않습니다.\n    * 동기식 반응이 필요하며, 이를 통해 프레임워크 논리에 따라 후속 작업 스케줄링이 가능합니다.\n    * 쓰기는 동기적으로 즉시 적용됩니다(프레임워크에서 배치 처리를 원하면 별도 구현).\n    * 이펙트가 \"더러워졌는지\" 확인하는 것과 실제로 이펙트를 실행하는 것을 분리할 수 있습니다(2단계 이펙트 스케줄러 지원).\n* 의존성 기록을 남기지 않고 시그널을 읽을 수 있는 기능(`untrack`)\n* Signals/반응성을 사용하는 서로 다른 코드베이스 간의 조합 지원, 예:\n    * (아래의 예외 사항을 제외하면) 여러 프레임워크를 함께 사용할 때도 추적/반응성 자체는 공유 가능\n    * 프레임워크에 독립적인 반응형 자료구조(예: 재귀적으로 반응하는 스토어 프록시, 반응형 Map, Set, Array 등)\n\n### 건전성(Soundness)\n\n* 동기 반응의 순진한 오용을 권장하지 않거나 금지함\n    * 건전성 위험: 잘못 사용하면 \"[글리치(glitch)](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\"가 발생할 수 있음. 즉, 시그널이 설정될 때 바로 렌더링하면, 최종 사용자에게 불완전한 애플리케이션 상태가 노출될 수 있습니다. 따라서 이 기능은 반드시 애플리케이션 로직이 완료된 후, 더 큰 작업을 지능적으로 예약하는 용도로만 사용해야 합니다.\n    * 해결책: 동기식 반응 콜백 내에서 시그널을 읽거나 쓸 수 없도록 금지\n* `untrack` 사용을 권장하지 않고, 그 불안정함을 명확히 표시\n    * 건전성 위험: `untrack`을 사용하면, 어떤 시그널의 값이 다른 시그널에 의존하지만, 그 시그널이 변경될 때 업데이트되지 않는 계산된 시그널을 만들 수 있습니다. untrack된 접근이 계산 결과에 영향을 주지 않을 때만 사용해야 합니다.\n    * 해결책: API 이름에 \"unsafe\"라는 표시를 명시\n* 참고: 본 제안은 계산 및 이펙트 시그널에서 시그널을 읽고 쓸 수 있도록 허용하며, 읽기 이후의 쓰기를 제한하지 않습니다(건전성 위험에도 불구하고). 이는 프레임워크와의 통합 시 유연성과 호환성을 유지하기 위함입니다.\n\n### 표면 API(Surface API)\n\n* 여러 프레임워크가 자체 시그널/반응성 메커니즘을 구현할 수 있는 튼튼한 기반이 되어야 합니다.\n    * 재귀적 스토어 프록시, 데코레이터 기반 클래스 필드 반응성, `.value`, `[state, setState]` 스타일 API 모두에 적합한 기반이어야 합니다.\n    * 다양한 프레임워크가 허용하는 유효한 패턴을 표현할 수 있는 의미론을 제공해야 합니다. 예를 들어, 즉시 반영되는 쓰기든, 나중에 배치 적용되는 쓰기든, 이러한 시그널이 기반이 될 수 있어야 합니다.\n* 이 API가 JavaScript 개발자가 직접 사용하기에도 편리하면 좋습니다.\n    * 어떤 기능이 생태계 개념과 일치한다면, 공통 어휘를 사용하는 것이 좋습니다.\n        * 단, 동일한 이름을 그대로 사용하는 것은 피해야 합니다!\n    * \"JS 개발자 사용성\"과 \"프레임워크를 위한 모든 훅 제공\" 사이에 긴장이 존재\n        * 아이디어: 모든 훅을 제공하되, 오용 시에는 에러를 포함\n        * 아이디어: 미묘한 API는 [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle)처럼 `subtle` 네임스페이스 아래에 두어, 프레임워크 구현이나 개발자 도구 빌드 등 고급 사용에 필요한 API와, 일반적인 애플리케이션 개발에서 사용하는 API를 구분\n* 좋은 성능으로 구현 및 사용 가능해야 하며, 표면 API 자체가 과도한 오버헤드를 유발하지 않아야 함\n    * 서브클래싱을 허용하여, 프레임워크가 자체 메서드와 필드(비공개 필드 포함)를 추가할 수 있어야 합니다. 이는 프레임워크 레벨에서 추가 할당이 필요 없도록 하는 데 중요합니다. \"메모리 관리\" 항목 참고.\n\n### 메모리 관리\n\n* 가능하다면: 어떤 계산 시그널도 미래에 읽힐 수 있는 라이브 객체가 참조하지 않으면, 더 넓은 그래프에 연결되어 있더라도(예: 라이브 상태를 읽는 경우) 가비지 컬렉션이 가능해야 합니다.",
  "status": "ok"
}