{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "با استفاده از [AsyncContext](https://github.com/tc39/proposal-async-context)، کال‌بکی که به `new Signal.subtle.Watcher` پاس داده می‌شود، *بر* اسنپ‌شات زمان فراخوانی سازنده بسته نمی‌شود، بنابراین اطلاعات متنی پیرامون عمل نوشتن قابل مشاهده خواهد بود.\n\n#### متد: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. اگر `frozen` برابر true باشد، یک استثنا پرتاب کن.\n1. اگر هر یک از آرگومان‌ها سیگنال نباشد، یک استثنا پرتاب کن.\n1. همه آرگومان‌ها را به انتهای مجموعه `signals` این شیء اضافه کن.\n1. برای هر سیگنال جدیدی که اکنون مشاهده می‌شود، به ترتیب از چپ به راست،\n    1. این واچر را به عنوان یک `sink` به آن سیگنال اضافه کن.\n    1. اگر این اولین sink بود، سپس به منابع بالا برو و آن سیگنال را به عنوان یک sink اضافه کن.\n    1. مقدار `frozen` را روی true قرار بده.\n    1. اگر کال‌بک `watched` وجود داشت، آن را فراخوانی کن.\n    1. مقدار `frozen` را به false بازگردان.\n1. اگر وضعیت Signal روی `~waiting~` بود، آن را به `~watching~` تغییر بده.\n\n#### متد: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. اگر `frozen` برابر true باشد، یک استثنا پرتاب کن.\n1. اگر هر یک از آرگومان‌ها سیگنال نباشد، یا توسط این واچر مشاهده نشود، یک استثنا پرتاب کن.\n1. برای هر سیگنال در آرگومان‌ها، به ترتیب از چپ به راست،\n    1. آن سیگنال را از مجموعه `signals` این Watcher حذف کن.\n    1. این Watcher را از مجموعه `sink` آن Signal حذف کن.\n    1. اگر مجموعه `sink` آن Signal خالی شد، آن Signal را از مجموعه sink هر یک از منابعش حذف کن.\n    1. مقدار `frozen` را روی true قرار بده.\n    1. اگر کال‌بک `unwatched` وجود داشت، آن را فراخوانی کن.\n    1. مقدار `frozen` را به false بازگردان.\n1. اگر اکنون این واچر هیچ `signals`ای ندارد و وضعیتش `~watching~` است، پس وضعیت را به `~waiting~` تغییر بده.\n\n#### متد: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. یک آرایه حاوی زیرمجموعه‌ای از `signals` که سیگنال‌های محاسبه‌ای (Computed Signals) در وضعیت‌های `~dirty~` یا `~pending~` هستند، بازگردان.\n\n### متد: `Signal.subtle.untrack(cb)`\n\n1. مقدار فعلی `computing` در context اجرا را به `c` اختصاص بده.\n1. مقدار `computing` را null کن.\n1. `cb` را فراخوانی کن.\n1. مقدار `computing` را به `c` بازگردان (حتی اگر `cb` یک استثنا پرتاب کند).\n1. مقدار بازگشتی `cb` را بازگردان (هر استثنایی را دوباره پرتاب کن).\n\nنکته: untrack وضعیت `frozen` را تغییر نمی‌دهد، که این وضعیت به طور دقیق حفظ می‌شود.\n\n### متد: `Signal.subtle.currentComputed()`\n\n1. مقدار فعلی `computing` را بازگردان.\n\n### الگوریتم‌های مشترک\n\n##### الگوریتم: محاسبه مجدد سیگنال محاسبه‌ای کثیف (dirty)\n\n1. مجموعه `sources` این Signal را پاک کن و آن را از مجموعه `sinks` این منابع حذف کن.\n1. مقدار قبلی `computing` را ذخیره کن و `computing` را به این Signal اختصاص بده.\n1. وضعیت این Signal را روی `~computing~` قرار بده.\n1. کال‌بک این سیگنال محاسبه‌ای را با استفاده از این Signal به عنوان this اجرا کن. مقدار بازگشتی را ذخیره کن و اگر کال‌بک استثنا پرتاب کرد، آن را برای پرتاب مجدد ذخیره کن.\n1. مقدار قبلی `computing` را بازگردان.\n1. الگوریتم \"تنظیم مقدار سیگنال\" را بر روی مقدار بازگشتی کال‌بک اجرا کن.\n2. وضعیت این Signal را روی `~clean~` قرار بده.\n1. اگر آن الگوریتم مقدار `~dirty~` را بازگرداند: تمام sinks این Signal را به عنوان `~dirty~` علامت‌گذاری کن (قبلاً ممکن بود sinks ترکیبی از checked و dirty باشند). (یا اگر این سیگنال مشاهده نمی‌شود، یک شماره نسل جدید برای نشان دادن کثیفی اتخاذ کن یا چیزی شبیه به آن.)\n1. در غیر این صورت، اگر الگوریتم مقدار `~clean~` را بازگرداند: در این حالت، برای هر sink با وضعیت `~checked~` از این Signal، اگر همه منابع آن Signal اکنون پاک (clean) هستند، آن Signal را نیز به عنوان `~clean~` علامت‌گذاری کن. این مرحله پاک‌سازی را به صورت بازگشتی برای sinks بعدی، برای هر سیگنال تازه پاک که sinks checked دارد، اعمال کن. (یا اگر این سیگنال مشاهده نمی‌شود، به نوعی همین را نشان بده تا پاک‌سازی به صورت Lazy ادامه یابد.)\n\n##### الگوریتم تنظیم مقدار سیگنال\n\n1. اگر به این الگوریتم یک مقدار داده شده بود (در مقابل یک استثنا جهت پرتاب مجدد، از الگوریتم محاسبه مجدد سیگنال محاسبه‌ای کثیف):\n    1. تابع `equals` این Signal را با پارامترهای مقدار فعلی `value`، مقدار جدید و خود Signal فراخوانی کن. اگر استثنایی پرتاب شد، آن استثنا را (برای پرتاب مجدد هنگام خواندن) به عنوان مقدار Signal ذخیره کن و ادامه بده به گونه‌ای که انگار کال‌بک false بازگردانده است.\n    1. اگر آن تابع true بازگرداند، مقدار `~clean~` را بازگردان.\n1. مقدار `value` این Signal را روی پارامتر قرار بده.\n1. مقدار `~dirty~` را بازگردان.\n\n## سوالات متداول (FAQ)\n\n**سوال**: آیا کمی زود نیست که چیزی مرتبط با سیگنال‌ها را استاندارد کنیم، وقتی که آن‌ها تازه در ۲۰۲۲ داغ شده‌اند؟ آیا نباید به آن‌ها زمان بیشتری بدهیم تا تکامل یابند و پایدار شوند؟\n\n**پاسخ**: وضعیت فعلی سیگنال‌ها در فریم‌ورک‌های وب حاصل بیش از ۱۰ سال توسعه پیوسته است. با افزایش سرمایه‌گذاری، همان طور که در سال‌های اخیر رخ داده است، تقریباً همه فریم‌ورک‌های وب به یک مدل هسته‌ای بسیار مشابه از سیگنال‌ها نزدیک می‌شوند. این پیشنهاد حاصل تمرین طراحی مشترک بین تعداد زیادی از رهبران فعلی فریم‌ورک‌های وب است و بدون اعتبارسنجی آن گروه از متخصصان حوزه در زمینه‌های مختلف، به سمت استانداردسازی پیش نخواهد رفت.\n\n#### سیگنال‌ها چگونه استفاده می‌شوند؟\n\n**سوال**: آیا اصلاً سیگنال‌های داخلی توسط فریم‌ورک‌ها قابل استفاده هستند، با توجه به یکپارچگی تنگاتنگ آن‌ها با رندرینگ و مالکیت؟\n\n**پاسخ**: بخش‌هایی که بیشتر خاص فریم‌ورک‌ها هستند معمولاً در حوزه افکت‌ها، زمان‌بندی و مالکیت/تخریب قرار دارند، که این پیشنهاد قصد حل آن‌ها را ندارد. اولویت اول ما با نمونه‌سازی سیگنال‌های استاندارد این است که اعتبارسنجی کنیم آن‌ها می‌توانند \"زیر\" فریم‌ورک‌های موجود به طور سازگار و با عملکرد خوب قرار بگیرند.\n\n**سوال**: آیا API سیگنال قرار است مستقیماً توسط توسعه‌دهندگان برنامه استفاده شود یا توسط فریم‌ورک‌ها بسته‌بندی گردد؟\n\n**پاسخ**: اگرچه این API می‌تواند مستقیماً توسط توسعه‌دهندگان برنامه استفاده شود (حداقل بخشی که در فضای نام `Signal.subtle` قرار ندارد)، اما به طور خاص برای ارگونومی طراحی نشده است. در عوض، نیازهای نویسندگان کتابخانه/فریم‌ورک اولویت دارند. انتظار می‌رود بیشتر فریم‌ورک‌ها حتی APIهای پایه‌ای مانند `Signal.State` و `Signal.Computed` را با چیزی که تمایل ارگونومیک آن‌ها را بیان می‌کند، بسته‌بندی کنند. در عمل، معمولاً بهتر است سیگنال‌ها را از طریق یک فریم‌ورک استفاده کنید که ویژگی‌های پیچیده‌تر (مانند Watcher، `untrack`) و همچنین مدیریت مالکیت و تخریب (مانند تعیین زمان اضافه و حذف سیگنال‌ها از واچرها) و زمان‌بندی رندرینگ به DOM را مدیریت می‌کند--این پیشنهاد تلاش نمی‌کند آن مسائل را حل کند.\n\n**سوال**: آیا باید سیگنال‌های مربوط به یک ویجت را هنگام تخریب آن ویجت، حذف کنم؟ API مربوط به این کار چیست؟\n\n**پاسخ**: عملیات تخریب مربوطه اینجا `Signal.subtle.Watcher.prototype.unwatch` است. فقط سیگنال‌های مشاهده‌شده باید پاک‌سازی شوند (با unwatch کردن آن‌ها)، در حالی که سیگنال‌های مشاهده‌نشده می‌توانند به طور خودکار جمع‌آوری حافظه شوند.\n\n**سوال**: آیا سیگنال‌ها با VDOM یا مستقیماً با HTML DOM زیرین کار می‌کنند؟\n\n**پاسخ**: بله! سیگنال‌ها مستقل از فناوری رندرینگ هستند. فریم‌ورک‌های جاوااسکریپتی موجود که از ساختارهای شبیه سیگنال استفاده می‌کنند با VDOM (مثلاً Preact)، DOM بومی (مثلاً Solid) و ترکیبی (مثلاً Vue) یکپارچه می‌شوند. همین امر برای سیگنال‌های داخلی نیز ممکن خواهد بود.\n\n**سوال**: آیا استفاده از سیگنال‌ها در زمینه فریم‌ورک‌های مبتنی بر کلاس مانند Angular و Lit ارگونومیک خواهد بود؟ فریم‌ورک‌های مبتنی بر کامپایلر مانند Svelte چطور؟\n\n**پاسخ**: فیلدهای کلاس می‌توانند با یک دکوراتور accessors به راحتی مبتنی بر سیگنال شوند، همان طور که در [مستند Signal polyfill](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators) نشان داده شده است. سیگنال‌ها بسیار با Runes در Svelte 5 هماهنگ هستند--تبدیل runes به API سیگنال تعریف‌شده در اینجا برای یک کامپایلر ساده است، و در واقع این همان کاری است که Svelte 5 به طور داخلی انجام می‌دهد (اما با کتابخانه سیگنال اختصاصی خودش).\n\n**سوال**: آیا سیگنال‌ها با SSR کار می‌کنند؟ Hydration؟ Resumability؟\n\n**پاسخ**: بله. Qwik از سیگنال‌ها با این دو ویژگی به خوبی استفاده می‌کند و سایر فریم‌ورک‌ها نیز رویکردهای توسعه‌یافته دیگری برای hydration با سیگنال‌ها و با نقاط قوت متفاوت دارند. ما فکر می‌کنیم که می‌توان سیگنال‌های قابل resume در Qwik را با یک سیگنال State و Computed که به هم وصل شده‌اند مدل کرد، و برنامه داریم این را در کد ثابت کنیم.",
  "status": "ok"
}