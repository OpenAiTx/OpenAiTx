{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "`state` của một Computed Signal có thể là một trong các trạng thái sau:\n\n- `~clean~`: Giá trị của Signal hiện tại và được biết là không lỗi thời.\n- `~checked~`: Một nguồn (gián tiếp) của Signal này đã thay đổi; Signal này có giá trị nhưng _có thể_ đã lỗi thời. Chỉ khi tất cả các nguồn trực tiếp được đánh giá thì mới biết chính xác giá trị có lỗi thời hay không.\n- `~computing~`: Callback của Signal này hiện đang được thực thi như là hệ quả phụ của một lệnh gọi `.get()`.\n- `~dirty~`: Hoặc Signal này có giá trị được xác định là đã lỗi thời, hoặc nó chưa bao giờ được đánh giá.\n\nBiểu đồ chuyển trạng thái như sau:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nCác chuyển trạng thái là:\n| Số | Từ | Đến | Điều kiện | Thuật toán |\n|----|----|-----|-----------|------------|\n| 1 | `~checked~` | `~dirty~` | Một nguồn trực tiếp của signal này, là một computed signal, đã được đánh giá và giá trị của nó đã thay đổi. | Thuật toán: tính lại Computed Signal bị dirty |\n| 2 | `~clean~` | `~dirty~` | Một nguồn trực tiếp của signal này, là một State, đã được set với giá trị khác giá trị trước đó. | Phương thức: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Một nguồn đệ quy, không phải trực tiếp, của signal này, là một State, đã được set với giá trị khác giá trị trước đó. | Phương thức: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | Chúng ta chuẩn bị thực thi `callback`. | Thuật toán: tính lại Computed Signal bị dirty |\n| 5 | `~computing~` | `~clean~` | `callback` đã kết thúc đánh giá và hoặc trả về một giá trị hoặc ném ra ngoại lệ. | Thuật toán: tính lại Computed Signal bị dirty |\n| 6 | `~checked~` | `~clean~` | Tất cả nguồn trực tiếp của signal này đã được đánh giá, và tất cả đều không thay đổi, vì vậy giờ đây được xác nhận là không lỗi thời. | Thuật toán: tính lại Computed Signal bị dirty |\n\n#### Các slot nội bộ của `Signal.Computed`\n\n- `value`: Giá trị cache trước đó của Signal, hoặc `~uninitialized~` đối với Computed Signal chưa từng được đọc. Giá trị này có thể là một ngoại lệ sẽ được ném lại khi giá trị được đọc. Luôn là `undefined` đối với effect signals.\n- `state`: Có thể là `~clean~`, `~checked~`, `~computing~`, hoặc `~dirty~`.\n- `sources`: Một tập hợp có thứ tự các Signal mà Signal này phụ thuộc vào.\n- `sinks`: Một tập hợp có thứ tự các Signal phụ thuộc vào Signal này.\n- `equals`: Phương thức so sánh được cung cấp trong options.\n- `callback`: Callback được gọi để lấy giá trị của Computed Signal. Được gán là tham số đầu tiên truyền vào constructor.\n\n#### Constructor của `Signal.Computed`\n\nConstructor sẽ thiết lập\n- `callback` thành tham số đầu tiên của nó\n- `equals` dựa trên options, mặc định là `Object.is` nếu không có\n- `state` là `~dirty~`\n- `value` là `~uninitialized~`\n\nVới [AsyncContext](https://github.com/tc39/proposal-async-context), callback truyền vào `new Signal.Computed` sẽ đóng gói (close over) snapshot tại thời điểm constructor được gọi, và khôi phục snapshot này trong quá trình thực thi callback.\n\n#### Phương thức: `Signal.Computed.prototype.get`\n\n1. Nếu ngữ cảnh thực thi hiện tại là `frozen` hoặc Signal này có trạng thái `~computing~`, hoặc nếu signal này là một Watcher và đang `computing` một computed Signal, ném ra ngoại lệ.\n1. Nếu `computing` không phải là `null`, thêm Signal này vào tập `sources` của `computing`.\n1. LƯU Ý: Chúng ta không thêm `computing` vào tập `sinks` của Signal này cho đến khi/chỉ khi nó được Watcher theo dõi.\n1. Nếu trạng thái của Signal này là `~dirty~` hoặc `~checked~`: Lặp lại các bước sau cho đến khi Signal này ở trạng thái `~clean~`:\n    1. Đệ quy thông qua `sources` để tìm nguồn đệ quy sâu nhất, bên trái nhất (tức là nguồn được quan sát sớm nhất) là một Computed Signal được đánh dấu `~dirty~` (dừng tìm khi gặp Computed Signal `~clean~`, và bao gồm Computed Signal này như phần cuối cùng cần tìm).\n    1. Thực hiện thuật toán \"tính lại Computed Signal bị dirty\" trên Signal đó.\n1. Ở thời điểm này, trạng thái của Signal này sẽ là `~clean~`, và không có nguồn đệ quy nào là `~dirty~` hoặc `~checked~`. Trả về giá trị `value` của Signal. Nếu giá trị là một ngoại lệ, ném lại ngoại lệ đó.\n\n### Lớp `Signal.subtle.Watcher`\n\n#### Máy trạng thái của `Signal.subtle.Watcher`\n\n`state` của một Watcher có thể là một trong các trạng thái sau:\n\n- `~waiting~`: Callback `notify` đã được chạy, hoặc Watcher mới được tạo, nhưng chưa theo dõi signal nào.\n- `~watching~`: Watcher đang chủ động theo dõi các signal, nhưng chưa có thay đổi nào xảy ra cần phải gọi callback `notify`.\n- `~pending~`: Một phụ thuộc của Watcher đã thay đổi, nhưng callback `notify` chưa được chạy.\n\nBiểu đồ chuyển trạng thái như sau:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nCác chuyển trạng thái là:\n| Số | Từ | Đến | Điều kiện | Thuật toán |\n|----|----|-----|-----------|------------|\n| 1 | `~waiting~` | `~watching~` | Phương thức `watch` của Watcher đã được gọi. | Phương thức: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Phương thức `unwatch` của Watcher đã được gọi, và signal cuối cùng đã bị loại bỏ. | Phương thức: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Một signal đang theo dõi có thể đã thay đổi giá trị. | Phương thức: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | Callback `notify` đã được chạy. | Phương thức: `Signal.State.prototype.set(newValue)` |\n\n#### Các slot nội bộ của `Signal.subtle.Watcher`\n\n- `state`: Có thể là `~watching~`, `~pending~` hoặc `~waiting~`\n- `signals`: Một tập hợp có thứ tự các Signal mà Watcher này đang theo dõi\n- `notifyCallback`: Callback được gọi khi có sự thay đổi. Được gán là tham số đầu tiên truyền vào constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` được thiết lập là `~waiting~`.\n1. Khởi tạo `signals` là một tập rỗng.\n1. `notifyCallback` được gán là tham số callback.",
  "status": "ok"
}