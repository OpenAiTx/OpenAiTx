{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback aangeroepen wanneer isWatched true wordt, als het eerder false was\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback aangeroepen wanneer isWatched false wordt, als het eerder true was\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Hoe Signals werken\n\nEen Signal vertegenwoordigt een cel met data die in de loop van de tijd kan veranderen. Signals kunnen \"state\" zijn (gewoon een waarde die handmatig wordt ingesteld) of \"computed\" (een formule gebaseerd op andere Signals).\n\nComputed Signals werken door automatisch bij te houden welke andere Signals worden gelezen tijdens hun evaluatie. Wanneer een computed wordt gelezen, controleert deze of een van zijn eerder vastgelegde afhankelijkheden is gewijzigd, en evalueert zichzelf opnieuw indien nodig. Wanneer meerdere computed Signals genest zijn, gaat alle toeschrijving van de tracking naar de binnenste.\n\nComputed Signals zijn lui, oftewel pull-based: ze worden alleen opnieuw geÃ«valueerd wanneer ze worden opgevraagd, zelfs als een van hun afhankelijkheden eerder is gewijzigd.\n\nDe callback die aan computed Signals wordt doorgegeven, moet over het algemeen \"puur\" zijn in de zin dat het een deterministische, bijwerkingen-vrije functie is van de andere Signals die hij benadert. Tegelijkertijd is het tijdstip waarop de callback wordt aangeroepen deterministisch, waardoor bijwerkingen met zorg kunnen worden gebruikt.\n\nSignals bevatten prominente caching/memoization: zowel state als computed Signals onthouden hun huidige waarde, en starten alleen een herberekening van computed Signals die naar hen verwijzen als ze daadwerkelijk veranderen. Herhaalde vergelijkingen van oude versus nieuwe waarden zijn niet nodigâde vergelijking vindt Ã©Ã©n keer plaats wanneer de bron-Signal wordt gereset/opnieuw geÃ«valueerd, en het Signal-mechanisme houdt bij welke zaken die naar dat Signal verwijzen nog niet zijn bijgewerkt op basis van de nieuwe waarde. Intern wordt dit meestal weergegeven via \"graph coloring\" zoals beschreven in (Milo's blogpost).\n\nComputed Signals volgen hun afhankelijkheden dynamischâelke keer dat ze worden uitgevoerd, kunnen ze van andere zaken afhankelijk zijn, en die precieze afhankelijkheidsset wordt actueel gehouden in de Signal-grafiek. Dit betekent dat als je een afhankelijkheid alleen in Ã©Ã©n tak nodig hebt, en de vorige berekening nam de andere tak, een wijziging aan die tijdelijk ongebruikte waarde niet zal zorgen dat de computed Signal wordt herberekend, zelfs niet wanneer deze wordt opgevraagd.\n\nIn tegenstelling tot JavaScript Promises verloopt alles in Signals synchroon:\n- Het instellen van een Signal op een nieuwe waarde is synchroon en dit wordt direct weerspiegeld bij het lezen van een computed Signal dat er vervolgens van afhankelijk is. Er is geen ingebouwde batching van deze mutatie.\n- Het lezen van computed Signals is synchroonâhun waarde is altijd beschikbaar.\n- De `notify` callback in Watchers, zoals hieronder uitgelegd, wordt synchroon uitgevoerd, tijdens de `.set()`-aanroep die het heeft getriggerd (maar nadat graph coloring is voltooid).\n\nNet als bij Promises kunnen Signals een foutstatus weergeven: als een callback van een computed Signal een fout gooit, wordt die fout gecachet als een andere waarde, en opnieuw gegooid telkens wanneer het Signal wordt gelezen.\n\n### De Signal-klasse begrijpen\n\nEen `Signal`-instantie vertegenwoordigt de mogelijkheid om een dynamisch veranderende waarde te lezen waarvan de updates in de loop van de tijd worden gevolgd. Het omvat ook impliciet de mogelijkheid om je op het Signal te abonneren, impliciet via een getraceerde toegang vanuit een ander computed Signal.\n\nDe API hier is ontworpen om te passen bij de ruwe ecosysteemconsensus onder een groot deel van de Signal-libraries in het gebruik van namen als \"signal\", \"computed\" en \"state\". Toegang tot Computed en State Signals gaat echter via een `.get()`-methode, wat afwijkt van alle populaire Signal-API's, die ofwel een `.value`-achtige accessor gebruiken, of `signal()`-aanroepsyntaxis.\n\nDe API is ontworpen om het aantal allocaties te verminderen, zodat Signals geschikt zijn voor integratie in JavaScript-frameworks terwijl dezelfde of betere prestaties worden bereikt dan bestaande framework-aangepaste Signals. Dit betekent:\n- State Signals zijn een enkel beschrijfbaar object, dat zowel kan worden opgevraagd als ingesteld vanuit dezelfde referentie. (Zie de implicaties hieronder in de sectie \"Capability separation\".)\n- Zowel State als Computed Signals zijn ontworpen om subclassable te zijn, om frameworks de mogelijkheid te geven extra eigenschappen toe te voegen via publieke en private class fields (evenals methoden voor het gebruik van die state).\n- Diverse callbacks (bijv. `equals`, de computed callback) worden aangeroepen met het relevante Signal als de `this`-waarde voor context, zodat er niet per Signal een nieuwe closure nodig is. In plaats daarvan kan context worden opgeslagen in extra eigenschappen van het signal zelf.\n\nSommige foutcondities die door deze API worden afgedwongen:\n- Het is een fout om een computed recursief te lezen.\n- De `notify`-callback van een Watcher mag geen enkele signal lezen of schrijven.\n- Als een callback van een computed Signal een fout gooit, gooien volgende toegangspogingen tot het Signal die gecachete fout opnieuw, totdat een van de afhankelijkheden verandert en het opnieuw wordt berekend.\n\nSommige condities die *niet* worden afgedwongen:\n- Computed Signals mogen naar andere Signals schrijven, synchroon binnen hun callback.\n- Werk dat in de wachtrij wordt gezet door de `notify`-callback van een Watcher mag signals lezen of schrijven, waardoor het mogelijk is om [klassieke React-antipatterns](https://react.dev/learn/you-might-not-need-an-effect) na te bootsen in termen van Signals!\n\n### Effecten implementeren\n\nDe hierboven gedefinieerde `Watcher` interface vormt de basis voor het implementeren van typische JS API's voor effecten: callbacks die opnieuw worden uitgevoerd wanneer andere Signals veranderen, puur voor hun bijwerking. De `effect`-functie die hierboven in het eerste voorbeeld werd gebruikt, kan als volgt worden gedefinieerd:\n\n```ts\n// Deze functie zou meestal in een library/framework staan, niet in applicatiecode\n// LET OP: Deze scheduling-logica is te basic om nuttig te zijn. Niet kopiÃ«ren/plakken.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Een effect-Signal dat evalueert tot cb, dat een read van\n// zichzelf in de microtask queue plant telkens als een van zijn afhankelijkheden kan veranderen\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nDe Signal-API bevat geen ingebouwde functie zoals `effect`. Dit komt omdat effect-scheduling subtiel is en vaak samenhangt met framework-rendercycli en andere hoog-niveau framework-specifieke status of strategieÃ«n waar JS geen toegang tot heeft.\n\nEen uitleg van de verschillende gebruikte bewerkingen: de `notify`-callback die wordt doorgegeven aan de Watcher-constructor is de functie die wordt aangeroepen wanneer het Signal van een \"clean\" state (waarvan we weten dat de cache geÃ¯nitialiseerd en geldig is) naar een \"checked\" of \"dirty\" state gaat (waarbij de cache mogelijk niet geldig is omdat ten minste Ã©Ã©n van de states waarvan deze recursief afhankelijk is, is gewijzigd).\n\nAanroepen van `notify` worden uiteindelijk getriggerd door een `.set()`-aanroep op een state Signal. Deze aanroep is synchroon: hij vindt plaats vÃ³Ã³rdat `.set` retourneert. Maar het is niet nodig om je zorgen te maken dat deze callback de Signal-grafiek in een half-verwerkte staat waarneemt, omdat tijdens een `notify`-callback geen enkele Signal kan worden gelezen of geschreven, zelfs niet in een `untrack`-aanroep. Omdat `notify` wordt aangeroepen tijdens `.set()`, onderbreekt het een andere logicadraad die mogelijk niet is voltooid. Om Signals te lezen of te schrijven vanuit `notify`, plan werk in om later uit te voeren, bijvoorbeeld door het Signal in een lijst te schrijven die later wordt geraadpleegd, of met `queueMicrotask` zoals hierboven.\n\nLet op: het is prima mogelijk om Signals effectief te gebruiken zonder `Signal.subtle.Watcher` door polling van computed Signals te plannen, zoals Glimmer doet. Toch hebben veel frameworks gemerkt dat het vaak handig is om deze scheduling-logica synchroon te laten uitvoeren, dus de Signals API bevat het.\n\nZowel computed als state Signals worden door de garbage collector opgeruimd zoals alle JS-waarden. Maar Watchers hebben een speciale manier om dingen in leven te houden: alle Signals die door een Watcher worden bekeken, blijven in leven zolang een van de onderliggende states bereikbaar is, omdat deze een toekomstige `notify`-aanroep (en dan een toekomstige `.get()`) kunnen triggeren. Vergeet daarom niet om `Watcher.prototype.unwatch` aan te roepen om effecten op te ruimen.\n\n### Een onveilig escape hatch\n\n`Signal.subtle.untrack` is een escape hatch waarmee Signals *zonder* tracking kunnen worden gelezen. Deze mogelijkheid is onveilig omdat het mogelijk maakt om computed Signals te maken waarvan de waarde afhangt van andere Signals, maar die niet worden bijgewerkt wanneer die Signals veranderen. Het moet alleen worden gebruikt wanneer de niet-getrackte toegang het resultaat van de berekening niet zal veranderen.\n\n<!--\nTODO: Toon voorbeeld waarbij het een goed idee is om untrack te gebruiken\n\n### Gebruik van watched/unwatched",
  "status": "ok"
}