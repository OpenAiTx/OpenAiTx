{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**س**: آیا سیگنال‌ها با جریان داده یک‌طرفه مانند React کار می‌کنند؟\n\n**ج**: بله، سیگنال‌ها مکانیزمی برای جریان داده یک‌طرفه هستند. فریم‌ورک‌های UI مبتنی بر سیگنال به شما اجازه می‌دهند نمای خود را به عنوان تابعی از مدل (که مدل شامل سیگنال‌ها است) بیان کنید. گرافی از وضعیت و سیگنال‌های محاسبه‌شده به صورت ساختاری بدون چرخه است. همچنین ممکن است الگوهای ضد React را با استفاده از سیگنال‌ها بازسازی کرد (!)؛ به عنوان مثال، معادل سیگنال از `setState` درون `useEffect` این است که از یک Watcher برای زمان‌بندی نوشتن در یک سیگنال State استفاده شود.\n\n**س**: سیگنال‌ها چه ارتباطی با سیستم‌های مدیریت وضعیت مانند Redux دارند؟ آیا سیگنال‌ها وضعیت بدون ساختار را تشویق می‌کنند؟\n\n**ج**: سیگنال‌ها می‌توانند پایه‌ای کارآمد برای انتزاعات مدیریت وضعیت مشابه store باشند. یک الگوی رایج در چندین فریم‌ورک، شیئی مبتنی بر Proxy است که به صورت داخلی ویژگی‌ها را با استفاده از سیگنال‌ها نمایش می‌دهد، مانند [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive)، یا [Solid stores](https://docs.solidjs.com/concepts/stores). این سیستم‌ها امکان گروه‌بندی انعطاف‌پذیر وضعیت را در سطح مناسب انتزاع برای هر برنامه فراهم می‌کنند.\n\n**س**: سیگنال‌ها چه چیزی ارائه می‌دهند که Proxy در حال حاضر مدیریت نمی‌کند؟\n\n**ج**: پروکسی‌ها و سیگنال‌ها مکمل هم هستند و به خوبی با هم کار می‌کنند. پروکسی‌ها به شما اجازه می‌دهند عملیات شیء سطحی را رهگیری کنید و سیگنال‌ها هماهنگی گراف وابستگی (سلول‌ها) را انجام می‌دهند. پشتیبانی یک Proxy با سیگنال‌ها، راهی عالی برای ساختار واکنشی تو در تو با ارگونومی عالی است.\n\nدر این مثال، می‌توانیم با استفاده از پروکسی، سیگنال را دارای ویژگی getter و setter کنیم به جای استفاده از متدهای `get` و `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// استفاده در یک زمینه فرضی واکنشی:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nهنگام استفاده از یک رندرر که برای واکنش‌پذیری دقیق بهینه شده است، کلیک روی دکمه باعث به‌روزرسانی سلول `b.value` می‌شود.\n\nمشاهده کنید:\n- نمونه‌هایی از ساختارهای واکنشی تو در تو که با هر دو سیگنال و پروکسی ساخته شده‌اند: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- نمونه پیاده‌سازی‌های قبلی که رابطه بین داده واکنشی و پروکسی‌ها را نشان می‌دهند: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [بحث](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### سیگنال‌ها چگونه کار می‌کنند؟\n\n**س**: آیا سیگنال‌ها مبتنی بر push هستند یا pull؟\n\n**ج**: ارزیابی سیگنال‌های محاسبه‌شده مبتنی بر pull است: سیگنال‌های محاسبه‌شده فقط زمانی ارزیابی می‌شوند که `.get()` فراخوانی شود، حتی اگر وضعیت زیرین خیلی قبل‌تر تغییر کرده باشد. در عین حال، تغییر یک سیگنال State ممکن است بلافاصله باعث فراخوانی callback یک Watcher شود و اعلان را \"push\" کند. بنابراین، می‌توان سیگنال‌ها را به عنوان یک سازه \"push-pull\" در نظر گرفت.\n\n**س**: آیا سیگنال‌ها عدم قطعیت را به اجرای جاوااسکریپت وارد می‌کنند؟\n\n**ج**: خیر. اولاً، همه عملیات سیگنال معنای کاملاً تعریف‌شده و ترتیب مشخص دارند و در پیاده‌سازی‌های سازگار تفاوتی نخواهند داشت. در سطح بالاتر، سیگنال‌ها از یک سری اصول پیروی می‌کنند که نسبت به آن‌ها \"sound\" هستند. یک سیگنال محاسبه‌شده همیشه گراف سیگنال را در وضعیت سازگار مشاهده می‌کند و اجرای آن توسط کدهای تغییر دهنده سیگنال دیگر قطع نمی‌شود (به جز چیزهایی که خودش فراخوانی می‌کند). توضیح بیشتر را در بالا ببینید.\n\n**س**: وقتی در یک سیگنال state می‌نویسم، چه زمانی به‌روزرسانی سیگنال محاسبه‌شده زمان‌بندی می‌شود؟\n\n**ج**: زمان‌بندی نمی‌شود! سیگنال محاسبه‌شده دفعه بعد که کسی آن را بخواند، خودش را بازمحاسبه می‌کند. به صورت همزمان، ممکن است callback مربوط به `notify` یک Watcher فراخوانی شود و به فریم‌ورک‌ها اجازه دهد خواندن را در زمانی که مناسب می‌دانند برنامه‌ریزی کنند.\n\n**س**: چه زمانی نوشتن در سیگنال‌های state اعمال می‌شود؟ بلافاصله یا به صورت دسته‌ای (batch)؟\n\n**ج**: نوشتن در سیگنال‌های state بلافاصله منعکس می‌شود—دفعه بعد که یک سیگنال محاسبه‌شده که به سیگنال state وابسته است خوانده شود، در صورت نیاز خود را مجدداً محاسبه می‌کند، حتی اگر بلافاصله در خط بعدی کد باشد. با این حال، تنبلی ذاتی این مکانیزم (که سیگنال‌های محاسبه‌شده فقط هنگام خواندن محاسبه می‌شوند) در عمل باعث می‌شود محاسبات به صورت دسته‌ای انجام شود.\n\n**س**: منظور از اجرای \"بدون glitch\" در سیگنال‌ها چیست؟\n\n**ج**: مدل‌های مبتنی بر push قبلی برای واکنش‌پذیری، با مشکل محاسبات زائد مواجه بودند: اگر یک به‌روزرسانی به یک سیگنال state باعث شود سیگنال محاسبه‌شده فوراً اجرا شود، در نهایت ممکن است این به‌روزرسانی به UI push شود. اما این نوشتن در UI ممکن است زودهنگام باشد اگر قرار باشد یک تغییر دیگر در سیگنال state اصلی قبل از فریم بعدی رخ دهد. گاهی حتی مقادیر میانی نادرست به کاربران نهایی نمایش داده می‌شد که ناشی از چنین [glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)‌هایی بود. سیگنال‌ها با pull-based بودن، نه push-based، از این دینامیک اجتناب می‌کنند: زمانی که فریم‌ورک زمان رندر UI را برنامه‌ریزی می‌کند، به‌روزرسانی‌های مناسب را می‌کشد و از کار بیهوده هم در محاسبه و هم در نوشتن به DOM جلوگیری می‌کند.\n\n**س**: منظور از \"lossy\" بودن سیگنال‌ها چیست؟\n\n**ج**: این وجه دیگر اجرای بدون glitch است: سیگنال‌ها یک سلول داده را نمایش می‌دهند—فقط مقدار فعلی بلافاصله (که ممکن است تغییر کند)، نه جریان داده در طول زمان. بنابراین، اگر دوبار پشت سر هم بدون کار دیگری در یک سیگنال state بنویسید، اولین نوشتن \"از دست می‌رود\" و توسط هیچ سیگنال محاسبه‌شده یا افکتی دیده نمی‌شود. این ویژگی است، نه باگ—سازه‌های دیگر (مانند async iterables، observableها) برای جریان‌ها مناسب‌تر هستند.\n\n**س**: آیا سیگنال‌های بومی سریع‌تر از پیاده‌سازی‌های فعلی JS Signal خواهند بود؟\n\n**ج**: امیدواریم چنین باشد (با یک ضریب ثابت کوچک)، اما این باید در کد ثابت شود. موتورهای JS جادویی نیستند و در نهایت باید همان نوع الگوریتم‌هایی را که پیاده‌سازی‌های JS سیگنال دارند، پیاده‌سازی کنند. بخش بالا در مورد عملکرد را ببینید.\n\n#### چرا سیگنال‌ها اینگونه طراحی شده‌اند؟\n\n**س**: چرا این پیشنهاد شامل یک تابع `effect()` نیست، در حالی که افکت‌ها برای هر استفاده عملی از سیگنال‌ها ضروری هستند؟\n\n**ج**: افکت‌ها ذاتاً به زمان‌بندی و حذف (disposal) مربوط می‌شوند که توسط فریم‌ورک‌ها مدیریت می‌شود و خارج از محدوده این پیشنهاد است. در عوض، این پیشنهاد پایه لازم برای پیاده‌سازی افکت‌ها را از طریق API سطح پایین‌تر `Signal.subtle.Watcher` فراهم می‌کند.\n\n**س**: چرا اشتراک‌ها خودکار هستند و یک رابط دستی ارائه نشده است؟\n\n**ج**: تجربه نشان داده که رابط‌های اشتراک‌گذاری دستی برای واکنش‌پذیری، ارگونومیک و قابل اعتماد نیستند. رهگیری خودکار، ترکیب‌پذیرتر است و ویژگی اصلی سیگنال‌ها به شمار می‌رود.\n\n**س**: چرا callback مربوط به Watcher به صورت همزمان اجرا می‌شود و نه در یک microtask زمان‌بندی می‌شود؟\n\n**ج**: چون callback نمی‌تواند سیگنال‌ها را بخواند یا بنویسد، اجرای همزمان آن مشکلی ایجاد نمی‌کند. یک callback معمولی یک سیگنال را به یک آرایه برای خواندن بعدی اضافه می‌کند یا یک بیت را جایی علامت می‌زند. زمان‌بندی یک microtask جداگانه برای این اقدامات غیرضروری و بسیار پرهزینه است.\n\n**س**: این API برخی امکانات خوبی را که فریم‌ورک مورد علاقه من ارائه می‌دهد و کار با سیگنال‌ها را آسان‌تر می‌کند، ندارد. آیا می‌توان آن‌ها را هم به استاندارد اضافه کرد؟\n\n**ج**: شاید. افزونه‌های مختلف هنوز در حال بررسی هستند. لطفاً یک issue ثبت کنید تا در مورد ویژگی‌های مفقود بحث شود.\n\n**س**: آیا می‌توان این API را کوچک‌تر یا ساده‌تر کرد؟\n\n**ج**: هدف قطعاً حفظ حداقل بودن این API است و با آنچه در بالا ارائه شد، این هدف دنبال شده است. اگر پیشنهادی برای حذف بخش‌های اضافی دارید، لطفاً issue ثبت کنید تا بحث شود.\n\n#### سیگنال‌ها چگونه استانداردسازی می‌شوند؟\n\n**س**: آیا نباید کار استانداردسازی در این حوزه را با یک مفهوم ابتدایی‌تر مانند observableها آغاز کنیم؟",
  "status": "ok"
}