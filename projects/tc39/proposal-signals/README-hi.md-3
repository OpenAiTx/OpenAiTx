{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* ध्यान दें कि आजकल अधिकांश फ्रेमवर्क्स को कंप्यूटेड सिग्नल्स का स्पष्ट रूप से डिस्पोज़ल करना आवश्यक होता है, यदि उनका कोई रेफरेंस किसी अन्य सिग्नल ग्राफ से है जो अभी भी जीवित है।\n* जब इनका जीवनकाल UI कंपोनेंट के जीवनकाल से जुड़ा होता है, और इफेक्ट्स को वैसे भी डिस्पोज़ करना पड़ता है, तब यह इतना बुरा नहीं लगता।\n* यदि इन सिमेंटिक्स के साथ निष्पादन बहुत महंगा है, तो हमें नीचे दिए गए API में कंप्यूटेड सिग्नल्स के स्पष्ट डिस्पोज़ल (या \"अनलिंकिंग\") को जोड़ना चाहिए, जो वर्तमान में इसमें नहीं है।\n* एक अलग संबंधित लक्ष्य: एलोकेशन की संख्या को न्यूनतम करें, उदाहरण के लिए,\n    * एक राइटेबल सिग्नल बनाने के लिए (दो अलग-अलग क्लोज़र + ऐरे से बचें)\n    * इफेक्ट्स को इम्प्लीमेंट करने के लिए (हर रिएक्शन के लिए क्लोज़र से बचें)\n    * सिग्नल बदलावों को ऑब्जर्व करने के API में, अतिरिक्त अस्थायी डाटा स्ट्रक्चर बनाने से बचें\n    * समाधान: सबक्लासेस में परिभाषित मेथड्स और फील्ड्स के पुन: उपयोग की सुविधा के लिए क्लास-आधारित API\n\n## API स्केच\n\nएक सिग्नल API का प्रारंभिक विचार नीचे दिया गया है। ध्यान दें कि यह सिर्फ एक प्रारंभिक ड्राफ्ट है, और हम समय के साथ बदलाव की संभावना देखते हैं। आइए पूरी `.d.ts` से शुरुआत करें ताकि हमें इसके समग्र स्वरूप का अंदाज़ा हो जाए, और फिर हम इसकी सारी डिटेल्स पर चर्चा करेंगे कि इसका क्या अर्थ है।\n\n```ts\ninterface Signal<T> {\n    // सिग्नल का मान प्राप्त करें\n    get(): T;\n}\n\nnamespace Signal {\n    // एक रीड-राइट सिग्नल\n    class State<T> implements Signal<T> {\n        // मान t के साथ एक स्टेट सिग्नल बनाएँ\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // सिग्नल का मान प्राप्त करें\n        get(): T;\n\n        // स्टेट सिग्नल का मान t पर सेट करें\n        set(t: T): void;\n    }\n\n    // एक सिग्नल जो अन्य सिग्नल्स पर आधारित फॉर्मूला है\n    class Computed<T = unknown> implements Signal<T> {\n        // एक सिग्नल बनाएं जो कॉलबैक द्वारा लौटाए गए मान पर इवैल्युएट होता है।\n        // कॉलबैक को इस सिग्नल को this वैल्यू के रूप में पास किया जाता है।\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // सिग्नल का मान प्राप्त करें\n        get(): T;\n    }\n\n    // इस नेमस्पेस में \"एडवांस्ड\" फीचर्स शामिल हैं, जो एप्लिकेशन डेवलपर्स की बजाय फ्रेमवर्क ऑथर्स के लिए बेहतर हैं।\n    // `crypto.subtle` के समान\n    namespace subtle {\n        // सभी ट्रैकिंग को डिसेबल करके एक कॉलबैक चलाएँ\n        function untrack<T>(cb: () => T): T;\n\n        // वर्तमान कंप्यूटेड सिग्नल प्राप्त करें जो किसी भी सिग्नल रीड को ट्रैक कर रहा है, यदि कोई है\n        function currentComputed(): Computed | null;\n\n        // ऑर्डर में उन सभी सिग्नल्स की सूची लौटाएं, जिनका इसने पिछली बार इवैल्युएशन के दौरान रेफरेंस लिया था।\n        // वॉचर के लिए, उन सिग्नल्स का सेट लिस्ट करता है जिन्हें वह वॉच कर रहा है।\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // वे वॉचर्स लौटाएं जिनमें यह सिग्नल शामिल है, साथ ही वे कंप्यूटेड सिग्नल्स जिन्होंने पिछली बार इसके मान को पढ़ा था,\n        // यदि वह कंप्यूटेड सिग्नल (रेकर्सिवली) वॉच किया जा रहा है।\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // यदि यह सिग्नल \"लाइव\" है, यानी इसे कोई वॉचर वॉच कर रहा है,\n        // या इसे कोई कंप्यूटेड सिग्नल पढ़ रहा है जो (रेकर्सिवली) लाइव है, तो True लौटाएं।\n        function hasSinks(s: State | Computed): boolean;\n\n        // यदि यह एलिमेंट \"रिएक्टिव\" है, यानी यह किसी अन्य सिग्नल पर निर्भर करता है, तो True लौटाएं।\n        // एक कंप्यूटेड जिसका hasSources false है वह हमेशा समान स्थिर मान लौटाएगा।\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // जब वॉचर का कोई (रेकर्सिव) सोर्स लिखा जाता है, तो इस कॉलबैक को कॉल करें,\n            // यदि इसे पिछले `watch` कॉल के बाद पहले ही कॉल नहीं किया गया है।\n            // notify के दौरान कोई सिग्नल पढ़ा या लिखा नहीं जा सकता।\n            constructor(notify: (this: Watcher) => void);\n\n            // इन सिग्नल्स को वॉचर के सेट में जोड़ें, और वॉचर को सेट करें कि अगली बार जब भी सेट में कोई भी सिग्नल (या उसकी कोई डिपेंडेंसी) बदले, तो उसका notify कॉलबैक चलाया जाए।\n            // इसे बिना किसी आर्ग्युमेंट के भी कॉल किया जा सकता है, सिर्फ \"notified\" स्टेट को रीसेट करने के लिए, जिससे notify कॉलबैक फिर से इनवोक होगा।\n            watch(...s: Signal[]): void;\n\n            // इन सिग्नल्स को वॉच किए गए सेट से हटाएं (जैसे, डिस्पोज़ किए गए इफेक्ट के लिए)\n            unwatch(...s: Signal[]): void;\n\n            // वॉचर के सेट में मौजूद सोर्सेज में से जो अभी भी डर्टी हैं उनका सेट लौटाएं, या वह कंप्यूटेड सिग्नल लौटाएं\n            // जिसमें कोई सोर्स डर्टी या पेंडिंग है और अभी तक री-इवैल्युएट नहीं हुआ है\n            getPending(): Signal[];\n        }\n\n        // वॉच या अनवॉच होने पर ऑब्जर्व करने के लिए हुक्स\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // पुराने और नए मान के बीच कस्टम तुलना फंक्शन। डिफ़ॉल्ट: Object.is।\n        // सिग्नल को this वैल्यू के रूप में संदर्भ के लिए पास किया जाता है।\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "status": "ok"
}