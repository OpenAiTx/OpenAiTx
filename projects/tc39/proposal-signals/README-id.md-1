{
  "id": 1,
  "origin": "# ğŸš¦ JavaScript Signals standard proposalğŸš¦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and moreâ€¦\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# ğŸš¦ Proposal Standar Sinyal JavaScript ğŸš¦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nTahap 1 ([penjelasan](https://tc39.es/process-document/))\n\nPendukung proposal TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nPenulis asli: Rob Eisenberg dan Daniel Ehrenberg\n\nDokumen ini menjelaskan arah awal yang umum untuk sinyal dalam JavaScript, mirip dengan upaya Promises/A+ yang mendahului Promises yang distandarisasi oleh TC39 di ES2015. Coba sendiri menggunakan [polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSerupa dengan Promises/A+, upaya ini berfokus pada penyelarasan ekosistem JavaScript. Jika penyelarasan ini berhasil, maka standar bisa muncul berdasarkan pengalaman tersebut. Beberapa penulis framework berkolaborasi di sini pada model umum yang dapat mendukung inti reaktivitas mereka. Draf saat ini didasarkan pada masukan desain dari penulis/pemelihara [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), dan lainnya...\n\nBerbeda dari Promises/A+, kami tidak mencoba menyelesaikan permukaan API yang umum untuk pengembang, melainkan semantik inti yang tepat dari grafik sinyal yang mendasari. Proposal ini memang mencakup API yang sepenuhnya konkret, tetapi API ini tidak ditujukan untuk sebagian besar pengembang aplikasi. Sebagai gantinya, API sinyal di sini lebih cocok untuk dibangun di atasnya oleh framework, menyediakan interoperabilitas melalui grafik sinyal umum dan mekanisme pelacakan otomatis.\n\nRencana proposal ini adalah melakukan prototipe awal secara signifikan, termasuk integrasi ke beberapa framework, sebelum melanjutkan ke Tahap 1. Kami hanya tertarik untuk menstandarisasi Sinyal jika memang cocok digunakan secara praktis di berbagai framework, dan memberikan manfaat nyata dibandingkan sinyal yang disediakan oleh framework. Kami berharap bahwa prototipe awal yang signifikan akan memberi kami informasi ini. Lihat \"Status dan rencana pengembangan\" di bawah untuk detail lebih lanjut.\n\n## Latar Belakang: Mengapa Sinyal?\n\nUntuk mengembangkan antarmuka pengguna (UI) yang rumit, pengembang aplikasi JavaScript perlu menyimpan, menghitung, membatalkan, menyinkronkan, dan mendorong status ke lapisan tampilan aplikasi secara efisien. UI umumnya melibatkan lebih dari sekadar mengelola nilai sederhana, tetapi sering kali melibatkan perenderan status terhitung yang bergantung pada pohon kompleks nilai lain atau status yang juga dihitung sendiri. Tujuan Sinyal adalah menyediakan infrastruktur untuk mengelola status aplikasi seperti itu agar pengembang dapat fokus pada logika bisnis alih-alih detail yang berulang ini.\n\nKonstruk mirip sinyal telah secara independen ditemukan berguna dalam konteks non-UI juga, khususnya dalam sistem build untuk menghindari build ulang yang tidak perlu.\n\nSinyal digunakan dalam pemrograman reaktif untuk menghilangkan kebutuhan dalam mengelola pembaruan di aplikasi.\n\n> Model pemrograman deklaratif untuk memperbarui berdasarkan perubahan status.\n\ndari _[Apa itu Reaktivitas?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Contoh - Counter VanillaJS\n\nDiberikan sebuah variabel, `counter`, Anda ingin merender ke dalam DOM apakah counter itu genap atau ganjil. Setiap kali `counter` berubah, Anda ingin memperbarui DOM dengan paritas terbaru. Dalam Vanilla JS, Anda mungkin memiliki kode seperti ini:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulasikan pembaruan eksternal ke counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!CATATAN]  \n> Global digunakan di sini hanya untuk tujuan demonstrasi. Manajemen status yang benar memiliki banyak solusi, dan contoh dalam proposal ini dimaksudkan agar seminimal mungkin. Proposal ini tidak menganjurkan penggunaan variabel global.\n\n\nIni memiliki sejumlah masalah...\n\n* Pengaturan `counter` berisik dan penuh boilerplate.\n* Status `counter` sangat terikat dengan sistem rendering.\n* Jika `counter` berubah tetapi `parity` tidak (misal: counter dari 2 ke 4), maka kita melakukan komputasi parity dan rendering yang tidak perlu.\n* Bagaimana jika bagian lain dari UI kita hanya ingin merender ketika `counter` diperbarui?\n* Bagaimana jika bagian lain dari UI kita bergantung hanya pada `isEven` atau `parity`?\n\nBahkan dalam skenario yang relatif sederhana ini, sejumlah masalah muncul dengan cepat. Kita bisa mencoba mengatasinya dengan menambahkan pub/sub untuk `counter`. Ini memungkinkan konsumen tambahan dari `counter` dapat berlangganan untuk menambahkan reaksi mereka sendiri terhadap perubahan status.\n\nNamun, kita masih terjebak dengan masalah berikut:\n\n* Fungsi render, yang hanya bergantung pada `parity`, malah harus \"tahu\" bahwa sebenarnya ia perlu berlangganan ke `counter`.\n* Tidak mungkin memperbarui UI hanya berdasarkan `isEven` atau `parity`, tanpa langsung berinteraksi dengan `counter`.\n* Boilerplate kita bertambah. Setiap kali Anda menggunakan sesuatu, bukan hanya sekadar memanggil fungsi atau membaca variabel, tetapi harus berlangganan dan melakukan pembaruan di sana. Mengelola unsubscription juga sangat rumit.\n\nSekarang, kita bisa menyelesaikan beberapa masalah dengan menambahkan pub/sub tidak hanya pada `counter` tetapi juga ke `isEven` dan `parity`. Kita kemudian harus membuat `isEven` berlangganan ke `counter`, `parity` ke `isEven`, dan `render` ke `parity`. Sayangnya, bukan hanya kode boilerplate kita yang meledak, tetapi juga kita harus mengelola banyak langganan dan potensi kebocoran memori jika tidak membersihkan semuanya dengan benar. Jadi, kita telah menyelesaikan beberapa masalah tetapi menciptakan kategori masalah baru dan banyak kode. Lebih buruknya lagi, kita harus melalui seluruh proses ini untuk setiap bagian status di sistem kita.\n\n### Memperkenalkan Sinyal\n\nAbstraksi data binding dalam UI untuk model dan tampilan telah lama menjadi inti framework UI di berbagai bahasa pemrograman, meskipun tidak ada mekanisme seperti itu yang dibangun dalam JS atau platform web. Dalam framework dan pustaka JS, telah banyak eksperimen dalam berbagai cara untuk merepresentasikan binding ini, dan pengalaman telah menunjukkan kekuatan alur data satu arah bersamaan dengan tipe data kelas satu yang merepresentasikan sel status atau komputasi yang diturunkan dari data lain, yang kini sering disebut \"Sinyal\".\nPendekatan nilai reaktif kelas satu ini tampaknya pertama kali populer muncul di framework web JavaScript open-source dengan [Knockout](https://knockoutjs.com/) [pada 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). Dalam beberapa tahun setelahnya, banyak variasi dan implementasi telah dibuat. Dalam 3-4 tahun terakhir, primitif Sinyal dan pendekatan terkait semakin berkembang, dengan hampir setiap pustaka atau framework JavaScript modern memiliki sesuatu yang serupa, dengan nama yang berbeda-beda.\n\nUntuk memahami Sinyal, mari kita lihat contoh di atas, dibayangkan ulang dengan API Sinyal yang dijelaskan lebih lanjut di bawah ini.\n\n#### Contoh - Counter Signals\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// Sebuah library atau framework mendefinisikan efek berdasarkan primitif Signal lain\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulasikan pembaruan eksternal ke counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nAda beberapa hal yang langsung dapat kita lihat:\n* Kita telah menghilangkan boilerplate yang berisik pada variabel `counter` dari contoh sebelumnya.\n* Ada satu API terpadu untuk menangani nilai, komputasi, dan efek samping.\n* Tidak ada masalah referensi melingkar atau ketergantungan terbalik antara `counter` dan `render`.\n* Tidak ada langganan manual, juga tidak ada kebutuhan untuk pencatatan.\n* Ada cara untuk mengontrol waktu/penjadwalan efek samping.\n\nSinyal memberi kita jauh lebih banyak daripada yang terlihat di permukaan API:",
  "status": "ok"
}