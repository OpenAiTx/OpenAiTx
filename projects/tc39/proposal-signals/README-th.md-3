{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* โปรดทราบว่าเฟรมเวิร์กส่วนใหญ่ในปัจจุบันต้องการการกำจัด (dispose) Signal ที่คำนวณได้ (computed Signals) อย่างชัดเจน หาก Signal นั้นมีการอ้างอิงถึงหรือจากกราฟ Signal อื่นที่ยังคงมีชีวิตอยู่\n* เรื่องนี้จะไม่เป็นปัญหามากนักหากอายุการใช้งานของ Signal ผูกกับอายุการใช้งานของคอมโพเนนต์ UI และเอฟเฟ็กต์ต่าง ๆ จำเป็นต้องถูกกำจัดอยู่แล้ว\n* หากการดำเนินการด้วยลักษณะนี้มีค่าใช้จ่ายสูงเกินไป ก็ควรเพิ่มการกำจัด (dispose) หรือ \"unlinking\" ของ Signal ที่คำนวณได้เข้าไปใน API ด้านล่าง ซึ่งขณะนี้ยังไม่มี\n* เป้าหมายที่เกี่ยวข้องอีกประการหนึ่ง: ลดจำนวนการจัดสรรหน่วยความจำ เช่น\n    * เพื่อสร้าง Signal ที่เขียนค่าได้ (writable Signal) (หลีกเลี่ยงการใช้ closure สองตัวแยกกัน + array)\n    * เพื่อใช้งานเอฟเฟ็กต์ (หลีกเลี่ยงการใช้ closure สำหรับทุก ๆ การตอบสนอง)\n    * ใน API สำหรับสังเกตการเปลี่ยนแปลงของ Signal ให้หลีกเลี่ยงการสร้างโครงสร้างข้อมูลชั่วคราวเพิ่มเติม\n    * ทางออก: API ที่ใช้คลาส (Class-based API) ซึ่งช่วยให้สามารถนำกลับมาใช้ใหม่ได้ทั้ง methods และ fields ที่กำหนดไว้ในคลาสย่อย\n\n## ร่าง API\n\nแนวคิดเบื้องต้นของ Signal API แสดงอยู่ด้านล่าง โปรดทราบว่านี่เป็นเพียงร่างแรกเริ่มเท่านั้น และเราคาดว่าจะมีการเปลี่ยนแปลงต่อไปในอนาคต เริ่มจากไฟล์ `.d.ts` เต็มรูปแบบเพื่อดูโครงสร้างโดยรวม จากนั้นเราจะพูดคุยรายละเอียดของแต่ละส่วน\n\n```ts\ninterface Signal<T> {\n    // รับค่าของ signal\n    get(): T;\n}\n\nnamespace Signal {\n    // Signal ที่อ่าน-เขียนค่าได้\n    class State<T> implements Signal<T> {\n        // สร้าง state Signal โดยเริ่มจากค่า t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // รับค่าของ signal\n        get(): T;\n\n        // กำหนดค่า state Signal เป็น t\n        set(t: T): void;\n    }\n\n    // Signal ที่คำนวณค่าจาก Signal อื่น ๆ\n    class Computed<T = unknown> implements Signal<T> {\n        // สร้าง Signal ที่ประเมินผลด้วยค่าที่ callback ส่งคืน\n        // Callback จะถูกเรียกโดยใช้ signal นี้เป็นค่า this\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // รับค่าของ signal\n        get(): T;\n    }\n\n    // เนมสเปซนี้รวมฟีเจอร์ \"ขั้นสูง\" ซึ่งเหมาะสำหรับผู้พัฒนาเฟรมเวิร์กมากกว่านักพัฒนาแอปพลิเคชัน\n    // คล้ายกับ `crypto.subtle`\n    namespace subtle {\n        // รัน callback โดยปิดการ tracking ทั้งหมด\n        function untrack<T>(cb: () => T): T;\n\n        // รับ computed signal ปัจจุบันที่กำลัง track การอ่าน signal ใด ๆ ถ้ามี\n        function currentComputed(): Computed | null;\n\n        // ส่งคืนลิสต์เรียงลำดับของ signal ทั้งหมดที่ signal นี้อ้างอิงถึง\n        // ในการประเมินค่าครั้งล่าสุด\n        // สำหรับ Watcher จะแสดงชุดของ signal ที่กำลังเฝ้าดู\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // ส่งคืน Watchers ที่ signal นี้อยู่ในนั้น รวมถึง\n        // Computed signals ที่อ่าน signal นี้ในการประเมินค่าครั้งล่าสุด\n        // หาก computed signal นั้น (แบบ recursive) ถูกเฝ้าดู\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // คืนค่า true หาก signal นี้ \"มีชีวิต\" คือถูกเฝ้าดูโดย Watcher,\n        // หรือถูกอ่านโดย Computed signal ที่ (แบบ recursive) มีชีวิต\n        function hasSinks(s: State | Computed): boolean;\n\n        // คืนค่า true หาก element นี้เป็น \"reactive\" คือขึ้นอยู่กับ signal อื่น\n        // Computed ที่ hasSources เป็น false จะคืนค่าคงที่เสมอ\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // เมื่อ (recursive) source ของ Watcher ถูกเขียน จะเรียก callback นี้\n            // หาก callback ยังไม่ถูกเรียกตั้งแต่ `watch` ครั้งล่าสุด\n            // ห้ามอ่านหรือเขียน signal ใด ๆ ระหว่าง notify\n            constructor(notify: (this: Watcher) => void);\n\n            // เพิ่ม signals เหล่านี้เข้าในชุดของ Watcher และตั้ง watcher ให้รัน\n            // notify callback เมื่อใดก็ตามที่ signal ในชุด (หรือ dependency ของมัน) มีการเปลี่ยนแปลง\n            // สามารถเรียกโดยไม่มีอาร์กิวเมนต์เพื่อรีเซ็ตสถานะ \"notified\" ได้\n            // เพื่อให้ notify callback ถูกเรียกอีกครั้ง\n            watch(...s: Signal[]): void;\n\n            // ลบ signals เหล่านี้ออกจากชุดที่เฝ้าดู (เช่น สำหรับ effect ที่ถูก dispose)\n            unwatch(...s: Signal[]): void;\n\n            // ส่งคืนชุดของ sources ในชุด Watcher ที่ยัง dirty หรือเป็น computed signal\n            // ที่มี source เป็น dirty หรือ pending และยังไม่ได้ประเมินค่าใหม่\n            getPending(): Signal[];\n        }\n\n        // ฮุคสำหรับสังเกตว่ากำลังถูกเฝ้าดูหรือไม่ถูกเฝ้าดูอีกต่อไป\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // ฟังก์ชันเปรียบเทียบค่าระหว่างค่าเก่าและค่าใหม่ กำหนดค่าเริ่มต้น: Object.is\n        // signal จะถูกส่งเข้าเป็นค่า this สำหรับ context\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}