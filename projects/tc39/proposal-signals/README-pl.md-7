{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Z [AsyncContext](https://github.com/tc39/proposal-async-context), przekazana zwrotna funkcja do `new Signal.subtle.Watcher` *nie* zamyka się nad migawką z momentu wywołania konstruktora, dzięki czemu kontekstualne informacje dotyczące zapisu są widoczne.\n\n#### Metoda: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Jeśli `frozen` jest prawdziwe, rzuć wyjątek.\n1. Jeśli którykolwiek z argumentów nie jest sygnałem, rzuć wyjątek.\n1. Dodaj wszystkie argumenty na koniec tablicy `signals` tego obiektu.\n1. Dla każdego nowo obserwowanego sygnału, w kolejności od lewej do prawej,\n    1. Dodaj tego watcher'a jako `sink` do tego sygnału.\n    1. Jeśli to był pierwszy sink, rekurencyjnie dodaj ten sygnał jako sink do jego źródeł.\n    1. Ustaw `frozen` na true.\n    1. Wywołaj callback `watched` jeśli istnieje.\n    1. Przywróć `frozen` do wartości false.\n1. Jeśli `state` sygnału to `~waiting~`, ustaw je na `~watching~`.\n\n#### Metoda: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Jeśli `frozen` jest prawdziwe, rzuć wyjątek.\n1. Jeśli którykolwiek z argumentów nie jest sygnałem lub nie jest obserwowany przez tego watcher'a, rzuć wyjątek.\n1. Dla każdego sygnału w argumentach, w kolejności od lewej do prawej,\n    1. Usuń ten sygnał z zestawu `signals` tego Watcher'a.\n    1. Usuń tego Watcher'a z zestawu `sink` tego sygnału.\n    1. Jeśli zestaw `sink` tego sygnału stał się pusty, usuń ten sygnał jako sink ze wszystkich jego źródeł.\n    1. Ustaw `frozen` na true.\n    1. Wywołaj callback `unwatched` jeśli istnieje.\n    1. Przywróć `frozen` do wartości false.\n1. Jeśli watcher nie ma teraz żadnych `signals`, a jego `state` to `~watching~`, ustaw je na `~waiting~`.\n\n#### Metoda: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Zwróć tablicę zawierającą podzbiór `signals`, które są sygnałami typu Computed w stanie `~dirty~` lub `~pending~`.\n\n### Metoda: `Signal.subtle.untrack(cb)`\n\n1. Niech `c` będzie bieżącym stanem `computing` kontekstu wykonania.\n1. Ustaw `computing` na null.\n1. Wywołaj `cb`.\n1. Przywróć `computing` do wartości `c` (nawet jeśli `cb` rzucił wyjątek).\n1. Zwróć wartość zwróconą przez `cb` (ponownie rzucając dowolny wyjątek).\n\nUwaga: untrack nie wyprowadza z `frozen`, który utrzymywany jest rygorystycznie.\n\n### Metoda: `Signal.subtle.currentComputed()`\n\n1. Zwraca bieżącą wartość `computing`.\n\n### Wspólne algorytmy\n\n##### Algorytm: przelicz brudny sygnał obliczany (dirty computed Signal)\n\n1. Wyczyść zestaw `sources` tego sygnału oraz usuń go z zestawu `sinks` tych źródeł.\n1. Zapisz poprzednią wartość `computing` i ustaw `computing` na ten sygnał.\n1. Ustaw stan tego sygnału na `~computing~`.\n1. Uruchom callback tego sygnału obliczanego, używając tego sygnału jako wartości `this`. Zapisz wartość zwrotną, a jeśli callback rzucił wyjątek, zapisz go do ponownego rzucenia.\n1. Przywróć poprzednią wartość `computing`.\n1. Zastosuj algorytm „set Signal value” do wartości zwrotnej callbacka.\n2. Ustaw stan tego sygnału na `~clean~`.\n1. Jeśli ten algorytm zwrócił `~dirty~`: oznacz wszystkie sinks tego sygnału jako `~dirty~` (wcześniej sinks mogły być mieszanką checked i dirty). (Lub, jeśli nie jest obserwowany, przyjmij nowy numer generacji oznaczający brud, lub coś podobnego.)\n1. W przeciwnym razie algorytm zwrócił `~clean~`: w tym przypadku dla każdego sinka typu `~checked~` tego sygnału, jeśli wszystkie źródła tego sygnału są już czyste, oznacz również ten sygnał jako `~clean~`. Zastosuj ten krok czyszczenia rekurencyjnie do dalszych sinków, do wszystkich nowych czystych sygnałów, które mają checked sinks. (Lub, jeśli nie jest obserwowany, wskaż to w jakiś sposób, aby czyszczenie mogło być wykonane leniwie.)\n\n##### Algorytm ustawiania wartości sygnału (Set Signal value algorithm)\n\n1. Jeśli algorytm otrzymał wartość (a nie wyjątek do ponownego rzucenia z algorytmu przeliczania brudnego sygnału obliczanego):\n    1. Wywołaj funkcję `equals` tego sygnału, przekazując jako parametry bieżącą `value`, nową wartość oraz ten sygnał. Jeśli zostanie rzucony wyjątek, zapisz go (do ponownego rzucenia przy odczycie) jako wartość sygnału i kontynuuj tak, jakby callback zwrócił false.\n    1. Jeśli ta funkcja zwróciła true, zwróć `~clean~`.\n1. Ustaw `value` tego sygnału na przekazany parametr.\n1. Zwróć `~dirty~`\n\n## FAQ\n\n**Q**: Czy nie jest za wcześnie na standaryzację czegoś związanego z Signals, skoro dopiero od 2022 roku stały się nowym gorącym tematem? Czy nie powinniśmy dać im więcej czasu na ewolucję i stabilizację?\n\n**A**: Obecny stan Signals w frameworkach webowych to rezultat ponad 10 lat ciągłego rozwoju. W miarę wzrostu inwestycji, jak to miało miejsce w ostatnich latach, prawie wszystkie frameworki webowe zbliżają się do bardzo podobnego modelu podstawowego Signals. Ta propozycja jest wynikiem wspólnego ćwiczenia projektowego dużej liczby obecnych liderów frameworków webowych i nie będzie forsowana do standaryzacji bez walidacji tej grupy ekspertów domenowych w różnych kontekstach.\n\n#### Jak używane są Signals?\n\n**Q**: Czy wbudowane Signals w ogóle mogą być używane przez frameworki, biorąc pod uwagę ich ścisłą integrację z renderowaniem i własnością?\n\n**A**: Elementy bardziej specyficzne dla frameworków dotyczą efektów, planowania (scheduling) i własności/zwalniania zasobów, których ta propozycja nie próbuje rozwiązać. Naszym pierwszym priorytetem przy prototypowaniu Signals na ścieżce standaryzacji jest sprawdzenie, czy mogą one działać „pod” istniejącymi frameworkami w sposób kompatybilny i wydajny.\n\n**Q**: Czy API Signal ma być używane bezpośrednio przez deweloperów aplikacji, czy opakowane przez frameworki?\n\n**A**: Chociaż to API może być używane bezpośrednio przez deweloperów aplikacji (przynajmniej ta część, która nie jest w przestrzeni nazw `Signal.subtle`), nie jest ono zaprojektowane jako szczególnie ergonomiczne. Priorytetem są potrzeby autorów bibliotek/frameworków. Większość frameworków prawdopodobnie opakuje nawet podstawowe API `Signal.State` i `Signal.Computed` w coś wyrażającego ich ergonomiczną filozofię. W praktyce najlepiej korzystać z Signals przez framework, który zarządza trudniejszymi funkcjonalnościami (np. Watcher, `untrack`), a także własnością i zwalnianiem zasobów (np. określaniem, kiedy sygnały powinny być dodane do i usunięte z watcherów) oraz planowaniem renderowania do DOM—ta propozycja nie próbuje rozwiązać tych problemów.\n\n**Q**: Czy muszę usuwać Signals powiązane z widgetem, gdy ten widget jest niszczony? Jakie jest API do tego?\n\n**A**: Odpowiednia operacja usuwania to `Signal.subtle.Watcher.prototype.unwatch`. Tylko obserwowane sygnały wymagają czyszczenia (poprzez unwatch), podczas gdy nieobserwowane mogą być automatycznie zbierane przez garbage collector.\n\n**Q**: Czy Signals działają z VDOM, czy bezpośrednio z natywnym HTML DOM?\n\n**A**: Tak! Signals są niezależne od technologii renderowania. Istniejące frameworki JavaScript używające konstrukcji podobnych do Signal integrują się zarówno z VDOM (np. Preact), natywnym DOM (np. Solid), jak i hybrydowo (np. Vue). To samo będzie możliwe z wbudowanymi Signals.\n\n**Q**: Czy używanie Signals w kontekście frameworków opartych o klasy, takich jak Angular i Lit, będzie ergonomiczne? A co z frameworkami kompilowanymi, jak Svelte?\n\n**A**: Pola klasowe mogą być oparte na Signal za pomocą prostego dekoratora dostępowego, jak pokazano w [readme polifillu Signal](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals są bardzo blisko spokrewnione z Runes z Svelte 5—kompilator może łatwo przekształcić runes w API Signal zdefiniowane tutaj, i faktycznie tak właśnie działa Svelte 5 wewnętrznie (ale z własną biblioteką Signals).\n\n**Q**: Czy Signals działają z SSR? Hydration? Resumability?\n\n**A**: Tak. Qwik wykorzystuje Signals z powodzeniem dla obu tych cech, a inne frameworki mają inne dobrze rozwinięte podejścia do hydration przy użyciu Signals z różnymi kompromisami. Uważamy, że możliwe jest zamodelowanie rezumowalnych Signals Qwika przy użyciu sygnału State i Computed połączonych razem i planujemy to udowodnić w kodzie.",
  "status": "ok"
}