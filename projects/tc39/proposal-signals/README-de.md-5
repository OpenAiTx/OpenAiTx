{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Beispiel zeigen, wie ein Observable in ein berechnetes Signal umgewandelt wird, das nur abonniert wird, wenn es von einem Effekt verwendet wird\n\nTODO: Beispiel zeigen, wie ein berechnetes Signal das Ergebnis eines Fetch darstellt, das auf einen Zustand gerichtet ist und abgebrochen wird\n\n### Introspektion für SSR\n\nTODO: Zeigen, wie die Serialisierung des Signalgraphen funktioniert\n\nTODO: Zeigen, wie man ein Signal später von State zu Computed „hydratisieren“ kann, unter Verwendung einiger Signale.\n-->\n\n### Vorerst weggelassen\n\nDiese Funktionen könnten später hinzugefügt werden, sind aber im aktuellen Entwurf nicht enthalten. Ihr Fehlen ist auf den Mangel an etabliertem Konsens im Designraum unter den Frameworks sowie auf die nachgewiesene Möglichkeit zurückzuführen, ihr Fehlen mit Mechanismen auf Grundlage des in diesem Dokument beschriebenen Signals-Konzepts zu umgehen. Leider begrenzt das Weglassen jedoch das Potenzial der Interoperabilität zwischen Frameworks. Während Prototypen von Signals, wie in diesem Dokument beschrieben, entwickelt werden, wird geprüft, ob diese Auslassungen die richtige Entscheidung waren.\n\n* **Async**: In diesem Modell sind Signale immer synchron zur Auswertung verfügbar. Es ist jedoch oft nützlich, bestimmte asynchrone Prozesse zu haben, die dazu führen, dass ein Signal gesetzt wird, und zu wissen, wann ein Signal noch „lädt“. Eine einfache Möglichkeit, den Ladezustand zu modellieren, ist mit Ausnahmen, und das Ausnahme-Caching-Verhalten von berechneten Signalen lässt sich mit dieser Technik einigermaßen sinnvoll kombinieren. Verbesserte Techniken werden in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30) diskutiert.\n* **Transaktionen**: Für Übergänge zwischen Ansichten ist es oft nützlich, einen Live-Zustand für sowohl den „von“- als auch den „zu“-Zustand zu halten. Der „zu“-Zustand wird im Hintergrund gerendert, bis er bereit ist, übernommen zu werden (Abschluss der Transaktion), während der „von“-Zustand interaktiv bleibt. Das gleichzeitige Beibehalten beider Zustände erfordert das „Forken“ des Zustands des Signalgraphen, und es kann sogar nützlich sein, mehrere ausstehende Übergänge gleichzeitig zu unterstützen. Diskussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nEinige mögliche [Convenience-Methoden](https://github.com/proposal-signals/proposal-signals/issues/32) werden ebenfalls ausgelassen.\n\n## Status und Entwicklungsplan\n\nDieser Vorschlag steht auf der TC39-Agenda für April 2024 für Stage 1. Er kann derzeit als „Stage 0“ betrachtet werden.\n\n[Ein Polyfill](https://github.com/proposal-signals/signal-polyfill) für diesen Vorschlag ist verfügbar, mit einigen grundlegenden Tests. Einige Framework-Autoren haben begonnen, mit dem Austausch dieser Signal-Implementierung zu experimentieren, aber diese Nutzung befindet sich noch in einem frühen Stadium.\n\nDie Mitwirkenden am Signal-Vorschlag möchten bei der Weiterentwicklung dieses Vorschlags besonders **konservativ** vorgehen, um nicht in die Falle zu tappen, etwas zu veröffentlichen, das wir später bereuen und tatsächlich nicht nutzen. Unser Plan ist es, die folgenden zusätzlichen Aufgaben, die nicht vom TC39-Prozess gefordert werden, durchzuführen, um sicherzustellen, dass dieser Vorschlag auf dem richtigen Weg ist:\n\nVor der Beantragung von Stage 2 planen wir:\n- Entwicklung mehrerer produktionsreifer Polyfill-Implementierungen, die solide, gut getestet (z. B. bestehen Tests verschiedener Frameworks sowie Test262-ähnliche Tests) und in Bezug auf die Leistung wettbewerbsfähig sind (wie durch einen umfassenden Signal/Framework-Benchmark-Satz überprüft).\n- Integration der vorgeschlagenen Signal-API in eine Vielzahl von JS-Frameworks, die wir als einigermaßen repräsentativ betrachten, und einige große Anwendungen arbeiten auf dieser Basis. Testen, ob sie in diesen Kontexten effizient und korrekt funktioniert.\n- Ein solides Verständnis für den Raum möglicher Erweiterungen der API haben und entschieden haben, welche (falls überhaupt) in diesen Vorschlag aufgenommen werden sollten.\n\n## Signal-Algorithmen\n\nIn diesem Abschnitt wird jede der für JavaScript bereitgestellten APIs in Bezug auf die Algorithmen beschrieben, die sie implementieren. Dies kann als Proto-Spezifikation betrachtet werden und ist zu diesem frühen Zeitpunkt enthalten, um eine mögliche Semantik festzulegen, wobei Änderungen sehr offen sind.\n\nEinige Aspekte des Algorithmus:\n- Die Reihenfolge der Lesezugriffe auf Signale innerhalb eines Computed ist signifikant und zeigt sich in der Reihenfolge, in der bestimmte Callbacks (welcher `Watcher` aufgerufen wird, `equals`, der erste Parameter für `new Signal.Computed` und die `watched`/`unwatched`-Callbacks) ausgeführt werden. Das bedeutet, dass die Quellen eines berechneten Signals geordnet gespeichert werden müssen.\n- Diese vier Callbacks können alle Ausnahmen auslösen, und diese Ausnahmen werden auf vorhersehbare Weise an den aufrufenden JS-Code weitergegeben. Die Ausnahmen beenden *nicht* die Ausführung dieses Algorithmus oder hinterlassen den Graphen in einem halb verarbeiteten Zustand. Für Fehler, die im `notify`-Callback eines Watchers ausgelöst werden, wird diese Ausnahme an den `.set()`-Aufruf gesendet, der sie ausgelöst hat, wobei ein AggregateError verwendet wird, wenn mehrere Ausnahmen ausgelöst wurden. Die anderen (einschließlich `watched`/`unwatched`?) werden im Wert des Signals gespeichert, um beim Lesen erneut ausgelöst zu werden, und ein solches erneut auslösendes Signal kann wie jedes andere mit einem normalen Wert als `~clean~` markiert werden.\n- Es wird darauf geachtet, Zirkelbezüge in Fällen von berechneten Signalen zu vermeiden, die nicht „beobachtet“ werden (von einem Watcher beobachtet werden), sodass sie unabhängig von anderen Teilen des Signalgraphen vom Garbage Collector gesammelt werden können. Intern kann dies mit einem System von Generationsnummern implementiert werden, die immer gesammelt werden; beachten Sie, dass optimierte Implementierungen auch lokale, knotenspezifische Generationsnummern enthalten oder das Verfolgen einiger Nummern bei beobachteten Signalen vermeiden können.\n\n### Versteckter globaler Zustand\n\nSignal-Algorithmen müssen auf bestimmten globalen Zustand zugreifen. Dieser Zustand ist global für den gesamten Thread oder „Agent“.\n\n- `computing`: Das innerste berechnete oder Effekt-Signal, das derzeit aufgrund eines `.get`- oder `.run`-Aufrufs neu ausgewertet wird, oder `null`. Anfangswert: `null`.\n- `frozen`: Boolean, der angibt, ob gerade ein Callback ausgeführt wird, der erfordert, dass der Graph nicht verändert wird. Anfangswert: `false`.\n- `generation`: Eine fortlaufende Ganzzahl, beginnend bei 0, wird verwendet, um zu verfolgen, wie aktuell ein Wert ist, und Zirkelbezüge zu vermeiden.\n\n### Der `Signal`-Namensraum\n\n`Signal` ist ein gewöhnliches Objekt, das als Namensraum für Signal-bezogene Klassen und Funktionen dient.\n\n`Signal.subtle` ist ein ähnliches inneres Namensraum-Objekt.\n\n### Die Klasse `Signal.State`\n\n#### Interne Slots von `Signal.State`\n\n- `value`: Der aktuelle Wert des State-Signals\n- `equals`: Die Vergleichsfunktion, die beim Ändern von Werten verwendet wird\n- `watched`: Der Callback, der aufgerufen wird, wenn das Signal von einem Effekt beobachtet wird\n- `unwatched`: Der Callback, der aufgerufen wird, wenn das Signal nicht mehr von einem Effekt beobachtet wird\n- `sinks`: Menge der beobachteten Signale, die von diesem abhängen\n\n#### Konstruktor: `Signal.State(initialValue, options)`\n\n1. Setze den `value` dieses Signals auf `initialValue`.\n1. Setze das `equals` dieses Signals auf options?.equals\n1. Setze das `watched` dieses Signals auf options?.[Signal.subtle.watched]\n1. Setze das `unwatched` dieses Signals auf options?.[Signal.subtle.unwatched]\n1. Setze das `sinks` dieses Signals auf die leere Menge\n\n#### Methode: `Signal.State.prototype.get()`\n\n1. Wenn `frozen` wahr ist, löse eine Ausnahme aus.\n1. Wenn `computing` nicht `undefined` ist, füge dieses Signal zur `sources`-Menge von `computing` hinzu.\n1. HINWEIS: Wir fügen `computing` erst dann zur `sinks`-Menge dieses Signals hinzu, wenn es von einem Watcher beobachtet wird.\n1. Gib den `value` dieses Signals zurück.\n\n#### Methode: `Signal.State.prototype.set(newValue)`\n\n1. Wenn der aktuelle Ausführungskontext `frozen` ist, löse eine Ausnahme aus.\n1. Führe den Algorithmus „Signal-Wert setzen“ mit diesem Signal und dem ersten Parameter für den Wert aus.\n1. Wenn dieser Algorithmus `~clean~` zurückgab, gib undefined zurück.\n1. Setze den `state` aller `sinks` dieses Signals auf (falls es sich um ein Computed Signal handelt) `~dirty~`, wenn sie zuvor clean waren, oder (falls es sich um einen Watcher handelt) `~pending~`, wenn er zuvor `~watching~` war.\n1. Setze den `state` aller Computed-Signal-Abhängigkeiten der Sinks (rekursiv) auf `~checked~`, wenn sie zuvor `~clean~` waren (d. h. lasse Dirty-Markierungen bestehen), oder für Watcher auf `~pending~`, wenn zuvor `~watching~`.\n1. Für jeden zuvor `~watching~` Watcher, der bei dieser rekursiven Suche gefunden wurde, dann in Tiefensuche-Reihenfolge:\n    1. Setze `frozen` auf true.\n    1. Rufe ihren `notify`-Callback auf (speichere dabei etwaige ausgelöste Ausnahmen, ignoriere aber den Rückgabewert von `notify`).\n    1. Setze `frozen` wieder auf false.\n    1. Setze den `state` des Watchers auf `~waiting~`.\n1. Wenn bei den `notify`-Callbacks eine Ausnahme ausgelöst wurde, gib sie nach dem Ausführen aller `notify`-Callbacks an den Aufrufer weiter. Wenn mehrere Ausnahmen auftraten, fasse sie zu einem AggregateError zusammen und werfe diesen.\n1. Gib undefined zurück.\n\n### Die Klasse `Signal.Computed`\n\n#### `Signal.Computed` Zustandsautomat",
  "status": "ok"
}