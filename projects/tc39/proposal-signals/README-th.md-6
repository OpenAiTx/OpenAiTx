{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "`state` ของ Computed Signal อาจเป็นสถานะใดสถานะหนึ่งดังต่อไปนี้:\n\n- `~clean~`: ค่าของ Signal มีอยู่และทราบแน่ว่าไม่ล้าสมัย\n- `~checked~`: แหล่งข้อมูล (indirect) ของ Signal นี้มีการเปลี่ยนแปลง; Signal นี้ยังมีค่าอยู่แต่ _อาจจะ_ ล้าสมัย การจะทราบว่าล้าสมัยหรือไม่ จะรู้ได้ก็ต่อเมื่อมีการประเมินแหล่งข้อมูลทั้งหมดแบบ immediate แล้ว\n- `~computing~`: callback ของ Signal นี้กำลังถูกดำเนินการอยู่ในฐานะผลข้างเคียงของการเรียก `.get()`\n- `~dirty~`: Signal นี้มีค่าที่รู้แน่ว่าล้าสมัย หรือไม่เคยถูกประเมินค่ามาก่อนเลย\n\nกราฟการเปลี่ยนสถานะเป็นดังนี้:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nการเปลี่ยนสถานะมีดังนี้:\n| หมายเลข | จาก | ไป | เงื่อนไข | อัลกอริทึม |\n| ------- | --- | -- | -------- | ---------- |\n| 1 | `~checked~` | `~dirty~` | immediate source ของ signal นี้ซึ่งเป็น computed signal ได้ถูกประเมินค่าแล้วและค่าของมันเปลี่ยนแปลง | อัลกอริทึม: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | immediate source ของ signal นี้ซึ่งเป็น State ถูก set ด้วยค่าที่ไม่เท่ากับค่าก่อนหน้า | เมธอด: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | แหล่งข้อมูล recursive (แต่ไม่ใช่ immediate) ของ signal นี้ซึ่งเป็น State ถูก set ด้วยค่าที่ไม่เท่ากับค่าก่อนหน้า | เมธอด: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | กำลังจะทำการ execute `callback` | อัลกอริทึม: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | `callback` ได้ประเมินค่าเสร็จสิ้นและคืนค่าหรือโยน exception | อัลกอริทึม: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | แหล่งข้อมูล immediate ของ signal นี้ทั้งหมดถูกประเมินค่าแล้วและไม่มีการเปลี่ยนแปลงใดๆ จึงทราบแน่ว่าไม่ล้าสมัย | อัลกอริทึม: recalculate dirty computed Signal |\n\n#### Slot ภายในของ `Signal.Computed`\n\n- `value`: ค่าที่ cache ไว้ก่อนหน้าของ Signal หรือ `~uninitialized~` สำหรับ computed Signal ที่ไม่เคยถูกอ่าน ค่าอาจเป็น exception ที่จะถูกโยนซ้ำเมื่อมีการอ่านค่าเสมอ เป็น `undefined` เสมอสำหรับ effect signals\n- `state`: อาจเป็น `~clean~`, `~checked~`, `~computing~` หรือ `~dirty~`\n- `sources`: ชุดของ Signals ที่ Signal นี้ขึ้นอยู่กับเรียงตามลำดับ\n- `sinks`: ชุดของ Signals ที่ขึ้นอยู่กับ Signal นี้เรียงตามลำดับ\n- `equals`: เมธอดเปรียบเทียบความเท่ากันที่กำหนดใน options\n- `callback`: callback ที่ใช้เพื่อรับค่าของ computed Signal กำหนดค่าจากพารามิเตอร์แรกที่ส่งให้ constructor\n\n#### คอนสตรัคเตอร์ของ `Signal.Computed`\n\nคอนสตรัคเตอร์จะกำหนด\n- `callback` เป็นพารามิเตอร์แรกที่ได้รับ\n- `equals` จาก options ถ้าไม่มีจะใช้ `Object.is` เป็นค่าเริ่มต้น\n- `state` เป็น `~dirty~`\n- `value` เป็น `~uninitialized~`\n\nเมื่อใช้ [AsyncContext](https://github.com/tc39/proposal-async-context) callback ที่ถูกส่งให้กับ `new Signal.Computed` จะปิดเหนือ snapshot ขณะเรียก constructor และคืนค่าสภาพแวดล้อมนั้นระหว่างการทำงาน\n\n#### เมธอด: `Signal.Computed.prototype.get`\n\n1. ถ้า execution context ปัจจุบันคือ `frozen` หรือ Signal นี้มี state เป็น `~computing~` หรือหาก signal นี้เป็น Watcher และกำลัง `computing` computed Signal ให้โยน exception\n1. ถ้า `computing` ไม่เป็น `null` ให้เพิ่ม Signal นี้ในชุด `sources` ของ `computing`\n1. หมายเหตุ: จะไม่เพิ่ม `computing` ไปในชุด `sinks` ของ Signal นี้จนกว่าจะถูก Watcher เฝ้าดู\n1. หาก state ของ Signal นี้คือ `~dirty~` หรือ `~checked~`: ทำขั้นตอนต่อไปนี้ซ้ำจนกว่า Signal นี้จะเป็น `~clean~`:\n    1. ไต่กลับขึ้นไปผ่าน `sources` เพื่อหา recursive source ที่ลึกสุด, ซ้ายสุด (คือ สังเกตเจอก่อนสุด) ซึ่งเป็น Computed Signal ที่ถูกทำเครื่องหมายว่า `~dirty~` (หยุดค้นหาเมื่อเจอ Computed Signal ที่ `~clean~` และรวม Computed Signal นี้เป็นตัวสุดท้ายที่ค้นหา)\n    1. ทำอัลกอริทึม \"recalculate dirty computed Signal\" กับ Signal นั้น\n1. ณ จุดนี้ Signal นี้จะมีสถานะ `~clean~` และ recursive sources ทั้งหมดจะไม่เป็น `~dirty~` หรือ `~checked~` คืนค่าของ Signal หากค่านั้นเป็น exception ให้โยน exception นั้น\n\n### คลาส `Signal.subtle.Watcher`\n\n#### สเตตแมชชีนของ `Signal.subtle.Watcher`\n\n`state` ของ Watcher อาจเป็นสถานะใดสถานะหนึ่งดังต่อไปนี้:\n\n- `~waiting~`: มีการ run `notify` callback แล้ว หรือ Watcher นี้ถูกสร้างขึ้นใหม่แต่ยังไม่ได้เฝ้าดู signal ใด\n- `~watching~`: Watcher กำลังเฝ้าดู signals อยู่ แต่ยังไม่มีการเปลี่ยนแปลงใดที่จำเป็นต้องเรียก `notify` callback\n- `~pending~`: มี dependency ของ Watcher เปลี่ยนแปลง แต่ยังไม่ได้ run `notify` callback\n\nกราฟการเปลี่ยนสถานะเป็นดังนี้:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nการเปลี่ยนสถานะมีดังนี้:\n| หมายเลข | จาก | ไป | เงื่อนไข | อัลกอริทึม |\n| ------- | --- | -- | -------- | ---------- |\n| 1 | `~waiting~` | `~watching~` | มีการเรียกใช้เมธอด `watch` ของ Watcher | เมธอด: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | มีการเรียกใช้เมธอด `unwatch` ของ Watcher และสัญญาณที่เฝ้าดูตัวสุดท้ายถูกลบออก | เมธอด: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | signal ที่เฝ้าดูอาจมีการเปลี่ยนค่า | เมธอด: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | มีการ run `notify` callback | เมธอด: `Signal.State.prototype.set(newValue)` |\n\n#### slot ภายในของ `Signal.subtle.Watcher`\n\n- `state`: อาจเป็น `~watching~`, `~pending~` หรือ `~waiting~`\n- `signals`: ชุดของ Signals ที่ Watcher นี้กำลังเฝ้าดู เรียงตามลำดับ\n- `notifyCallback`: callback ที่ถูกเรียกเมื่อมีการเปลี่ยนแปลงบางอย่าง กำหนดจากพารามิเตอร์แรกที่ส่งให้ constructor\n\n#### คอนสตรัคเตอร์: `new Signal.subtle.Watcher(callback)`\n\n1. กำหนด `state` เป็น `~waiting~`\n1. กำหนด `signals` ให้เป็นชุดว่าง\n1. กำหนด `notifyCallback` เป็น callback ที่ได้รับเป็นพารามิเตอร์",
  "status": "ok"
}