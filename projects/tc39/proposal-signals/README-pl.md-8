{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q**: Czy Sygnały współpracują z jednokierunkowym przepływem danych, tak jak React?\n\n**A**: Tak, Sygnały są mechanizmem jednokierunkowego przepływu danych. Frameworki UI oparte na sygnałach pozwalają wyrazić widok jako funkcję modelu (gdzie model obejmuje sygnały). Graf stanu i obliczanych sygnałów jest z założenia acykliczny. Możliwe jest także odtworzenie antywzorców znanych z Reacta w ramach sygnałów (!), np. sygnałowy odpowiednik `setState` wewnątrz `useEffect` to użycie Watchera do zaplanowania zapisu do sygnału typu State.\n\n**Q**: Jak sygnały mają się do systemów zarządzania stanem, takich jak Redux? Czy sygnały promują nieustrukturyzowany stan?\n\n**A**: Sygnały mogą stanowić wydajną podstawę do budowy abstrakcji magazynu stanu (store-like state management). Powszechnym wzorcem spotykanym w wielu frameworkach jest obiekt oparty na Proxy, który wewnętrznie reprezentuje właściwości za pomocą sygnałów, np. [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive) lub [Solid stores](https://docs.solidjs.com/concepts/stores). Systemy te umożliwiają elastyczne grupowanie stanu na odpowiednim poziomie abstrakcji dla konkretnej aplikacji.\n\n**Q**: Co oferują sygnały, czego `Proxy` obecnie nie obsługuje?\n\n**A**: Proxy i sygnały się uzupełniają i dobrze ze sobą współpracują. Proxy pozwala przechwytywać płytkie operacje na obiektach, a sygnały koordynują graf zależności (komórek). Podstawienie Proxy na sygnałach to świetny sposób na stworzenie zagnieżdżonej reaktywnej struktury o wysokiej ergonomii.\n\nW tym przykładzie możemy użyć proxy, aby sygnał miał właściwość getter i setter zamiast używać metod `get` i `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// użycie w hipotetycznym kontekście reaktywnym:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>zmień</button>\n</template>\n```\nprzy użyciu rendererów zoptymalizowanych pod kątem reaktywności o wysokiej szczegółowości, kliknięcie przycisku spowoduje aktualizację komórki `b.value`.\n\nZobacz:\n- przykłady zagnieżdżonych reaktywnych struktur tworzonych zarówno z sygnałami, jak i Proxy: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- przykłady wcześniejszych implementacji pokazujących relację między danymi reaktywnymi a proxy: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [dyskusja](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Jak działają sygnały?\n\n**Q**: Czy sygnały są oparte na mechanizmie push czy pull?\n\n**A**: Ewaluacja obliczanych sygnałów jest oparta na pull: sygnały obliczane są ewaluowane tylko wtedy, gdy wywoływane jest `.get()`, nawet jeśli stan bazowy zmienił się dużo wcześniej. Jednocześnie zmiana sygnału typu State może natychmiast wywołać callback Watchera, „wypychając” powiadomienie. Sygnały można więc uznać za konstrukcję „push-pull”.\n\n**Q**: Czy sygnały wprowadzają niedeterministyczność do działania JavaScript?\n\n**A**: Nie. Wszystkie operacje na sygnałach mają dobrze zdefiniowaną semantykę i kolejność, i nie będą się różnić między zgodnymi implementacjami. Na wyższym poziomie sygnały przestrzegają pewnych niezmienników, względem których są „poprawne”. Sygnał obliczany zawsze widzi graf sygnałów w spójnym stanie, a jego wykonywanie nie jest przerywane przez inny kod modyfikujący sygnały (poza tym, który sam wywołuje). Patrz opis powyżej.\n\n**Q**: Kiedy, po zapisie do sygnału stanu, planowana jest aktualizacja sygnału obliczanego?\n\n**A**: Nie jest planowana! Sygnał obliczany przeliczy się przy następnym odczycie. Sygonicznie, callback Watchera może być wywołany, co pozwala frameworkom zaplanować odczyt w odpowiednim dla nich momencie.\n\n**Q**: Kiedy zapisy do sygnałów stanu mają efekt? Natychmiast, czy są grupowane?\n\n**A**: Zapisy do sygnałów stanu są odzwierciedlane natychmiast — przy kolejnym odczycie sygnału obliczanego zależnego od tego stanu, sygnał obliczany przeliczy się jeśli będzie to potrzebne, nawet w następnej linii kodu. Jednak leniwość mechanizmu (obliczane sygnały są liczone tylko przy odczycie) sprawia, że w praktyce obliczenia mogą być wykonywane grupowo.\n\n**Q**: Co oznacza, że sygnały umożliwiają „wykonywanie bez zakłóceń” (glitch-free)?\n\n**A**: Wcześniejsze modele reaktywności oparte na push napotykały problem zbędnych obliczeń: jeśli aktualizacja sygnału stanu powoduje natychmiastowe przeliczenie sygnału obliczanego, ostatecznie może to wypchnąć aktualizację do UI. Ale ten zapis do UI może być przedwczesny, jeśli za chwilę nastąpi kolejna zmiana sygnału stanu przed kolejną klatką. Czasami nieprawidłowe wartości pośrednie były nawet widoczne dla użytkowników końcowych z powodu takich [zakłóceń](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Sygnały unikają tego zjawiska dzięki mechanizmowi pull, a nie push: w momencie, gdy framework planuje renderowanie UI, pobiera odpowiednie aktualizacje, unikając zbędnej pracy zarówno w obliczeniach, jak i przy zapisie do DOM.\n\n**Q**: Co oznacza, że sygnały są „utratne” (lossy)?\n\n**A**: To druga strona braku zakłóceń: sygnały reprezentują komórkę danych — tylko bieżącą wartość (która może się zmieniać), a nie strumień danych w czasie. Więc jeśli zapiszesz do sygnału stanu dwukrotnie z rzędu bez innych operacji, pierwszy zapis jest „utracony” i nigdy nie zostanie zauważony przez sygnały obliczane lub efekty. Jest to uznawane za zaletę, a nie błąd — do strumieni danych bardziej odpowiednie są inne konstrukty (np. asynchroniczne iteratory, obserwowalne).\n\n**Q**: Czy natywne sygnały będą szybsze niż obecne implementacje sygnałów w JS?\n\n**A**: Mamy nadzieję, że tak (o niewielki stały czynnik), ale to trzeba jeszcze udowodnić w kodzie. Silniki JS nie są magiczne i ostatecznie będą musiały implementować te same algorytmy co implementacje sygnałów w JS. Patrz sekcja powyżej o wydajności.\n\n#### Dlaczego sygnały zostały zaprojektowane w ten sposób?\n\n**Q**: Dlaczego ta propozycja nie zawiera funkcji `effect()`, skoro efekty są niezbędne do praktycznego użycia sygnałów?\n\n**A**: Efekty są nierozłącznie związane z planowaniem i usuwaniem, które zarządzane są przez frameworki i wykraczają poza zakres tej propozycji. Zamiast tego ta propozycja obejmuje podstawy do implementacji efektów poprzez niższopoziomowe API `Signal.subtle.Watcher`.\n\n**Q**: Dlaczego subskrypcje są automatyczne, a nie poprzez ręczny interfejs?\n\n**A**: Doświadczenie pokazuje, że ręczne interfejsy subskrypcji w reaktywności są nieergonomiczne i podatne na błędy. Automatyczne śledzenie jest bardziej składane i stanowi podstawową cechę sygnałów.\n\n**Q**: Dlaczego callback Watchera jest wykonywany synchronicznie, a nie planowany w mikro-zadaniu?\n\n**A**: Ponieważ callback nie może czytać ani zapisywać sygnałów, wywoływanie go synchronicznie nie wprowadza niepoprawności. Typowy callback dodaje sygnał do tablicy do późniejszego odczytu lub ustawia gdzieś bit. Nie ma potrzeby, ani praktycznego sensu, tworzyć osobne mikro-zadanie dla tego typu akcji.\n\n**Q**: W tym API brakuje pewnych udogodnień obecnych w moim ulubionym frameworku, które ułatwiają programowanie z sygnałami. Czy to też może zostać dodane do standardu?\n\n**A**: Może. Różne rozszerzenia są nadal rozważane. Prosimy o zgłaszanie problemów, jeśli uznasz, że jakaś brakująca funkcja jest ważna.\n\n**Q**: Czy to API można uprościć lub zmniejszyć?\n\n**A**: Zdecydowanie dążymy do tego, by API było minimalne, i staraliśmy się to osiągnąć w przedstawionej powyżej formie. Jeśli masz pomysły na kolejne rzeczy, które można usunąć, zgłoś problem do dyskusji.\n\n#### Jak sygnały są standaryzowane?\n\n**Q**: Czy nie powinniśmy rozpocząć prac standaryzacyjnych w tym obszarze od bardziej prymitywnego konceptu, jak obserwowalne?",
  "status": "ok"
}