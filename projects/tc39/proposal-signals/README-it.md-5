{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Mostrare un esempio di conversione di un Observable in un segnale computed, sottoscritto solo quando utilizzato da un effetto\n\nTODO: Mostrare un esempio di un segnale computed che rappresenta il risultato di una fetch indirizzata a uno stato, che viene annullata\n\n### Introspezione per SSR\n\nTODO: Mostrare come funziona la serializzazione del grafo dei segnali\n\nTODO: Mostrare come si può \"idratare\" un segnale da stato a computed successivamente, utilizzando alcuni segnali.\n-->\n\n### Omissi per ora\n\nQueste funzionalità potrebbero essere aggiunte in seguito, ma non sono incluse nell'attuale bozza. La loro omissione è dovuta alla mancanza di un consenso stabilito nello spazio di progettazione tra i framework, nonché alla dimostrata capacità di aggirare la loro assenza con meccanismi costruiti sopra la nozione di Signals descritta in questo documento. Tuttavia, sfortunatamente, l'omissione limita il potenziale di interoperabilità tra i framework. Man mano che vengono prodotti prototipi di Signals come descritto in questo documento, ci sarà uno sforzo per riesaminare se queste omissioni sono state la decisione appropriata.\n\n* **Async**: I segnali sono sempre disponibili in modo sincrono per la valutazione, in questo modello. Tuttavia, è spesso utile avere alcuni processi asincroni che portano all'impostazione di un segnale e comprendere quando un segnale è ancora in \"caricamento\". Un modo semplice per modellare lo stato di caricamento è tramite eccezioni, e il comportamento di caching delle eccezioni dei segnali computed si compone in modo ragionevole con questa tecnica. Tecniche migliorate sono discusse in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transazioni**: Per le transizioni tra viste, è spesso utile mantenere uno stato attivo sia per lo stato di \"partenza\" che per quello di \"arrivo\". Lo stato \"di arrivo\" viene renderizzato in background, fino a quando non è pronto per essere scambiato (commettendo la transazione), mentre lo stato \"di partenza\" rimane interattivo. Mantenere entrambi gli stati contemporaneamente richiede il \"fork\" dello stato del grafo dei segnali, e potrebbe persino essere utile supportare più transizioni in sospeso contemporaneamente. Discussione in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nAnche alcuni possibili [metodi di convenienza](https://github.com/proposal-signals/proposal-signals/issues/32) sono omessi.\n\n## Stato e piano di sviluppo\n\nQuesta proposta è all'ordine del giorno di TC39 per aprile 2024 per lo Stage 1. Attualmente può essere considerata come \"Stage 0\".\n\n[Un polyfill](https://github.com/proposal-signals/signal-polyfill) per questa proposta è disponibile, con alcuni test di base. Alcuni autori di framework hanno iniziato a sperimentare la sostituzione di questa implementazione di signal, ma questo utilizzo è in una fase iniziale.\n\nI collaboratori della proposta Signal vogliono essere particolarmente **conservativi** su come portiamo avanti questa proposta, per evitare di ritrovarci nella trappola di far uscire qualcosa di cui finiremmo per pentirci e che poi non verrebbe effettivamente utilizzato. Il nostro piano è di svolgere le seguenti attività extra, non richieste dal processo TC39, per assicurarci che questa proposta sia sulla strada giusta:\n\nPrima di proporre per lo Stage 2, intendiamo:\n- Sviluppare più implementazioni polyfill di livello produttivo che siano solide, ben testate (ad esempio, superando i test di vari framework oltre a test di tipo test262) e competitive in termini di prestazioni (come verificato con un set approfondito di benchmark signal/framework).\n- Integrare la Signal API proposta in un gran numero di framework JS che riteniamo rappresentativi, e far lavorare alcune grandi applicazioni su questa base. Testare che funzioni in modo efficiente e corretto in questi contesti.\n- Avere una solida comprensione dello spazio delle possibili estensioni dell'API, e aver concluso quali (se ce ne sono) dovrebbero essere aggiunte a questa proposta.\n\n## Algoritmi Signal\n\nQuesta sezione descrive ciascuna delle API esposte a JavaScript, in termini degli algoritmi che implementano. Questo può essere considerato come una proto-specifica, ed è incluso già in questa fase per fissare un possibile insieme di semantiche, restando molto aperti ai cambiamenti.\n\nAlcuni aspetti dell'algoritmo:\n- L'ordine delle letture dei Signals all'interno di un computed è significativo, ed è osservabile nell'ordine in cui vengono eseguite alcune callback (quando viene invocato `Watcher`, `equals`, il primo parametro di `new Signal.Computed`, e le callback `watched`/`unwatched`). Ciò significa che le sorgenti di un Signal computed devono essere memorizzate in modo ordinato.\n- Queste quattro callback possono tutte generare eccezioni, ed esse vengono propagate in modo prevedibile al codice JS chiamante. Le eccezioni *non* interrompono l'esecuzione di questo algoritmo né lasciano il grafo in uno stato parzialmente elaborato. Per gli errori lanciati nella callback `notify` di un Watcher, quell'eccezione viene inviata alla chiamata `.set()` che l'ha innescata, utilizzando un AggregateError se sono state sollevate più eccezioni. Le altre (incluse `watched`/`unwatched`?) sono memorizzate nel valore del Signal, per essere rilanciate quando letto, e un Signal che rilancia può essere marcato `~clean~` come qualsiasi altro con un valore normale.\n- Si presta attenzione ad evitare circolarità nei casi di segnali computed che non sono \"watched\" (osservati da alcun Watcher), così che possano essere raccolti dal garbage collector indipendentemente da altre parti del grafo dei segnali. Internamente, ciò può essere implementato con un sistema di numeri di generazione che vengono sempre raccolti; si noti che implementazioni ottimizzate possono anche includere numeri di generazione locali per nodo, o evitare di tracciare alcuni numeri su segnali watched.\n\n### Stato globale nascosto\n\nGli algoritmi Signal devono fare riferimento a determinati stati globali. Questo stato è globale per l'intero thread, o \"agente\".\n\n- `computing`: Il Signal computed o effect più interno attualmente in fase di ricalcolo a causa di una chiamata `.get` o `.run`, oppure `null`. Inizialmente `null`.\n- `frozen`: Booleano che indica se è attualmente in esecuzione una callback che richiede che il grafo non venga modificato. Inizialmente `false`.\n- `generation`: Un intero incrementale, che parte da 0, usato per tracciare quanto è aggiornato un valore evitando circolarità.\n\n### Lo spazio dei nomi `Signal`\n\n`Signal` è un oggetto ordinario che funge da spazio dei nomi per classi e funzioni relative ai Signal.\n\n`Signal.subtle` è un oggetto di spazio dei nomi interno simile.\n\n### La classe `Signal.State`\n\n#### Slot interni di `Signal.State`\n\n- `value`: Il valore attuale del signal di stato\n- `equals`: La funzione di confronto utilizzata quando si cambiano i valori\n- `watched`: La callback che viene chiamata quando il segnale viene osservato da un effect\n- `unwatched`: La callback che viene chiamata quando il segnale non è più osservato da un effect\n- `sinks`: Insieme dei segnali watched che dipendono da questo\n\n#### Costruttore: `Signal.State(initialValue, options)`\n\n1. Imposta il `value` di questo Signal su `initialValue`.\n1. Imposta il `equals` di questo Signal su options?.equals\n1. Imposta il `watched` di questo Signal su options?.[Signal.subtle.watched]\n1. Imposta il `unwatched` di questo Signal su options?.[Signal.subtle.unwatched]\n1. Imposta il `sinks` di questo Signal sull'insieme vuoto\n\n#### Metodo: `Signal.State.prototype.get()`\n\n1. Se `frozen` è true, solleva un'eccezione.\n1. Se `computing` non è `undefined`, aggiungi questo Signal all'insieme `sources` di `computing`.\n1. NOTA: Non aggiungiamo `computing` all'insieme `sinks` di questo Signal finché non viene osservato da un Watcher.\n1. Restituisci il `value` di questo Signal.\n\n#### Metodo: `Signal.State.prototype.set(newValue)`\n\n1. Se il contesto di esecuzione attuale è `frozen`, solleva un'eccezione.\n1. Esegui l'algoritmo \"set Signal value\" con questo Signal e il primo parametro per il valore.\n1. Se quell'algoritmo ha restituito `~clean~`, allora restituisci undefined.\n1. Imposta lo `state` di tutti i `sinks` di questo Signal a (se è un Signal Computed) `~dirty~` se erano precedentemente clean, oppure (se è un Watcher) `~pending~` se era precedentemente `~watching~`.\n1. Imposta lo `state` di tutte le dipendenze Computed Signal dei sinks (ricorsivamente) a `~checked~` se erano precedentemente `~clean~` (cioè, lascia i segni di dirty al loro posto), oppure per i Watcher, `~pending~` se precedentemente `~watching~`.\n1. Per ogni Watcher precedentemente `~watching~` incontrato in quella ricerca ricorsiva, quindi in ordine di profondità,\n    1. Imposta `frozen` su true.\n    1. Chiama la loro callback `notify` (salvando da parte qualsiasi eccezione sollevata, ma ignorando il valore restituito di `notify`).\n    1. Ripristina `frozen` su false.\n    1. Imposta lo `state` del Watcher su `~waiting~`.\n1. Se è stata sollevata qualche eccezione dalle callback `notify`, propagala al chiamante dopo che tutte le callback `notify` sono state eseguite. Se ci sono più eccezioni, raggruppale in un AggregateError e sollevalo.\n1. Restituisci undefined.\n\n### La classe `Signal.Computed`\n\n#### Macchina a stati di `Signal.Computed`",
  "status": "ok"
}