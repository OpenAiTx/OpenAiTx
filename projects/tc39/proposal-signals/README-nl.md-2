{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Automatische afhankelijkheidstracering** - Een berekende Signaal ontdekt automatisch van welke andere Signalen hij afhankelijk is, of dat nu eenvoudige waarden zijn of andere berekeningen.\n* **Lui evalueren** - Berekeningen worden niet direct geëvalueerd wanneer ze worden gedeclareerd, noch worden ze onmiddellijk geëvalueerd wanneer hun afhankelijkheden veranderen. Ze worden alleen geëvalueerd wanneer hun waarde expliciet wordt opgevraagd.\n* **Memoization** - Berekende Signalen cachen hun laatste waarde zodat berekeningen waarvan de afhankelijkheden niet zijn gewijzigd, niet opnieuw hoeven te worden geëvalueerd, ongeacht hoe vaak ze worden benaderd.\n\n## Motivatie voor standaardisatie van Signalen\n\n#### Interoperabiliteit\n\nElke Signaal-implementatie heeft zijn eigen automatische traceringmechanisme om de bronnen bij te houden die worden aangetroffen bij het evalueren van een berekend Signaal. Dit maakt het moeilijk om modellen, componenten en bibliotheken te delen tussen verschillende frameworks—ze zijn vaak valselijk gekoppeld aan hun view-engine (aangezien Signalen meestal als onderdeel van JS-frameworks worden geïmplementeerd).\n\nEen doel van dit voorstel is om het reactieve model volledig los te koppelen van de rendering-view, zodat ontwikkelaars kunnen migreren naar nieuwe renderingtechnologieën zonder hun niet-UI-code te herschrijven, of gedeelde reactieve modellen in JS kunnen ontwikkelen om te worden ingezet in verschillende contexten. Helaas is het door versiebeheer en duplicatie onpraktisch gebleken om een hoog niveau van delen te bereiken via JS-niveau bibliotheken—ingebouwde functionaliteit biedt een sterkere garantie voor delen.\n\n#### Prestaties/geheugengebruik\n\nHet levert altijd een klein potentieel prestatievoordeel op als er minder code hoeft te worden meegeleverd doordat veelgebruikte bibliotheken ingebouwd zijn, maar implementaties van Signalen zijn over het algemeen vrij klein, dus we verwachten niet dat dit effect erg groot is.\n\nWe vermoeden dat native C++-implementaties van signaalgerelateerde datastructuren en algoritmen iets efficiënter kunnen zijn dan wat in JS haalbaar is, met een constante factor. Er worden echter geen algoritmische veranderingen verwacht ten opzichte van wat in een polyfill aanwezig zou zijn; van engines wordt niet verwacht dat ze hier magisch zijn, en de reactiviteitsalgoritmen zelf zullen goed gedefinieerd en ondubbelzinnig zijn.\n\nDe championgroep verwacht verschillende implementaties van Signalen te ontwikkelen en deze te gebruiken om deze prestatiemogelijkheden te onderzoeken.\n\n#### DevTools\n\nMet bestaande JS-taal Signaal-bibliotheken kan het moeilijk zijn om zaken als het volgende te traceren:\n* De callstack over een keten van berekende Signalen, die de causale keten voor een fout toont\n* De referentiegrafiek tussen Signalen, wanneer het ene Signaal afhankelijk is van een ander — belangrijk bij het debuggen van geheugengebruik\n\nIngebouwde Signalen stellen JS-runtimes en DevTools in staat om mogelijk betere ondersteuning te bieden voor het inspecteren van Signalen, met name voor debugging of prestatieanalyse, of dit nu is ingebouwd in browsers of via een gedeelde extensie. Bestaande tools zoals de elementinspector, performance snapshot en geheugenprofilers kunnen worden bijgewerkt om specifiek Signalen te markeren in hun presentatie van informatie.\n\n#### Secundaire voordelen\n\n##### Voordelen van een standaardbibliotheek\n\nOver het algemeen had JavaScript een vrij minimale standaardbibliotheek, maar een trend binnen TC39 is om van JS meer een \"batterijen-inbegrepen\" taal te maken, met een hoogwaardige ingebouwde set functionaliteiten. Zo vervangt Temporal moment.js, en een aantal kleine functies, zoals `Array.prototype.flat` en `Object.groupBy`, vervangen veel lodash-use-cases. Voordelen zijn onder meer kleinere bundelgroottes, verbeterde stabiliteit en kwaliteit, minder te leren bij het toetreden tot een nieuw project en een algemeen gedeelde vocabulaire onder JS-ontwikkelaars.\n\n##### HTML/DOM-integratie (een toekomstige mogelijkheid)\n\nHuidig werk binnen W3C en door browserbouwers richt zich op het brengen van native templating naar HTML ([DOM Parts][wicg-pr-1023] en [Template Instantiation][wicg-propsal-template-instantiation]). Daarnaast onderzoekt de W3C Web Components CG de mogelijkheid om Web Components uit te breiden met een volledig declaratieve HTML-API. Voor beide doelen zal uiteindelijk een reactief primitieven nodig zijn in HTML. Daarnaast zijn veel ergonomische verbeteringen aan de DOM door integratie van Signalen denkbaar en ook gevraagd door de gemeenschap.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Let op, deze integratie zou een apart traject zijn dat later volgt, en maakt geen deel uit van dit voorstel zelf.\n\n##### Informatie-uitwisseling binnen het ecosysteem (*geen* reden om te shippen)\n\nStandaardisatie-inspanningen kunnen soms al op \"community\"-niveau nuttig zijn, zelfs zonder veranderingen in browsers. De Signalen-inspanning brengt veel verschillende frameworkauteurs samen voor een diepgaand gesprek over de aard van reactiviteit, algoritmen en interoperabiliteit. Dit is al nuttig gebleken, maar rechtvaardigt geen opname in JS-engines en browsers; Signalen mogen alleen aan de JavaScript-standaard worden toegevoegd als er significante voordelen zijn *buiten* de informatie-uitwisseling binnen het ecosysteem.\n\n## Ontwerpdoelen voor Signalen\n\nHet blijkt dat bestaande Signaalbibliotheken in de kern niet zo veel van elkaar verschillen. Dit voorstel wil voortbouwen op hun succes door de belangrijke kwaliteiten van veel van die bibliotheken te implementeren.\n\n### Kernfeatures\n\n* Een Signaaltype dat staat vertegenwoordigt, d.w.z. een schrijfbaar Signaal. Dit is een waarde die anderen kunnen lezen.\n* Een computed/memo/afgeleid Signaaltype, dat afhankelijk is van andere en lui wordt berekend en gecached.\n    * De berekening is lui, wat betekent dat berekende Signalen standaard niet opnieuw worden berekend wanneer een van hun afhankelijkheden verandert, maar alleen worden uitgevoerd als iemand ze daadwerkelijk leest.\n    * De berekening is \"[glitch](https://nl.wikipedia.org/wiki/Reactive_programming#Glitches)-vrij\", wat betekent dat er nooit onnodige berekeningen worden uitgevoerd. Dit impliceert dat, wanneer een applicatie een berekend Signaal leest, er een topologische sortering wordt uitgevoerd van de mogelijk vervuilde delen van de graaf die moeten draaien, om dubbele bewerkingen te elimineren.\n    * De berekening wordt gecached, wat betekent dat als, sinds de laatste keer dat een afhankelijkheid is gewijzigd, er geen afhankelijkheden zijn gewijzigd, het berekende Signaal *niet* opnieuw wordt berekend wanneer het wordt benaderd.\n    * Aangepaste vergelijkingen zijn mogelijk voor zowel berekende Signalen als toestandssignalen, om te bepalen wanneer verdere berekende Signalen die ervan afhankelijk zijn moeten worden bijgewerkt.\n* Reacties op de situatie waarin een berekend Signaal een van zijn afhankelijkheden (of geneste afhankelijkheden) \"vervuild\" raakt en verandert, wat betekent dat de waarde van het Signaal mogelijk verouderd is.\n    * Deze reactie is bedoeld om meer significant werk later in te plannen.\n    * Effecten worden geïmplementeerd in termen van deze reacties, plus planningsmechanismen op framework-niveau.\n    * Berekende signalen moeten kunnen reageren op de vraag of ze geregistreerd zijn als een (geneste) afhankelijkheid van een van deze reacties.\n* JS-frameworks in staat stellen hun eigen planning te doen. Geen Promise-achtige ingebouwde, verplichte planning.\n    * Synchrone reacties zijn nodig om het later inplannen van werk op basis van frameworklogica mogelijk te maken.\n    * Schrijfbewerkingen zijn synchroon en hebben direct effect (een framework dat schrijfbewerkingen wil batchen kan dat erbovenop doen).\n    * Het is mogelijk om te scheiden of een effect \"vervuild\" kan zijn van het daadwerkelijk uitvoeren van het effect (dit maakt een tweefasige effect-planner mogelijk).\n* Mogelijkheid om Signalen te lezen *zonder* dat afhankelijkheden worden geregistreerd (`untrack`)\n* Samenstelling van verschillende codebases die Signalen/reactiviteit gebruiken mogelijk maken, bijvoorbeeld\n    * Meerdere frameworks samen gebruiken wat betreft tracking/reactiviteit zelf (behoudens uitzonderingen, zie hieronder)\n    * Framework-onafhankelijke reactieve datastructuren (bijvoorbeeld recursieve reactieve store-proxy, reactieve Map en Set en Array, enz.)\n\n### Soundness\n\n* Ontraden/verbieden van naïef misbruik van synchrone reacties.\n    * Risico voor soundness: het kan \"[glitches](https://nl.wikipedia.org/wiki/Reactive_programming#Glitches)\" blootstellen bij onjuist gebruik: Als rendering direct gebeurt wanneer een Signaal wordt gezet, kan het onvolledige applicatietoestand tonen aan de eindgebruiker. Deze functie moet daarom alleen worden gebruikt om werk voor later intelligent in te plannen, nadat de applicatielogica klaar is.\n    * Oplossing: Het lezen en schrijven van een Signaal vanuit een synchrone reactiecallback verbieden.\n* Ontraden van `untrack` en het markeren van het onveilige karakter ervan\n    * Risico voor soundness: staat toe dat berekende Signalen worden gemaakt waarvan de waarde afhankelijk is van andere Signalen, maar die niet worden bijgewerkt als die Signalen veranderen. Het moet alleen worden gebruikt als de ongevolgde toegang geen invloed heeft op het resultaat van de berekening.\n    * Oplossing: De API wordt als \"onveilig\" aangeduid in de naam.\n* Opmerking: Dit voorstel staat toe dat signalen zowel gelezen als geschreven kunnen worden vanuit berekende en effect-signalen, zonder beperkingen op schrijfbewerkingen na lezingen, ondanks het soundness-risico. Deze beslissing is genomen om flexibiliteit en compatibiliteit in de integratie met frameworks te behouden.\n\n### Surface API\n\n* Moet een solide basis zijn voor meerdere frameworks om hun Signalen/reactiviteitsmechanismen te implementeren.\n    * Moet een goede basis vormen voor recursieve store-proxies, decorator-gebaseerde class field reactiviteit, en zowel `.value` als `[state, setState]`-achtige APIs.\n    * De semantiek kan de geldige patronen uitdrukken die door verschillende frameworks mogelijk worden gemaakt. Bijvoorbeeld, het moet mogelijk zijn dat deze Signalen de basis vormen voor direct gereflecteerde schrijfbewerkingen of schrijfbewerkingen die worden gebundeld en later toegepast.\n* Het zou fijn zijn als deze API direct bruikbaar is door JavaScript-ontwikkelaars.\n    * Als een functie overeenkomt met een ecosysteemconcept, is het goed om gemeenschappelijke vocabulaire te gebruiken.\n        * Het is echter belangrijk om niet letterlijk exact dezelfde namen te gebruiken!\n    * Spanning tussen \"bruikbaarheid voor JS-ontwikkelaars\" en \"alle hooks bieden voor frameworks\"\n        * Idee: Bied alle hooks, maar voeg waar mogelijk fouten toe bij verkeerd gebruik.\n        * Idee: Plaats subtiele APIs in een `subtle` namespace, vergelijkbaar met [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), om het verschil te markeren tussen APIs die nodig zijn voor geavanceerd gebruik zoals frameworkimplementatie of devtools, versus APIs voor dagelijks applicatiegebruik zoals het instantiëren van signalen voor gebruik met een framework.\n* Moet implementeerbaar en bruikbaar zijn met goede prestaties — de surface API veroorzaakt niet te veel overhead\n    * Sta subklassen toe, zodat frameworks hun eigen methodes en velden kunnen toevoegen, inclusief private velden. Dit is belangrijk om extra allocaties op frameworkniveau te voorkomen. Zie \"Memory management\" hieronder.\n\n### Geheugenbeheer\n\n* Indien mogelijk: Een berekend Signaal moet door de garbage collector kunnen worden opgeruimd als er niets levends naar verwijst voor mogelijke toekomstige lezingen, zelfs als het is gekoppeld aan een bredere graaf die actief blijft (bijvoorbeeld door het lezen van een status die actief blijft).",
  "status": "ok"
}