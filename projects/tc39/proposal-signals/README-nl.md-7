{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Met [AsyncContext](https://github.com/tc39/proposal-async-context) sluit de callback die aan `new Signal.subtle.Watcher` wordt doorgegeven *niet* aan bij de snapshot van het moment waarop de constructor werd aangeroepen, zodat contextuele informatie rond de schrijfoperatie zichtbaar is.\n\n#### Methode: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Als `frozen` waar is, gooi een uitzondering.\n1. Als een van de argumenten geen signaal is, gooi een uitzondering.\n1. Voeg alle argumenten toe aan het einde van de `signals` van dit object.\n1. Voor elk nieuw bekeken signaal, van links naar rechts,\n    1. Voeg deze watcher toe als een `sink` aan dat signaal.\n    1. Als dit de eerste sink was, ga dan recursief naar boven naar de bronnen om dat signaal als sink toe te voegen.\n    1. Zet `frozen` op waar.\n    1. Roep de `watched` callback aan indien deze bestaat.\n    1. Herstel `frozen` naar onwaar.\n1. Als de `state` van het Signaal `~waiting~` is, zet deze dan op `~watching~`.\n\n#### Methode: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Als `frozen` waar is, gooi een uitzondering.\n1. Als een van de argumenten geen signaal is, of niet door deze watcher wordt bekeken, gooi een uitzondering.\n1. Voor elk signaal in de argumenten, van links naar rechts,\n    1. Verwijder dat signaal uit de `signals`-set van deze Watcher.\n    1. Verwijder deze Watcher uit de `sink`-set van dat Signaal.\n    1. Als de `sink`-set van dat Signaal leeg is geworden, verwijder dat Signaal dan als sink uit elk van zijn bronnen.\n    1. Zet `frozen` op waar.\n    1. Roep de `unwatched` callback aan indien deze bestaat.\n    1. Herstel `frozen` naar onwaar.\n1. Als de watcher nu geen `signals` meer heeft, en zijn `state` is `~watching~`, zet deze dan op `~waiting~`.\n\n#### Methode: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Retourneer een Array met het deel van `signals` dat Computed Signals zijn met de status `~dirty~` of `~pending~`.\n\n### Methode: `Signal.subtle.untrack(cb)`\n\n1. Laat `c` de huidige `computing` state van de uitvoeringscontext zijn.\n1. Zet `computing` op null.\n1. Roep `cb` aan.\n1. Herstel `computing` naar `c` (ook als `cb` een uitzondering gooide).\n1. Retourneer de returnwaarde van `cb` (gooi eventuele uitzondering opnieuw).\n\nOpmerking: untrack haalt je niet uit de `frozen`-status, die strikt wordt gehandhaafd.\n\n### Methode: `Signal.subtle.currentComputed()`\n\n1. Retourneer de huidige `computing` waarde.\n\n### Algemene algoritmen\n\n##### Algoritme: herbereken dirty computed Signal\n\n1. Maak de `sources`-set van dit Signaal leeg en verwijder het uit de `sinks`-sets van die bronnen.\n1. Bewaar de vorige `computing`-waarde en zet `computing` op dit Signaal.\n1. Zet de state van dit Signaal op `~computing~`.\n1. Voer de callback van dit computed Signaal uit, gebruik dit Signaal als de this-waarde. Bewaar de returnwaarde, en als de callback een uitzondering gooide, sla die op voor hergooien.\n1. Herstel de vorige `computing`-waarde.\n1. Pas het \"set Signal value\"-algoritme toe op de returnwaarde van de callback.\n2. Zet de state van dit Signaal op `~clean~`.\n1. Als dat algoritme `~dirty~` retourneerde: markeer alle sinks van dit Signaal als `~dirty~` (voorheen konden de sinks een mix zijn van checked en dirty). (Of, als dit niet bekeken wordt, neem dan een nieuw generatienummer aan om vuilheid aan te geven, of iets dergelijks.)\n1. Anders, als dat algoritme `~clean~` retourneerde: Markeer in dit geval voor elke `~checked~` sink van dit Signaal, als al zijn bronnen nu schoon zijn, dat Signaal ook als `~clean~`. Pas deze opruimstap recursief toe op verdere sinks, op alle nieuw schone Signals die gecontroleerde sinks hebben. (Of, als dit niet bekeken wordt, geef dit op een of andere manier aan, zodat de opruiming uitgesteld kan doorgaan.)\n\n##### Set Signal value algoritme\n\n1. Als aan dit algoritme een waarde is doorgegeven (in tegenstelling tot een uitzondering voor hergooien, uit het recalculate dirty computed Signal algoritme):\n    1. Roep de `equals`-functie van dit Signaal aan, met als parameters de huidige `value`, de nieuwe waarde, en dit Signaal. Als een uitzondering wordt gegooid, sla die uitzondering op (voor hergooien bij lezen) als de waarde van het Signaal en ga verder alsof de callback false had teruggegeven.\n    1. Als die functie true retourneert, retourneer `~clean~`.\n1. Zet de `value` van dit Signaal op de parameter.\n1. Retourneer `~dirty~`\n\n## FAQ\n\n**V**: Is het niet wat vroeg om iets te standaardiseren rond Signals, terwijl ze pas sinds 2022 een hype zijn? Moeten we ze niet meer tijd geven om te evolueren en te stabiliseren?\n\n**A**: De huidige status van Signals in webframeworks is het resultaat van meer dan 10 jaar continue ontwikkeling. Nu de investeringen toenemen, zoals in de afgelopen jaren, naderen bijna alle webframeworks een zeer vergelijkbaar kernmodel van Signals. Dit voorstel is het resultaat van een gedeelde ontwerp-oefening tussen een groot aantal huidige leiders in webframeworks, en zal niet worden doorgezet naar standaardisatie zonder de validatie van die groep domeinexperts in diverse contexten.\n\n#### Hoe worden Signals gebruikt?\n\n**V**: Kunnen ingebouwde Signals überhaupt door frameworks worden gebruikt, gezien hun nauwe integratie met rendering en eigenaarschap?\n\n**A**: De onderdelen die meer frameworkspecifiek zijn, bevinden zich vooral op het gebied van effecten, scheduling en eigenaarschap/opruiming, waar dit voorstel geen oplossing voor biedt. Onze eerste prioriteit met het prototypen van standards-track Signals is te valideren dat ze \"onder\" bestaande frameworks kunnen functioneren, compatibel en met goede prestaties.\n\n**V**: Is de Signal API bedoeld om direct door applicatie-ontwikkelaars te worden gebruikt, of om door frameworks te worden ingepakt?\n\n**A**: Hoewel deze API direct door applicatie-ontwikkelaars gebruikt kan worden (tenminste het deel dat niet binnen de `Signal.subtle` namespace valt), is hij niet ontworpen voor bijzondere ergonomie. In plaats daarvan staan de behoeften van bibliotheek/framework-auteurs voorop. De meeste frameworks zullen zelfs de basis-API’s `Signal.State` en `Signal.Computed` omwikkelen met iets dat hun ergonomische voorkeur uitdrukt. In de praktijk is het meestal het beste om Signals via een framework te gebruiken, dat lastigere functionaliteiten beheert (zoals Watcher, `untrack`), evenals eigenaarschap en opruiming (bijvoorbeeld bepalen wanneer signals aan watchers moeten worden toegevoegd of verwijderd), en het plannen van rendering naar de DOM--dit voorstel probeert die problemen niet op te lossen.\n\n**V**: Moet ik Signals die bij een widget horen afbreken wanneer die widget wordt vernietigd? Wat is de API daarvoor?\n\n**A**: De relevante teardown-operatie hier is `Signal.subtle.Watcher.prototype.unwatch`. Alleen bekeken Signals moeten worden opgeschoond (door ze te unwatchen), terwijl niet-bekeken Signals automatisch garbage-collected kunnen worden.\n\n**V**: Werken Signals met VDOM, of direct met de onderliggende HTML DOM?\n\n**A**: Ja! Signals zijn onafhankelijk van renderingtechnologie. Bestaande JavaScript-frameworks die Signal-achtige constructies gebruiken, integreren met VDOM (bijv. Preact), de native DOM (bijv. Solid) en een combinatie (bijv. Vue). Hetzelfde zal mogelijk zijn met ingebouwde Signals.\n\n**V**: Zal het ergonomisch zijn om Signals te gebruiken in de context van op klassen gebaseerde frameworks zoals Angular en Lit? En wat met compilergebaseerde frameworks zoals Svelte?\n\n**A**: Klassevelden kunnen Signal-based worden gemaakt met een eenvoudige accessor decorator, zoals te zien is in [de Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals sluiten zeer nauw aan bij Svelte 5's Runes--het is eenvoudig voor een compiler om runes naar de hier gedefinieerde Signal API te transformeren, en dit is in feite wat Svelte 5 intern doet (maar dan met een eigen Signals-bibliotheek).\n\n**V**: Werken Signals met SSR? Hydration? Resumability?\n\n**A**: Ja. Qwik gebruikt Signals zeer effectief met beide eigenschappen, en andere frameworks hebben andere goed ontwikkelde benaderingen voor hydration met Signals met verschillende trade-offs. We denken dat het mogelijk is om Qwik's resumable Signals te modelleren met een State en Computed signal die aan elkaar gekoppeld zijn, en zijn van plan dit in code te bewijzen.",
  "status": "ok"
}