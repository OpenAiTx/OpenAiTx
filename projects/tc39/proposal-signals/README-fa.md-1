{
  "id": 1,
  "origin": "# 🚦 JavaScript Signals standard proposal🚦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and more…\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# 🚦 پیشنهاد استاندارد سیگنال‌های جاوااسکریپت 🚦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nمرحله ۱ ([توضیح](https://tc39.es/process-document/))\n\nحامیان پیشنهاد TC39: دنیل ارنبرگ، یهودا کاتز، جاتین رامناتان، شی لوئیس، کریستن هول گرت، دومینیک گاناوی، پرستون سگو، میلو ام، راب آیزنبرگ\n\nنویسندگان اصلی: راب آیزنبرگ و دنیل ارنبرگ\n\nاین سند یک مسیر اولیه و مشترک برای سیگنال‌ها در جاوااسکریپت را توصیف می‌کند، مشابه تلاش Promises/A+ که پیش از استاندارد شدن Promiseها توسط TC39 در ES2015 انجام شد. خودتان امتحان کنید، با استفاده از [یک پلی‌فیل](https://github.com/proposal-signals/signal-polyfill).\n\nمشابه Promises/A+، این تلاش بر هم‌راستا کردن اکوسیستم جاوااسکریپت متمرکز است. اگر این هم‌راستایی موفقیت‌آمیز باشد، یک استاندارد می‌تواند بر اساس آن تجربه شکل بگیرد. چندین نویسنده فریم‌ورک در اینجا بر روی یک مدل مشترک همکاری می‌کنند که می‌تواند هسته ری‌اکتیویتی فریم‌ورک آن‌ها را پشتیبانی کند. پیش‌نویس فعلی بر اساس ورودی‌های طراحی نویسندگان/نگهدارندگان [Angular](https://angular.io/)، [Bubble](https://bubble.io/)، [Ember](https://emberjs.com/)، [FAST](https://www.fast.design/)، [MobX](https://mobx.js.org/)، [Preact](https://preactjs.com/)، [Qwik](https://qwik.dev/)، [RxJS](https://rxjs.dev/)، [Solid](https://www.solidjs.com/)، [Starbeam](https://www.starbeamjs.com/)، [Svelte](https://svelte.dev/)، [Vue](https://vuejs.org/)، [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a)، و دیگران بنا شده است…\n\nبرخلاف Promises/A+، ما سعی نداریم یک API سطح توسعه‌دهنده مشترک ارائه دهیم، بلکه بر مفاهیم دقیق هسته گراف سیگنال تمرکز داریم. این پیشنهاد شامل یک API کاملاً مشخص است، اما این API عمدتاً برای توسعه‌دهندگان برنامه‌های کاربردی هدف‌گذاری نشده است. در عوض، API سیگنال ارائه‌شده اینجا تناسب بهتری برای فریم‌ورک‌ها جهت توسعه بر پایه آن دارد و از طریق گراف سیگنال مشترک و مکانیزم خودکار ردیابی، قابلیت همکاری را فراهم می‌کند.\n\nبرنامه این پیشنهاد انجام نمونه‌سازی اولیه قابل توجه، از جمله یکپارچه‌سازی در چندین فریم‌ورک، پیش از پیشرفت به فراتر از مرحله ۱ است. ما تنها در صورتی به استانداردسازی سیگنال‌ها علاقه‌مندیم که آن‌ها برای استفاده عملی در چندین فریم‌ورک مناسب باشند و مزایای واقعی نسبت به سیگنال‌های ارائه‌شده توسط فریم‌ورک‌ها داشته باشند. امیدواریم نمونه‌سازی اولیه گسترده این اطلاعات را در اختیار ما قرار دهد. برای جزئیات بیشتر به بخش \"وضعیت و برنامه توسعه\" در ادامه مراجعه کنید.\n\n## پیش‌زمینه: چرا سیگنال‌ها؟\n\nبرای توسعه یک رابط کاربری (UI) پیچیده، توسعه‌دهندگان برنامه جاوااسکریپت نیاز دارند که وضعیت را ذخیره، محاسبه، ابطال، همگام‌سازی و به لایه نمایشی برنامه به شکل کارآمد انتقال دهند. رابط‌های کاربری معمولاً فقط مدیریت مقادیر ساده نیستند، بلکه اغلب رندر کردن وضعیت محاسبه‌شده‌ای که وابسته به یک درخت پیچیده از مقادیر یا وضعیت دیگر (که خود نیز محاسبه شده‌اند) را شامل می‌شوند. هدف سیگنال‌ها فراهم کردن زیرساخت برای مدیریت چنین وضعیت برنامه است تا توسعه‌دهندگان بتوانند بر منطق تجاری تمرکز کنند نه این جزئیات تکراری.\n\nساختارهایی شبیه به سیگنال به طور مستقل در زمینه‌های غیر-UI نیز مفید واقع شده‌اند، به ویژه در سیستم‌های ساخت (build systems) برای اجتناب از بازسازی‌های غیرضروری.\n\nسیگنال‌ها در برنامه‌نویسی واکنشی استفاده می‌شوند تا نیاز به مدیریت بروزرسانی در برنامه‌ها را حذف کنند.\n\n> یک مدل برنامه‌نویسی اعلانی برای بروزرسانی مبتنی بر تغییرات وضعیت.\n\nاز _[Reactivity چیست؟](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### مثال - شمارنده VanillaJS\n\nبا داشتن متغیری به نام `counter`، می‌خواهید در DOM نمایش دهید که شمارنده زوج است یا فرد. هر زمان که مقدار `counter` تغییر کند، می‌خواهید آخرین وضعیت زوج یا فرد بودن را در DOM بروزرسانی کنید. در جاوااسکریپت ساده، کد شما ممکن است به این صورت باشد:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// شبیه‌سازی بروزرسانی‌های خارجی به counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> از متغیرهای سراسری در اینجا فقط برای اهداف نمایشی استفاده شده است. راه‌حل‌های زیادی برای مدیریت صحیح وضعیت وجود دارد و مثال‌های این پیشنهاد به ساده‌ترین شکل ممکن ارائه شده‌اند. این پیشنهاد استفاده از متغیرهای سراسری را تشویق نمی‌کند.\n\n\nاین کد چندین مشکل دارد...\n\n* راه‌اندازی `counter` پر سر و صدا و شامل کد تکراری زیاد است.\n* وضعیت `counter` به طور محکم به سیستم رندر وابسته است.\n* اگر مقدار `counter` تغییر کند اما `parity` تغییر نکند (مثلاً مقدار شمارنده از ۲ به ۴ برود)، ما محاسبه غیرضروری وضعیت زوج/فرد و رندر غیرضروری انجام داده‌ایم.\n* اگر بخش دیگری از UI فقط بخواهد هنگام بروزرسانی `counter` رندر شود چه می‌شود؟\n* اگر بخش دیگری از UI فقط به `isEven` یا `parity` وابسته باشد چه؟\n\nحتی در این سناریوی نسبتاً ساده، مشکلات متعددی به سرعت بروز می‌کند. می‌توانیم سعی کنیم با معرفی pub/sub برای `counter` این مشکلات را دور بزنیم. این کار به مصرف‌کنندگان بیشتری از `counter` اجازه می‌دهد که واکنش‌های خود به تغییر وضعیت را اضافه کنند.\n\nبا این حال، هنوز با مشکلات زیر مواجه‌ایم:\n\n* تابع رندر که فقط به `parity` وابسته است باید \"بداند\" که در واقع باید به `counter` مشترک شود.\n* امکان بروزرسانی UI فقط بر اساس `isEven` یا `parity` بدون تعامل مستقیم با `counter` وجود ندارد.\n* حجم کد تکراری ما بیشتر شده است. هر زمان که چیزی را استفاده می‌کنید، دیگر فقط فراخوانی یک تابع یا خواندن یک متغیر نیست، بلکه باید اشتراک‌گذاری و بروزرسانی را مدیریت کنید. مدیریت لغو اشتراک هم به خصوص پیچیده است.\n\nاکنون می‌توانیم برخی مشکلات را با افزودن pub/sub نه فقط به `counter` بلکه به `isEven` و `parity` هم حل کنیم. در این صورت باید `isEven` را به `counter`، `parity` را به `isEven` و `render` را به `parity` مشترک کنیم. متاسفانه، نه تنها حجم کد تکراری ما بسیار زیاد می‌شود، بلکه با حجم زیادی از مدیریت اشتراک‌گذاری و خطر نشت حافظه روبرو هستیم، اگر همه چیز را به روش صحیح پاک‌سازی نکنیم. بنابراین، برخی مشکلات را حل کرده‌ایم اما دسته‌ای جدید از مشکلات و کد فراوان را ایجاد کرده‌ایم. بدتر از آن، باید این فرآیند را برای هر بخش از وضعیت سیستم تکرار کنیم.\n\n### معرفی سیگنال‌ها\n\nانتزاع‌های اتصال داده در UIها برای مدل و نما مدت‌هاست که هسته فریم‌ورک‌های UI در زبان‌های برنامه‌نویسی مختلف بوده‌اند، با وجود نبود چنین مکانیزمی در JS یا پلتفرم وب. در فریم‌ورک‌ها و کتابخانه‌های JS، آزمایش‌های زیادی برای نمایش این اتصال انجام شده و تجربه نشان داده است که جریان یک‌طرفه داده همراه با یک نوع داده درجه یک که نمایانگر یک سلول وضعیت یا محاسبه مشتق شده از داده‌های دیگر است (که امروزه غالباً \"سیگنال\" نامیده می‌شود) بسیار قدرتمند است.\nرویکرد مقدار واکنشی درجه یک به نظر می‌رسد اولین بار در فریم‌ورک‌های وب جاوااسکریپت متن‌باز با [Knockout](https://knockoutjs.com/) [در سال ۲۰۱۰](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/) محبوب شده باشد. در سال‌های بعد، انواع و پیاده‌سازی‌های زیادی ایجاد شده‌اند. در ۳-۴ سال اخیر، مفهوم اولیه سیگنال و رویکردهای مرتبط، محبوبیت بیشتری یافته‌اند، به طوری که تقریباً هر کتابخانه یا فریم‌ورک مدرن جاوااسکریپت چیزی مشابه با نام‌های مختلف ارائه می‌دهد.\n\nبرای درک سیگنال‌ها، بیایید به مثال بالا نگاه کنیم که با API سیگنال بازطراحی شده است.\n\n#### مثال - شمارنده با سیگنال‌ها\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// یک کتابخانه یا فریم‌ورک افکت‌هایی را بر اساس سایر سیگنال‌ها تعریف می‌کند\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// شبیه‌سازی بروزرسانی‌های خارجی به counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nچند نکته را فوراً می‌توان مشاهده کرد:\n* کد تکراری و پر سر و صدای مربوط به متغیر `counter` از مثال قبلی حذف شده است.\n* یک API یکپارچه برای مدیریت مقادیر، محاسبات و افکت‌های جانبی وجود دارد.\n* هیچ مشکل مرجع حلقوی یا وابستگی معکوسی بین `counter` و `render` وجود ندارد.\n* اشتراک‌گذاری دستی یا نیاز به مدیریت آن وجود ندارد.\n* راهی برای کنترل زمان‌بندی/برنامه‌ریزی افکت‌های جانبی وجود دارد.\n\nسیگنال‌ها بسیار بیشتر از آنچه در سطح API دیده می‌شود به ما ارائه می‌دهند:",
  "status": "ok"
}