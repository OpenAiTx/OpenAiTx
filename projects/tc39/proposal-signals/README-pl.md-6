{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "Stan `state` sygnału obliczanego (Computed Signal) może przyjmować jedną z następujących wartości:\n\n- `~clean~`: Wartość sygnału jest obecna i wiadomo, że nie jest nieaktualna.\n- `~checked~`: (Pośrednie) źródło tego sygnału uległo zmianie; sygnał posiada wartość, ale _może_ być nieaktualny. Czy jest nieaktualny, będzie wiadomo dopiero po ewaluacji wszystkich bezpośrednich źródeł.\n- `~computing~`: Callback tego sygnału jest obecnie wykonywany jako efekt uboczny wywołania `.get()`.\n- `~dirty~`: Ten sygnał ma wartość, o której wiadomo, że jest nieaktualna, lub nigdy nie został ewaluowany.\n\nGraf przejść przedstawia się następująco:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nPrzejścia:\n\n| Numer | Z      | Do     | Warunek | Algorytm |\n|-------|--------|--------|---------|----------|\n| 1     | `~checked~` | `~dirty~`    | Bezpośrednie źródło tego sygnału, które jest sygnałem obliczanym, zostało ewaluowane i jego wartość się zmieniła. | Algorytm: ponowne obliczenie nieaktualnego sygnału obliczanego |\n| 2     | `~clean~`   | `~dirty~`    | Bezpośrednie źródło tego sygnału, które jest sygnałem stanu (State), zostało ustawione na wartość różną od poprzedniej. | Metoda: `Signal.State.prototype.set(newValue)` |\n| 3     | `~clean~`   | `~checked~`  | Rekurencyjne, lecz nie bezpośrednie źródło tego sygnału, które jest sygnałem stanu (State), zostało ustawione na wartość różną od poprzedniej. | Metoda: `Signal.State.prototype.set(newValue)` |\n| 4     | `~dirty~`   | `~computing~`| Zamierzamy wykonać `callback`. | Algorytm: ponowne obliczenie nieaktualnego sygnału obliczanego |\n| 5     | `~computing~`| `~clean~`   | Callback zakończył ewaluację i zwrócił wartość lub wyrzucił wyjątek. | Algorytm: ponowne obliczenie nieaktualnego sygnału obliczanego |\n| 6     | `~checked~` | `~clean~`    | Wszystkie bezpośrednie źródła tego sygnału zostały ewaluowane i wszystkie pozostały niezmienione, więc wiadomo, że sygnał nie jest nieaktualny. | Algorytm: ponowne obliczenie nieaktualnego sygnału obliczanego |\n\n#### Sloty wewnętrzne `Signal.Computed`\n\n- `value`: Poprzednia buforowana wartość sygnału lub `~uninitialized~` dla sygnału obliczanego, który nigdy nie był odczytywany. Wartością może być wyjątek, który jest ponownie wyrzucany podczas odczytu. Zawsze `undefined` dla sygnałów efektów.\n- `state`: Może być `~clean~`, `~checked~`, `~computing~` lub `~dirty~`.\n- `sources`: Uporządkowany zbiór sygnałów, od których zależy ten sygnał.\n- `sinks`: Uporządkowany zbiór sygnałów, które zależą od tego sygnału.\n- `equals`: Metoda porównująca przekazana w opcjach.\n- `callback`: Callback, który jest wywoływany w celu uzyskania wartości sygnału obliczanego. Ustawiany na pierwszy parametr przekazany do konstruktora.\n\n#### Konstruktor `Signal.Computed`\n\nKonstruktor ustawia:\n- `callback` na swój pierwszy parametr\n- `equals` na podstawie opcji, domyślnie na `Object.is`, jeśli brak\n- `state` na `~dirty~`\n- `value` na `~uninitialized~`\n\nDzięki [AsyncContext](https://github.com/tc39/proposal-async-context), callback przekazany do `new Signal.Computed` domyka się nad snapshotem z chwili wywołania konstruktora i przywraca ten snapshot podczas swojego wykonania.\n\n#### Metoda: `Signal.Computed.prototype.get`\n\n1. Jeśli bieżący kontekst wykonania jest `frozen` albo ten sygnał ma stan `~computing~`, albo ten sygnał jest Watcherem i `computing` jest sygnałem obliczanym, rzuć wyjątek.\n1. Jeśli `computing` nie jest `null`, dodaj ten sygnał do zbioru `sources` sygnału `computing`.\n1. UWAGA: Nie dodajemy `computing` do zbioru `sinks` tego sygnału do czasu, aż (i o ile) stanie się obserwowany przez Watchera.\n1. Jeśli stan tego sygnału to `~dirty~` lub `~checked~`: Powtarzaj następujące kroki, aż sygnał osiągnie stan `~clean~`:\n    1. Rekurencyjnie przeszukuj `sources`, aby znaleźć najgłębsze, najbardziej lewe (czyli najwcześniej zaobserwowane) rekurencyjne źródło będące sygnałem obliczanym oznaczonym jako `~dirty~` (przerywając przeszukiwanie przy sygnale obliczanym oznaczonym jako `~clean~`, a ten sygnał obliczany włączyć jako ostatni do przeszukiwania).\n    1. Wykonaj algorytm \"ponowne obliczenie nieaktualnego sygnału obliczanego\" na tym sygnale.\n1. W tym momencie sygnał będzie miał stan `~clean~`, a żadne rekurencyjne źródło nie będzie już `~dirty~` ani `~checked~`. Zwróć wartość sygnału (`value`). Jeśli wartość to wyjątek, ponownie go wyrzuć.\n\n### Klasa `Signal.subtle.Watcher`\n\n#### Automat stanów `Signal.subtle.Watcher`\n\nStan `state` Watchera może być jednym z następujących:\n\n- `~waiting~`: Callback `notify` został wykonany lub Watcher jest nowy, ale nie obserwuje aktywnie żadnych sygnałów.\n- `~watching~`: Watcher aktywnie obserwuje sygnały, ale nie zaszły żadne zmiany wymagające wywołania `notify`.\n- `~pending~`: Zależność Watchera się zmieniła, ale callback `notify` nie został jeszcze wywołany.\n\nGraf przejść przedstawia się następująco:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nPrzejścia:\n\n| Numer | Z      | Do     | Warunek | Algorytm |\n|-------|--------|--------|---------|----------|\n| 1     | `~waiting~`  | `~watching~` | Wywołano metodę `watch` Watchera. | Metoda: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2     | `~watching~` | `~waiting~`  | Wywołano metodę `unwatch` Watchera i ostatni obserwowany sygnał został usunięty. | Metoda: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3     | `~watching~` | `~pending~`  | Obserwowany sygnał mógł zmienić wartość. | Metoda: `Signal.State.prototype.set(newValue)` |\n| 4     | `~pending~`  | `~waiting~`  | Callback `notify` został wykonany. | Metoda: `Signal.State.prototype.set(newValue)` |\n\n#### Sloty wewnętrzne `Signal.subtle.Watcher`\n\n- `state`: Może być `~watching~`, `~pending~` lub `~waiting~`\n- `signals`: Uporządkowany zbiór sygnałów, które ten Watcher obserwuje\n- `notifyCallback`: Callback wywoływany, gdy coś się zmieni. Ustawiany na pierwszy parametr przekazany do konstruktora.\n\n#### Konstruktor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` ustawiany jest na `~waiting~`.\n1. Inicjalizuje `signals` jako pusty zbiór.\n1. `notifyCallback` ustawiany jest na parametr callback.",
  "status": "ok"
}