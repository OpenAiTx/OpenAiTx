{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n    // تابع بازخوانی شده زمانی که isWatched به true تبدیل می‌شود، اگر قبلاً false بوده باشد\n    [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n    // تابع بازخوانی شده هر زمان که isWatched به false تبدیل می‌شود، اگر قبلاً true بوده باشد\n    [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n```\n\n### سیگنال‌ها چگونه کار می‌کنند\n\nیک Signal نمایانگر یک سلول داده است که ممکن است در طول زمان تغییر کند. سیگنال‌ها می‌توانند \"state\" (فقط یک مقدار که به صورت دستی تنظیم می‌شود) یا \"computed\" (یک فرمول مبتنی بر سایر سیگنال‌ها) باشند.\n\nسیگنال‌های محاسبه‌شده به صورت خودکار ردیابی می‌کنند که کدام سیگنال‌های دیگر در طول ارزیابی آن‌ها خوانده می‌شوند. وقتی یک سیگنال محاسبه‌شده خوانده می‌شود، بررسی می‌کند که آیا هر یک از وابستگی‌های ثبت‌شده قبلی‌اش تغییر کرده‌اند یا خیر، و در صورت تغییر، خودش را مجدداً ارزیابی می‌کند. وقتی چند سیگنال محاسبه‌شده تو در تو باشند، همه تخصیص ردیابی به داخلی‌ترین سیگنال مربوط می‌شود.\n\nسیگنال‌های محاسبه‌شده تنبل (lazy) هستند، یعنی مبتنی بر کشش (pull-based): آن‌ها فقط زمانی مجدداً ارزیابی می‌شوند که به آن‌ها دسترسی پیدا شود، حتی اگر یکی از وابستگی‌هایشان قبلاً تغییر کرده باشد.\n\nتابعی که به سیگنال‌های محاسبه‌شده داده می‌شود، معمولاً باید \"خالص\" باشد، به این معنا که یک تابع قطعی و بدون عوارض جانبی از سایر سیگنال‌هایی باشد که به آن‌ها دسترسی دارد. در عین حال، زمان‌بندی فراخوانی تابع، قطعی است و این امکان را می‌دهد که با احتیاط از عوارض جانبی استفاده شود.\n\nسیگنال‌ها دارای کش/مموایز کردن برجسته‌ای هستند: هم سیگنال‌های state و هم computed مقدار فعلی خود را به خاطر می‌سپارند و فقط زمانی باعث بازمحاسبه سیگنال‌های محاسبه‌شده‌ای می‌شوند که به آن‌ها ارجاع می‌دهند، که واقعاً تغییر کنند. حتی مقایسه مکرر مقدار قدیم و جدید لازم نیست—مقایسه فقط یک بار زمانی که سیگنال منبع بازنشانی/بازارزیابی می‌شود، انجام می‌شود و مکانیزم سیگنال پیگیری می‌کند که کدام ارجاعات به آن سیگنال هنوز بر اساس مقدار جدید به‌روزرسانی نشده‌اند. درونی، این معمولاً از طریق \"رنگ‌آمیزی گراف\" پیاده‌سازی می‌شود همان‌طور که در (پست وبلاگ Milo) توضیح داده شده است.\n\nسیگنال‌های محاسبه‌شده وابستگی‌های خود را به طور پویا ردیابی می‌کنند—هر بار که اجرا می‌شوند، ممکن است به چیزهای متفاوتی وابسته شوند و این مجموعه وابستگی دقیق در گراف سیگنال به‌روز نگه داشته می‌شود. این بدان معناست که اگر وابستگی فقط در یک شاخه لازم باشد و محاسبه قبلی شاخه دیگر را طی کرده باشد، در این صورت تغییر آن مقدار بلااستفاده موقت باعث بازمحاسبه سیگنال محاسبه‌شده نخواهد شد، حتی زمانی که کشیده شود.\n\nبرخلاف Promiseهای جاوااسکریپت، همه چیز در سیگنال‌ها به صورت همگام اجرا می‌شود:\n- تنظیم مقدار جدید برای یک سیگنال به صورت همگام است و این فوراً در هر سیگنال محاسبه‌شده‌ای که به آن وابسته است، منعکس می‌شود. هیچ دسته‌بندی (batching) داخلی‌ای برای این تغییر وجود ندارد.\n- خواندن سیگنال‌های محاسبه‌شده به صورت همگام انجام می‌شود—مقدار آن‌ها همیشه در دسترس است.\n- تابع `notify` در Watchers، همان‌طور که در ادامه توضیح داده شده است، به صورت همگام و در طول فراخوانی `.set()` که آن را تحریک کرده اجرا می‌شود (اما بعد از اتمام رنگ‌آمیزی گراف).\n\nمانند Promiseها، سیگنال‌ها می‌توانند وضعیت خطا را نمایش دهند: اگر تابع callback یک سیگنال محاسبه‌شده استثنا پرتاب کند، آن خطا مانند هر مقدار دیگری کش می‌شود و هر بار که سیگنال خوانده می‌شود مجدداً پرتاب می‌شود.\n\n### درک کلاس Signal\n\nیک نمونه از `Signal` نمایانگر قابلیت خواندن یک مقدار پویا است که به‌روزرسانی‌های آن در طول زمان ردیابی می‌شود. همچنین به طور ضمنی شامل قابلیت اشتراک در سیگنال است، به طور ضمنی از طریق دسترسی ردیابی شده از یک سیگنال محاسبه‌شده دیگر.\n\nاین API به گونه‌ای طراحی شده که با اجماع تقریبی اکوسیستم بین بخش بزرگی از کتابخانه‌های سیگنال در استفاده از نام‌هایی مانند \"signal\"، \"computed\" و \"state\" مطابقت داشته باشد. با این حال، دسترسی به سیگنال‌های Computed و State از طریق متد `.get()` انجام می‌شود، که با همه APIهای محبوب سیگنال که یا از دسترسی به سبک `.value` یا سینتکس فراخوانی `signal()` استفاده می‌کنند، تفاوت دارد.\n\nاین API برای کاهش تعداد تخصیص‌ها طراحی شده است تا سیگنال‌ها برای جاسازی در فریمورک‌های جاوااسکریپت مناسب باشند در حالی که به همان یا عملکردی بهتر از سیگنال‌های سفارشی فریمورک‌های موجود دست یابند. این موارد را شامل می‌شود:\n- سیگنال‌های state یک شیء قابل نوشتن منفرد هستند که می‌توان هم به آن دسترسی داشت و هم مقدار آن را از همان مرجع تنظیم کرد. (به پیامدهای زیر در بخش \"جداسازی قابلیت\" مراجعه کنید.)\n- هر دو نوع سیگنال State و Computed به گونه‌ای طراحی شده‌اند که قابل زیرکلاس‌گیری باشند تا امکان افزودن ویژگی‌های بیشتر از طریق فیلدهای کلاس عمومی و خصوصی (و همچنین متدهای استفاده از آن state) را برای فریمورک‌ها فراهم کنند.\n- فراخوانی‌های مختلف (مانند `equals`، تابع computed) با سیگنال مربوطه به عنوان مقدار `this` برای context فراخوانی می‌شوند، بنابراین نیازی به بستن جدید برای هر سیگنال نیست. در عوض، context می‌تواند در ویژگی‌های اضافی خود سیگنال ذخیره شود.\n\nبرخی شرایط خطایی که این API اعمال می‌کند:\n- خواندن بازگشتی یک سیگنال محاسبه‌شده خطا است.\n- تابع `notify` یک Watcher نمی‌تواند هیچ سیگنالی را بخواند یا بنویسد.\n- اگر callback یک سیگنال محاسبه‌شده استثنا پرتاب کند، دسترسی‌های بعدی به سیگنال همان خطای کش‌شده را مجدداً پرتاب می‌کنند، تا زمانی که یکی از وابستگی‌ها تغییر کند و مجدداً محاسبه شود.\n\nبرخی شرایط که *اعمال نمی‌شوند*:\n- سیگنال‌های محاسبه‌شده می‌توانند به سیگنال‌های دیگر بنویسند، به صورت همگام درون تابع callback خود\n- کاری که توسط callback `notify` یک Watcher در صف قرار می‌گیرد ممکن است سیگنال‌ها را بخواند یا بنویسد، که این امکان را می‌دهد تا [الگوهای ضعیف کلاسیک React](https://react.dev/learn/you-might-not-need-an-effect) را از نظر سیگنال‌ها بازتولید کنید!\n\n### پیاده‌سازی افکت‌ها\n\nرابط `Watcher` که در بالا تعریف شد، مبنایی برای پیاده‌سازی APIهای متداول JS برای افکت‌ها فراهم می‌کند: callbackهایی که هنگام تغییر سیگنال‌های دیگر، صرفاً برای عوارض جانبی‌شان مجدداً اجرا می‌شوند. تابع `effect` که در مثال ابتدایی بالا استفاده شد می‌تواند به صورت زیر تعریف شود:\n\n```ts\n// این تابع معمولاً در یک کتابخانه/فریمورک قرار دارد، نه در کد برنامه\n// توجه: این منطق زمان‌بندی بسیار ساده است و برای استفاده مناسب نیست. کپی/پیست نکنید.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// یک سیگنال effect که به cb ارزیابی می‌شود و هر زمان که یکی از وابستگی‌هایش ممکن است تغییر کند، یک خوانش از خودش را در صف microtask قرار می‌دهد\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nAPI سیگنال هیچ تابع داخلی مانند `effect` ندارد. دلیل آن این است که زمان‌بندی effect ظریف است و اغلب با چرخه‌های رندر فریمورک و سایر وضعیت‌ها یا استراتژی‌های ویژه فریمورک در سطح بالا که JS به آن‌ها دسترسی ندارد، ارتباط دارد.\n\nمروری بر عملیات مختلف استفاده شده در اینجا: callback `notify` که به سازنده Watcher داده می‌شود تابعی است که زمانی که سیگنال از حالت \"پاک\" (که کش مقداردهی اولیه و معتبر است) به حالت \"بررسی شده\" یا \"کثیف\" (که کش ممکن است معتبر یا نامعتبر باشد چون حداقل یکی از stateهایی که به طور بازگشتی به آن وابسته است تغییر کرده) می‌رود، فراخوانی می‌شود.\n\nفراخوانی‌های `notify` در نهایت توسط فراخوانی `.set()` روی یک سیگنال state تحریک می‌شوند. این فراخوانی همگام است: قبل از اینکه `.set` بازگردد انجام می‌شود. اما نیازی نیست نگران باشید که این callback گراف سیگنال را در حالتی نیمه‌پردازش شده ببیند، زیرا در طول callback `notify` هیچ سیگنالی قابل خواندن یا نوشتن نیست، حتی در یک فراخوانی `untrack`. چون `notify` در طول `.set()` فراخوانی می‌شود، دارد یک رشته منطقی دیگر را قطع می‌کند که ممکن است کامل نشده باشد. برای خواندن یا نوشتن سیگنال‌ها از `notify`، کار را برنامه‌ریزی کنید تا بعداً اجرا شود، مثلاً با نوشتن سیگنال در یک لیست برای دسترسی بعدی، یا با `queueMicrotask` همان‌طور که در بالا آمده است.\n\nتوجه داشته باشید که کاملاً ممکن است بدون استفاده از `Signal.subtle.Watcher` و تنها با زمان‌بندی polling سیگنال‌های محاسبه‌شده (همان‌طور که Glimmer انجام می‌دهد) از سیگنال‌ها به طور مؤثر استفاده کنید. با این حال، بسیاری از فریمورک‌ها دریافته‌اند که اغلب بسیار مفید است که این منطق زمان‌بندی به صورت همگام اجرا شود، بنابراین API سیگنال آن را شامل می‌شود.\n\nهم سیگنال‌های محاسبه‌شده و هم state مانند هر مقدار JS دیگری garbage-collect می‌شوند. اما Watcherها راه ویژه‌ای برای زنده نگه داشتن اشیا دارند: هر سیگنالی که توسط یک Watcher دیده می‌شود تا زمانی که هر یک از stateهای پایه قابل دسترس باشند، زنده نگه داشته می‌شود، زیرا این‌ها ممکن است یک فراخوانی `notify` آینده (و سپس یک `.get()` آینده) را تحریک کنند. به همین دلیل، به یاد داشته باشید که برای پاکسازی افکت‌ها باید `Watcher.prototype.unwatch` را فراخوانی کنید.\n\n### یک راه فرار ناسالم\n\n`Signal.subtle.untrack` یک راه فرار است که اجازه می‌دهد سیگنال‌ها *بدون* ردیابی این خوانش‌ها خوانده شوند. این قابلیت ناامن است زیرا اجازه می‌دهد سیگنال‌های محاسبه‌شده‌ای ساخته شوند که مقدارشان به سیگنال‌های دیگر وابسته است اما وقتی آن سیگنال‌ها تغییر می‌کنند به‌روزرسانی نمی‌شوند. باید زمانی استفاده شود که دسترسی‌های untracked نتیجه محاسبه را تغییر نمی‌دهد.\n\n<!--\nTODO: مثال جایی که استفاده از untrack ایده خوبی است\n\n### استفاده از watched/unwatched\n```",
  "status": "ok"
}