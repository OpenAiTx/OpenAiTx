{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q** : Les signaux fonctionnent-ils avec un flux de données unidirectionnel, comme le fait React ?\n\n**R** : Oui, les signaux sont un mécanisme pour le flux de données unidirectionnel. Les frameworks d'interface utilisateur basés sur les signaux vous permettent d'exprimer votre vue comme une fonction du modèle (où le modèle intègre des signaux). Un graphe d’état et de signaux calculés est acyclique par construction. Il est également possible de recréer les anti-patterns de React avec les signaux (!), par exemple, l’équivalent signal de `setState` dans `useEffect` consiste à utiliser un Watcher pour planifier une écriture sur un signal d’état.\n\n**Q** : Comment les signaux se rapportent-ils aux systèmes de gestion d’état comme Redux ? Les signaux encouragent-ils un état non structuré ?\n\n**R** : Les signaux peuvent constituer une base efficace pour des abstractions de gestion d’état de type store. Un schéma courant trouvé dans plusieurs frameworks est un objet basé sur un Proxy qui représente en interne les propriétés à l’aide de signaux, par exemple [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), ou [Solid stores](https://docs.solidjs.com/concepts/stores). Ces systèmes permettent de regrouper l’état de manière flexible au niveau d’abstraction adapté à l’application concernée.\n\n**Q** : Qu’apportent les signaux que le `Proxy` ne gère pas actuellement ?\n\n**R** : Les proxys et les signaux sont complémentaires et fonctionnent bien ensemble. Les proxys permettent d’intercepter les opérations superficielles sur les objets et les signaux coordonnent un graphe de dépendances (de cellules). Adosser un Proxy à des signaux est un excellent moyen de créer une structure réactive imbriquée avec une bonne ergonomie.\n\nDans cet exemple, nous pouvons utiliser un proxy pour que le signal dispose d’une propriété getter et setter au lieu d’utiliser les méthodes `get` et `set` :\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// utilisation dans un contexte réactif hypothétique :\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>changer</button>\n</template>\n```\nEn utilisant un renderer optimisé pour la réactivité fine, cliquer sur le bouton entraînera la mise à jour de la cellule `b.value`.\n\nVoir :\n- exemples de structures réactives imbriquées créées avec les signaux et les proxys : [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- exemple d’implémentations antérieures montrant la relation entre les données réactives et les proxys : [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Comment fonctionnent les signaux ?\n\n**Q** : Les signaux sont-ils basés sur le push ou le pull ?\n\n**R** : L’évaluation des signaux calculés est basée sur le pull : les signaux calculés ne sont évalués que lorsque `.get()` est appelé, même si l’état sous-jacent a changé bien avant. En même temps, la modification d’un signal d’état peut immédiatement déclencher le callback d’un Watcher, \"poussant\" la notification. Les signaux peuvent donc être considérés comme une construction \"push-pull\".\n\n**Q** : Les signaux introduisent-ils du non-déterminisme dans l’exécution JavaScript ?\n\n**R** : Non. D’une part, toutes les opérations sur les signaux ont une sémantique et un ordre bien définis, qui ne diffèrent pas selon les implémentations conformes. À un niveau supérieur, les signaux respectent un certain ensemble d’invariants, par rapport auxquels ils sont \"cohérents\". Un signal calculé observe toujours le graphe de signaux dans un état cohérent, et son exécution n’est pas interrompue par d’autres codes modifiant des signaux (sauf pour ce qu’il appelle lui-même). Voir la description ci-dessus.\n\n**Q** : Quand j’écris sur un signal d’état, quand la mise à jour du signal calculé est-elle planifiée ?\n\n**R** : Elle n’est pas planifiée ! Le signal calculé se recalculera la prochaine fois que quelqu’un le lira. De façon synchrone, le callback `notify` d’un Watcher peut être appelé, permettant aux frameworks de planifier une lecture au moment qu’ils jugent approprié.\n\n**Q** : Quand les écritures sur les signaux d’état prennent-elles effet ? Immédiatement, ou sont-elles regroupées ?\n\n**R** : Les écritures sur les signaux d’état sont reflétées immédiatement — la prochaine fois qu’un signal calculé dépendant du signal d’état est lu, il se recalculera si besoin, même si c’est à la ligne de code immédiatement suivante. Cependant, la paresse inhérente à ce mécanisme (les signaux calculés ne sont calculés que lorsqu’ils sont lus) fait que, dans la pratique, les calculs peuvent avoir lieu de manière groupée.\n\n**Q** : Que signifie pour les signaux de permettre une exécution \"sans glitch\" ?\n\n**R** : Les anciens modèles basés sur le push pour la réactivité faisaient face à un problème de calculs redondants : Si une mise à jour d’un signal d’état provoque l’exécution immédiate d’un signal calculé, cela peut finir par déclencher une mise à jour de l’UI. Mais cette écriture dans l’UI peut être prématurée, s’il devait y avoir un autre changement du signal d’état d’origine avant la prochaine frame. Parfois, des valeurs intermédiaires incorrectes étaient même montrées aux utilisateurs finaux à cause de tels [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Les signaux évitent cette dynamique en étant basés sur le pull plutôt que sur le push : Au moment où le framework planifie le rendu de l’UI, il va tirer les mises à jour appropriées, évitant ainsi du travail inutile, tant dans le calcul que dans l’écriture dans le DOM.\n\n**Q** : Que signifie pour les signaux d’être \"perdants\" (lossy) ?\n\n**R** : C’est le revers de l’exécution sans glitch : les signaux représentent une cellule de données — juste la valeur courante immédiate (qui peut changer), pas un flux de données dans le temps. Ainsi, si vous écrivez deux fois de suite sur un signal d’état sans rien faire d’autre, la première écriture est \"perdue\" et jamais vue par aucun signal calculé ou effet. Ceci est considéré comme une fonctionnalité et non un bug — d’autres constructions (par ex., les itérables asynchrones, les observables) sont plus adaptées aux flux.\n\n**Q** : Les signaux natifs seront-ils plus rapides que les implémentations existantes de signaux en JS ?\n\n**R** : Nous l’espérons (d’un petit facteur constant), mais cela reste à prouver dans le code. Les moteurs JS ne font pas de magie, et devront finalement implémenter les mêmes types d’algorithmes que les implémentations JS des signaux. Voir la section ci-dessus sur les performances.\n\n#### Pourquoi les signaux sont-ils conçus de cette façon ?\n\n**Q** : Pourquoi cette proposition n’inclut-elle pas de fonction `effect()`, alors que les effets sont nécessaires à toute utilisation pratique des signaux ?\n\n**R** : Les effets sont intrinsèquement liés à la planification et à la suppression, qui sont gérées par les frameworks et hors du champ de cette proposition. À la place, cette proposition inclut la base pour implémenter des effets via l’API plus bas niveau `Signal.subtle.Watcher`.\n\n**Q** : Pourquoi les abonnements sont-ils automatiques plutôt que de fournir une interface manuelle ?\n\n**R** : L’expérience a montré que les interfaces d’abonnement manuelles pour la réactivité sont peu ergonomiques et sujettes aux erreurs. Le suivi automatique est plus composable et constitue une fonctionnalité clé des signaux.\n\n**Q** : Pourquoi le callback du `Watcher` s’exécute-t-il de façon synchrone, plutôt que planifié dans une micro-tâche ?\n\n**R** : Parce que le callback ne peut ni lire ni écrire des signaux, il n’y a pas d’incohérence à l’appeler de façon synchrone. Un callback typique ajoutera un signal à un Array pour être lu plus tard, ou marquera un bit quelque part. Il est inutile et coûteux en pratique de créer une micro-tâche séparée pour ce genre d’actions.\n\n**Q** : Cette API manque de certaines choses agréables que mon framework préféré fournit, ce qui facilite la programmation avec les signaux. Peut-on aussi les ajouter au standard ?\n\n**R** : Peut-être. Diverses extensions sont encore à l’étude. Merci d’ouvrir une issue pour lancer la discussion sur toute fonctionnalité manquante que vous jugez importante.\n\n**Q** : Cette API peut-elle être réduite en taille ou en complexité ?\n\n**R** : Il est clairement souhaité de garder cette API minimale, et nous avons essayé de le faire avec ce qui est présenté ci-dessus. Si vous avez des idées pour retirer d’autres éléments, merci d’ouvrir une issue pour en discuter.\n\n#### Comment les signaux sont-ils standardisés ?\n\n**Q** : Ne devrait-on pas commencer le travail de standardisation dans ce domaine avec un concept plus primitif, comme les observables ?",
  "status": "ok"
}