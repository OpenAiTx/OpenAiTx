{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "O `state` de um Computed Signal pode ser um dos seguintes:\n\n- `~clean~`: O valor do Signal está presente e sabe-se que não está desatualizado.\n- `~checked~`: Uma fonte (indireta) deste Signal foi alterada; este Signal tem um valor, mas ele _pode_ estar desatualizado. Só será possível saber se está desatualizado quando todas as fontes imediatas forem avaliadas.\n- `~computing~`: O callback deste Signal está sendo executado atualmente como efeito colateral de uma chamada `.get()`.\n- `~dirty~`: Ou este Signal tem um valor que se sabe estar desatualizado, ou nunca foi avaliado.\n\nO grafo de transição é o seguinte:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nAs transições são:\n| Número | De | Para | Condição | Algoritmo |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | Uma fonte imediata deste signal, que é um computed signal, foi avaliada e seu valor foi alterado. | Algoritmo: recalcular Signal computado dirty |\n| 2 | `~clean~` | `~dirty~` | Uma fonte imediata deste signal, que é um State, foi definida com um valor diferente do anterior. | Método: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Uma fonte recursiva, mas não imediata, deste signal, que é um State, foi definida com um valor diferente do anterior. | Método: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | Estamos prestes a executar o `callback`. | Algoritmo: recalcular Signal computado dirty |\n| 5 | `~computing~` | `~clean~` | O `callback` terminou de ser avaliado e retornou um valor ou lançou uma exceção. | Algoritmo: recalcular Signal computado dirty |\n| 6 | `~checked~` | `~clean~` | Todas as fontes imediatas deste signal foram avaliadas e todas permaneceram inalteradas, então agora sabemos que não está desatualizado. | Algoritmo: recalcular Signal computado dirty |\n\n#### Slots internos de `Signal.Computed`\n\n- `value`: O valor em cache anterior do Signal, ou `~uninitialized~` para um Signal computado nunca lido. O valor pode ser uma exceção que é relançada quando o valor é lido. Sempre `undefined` para effect signals.\n- `state`: Pode ser `~clean~`, `~checked~`, `~computing~` ou `~dirty~`.\n- `sources`: Um conjunto ordenado de Signals dos quais este Signal depende.\n- `sinks`: Um conjunto ordenado de Signals que dependem deste Signal.\n- `equals`: O método equals fornecido nas opções.\n- `callback`: O callback chamado para obter o valor do Signal computado. Definido como o primeiro parâmetro passado ao construtor.\n\n#### Construtor de `Signal.Computed`\n\nO construtor define\n- `callback` como seu primeiro parâmetro\n- `equals` com base nas opções, padrão para `Object.is` se ausente\n- `state` para `~dirty~`\n- `value` para `~uninitialized~`\n\nCom [AsyncContext](https://github.com/tc39/proposal-async-context), o callback passado para `new Signal.Computed` fecha sobre o snapshot do momento em que o construtor foi chamado, e restaura esse snapshot durante sua execução.\n\n#### Método: `Signal.Computed.prototype.get`\n\n1. Se o contexto de execução atual está `frozen` ou se este Signal está no estado `~computing~`, ou se este signal é um Watcher e está `computing` um Signal computado, lance uma exceção.\n1. Se `computing` não for `null`, adicione este Signal ao conjunto `sources` de `computing`.\n1. NOTA: Não adicionamos `computing` ao conjunto `sinks` deste Signal até que ele seja observado por um Watcher.\n1. Se o estado deste Signal for `~dirty~` ou `~checked~`: Repita os passos a seguir até que este Signal esteja `~clean~`:\n    1. Recursivamente, suba via `sources` para encontrar a fonte recursiva mais profunda e à esquerda (ou seja, a primeira observada) que seja um Computed Signal marcado como `~dirty~` (interrompendo a busca ao encontrar um Computed Signal `~clean~` e incluindo este Computed Signal como o último a ser buscado).\n    1. Execute o algoritmo \"recalcular Signal computado dirty\" naquele Signal.\n1. Neste ponto, o estado deste Signal será `~clean~` e nenhuma fonte recursiva estará `~dirty~` ou `~checked~`. Retorne o `value` do Signal. Se o valor for uma exceção, relance essa exceção.\n\n### A classe `Signal.subtle.Watcher`\n\n#### Máquina de estados de `Signal.subtle.Watcher`\n\nO `state` de um Watcher pode ser um dos seguintes:\n\n- `~waiting~`: O callback `notify` foi executado, ou o Watcher é novo, mas não está observando ativamente nenhum signal.\n- `~watching~`: O Watcher está observando ativamente signals, mas nenhuma alteração ocorreu que necessite de um callback `notify`.\n- `~pending~`: Uma dependência do Watcher foi alterada, mas o callback `notify` ainda não foi executado.\n\nO grafo de transição é o seguinte:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nAs transições são:\n| Número | De | Para | Condição | Algoritmo |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | O método `watch` do Watcher foi chamado. | Método: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | O método `unwatch` do Watcher foi chamado e o último signal observado foi removido. | Método: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Um signal observado pode ter tido seu valor alterado. | Método: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | O callback `notify` foi executado. | Método: `Signal.State.prototype.set(newValue)` |\n\n#### Slots internos de `Signal.subtle.Watcher`\n\n- `state`: Pode ser `~watching~`, `~pending~` ou `~waiting~`\n- `signals`: Um conjunto ordenado de Signals que este Watcher está observando\n- `notifyCallback`: O callback chamado quando algo muda. Definido como o primeiro parâmetro passado ao construtor.\n\n#### Construtor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` é definido como `~waiting~`.\n1. Inicialize `signals` como um conjunto vazio.\n1. `notifyCallback` é definido como o parâmetro callback.",
  "status": "ok"
}