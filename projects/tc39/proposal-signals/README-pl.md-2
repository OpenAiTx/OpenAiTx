{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Automatyczne śledzenie zależności** – Sygnał obliczeniowy automatycznie wykrywa wszystkie inne Sygnały, od których jest zależny, niezależnie czy są to proste wartości czy inne obliczenia.\n* **Lenistwo obliczeniowe** – Obliczenia nie są wykonywane natychmiast po ich zadeklarowaniu, ani od razu po zmianie ich zależności. Są one wywoływane tylko wtedy, gdy ich wartość jest wyraźnie żądana.\n* **Memoizacja** – Sygnały obliczeniowe przechowują w pamięci swoją ostatnią wartość, więc jeśli zależności się nie zmieniły, nie ma potrzeby ponownego przeliczania wartości, niezależnie od liczby odczytów.\n\n## Motywacja do standaryzacji Sygnałów\n\n#### Współoperacyjność\n\nKażda implementacja Sygnałów posiada własny mechanizm automatycznego śledzenia, aby monitorować źródła napotkane podczas obliczania Sygnału obliczeniowego. Utrudnia to dzielenie się modelami, komponentami i bibliotekami pomiędzy różnymi frameworkami — są one zwykle fałszywie powiązane ze swoim silnikiem widoku (ponieważ Sygnały są zazwyczaj implementowane jako część frameworków JS).\n\nCelem tej propozycji jest całkowite oddzielenie modelu reaktywnego od warstwy widoku, umożliwiając deweloperom migrację do nowych technologii renderowania bez konieczności przepisywania kodu nie-UI, a także rozwijanie współdzielonych modeli reaktywnych JS do wdrożenia w różnych kontekstach. Niestety, z powodu wersjonowania i duplikacji okazało się niepraktyczne osiągnięcie wysokiego poziomu współdzielenia przez biblioteki na poziomie JS — wbudowane rozwiązania oferują silniejszą gwarancję współdzielenia.\n\n#### Wydajność/Użycie pamięci\n\nZawsze istnieje potencjał niewielkiego wzrostu wydajności dzięki mniejszej liczbie kodu przesyłanego z powodu powszechnie używanych bibliotek będących wbudowanymi, jednak implementacje Sygnałów są zazwyczaj niewielkie, więc nie spodziewamy się, by ten efekt był duży.\n\nPodejrzewamy, że natywne implementacje struktur danych i algorytmów związanych z Sygnałami w C++ mogą być nieco wydajniejsze niż to, co można osiągnąć w JS, o stały czynnik. Jednak nie przewiduje się zmian algorytmicznych względem tego, co byłoby obecne w polyfillu; silniki nie są tutaj magiczne, a same algorytmy reaktywności będą dobrze zdefiniowane i jednoznaczne.\n\nGrupa championów planuje opracować różne implementacje Sygnałów i wykorzystać je do zbadania tych możliwości wydajnościowych.\n\n#### DevTools\n\nW istniejących bibliotekach Sygnałów w języku JS trudno jest prześledzić takie rzeczy jak:\n* Stos wywołań przez łańcuch Sygnałów obliczeniowych, pokazujący przyczynowy łańcuch dla błędu\n* Graf odniesień pomiędzy Sygnałami, gdy jeden zależy od drugiego — ważne przy debugowaniu użycia pamięci\n\nWbudowane Sygnały umożliwiają środowiskom JS i narzędziom deweloperskim potencjalnie lepsze wsparcie dla inspekcji Sygnałów, szczególnie do debugowania lub analizy wydajności, niezależnie czy jest to wbudowane w przeglądarki, czy przez wspólne rozszerzenie. Istniejące narzędzia, takie jak inspektor elementów, migawki wydajności i profile pamięci mogą zostać zaktualizowane, by szczególnie wyróżniać Sygnały w prezentacji informacji.\n\n#### Korzyści drugorzędne\n\n##### Zalety standardowej biblioteki\n\nOgólnie rzecz biorąc, JavaScript posiadał dość minimalną bibliotekę standardową, ale trend w TC39 zmierza do uczynienia JS językiem „z bateriami w komplecie”, z wysokiej jakości, wbudowanym zestawem funkcjonalności. Na przykład Temporal zastępuje moment.js, a szereg mniejszych funkcji, np. `Array.prototype.flat` i `Object.groupBy` zastępuje wiele przypadków użycia lodash. Korzyści to mniejsze rozmiary paczek, poprawiona stabilność i jakość, mniej do nauki przy dołączaniu do nowego projektu i ogólnie wspólne słownictwo wśród deweloperów JS.\n\n##### Integracja z HTML/DOM (możliwość na przyszłość)\n\nObecne prace w W3C oraz u producentów przeglądarek zmierzają do wprowadzenia natywnego szablonowania do HTML ([DOM Parts][wicg-pr-1023] oraz [Template Instantiation][wicg-propsal-template-instantiation]). Dodatkowo, W3C Web Components CG bada możliwość rozszerzenia Web Components o w pełni deklaratywne API HTML. Aby osiągnąć oba te cele, ostatecznie HTML będzie potrzebować reaktywnego prymitywu. Ponadto, można sobie wyobrazić (i społeczność tego oczekuje) wiele ergonomicznych usprawnień DOM poprzez integrację Sygnałów.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Uwaga: ta integracja byłaby osobnym wysiłkiem, który pojawi się później, nie jest częścią tej propozycji.\n\n##### Wymiana informacji w ekosystemie (*nie* powód do wdrożenia)\n\nWysiłki standaryzacyjne czasami mogą być pomocne już na poziomie „społeczności”, nawet bez zmian w przeglądarkach. Prace nad Sygnałami jednoczą wielu różnych autorów frameworków do głębokiej dyskusji na temat natury reaktywności, algorytmów i współoperacyjności. To już okazało się przydatne, ale samo w sobie nie uzasadnia włączenia do silników JS i przeglądarek; Sygnały powinny być dodane do standardu JavaScript tylko jeśli są znaczące korzyści *ponad* wymianę informacji w ekosystemie, którą umożliwiają.\n\n## Cele projektowe dla Sygnałów\n\nOkazuje się, że istniejące biblioteki Sygnałów nie różnią się aż tak bardzo między sobą, jeśli chodzi o sedno działania. Propozycja ta ma na celu zbudowanie na ich sukcesach poprzez implementację istotnych cech wielu z tych bibliotek.\n\n### Główne cechy\n\n* Typ Sygnału, który reprezentuje stan, tzn. zapisywalny Sygnał. Jest to wartość, którą inni mogą odczytać.\n* Typ Sygnału obliczeniowego/memoizowanego/pochodnego, który zależy od innych i jest leniwie wyliczany oraz cache’owany.\n    * Obliczenia są leniwe, to znaczy, że Sygnały obliczeniowe nie są przeliczane automatycznie przy każdej zmianie zależności, ale tylko wtedy, gdy ktoś je rzeczywiście odczyta.\n    * Obliczenia są „[wolne od glitchy](https://pl.wikipedia.org/wiki/Programowanie_reaktywne#Glitches)”, czyli nigdy nie są wykonywane niepotrzebne kalkulacje. Oznacza to, że kiedy aplikacja odczytuje Sygnał obliczeniowy, wykonywane jest topologiczne sortowanie potencjalnie „brudnych” części grafu, by wyeliminować duplikaty.\n    * Obliczenia są cache’owane, co oznacza, że jeśli od ostatniej zmiany zależności żadna z nich się nie zmieniła, to Sygnał obliczeniowy *nie* jest przeliczany przy odczycie.\n    * Możliwe są niestandardowe porównania zarówno dla Sygnałów obliczeniowych jak i stanowych, aby zaznaczyć, kiedy dalsze Sygnały obliczeniowe zależne od nich powinny być zaktualizowane.\n* Reakcje na sytuację, gdy Sygnał obliczeniowy ma którąś ze swoich zależności (lub zagnieżdżonych zależności) oznaczoną jako „brudną” i zmienioną, co oznacza, że wartość Sygnału może być nieaktualna.\n    * Ta reakcja ma na celu zaplanowanie wykonania bardziej znaczącej pracy później.\n    * Efekty są implementowane w oparciu o te reakcje oraz planowanie na poziomie frameworka.\n    * Sygnały obliczeniowe muszą mieć możliwość reagowania na fakt, czy są zarejestrowane jako (zagnieżdżona) zależność jednej z tych reakcji.\n* Umożliwienie frameworkom JS własnego planowania. Brak wymuszonego wbudowanego planowania w stylu Promise.\n    * Potrzebne są synchroniczne reakcje, by umożliwić planowanie dalszej pracy na podstawie logiki frameworka.\n    * Zapisy są synchroniczne i mają natychmiastowy efekt (framework może batchować zapisy na wyższym poziomie).\n    * Możliwość oddzielenia sprawdzenia, czy efekt może być „brudny”, od rzeczywistego uruchomienia efektu (umożliwiając dwustopniowy scheduler efektów).\n* Możliwość odczytu Sygnałów *bez* rejestrowania zależności (`untrack`)\n* Umożliwienie kompozycji różnych baz kodowych korzystających z Sygnałów/reaktywności, np.:\n    * Używanie wielu frameworków razem, jeśli chodzi o śledzenie/zachowania reaktywne (z zastrzeżeniami — patrz niżej)\n    * Niezależne od frameworka reaktywne struktury danych (np. rekurencyjnie reaktywny proxy store, reaktywna Map i Set i Array, itp.)\n\n### Poprawność (Soundness)\n\n* Zniechęcanie/zabronienie naiwnego niewłaściwego użycia synchronicznych reakcji.\n    * Ryzyko dla poprawności: może ujawnić „[glitche](https://pl.wikipedia.org/wiki/Programowanie_reaktywne#Glitches)” jeśli jest użyte niewłaściwie: Jeśli renderowanie następuje natychmiast po ustawieniu Sygnału, użytkownik końcowy może zobaczyć niekompletny stan aplikacji. Ta funkcja powinna być używana jedynie do inteligentnego planowania pracy na później, po zakończeniu logiki aplikacji.\n    * Rozwiązanie: Zabronić odczytu i zapisu jakiegokolwiek Sygnału z wnętrza synchronicznego callbacka reakcji.\n* Zniechęcanie do `untrack` i zaznaczenie jego niepoprawnej natury\n    * Ryzyko dla poprawności: pozwala na tworzenie Sygnałów obliczeniowych, których wartość zależy od innych Sygnałów, ale które nie są aktualizowane, gdy te Sygnały się zmieniają. Powinien być używany tylko wtedy, gdy nieśledzone odczyty nie zmienią wyniku obliczenia.\n    * Rozwiązanie: API oznaczone jako „niebezpieczne” w nazwie.\n* Uwaga: Ta propozycja pozwala na odczyt i zapis Sygnałów zarówno ze Sygnałów obliczeniowych, jak i efektów, bez ograniczania zapisów po odczytach, mimo ryzyka dla poprawności. Ta decyzja została podjęta w celu zachowania elastyczności i kompatybilności z integracją z frameworkami.\n\n### API powierzchniowe (Surface API)\n\n* Musi stanowić solidną bazę dla wielu frameworków do implementacji swoich mechanizmów Sygnałów/reaktywności.\n    * Powinna być dobrą podstawą dla rekurencyjnych proxy store, reaktywności pól klas opartych na dekoratorach oraz zarówno API `.value`, jak i `[state, setState]`.\n    * Semantyka musi umożliwiać wyrażenie poprawnych wzorców obsługiwanych przez różne frameworki. Przykładowo, Sygnały te powinny stanowić bazę zarówno dla natychmiastowych zapisów, jak i zapisów batchowanych i stosowanych później.\n* Byłoby dobrze, gdyby to API było używalne bezpośrednio przez deweloperów JavaScript.\n    * Jeśli funkcja odpowiada pojęciu z ekosystemu, użycie wspólnego słownictwa jest dobre.\n        * Jednak ważne jest, by nie powielać dokładnie tych samych nazw!\n    * Napięcie między „użytecznością dla deweloperów JS” a „dostarczaniem wszystkich hooków frameworkom”\n        * Pomysł: Dostarczyć wszystkie hooki, ale dodać błędy przy ich niewłaściwym użyciu, jeśli to możliwe.\n        * Pomysł: Umieścić subtelne API w przestrzeni nazw `subtle`, podobnie jak [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), by wyznaczyć granicę między API niezbędnymi do bardziej zaawansowanych zastosowań (implementacja frameworka, dev tools) a codziennym rozwojem aplikacji (instancjonowanie sygnałów do użycia z frameworkiem).\n* Być możliwym do zaimplementowania i użycia z dobrą wydajnością — API powierzchniowe nie powoduje nadmiernych narzutów\n    * Umożliwia dziedziczenie, by frameworki mogły dodawać własne metody i pola, w tym prywatne. To ważne, by nie wymuszać dodatkowych alokacji na poziomie frameworka. Patrz sekcja „Zarządzanie pamięcią” poniżej.\n\n### Zarządzanie pamięcią\n\n* Jeśli to możliwe: Sygnał obliczeniowy powinien podlegać zbieraniu śmieci, jeśli nic żywego nie odwołuje się do niego dla potencjalnych przyszłych odczytów, nawet jeśli jest połączony w szerszy graf, który pozostaje żywy (np. przez odczyt stanu, który pozostaje żywy).",
  "status": "ok"
}