{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q**: Tín hiệu (Signals) có hoạt động với luồng dữ liệu một chiều như React không?\n\n**A**: Có, Tín hiệu là một cơ chế cho luồng dữ liệu một chiều. Các framework UI dựa trên tín hiệu cho phép bạn biểu diễn giao diện dưới dạng một hàm của mô hình (trong đó mô hình bao gồm các Tín hiệu). Đồ thị của trạng thái và Tín hiệu tính toán được xây dựng một cách phi chu trình. Cũng có thể tái tạo các antipatterns của React trong Signals (!), ví dụ, tương đương với việc dùng `setState` bên trong `useEffect` là sử dụng một Watcher để lên lịch ghi vào một tín hiệu State.\n\n**Q**: Tín hiệu liên quan như thế nào đến các hệ thống quản lý trạng thái như Redux? Tín hiệu có khuyến khích trạng thái không cấu trúc không?\n\n**A**: Tín hiệu có thể tạo thành nền tảng hiệu quả cho các trừu tượng quản lý trạng thái kiểu store. Một mẫu phổ biến được tìm thấy trong nhiều framework là một đối tượng dựa trên Proxy, bên trong biểu diễn các thuộc tính sử dụng Tín hiệu, ví dụ: [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), hoặc [Solid stores](https://docs.solidjs.com/concepts/stores). Các hệ thống này cho phép nhóm trạng thái linh hoạt ở mức trừu tượng phù hợp với ứng dụng cụ thể.\n\n**Q**: Tín hiệu cung cấp điều gì mà `Proxy` hiện tại không xử lý được?\n\n**A**: Proxy và Tín hiệu là bổ trợ cho nhau và kết hợp tốt với nhau. Proxy cho phép bạn can thiệp vào các thao tác đối tượng nông cạn, còn tín hiệu điều phối một đồ thị phụ thuộc (các ô). Hỗ trợ một Proxy bằng Tín hiệu là một cách tuyệt vời để tạo ra cấu trúc phản ứng lồng nhau với tính tiện dụng cao.\n\nTrong ví dụ này, ta có thể dùng proxy để biến tín hiệu thành thuộc tính getter và setter thay vì sử dụng phương thức `get` và `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// sử dụng trong một ngữ cảnh phản ứng giả định:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nkhi sử dụng một trình render được tối ưu hóa cho phản ứng chi tiết, nhấn nút sẽ làm cập nhật ô `b.value`.\n\nXem thêm:\n- ví dụ về cấu trúc phản ứng lồng nhau được tạo với cả Tín hiệu và Proxy: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- ví dụ về các triển khai trước đó cho thấy mối quan hệ giữa dữ liệu phản ứng và proxy: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [thảo luận](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Tín hiệu hoạt động như thế nào?\n\n**Q**: Tín hiệu là dựa trên đẩy (push-based) hay kéo (pull-based)?\n\n**A**: Việc đánh giá Tín hiệu tính toán là dựa trên kéo: Tín hiệu tính toán chỉ được đánh giá khi gọi `.get()`, ngay cả khi trạng thái bên dưới đã thay đổi từ trước đó. Đồng thời, thay đổi một tín hiệu State có thể ngay lập tức kích hoạt callback của Watcher, \"đẩy\" thông báo. Vì vậy, có thể coi Tín hiệu là một cấu trúc \"đẩy-kéo\".\n\n**Q**: Tín hiệu có làm phát sinh tính không xác định (nondeterminism) trong thực thi JavaScript không?\n\n**A**: Không. Tất cả các thao tác với Tín hiệu đều có ngữ nghĩa và thứ tự xác định rõ ràng, và sẽ không khác biệt giữa các triển khai tuân thủ chuẩn. Ở mức cao hơn, Tín hiệu tuân theo một số bất biến nhất định, đảm bảo tính \"sound\". Một Tín hiệu tính toán luôn quan sát đồ thị Tín hiệu ở trạng thái nhất quán, và việc thực thi của nó không bị gián đoạn bởi mã làm biến đổi Tín hiệu khác (trừ những gì nó tự gọi). Xem mô tả phía trên.\n\n**Q**: Khi tôi ghi vào một tín hiệu State, khi nào tín hiệu tính toán sẽ được cập nhật?\n\n**A**: Nó không được lên lịch! Tín hiệu tính toán sẽ tự tính lại lần kế tiếp khi có ai đó đọc nó. Đồng bộ, callback `notify` của Watcher có thể được gọi, cho phép framework lên lịch đọc vào thời điểm thích hợp.\n\n**Q**: Khi nào các ghi vào tín hiệu State có hiệu lực? Ngay lập tức, hay được gom lại (batched)?\n\n**A**: Ghi vào tín hiệu State có hiệu lực ngay lập tức—lần kế tiếp một tín hiệu tính toán phụ thuộc vào tín hiệu State đó được đọc, nó sẽ tự tính lại nếu cần thiết, thậm chí ở ngay dòng mã tiếp theo. Tuy nhiên, do tính lười của cơ chế này (tín hiệu tính toán chỉ được tính khi đọc), trên thực tế các phép tính có thể diễn ra theo kiểu được gom lại (batched).\n\n**Q**: \"Glitch-free\" trong thực thi của Tín hiệu nghĩa là gì?\n\n**A**: Các mô hình phản ứng dựa trên đẩy trước đây từng gặp vấn đề tính toán dư thừa: Nếu một cập nhật vào tín hiệu State gây cho tín hiệu tính toán chạy ngay, cuối cùng có thể đẩy cập nhật lên UI. Nhưng việc ghi này có thể quá sớm nếu sẽ còn một thay đổi nữa vào tín hiệu State gốc trước khung hình tiếp theo. Đôi khi, giá trị trung gian không chính xác thậm chí còn hiển thị cho người dùng cuối do các [glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches) như vậy. Tín hiệu tránh được động lực này nhờ dựa trên kéo, không dựa trên đẩy: Khi framework lên lịch render UI, nó sẽ kéo các cập nhật phù hợp, tránh lãng phí công sức cả trong tính toán lẫn ghi vào DOM.\n\n**Q**: Tín hiệu là \"lossy\" nghĩa là gì?\n\n**A**: Đây là mặt trái của thực thi không glitch: Tín hiệu đại diện cho một ô dữ liệu—chỉ giá trị hiện tại (có thể thay đổi), không phải luồng dữ liệu theo thời gian. Vì vậy, nếu bạn ghi vào một tín hiệu State hai lần liên tiếp mà không làm gì khác, lần ghi đầu tiên sẽ \"bị mất\" và không bao giờ được thấy bởi tín hiệu tính toán hay hiệu ứng nào. Điều này được xem là một tính năng chứ không phải lỗi—các cấu trúc khác (như async iterables, observables) phù hợp hơn với luồng dữ liệu.\n\n**Q**: Liệu Tín hiệu native có nhanh hơn các triển khai Tín hiệu JS hiện tại không?\n\n**A**: Chúng tôi hy vọng như vậy (theo một hệ số hằng số nhỏ), nhưng điều này cần được chứng minh qua mã nguồn. Engine JS không phải là phép màu, cuối cùng vẫn sẽ cần triển khai các loại thuật toán giống như các triển khai Tín hiệu bằng JS. Xem phần về hiệu năng phía trên.\n\n#### Vì sao Tín hiệu được thiết kế như vậy?\n\n**Q**: Tại sao đề xuất này không bao gồm hàm `effect()`, trong khi hiệu ứng là cần thiết cho bất kỳ việc sử dụng Tín hiệu thực tế nào?\n\n**A**: Hiệu ứng vốn liên quan đến lập lịch và giải phóng tài nguyên, những thứ do framework quản lý và nằm ngoài phạm vi của đề xuất này. Thay vào đó, đề xuất này đưa ra nền tảng để triển khai hiệu ứng thông qua API `Signal.subtle.Watcher` cấp thấp hơn.\n\n**Q**: Tại sao việc đăng ký (subscriptions) là tự động thay vì cung cấp giao diện thủ công?\n\n**A**: Kinh nghiệm cho thấy các giao diện đăng ký thủ công cho phản ứng rất khó dùng và dễ lỗi. Theo dõi tự động có tính kết hợp cao hơn và là tính năng cốt lõi của Tín hiệu.\n\n**Q**: Tại sao callback của `Watcher` chạy đồng bộ thay vì được lên lịch trong một microtask?\n\n**A**: Vì callback không thể đọc hay ghi Tín hiệu, nên không có vấn đề về tính soundness khi gọi đồng bộ. Một callback điển hình sẽ thêm một Tín hiệu vào Array để đọc sau, hoặc đánh dấu một bit ở đâu đó. Việc tạo một microtask riêng cho các hành động như vậy là không cần thiết và tốn kém.\n\n**Q**: API này thiếu một số tính năng hay mà framework ưa thích của tôi cung cấp, giúp lập trình với Tín hiệu dễ dàng hơn. Liệu có thể thêm vào chuẩn không?\n\n**A**: Có thể. Nhiều phần mở rộng vẫn đang được xem xét. Vui lòng tạo issue để thảo luận về bất kỳ tính năng thiếu nào mà bạn thấy quan trọng.\n\n**Q**: API này có thể được rút gọn về kích thước hoặc độ phức tạp không?\n\n**A**: Chúng tôi chắc chắn đặt mục tiêu giữ cho API này tối giản, và đã cố gắng làm như vậy với những gì đã trình bày ở trên. Nếu bạn có ý tưởng về những gì có thể loại bỏ thêm, hãy tạo issue để thảo luận.\n\n#### Tín hiệu đang được chuẩn hóa như thế nào?\n\n**Q**: Chúng ta có nên bắt đầu công việc chuẩn hóa trong lĩnh vực này với một khái niệm sơ khai hơn, chẳng hạn như observables không?",
  "status": "ok"
}