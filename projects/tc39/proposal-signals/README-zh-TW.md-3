{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* 請注意，目前大多數框架都需要顯式釋放（dispose）已計算的 Signal，尤其當它們與其他仍存活的 Signal 圖有任何引用關係時。\n* 當它們的生命週期與 UI 元件綁定時，這其實並不算太糟，因為效果（effects）本來也需要被釋放。\n* 如果用這種語義執行的代價太高，那麼我們應該在下方 API 中新增顯式的釋放（或「解除連結 unlinking」）計算型 Signal 的方法，目前 API 尚未提供此功能。\n* 另一個相關目標：最小化配置（allocation）次數，例如：\n    * 建立一個可寫 Signal 時（避免兩個獨立的閉包和一個陣列）\n    * 實作 effect（避免每個 reaction 都建立一個閉包）\n    * 在觀察 Signal 變化的 API 裡，避免建立額外的暫時性資料結構\n    * 解決方案：以類別為基礎的 API，允許重複使用子類別定義的方法與欄位\n\n## API 草案\n\n以下是一個 Signal API 的初步想法。請注意這僅是早期草稿，我們預期未來會有所變動。讓我們從完整的 `.d.ts` 開始，以掌握整體架構，然後再討論每個細節的意義。\n\n```ts\ninterface Signal<T> {\n    // 取得 signal 的值\n    get(): T;\n}\n\nnamespace Signal {\n    // 可讀寫的 Signal\n    class State<T> implements Signal<T> {\n        // 建立一個初始值為 t 的 state Signal\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // 取得 signal 的值\n        get(): T;\n\n        // 設定 state Signal 的值為 t\n        set(t: T): void;\n    }\n\n    // 依賴其他 Signal 的公式型 Signal\n    class Computed<T = unknown> implements Signal<T> {\n        // 建立一個 Signal，其值為 callback 回傳的結果。\n        // Callback 執行時，this 指向該 signal。\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // 取得 signal 的值\n        get(): T;\n    }\n\n    // 此命名空間包含「進階」功能，建議由框架作者使用，而非應用程式開發者。\n    // 類似於 `crypto.subtle`\n    namespace subtle {\n        // 執行 callback，且停用所有追蹤功能\n        function untrack<T>(cb: () => T): T;\n\n        // 取得目前正在追蹤 signal 讀取的 computed signal（如果有的話）\n        function currentComputed(): Computed | null;\n\n        // 回傳最近一次評估時，此 signal 所參考的所有 signal 的有序列表。\n        // 對於 Watcher，則列出其監看的 signal 集合。\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // 回傳此 signal 所屬的 Watchers，以及最近一次評估時讀取此 signal 的所有 Computed signals，\n        // 如果該 computed signal（遞迴地）被監看。\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // 如果此 signal 是「活躍」的（即被 Watcher 監看，\n        // 或被（遞迴）活躍的 Computed signal 讀取），則回傳 true。\n        function hasSinks(s: State | Computed): boolean;\n\n        // 如果此元素是「反應式」的，即依賴其他 signal，則回傳 true。\n        // 當 Computed 的 hasSources 為 false 時，將永遠回傳同一常數值。\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // 當 Watcher 的（遞迴）來源被寫入時，呼叫此 callback，\n            // 若自上次 `watch` 呼叫以來尚未被呼叫。\n            // 在 notify 執行期間，不能讀寫任何 signal。\n            constructor(notify: (this: Watcher) => void);\n\n            // 將這些 signals 加入 Watcher 監看的集合，並設定下一次這些 signal（或其依賴）變動時，\n            // 會執行 notify callback。\n            // 也可不帶參數呼叫以重設「已通知」狀態，使 notify callback 能再次被呼叫。\n            watch(...s: Signal[]): void;\n\n            // 從監看集合中移除這些 signal（例如，用於已釋放的 effect）\n            unwatch(...s: Signal[]): void;\n\n            // 回傳 Watcher 監看集合中仍為 dirty 的來源，或是具有 dirty/pending 來源但尚未重新評估的 computed signal\n            getPending(): Signal[];\n        }\n\n        // 監看或不再被監看時的觀察 hooks\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // 舊值與新值之間的自訂比較函式，預設為 Object.is。\n        // Signal 會作為 this 值傳入以供 context 使用。\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}