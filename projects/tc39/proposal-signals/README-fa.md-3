{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* توجه داشته باشید که اکثر فریمورک‌های امروزی نیاز به حذف صریح سیگنال‌های محاسبه‌شده دارند اگر آن‌ها هرگونه ارجاع به یا از یک گراف سیگنال دیگر که همچنان فعال باقی مانده است، داشته باشند.\n* این موضوع زمانی چندان بد نمی‌شود که طول عمر آن‌ها به طول عمر یک مؤلفه UI گره خورده باشد و افکت‌ها به هر حال باید حذف شوند.\n* اگر اجرای این مفاهیم بیش از حد پرهزینه باشد، باید حذف صریح (یا «قطع ارتباط») سیگنال‌های محاسبه‌شده را به API زیر اضافه کنیم که در حال حاضر فاقد آن است.\n* هدف مرتبط جداگانه: کمینه‌سازی تعداد تخصیص‌ها، به عنوان مثال:\n    * برای ساخت یک سیگنال قابل نوشتن (اجتناب از دو بسته‌بندی مجزا + آرایه)\n    * برای پیاده‌سازی افکت‌ها (اجتناب از یک بسته‌بندی برای هر واکنش جداگانه)\n    * در API مشاهده تغییرات سیگنال، از ایجاد ساختارهای داده موقتی اضافی خودداری شود\n    * راه‌حل: API مبتنی بر کلاس که امکان استفاده مجدد از متدها و فیلدهای تعریف‌شده در زیرکلاس‌ها را فراهم می‌کند\n\n## طرح اولیه API\n\nایده اولیه‌ای از یک API سیگنال در زیر آمده است. توجه داشته باشید که این تنها یک پیش‌نویس اولیه است و انتظار داریم در طول زمان تغییراتی رخ دهد. بیایید با فایل کامل `.d.ts` شروع کنیم تا ایده‌ای از ساختار کلی به دست آوریم، سپس جزئیات معنای هر بخش را بررسی خواهیم کرد.\n\n```ts\ninterface Signal<T> {\n    // دریافت مقدار سیگنال\n    get(): T;\n}\n\nnamespace Signal {\n    // یک سیگنال خواندنی-نوشتنی\n    class State<T> implements Signal<T> {\n        // ساخت یک سیگنال state با مقدار اولیه t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // دریافت مقدار سیگنال\n        get(): T;\n\n        // تنظیم مقدار سیگنال state به t\n        set(t: T): void;\n    }\n\n    // یک سیگنال که یک فرمول بر اساس سیگنال‌های دیگر است\n    class Computed<T = unknown> implements Signal<T> {\n        // ساخت سیگنالی که به مقداری که توسط callback بازگردانده می‌شود ارزیابی می‌شود.\n        // callback با این سیگنال به عنوان مقدار this فراخوانی می‌شود.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // دریافت مقدار سیگنال\n        get(): T;\n    }\n\n    // این فضای نام شامل ویژگی‌های \"پیشرفته\"‌ای است که بهتر است\n    // برای نویسندگان فریمورک حفظ شود تا توسعه‌دهندگان برنامه.\n    // مشابه با `crypto.subtle`\n    namespace subtle {\n        // اجرای یک callback با غیرفعال بودن کامل پیگیری\n        function untrack<T>(cb: () => T): T;\n\n        // دریافت سیگنال محاسبه‌شده فعلی که هر خواندن سیگنال را پیگیری می‌کند، در صورت وجود\n        function currentComputed(): Computed | null;\n\n        // بازمی‌گرداند لیست مرتب‌شده همه سیگنال‌هایی که این سیگنال\n        // در آخرین بار اجرا به آن‌ها ارجاع داده است.\n        // برای Watcher، مجموعه سیگنال‌هایی را فهرست می‌کند که آن را مشاهده می‌کند.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // بازمی‌گرداند Watcherهایی که این سیگنال در آن‌ها قرار دارد، به علاوه هر\n        // سیگنال Computed که آخرین بار این سیگنال را خوانده است،\n        // اگر آن سیگنال محاسبه‌شده (به صورت بازگشتی) مشاهده شود.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // اگر این سیگنال \"زنده\" باشد، یعنی توسط Watcher مشاهده شود،\n        // یا توسط یک سیگنال Computed که (به طور بازگشتی) زنده است خوانده شود، مقدار true بازمی‌گرداند.\n        function hasSinks(s: State | Computed): boolean;\n\n        // اگر این عنصر \"واکنشی\" باشد، یعنی به سیگنال دیگری وابسته باشد مقدار true بازمی‌گرداند.\n        // یک Computed که hasSources آن false است، همواره مقدار ثابت یکسانی را بازمی‌گرداند.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // زمانی که یک منبع (بازگشتی) Watcher نوشته شود، این callback را فراخوانی می‌کند،\n            // اگر از آخرین فراخوانی `watch` فراخوانی نشده باشد.\n            // در طول notify هیچ سیگنالی نباید خوانده یا نوشته شود.\n            constructor(notify: (this: Watcher) => void);\n\n            // این سیگنال‌ها را به مجموعه Watcher اضافه می‌کند و Watcher را تنظیم می‌کند تا\n            // callback notify را دفعه بعد که هر سیگنالی در مجموعه (یا یکی از وابستگی‌های آن) تغییر کرد اجرا کند.\n            // می‌توان بدون آرگومان نیز فراخوانی کرد تا فقط وضعیت \"اعلان‌شده\" را ریست کند، به طوری که\n            // callback notify دوباره فراخوانی شود.\n            watch(...s: Signal[]): void;\n\n            // این سیگنال‌ها را از مجموعه مشاهده‌شده حذف می‌کند (مثلاً برای یک افکت که حذف شده است)\n            unwatch(...s: Signal[]): void;\n\n            // مجموعه منابعی که در مجموعه Watcher هنوز کثیف هستند یا یک سیگنال محاسبه‌شده\n            // با منبعی که کثیف یا در حالت pending است و هنوز بازارزیابی نشده را بازمی‌گرداند\n            getPending(): Signal[];\n        }\n\n        // هوک‌هایی برای مشاهده آغاز یا پایان مشاهده\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // تابع مقایسه سفارشی بین مقدار قدیم و جدید. پیش‌فرض: Object.is.\n        // سیگنال به عنوان مقدار this برای زمینه ارسال می‌شود.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}