{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "`Computed Signal` の `state` は、以下のいずれかとなります。\n\n- `~clean~`: Signal の値が存在し、古くなっていないことが確認されています。\n- `~checked~`: この Signal の（間接的な）ソースが変更されました。この Signal には値がありますが、_古くなっているかもしれません_。古くなっているかどうかは、すべての直接的なソースが評価されたときにのみ判明します。\n- `~computing~`: この Signal のコールバックが、`.get()` 呼び出しの副作用として現在実行中です。\n- `~dirty~`: この Signal の値が古くなっていることが判明しているか、または一度も評価されていません。\n\n遷移グラフは以下のとおりです。\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\n遷移は以下のとおりです。\n| 番号 | From | To | 条件 | アルゴリズム |\n| ---- | ---- | -- | ---- | ------------ |\n| 1 | `~checked~` | `~dirty~` | この Signal の直接的なソース（計算 Signal）が評価され、その値が変化した。 | アルゴリズム: dirty な計算 Signal の再計算 |\n| 2 | `~clean~` | `~dirty~` | この Signal の直接的なソース（State）が、前の値と異なる値でセットされた。 | メソッド: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | この Signal の再帰的だが直接的でないソース（State）が、前の値と異なる値でセットされた。 | メソッド: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | `callback` の実行直前。 | アルゴリズム: dirty な計算 Signal の再計算 |\n| 5 | `~computing~` | `~clean~` | `callback` の評価が完了し、値が返されたか例外がスローされた。 | アルゴリズム: dirty な計算 Signal の再計算 |\n| 6 | `~checked~` | `~clean~` | この Signal のすべての直接的なソースが評価され、すべて変更がないことが判明したので、古くなっていないことが確定した。 | アルゴリズム: dirty な計算 Signal の再計算 |\n\n#### `Signal.Computed` 内部スロット\n\n- `value`: Signal の以前のキャッシュ値。未読の計算 Signal の場合は `~uninitialized~`。値が例外である場合、その値を読むときに再スローされます。effect signals の場合は常に `undefined`。\n- `state`: `~clean~`、`~checked~`、`~computing~`、`~dirty~` のいずれか。\n- `sources`: この Signal が依存している Signal の順序付きセット。\n- `sinks`: この Signal に依存している Signal の順序付きセット。\n- `equals`: オプションで提供された equals メソッド。\n- `callback`: 計算 Signal の値を取得するために呼ばれるコールバック。コンストラクタに渡された最初のパラメータ。\n\n#### `Signal.Computed` コンストラクタ\n\nコンストラクタは以下を設定します。\n- `callback` を最初のパラメータに設定\n- `equals` をオプションに基づき設定（指定がない場合は `Object.is` をデフォルト）\n- `state` を `~dirty~` に設定\n- `value` を `~uninitialized~` に設定\n\n[AsyncContext](https://github.com/tc39/proposal-async-context) を用いると、`new Signal.Computed` に渡されたコールバックはコンストラクタ呼び出し時点のスナップショットをクロージャし、実行時にこのスナップショットを復元します。\n\n#### メソッド: `Signal.Computed.prototype.get`\n\n1. 現在の実行コンテキストが `frozen` である場合、またはこの Signal の状態が `~computing~` である場合、もしくはこの Signal が Watcher で計算 Signal を `computing` している場合、例外をスローします。\n1. `computing` が `null` でない場合、この Signal を `computing` の `sources` セットに追加します。\n1. 注: この Signal の `sinks` セットに `computing` を追加するのは、Watcher により監視されるようになった場合のみです。\n1. この Signal の状態が `~dirty~` または `~checked~` である場合、次のステップをこの Signal が `~clean~` になるまで繰り返します:\n    1. `sources` を再帰的にたどり、`~dirty~` にマークされた一番深く左端（最も早く観測された）の計算 Signal を見つけます（`~clean~` の計算 Signal で探索を打ち切り、この計算 Signal 自身を探索の最後に含めます）。\n    1. その Signal に対し「dirty な計算 Signal の再計算」アルゴリズムを実行します。\n1. この時点で、この Signal の状態は `~clean~` となり、再帰的なソースにも `~dirty~` や `~checked~` は存在しません。Signal の `value` を返します。値が例外の場合、その例外を再スローします。\n\n### `Signal.subtle.Watcher` クラス\n\n#### `Signal.subtle.Watcher` 状態マシン\n\nWatcher の `state` は、以下のいずれかとなります。\n\n- `~waiting~`: `notify` コールバックが実行されたか、Watcher が新規作成されたが、まだ積極的にシグナルを監視していない状態。\n- `~watching~`: Watcher が積極的にシグナルを監視しているが、`notify` コールバックが必要となるような変化はまだ起きていない状態。\n- `~pending~`: Watcher の依存先が変更されたが、まだ `notify` コールバックが実行されていない状態。\n\n遷移グラフは以下のとおりです。\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\n遷移は以下のとおりです。\n| 番号 | From | To | 条件 | アルゴリズム |\n| ---- | ---- | -- | ---- | ------------ |\n| 1 | `~waiting~` | `~watching~` | Watcher の `watch` メソッドが呼び出された。 | メソッド: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Watcher の `unwatch` メソッドが呼び出され、最後に監視していた signal が削除された。 | メソッド: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | 監視している signal の値が変更された可能性がある。 | メソッド: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | `notify` コールバックが実行された。 | メソッド: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` 内部スロット\n\n- `state`: `~watching~`、`~pending~`、`~waiting~` のいずれか\n- `signals`: この Watcher が監視している Signal の順序付きセット\n- `notifyCallback`: 何かが変化したときに呼び出されるコールバック。コンストラクタに渡された最初のパラメータに設定\n\n#### コンストラクタ: `new Signal.subtle.Watcher(callback)`\n\n1. `state` は `~waiting~` に設定されます。\n1. `signals` を空のセットで初期化します。\n1. `notifyCallback` はコールバックパラメータに設定されます。",
  "status": "ok"
}