{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* Merk op dat de meeste frameworks tegenwoordig expliciete verwijdering vereisen van berekende Signals als ze enige referentie hebben naar of van een ander Signal-grafiek die in leven blijft.\n* Dit blijkt niet zo erg te zijn wanneer hun levensduur is gekoppeld aan de levensduur van een UI-component, en effecten toch verwijderd moeten worden.\n* Als het te duur is om met deze semantiek uit te voeren, dan zouden we expliciete verwijdering (of \"ontkoppeling\") van berekende Signals aan de onderstaande API moeten toevoegen, die dit momenteel niet heeft.\n* Een apart gerelateerd doel: Minimaliseer het aantal toewijzingen, bijvoorbeeld,\n    * om een schrijfbare Signal te maken (vermijd twee aparte closures + array)\n    * om effecten te implementeren (vermijd een closure voor elke afzonderlijke reactie)\n    * In de API voor het observeren van Signal-veranderingen, vermijd het aanmaken van extra tijdelijke datastructuren\n    * Oplossing: Klasse-gebaseerde API die hergebruik van methoden en velden in subklassen mogelijk maakt\n\n## API-overzicht\n\nEen eerste idee van een Signal-API staat hieronder. Let op: dit is slechts een vroege conceptversie en we verwachten dat deze in de loop van de tijd zal veranderen. Laten we beginnen met de volledige `.d.ts` om een beeld te krijgen van de algemene structuur, en daarna bespreken we de details van wat dit allemaal betekent.\n\n```ts\ninterface Signal<T> {\n    // Haal de waarde van het signaal op\n    get(): T;\n}\n\nnamespace Signal {\n    // Een lees-schrijf Signaal\n    class State<T> implements Signal<T> {\n        // Maak een status Signaal dat begint met de waarde t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Haal de waarde van het signaal op\n        get(): T;\n\n        // Stel de waarde van het status Signaal in op t\n        set(t: T): void;\n    }\n\n    // Een Signaal dat een formule is gebaseerd op andere Signal(en)\n    class Computed<T = unknown> implements Signal<T> {\n        // Maak een Signaal dat evalueert naar de waarde die door de callback wordt geretourneerd.\n        // Callback wordt aangeroepen met dit signaal als de this-waarde.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Haal de waarde van het signaal op\n        get(): T;\n    }\n\n    // Deze namespace bevat \"geavanceerde\" functies die beter zijn\n    // voor framework-auteurs dan voor applicatie-ontwikkelaars.\n    // Vergelijkbaar met `crypto.subtle`\n    namespace subtle {\n        // Voer een callback uit met alle tracking uitgeschakeld\n        function untrack<T>(cb: () => T): T;\n\n        // Haal het huidige berekende signaal op dat signal-lezen bijhoudt, indien aanwezig\n        function currentComputed(): Computed | null;\n\n        // Geeft een geordende lijst van alle signalen die door deze zijn geraadpleegd\n        // tijdens de laatste evaluatie.\n        // Voor een Watcher, lijst van signalen die het observeert.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Geeft de Watchers terug waarin dit signaal is opgenomen, plus eventuele\n        // Computed signalen die dit signaal lazen bij de laatste evaluatie,\n        // mits dat computed signaal (recursief) wordt geobserveerd.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True als dit signaal \"live\" is, oftewel als het wordt geobserveerd door een Watcher,\n        // of gelezen wordt door een Computed signaal dat (recursief) live is.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True als dit element \"reactief\" is, d.w.z. afhankelijk\n        // van een ander signaal. Een Computed waarbij hasSources false is\n        // zal altijd dezelfde constante waarde teruggeven.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // Wanneer een (recursieve) bron van de Watcher wordt beschreven, roep deze callback aan,\n            // als deze niet al is aangeroepen sinds de laatste `watch`-aanroep.\n            // Er mogen tijdens de notify geen signalen worden gelezen of geschreven.\n            constructor(notify: (this: Watcher) => void);\n\n            // Voeg deze signalen toe aan de Watcher-set, en stel de watcher in om zijn\n            // notify-callback uit te voeren de volgende keer dat een signaal in de set (of een van zijn afhankelijkheden) verandert.\n            // Kan zonder argumenten worden aangeroepen om alleen de \"notified\"-status te resetten, zodat\n            // de notify-callback opnieuw wordt aangeroepen.\n            watch(...s: Signal[]): void;\n\n            // Verwijder deze signalen uit de geobserveerde set (bijvoorbeeld voor een effect dat wordt verwijderd)\n            unwatch(...s: Signal[]): void;\n\n            // Geeft de set van bronnen in de Watcher-set die nog \"dirty\" zijn terug, of een computed signaal\n            // met een bron die \"dirty\" of \"pending\" is en nog niet opnieuw is geëvalueerd\n            getPending(): Signal[];\n        }\n\n        // Hooks om te observeren dat een signaal wordt geobserveerd of niet meer wordt geobserveerd\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Aangepaste vergelijkingsfunctie tussen oude en nieuwe waarde. Standaard: Object.is.\n        // Het signaal wordt als de this-waarde meegegeven voor context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}