{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q**: Signals 是否能像 React 那樣支援單向資料流？\n\n**A**: 可以，Signals 是一種單向資料流的機制。以 Signals 為基礎的 UI 框架讓你能將視圖表達為模型的函式（其中模型包含 Signals）。狀態與計算型 Signals 所組成的圖在構建時就是無環的。同時，也可以在 Signals 中重現 React 的反模式（！），例如在 `useEffect` 裡呼叫 `setState` 的 Signals 等價寫法，是用 Watcher 來安排對 State signal 的寫入。\n\n**Q**: Signals 與像 Redux 這類狀態管理系統有什麼關係？Signals 是否鼓勵無結構的狀態？\n\n**A**: Signals 可以作為類似 store 狀態管理抽象的高效基礎。多個框架中常見的一種模式是基於 Proxy 的物件，內部用 Signals 來表示屬性，例如 [Vue 的 `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive)，或 [Solid stores](https://docs.solidjs.com/concepts/stores)。這些系統讓應用能在合適的抽象層次靈活地分組狀態。\n\n**Q**: Signals 提供了哪些 `Proxy` 目前無法處理的功能？\n\n**A**: Proxy 和 Signals 是互補的，且能很好地結合使用。Proxy 讓你攔截淺層物件操作，而 Signals 協調（cell）依賴圖。用 Signals 作為 Proxy 的底層，是建立巢狀響應式結構且具備良好易用性的絕佳方式。\n\n在這個例子中，我們可以用 proxy 讓 signal 變成有 getter 和 setter 屬性的方式，而不是用 `get` 和 `set` 方法：\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// 在假設的響應式上下文中的用法：\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\n在使用針對細粒度反應性優化的 renderer 時，點擊按鈕會使 `b.value` cell 被更新。\n\n參見：\n- 用 Signals 與 Proxy 建立的巢狀響應式結構範例：[signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- 展示 reactive data 與 proxies 關係的過往實現範例：[tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [討論](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574)。\n\n#### Signals 如何運作？\n\n**Q**: Signals 是推送（push-based）還是拉取（pull-based）？\n\n**A**: 計算型 Signals 的求值是拉取式的：只有當呼叫 `.get()` 時，計算型 Signal 才會被求值，即使底層狀態早已變更。同時，改變 State signal 可能會立即觸發 Watcher 的 callback，\"推送\" 通知。所以 Signals 可視為「推-拉混合」結構。\n\n**Q**: Signals 會讓 JavaScript 執行帶來非決定性嗎？\n\n**A**: 不會。首先，所有 Signal 操作都有明確的語意與順序，且在符合規範的實作間不會有差異。在更高層次上，Signals 遵循一組不變式，其設計是「健全」的。計算型 Signal 總是在 Signal 圖處於一致狀態時觀察其狀態，且其執行不會被其他會改變 Signal 的程式碼中斷（除了它自己呼叫的情況）。詳見上文說明。\n\n**Q**: 當我寫入 state Signal 時，計算型 Signal 何時會排程更新？\n\n**A**: 並不會排程！計算型 Signal 會在下次有人讀取時自行重新計算。同步地，Watcher 的 `notify` callback 可能會被呼叫，使框架能在適當時機安排讀取。\n\n**Q**: 寫入 state Signals 何時生效？是立即生效還是會批次處理？\n\n**A**: 寫入 state Signals 會立即反映——下次有依賴該 state Signal 的計算型 Signal 被讀取時，它就會在需要時重新計算，即使是在緊接著的程式碼行。不過，這個機制本身的惰性（計算型 Signal 只在被讀取時才計算）意味著在實務上計算可能會以批次方式發生。\n\n**Q**: Signals 能讓執行「無瑕疵（glitch-free）」是什麼意思？\n\n**A**: 先前的推送式反應模型會遇到冗餘計算的問題：如果對 state Signal 的更新使計算型 Signal 立即執行，最終可能會推送更新到 UI。但如果在下一個 frame 之前還會有其他對來源 state Signal 的變更，這次寫入 UI 可能就過早。有時甚至因為這類 [glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches) 而讓終端用戶看到不正確的中間值。Signals 透過採用拉取式而非推送式來避免這種動態：當框架安排 UI 渲染時，它會拉取（pull）適當的更新，避免運算及 DOM 寫入上的浪費。\n\n**Q**: Signals 是「有損（lossy）」的意思是什麼？\n\n**A**: 這正是無瑕疵執行的反面：Signal 只代表一個資料 cell——即當前的即時值（會變動），而不是一段時間內的資料流。因此，如果你連續兩次寫入 state Signal，沒做其他動作，第一次寫入就會「遺失」且永遠不會被任何計算型 Signal 或 effect 看到。這被視為 feature 而非 bug——其他結構（如 async iterables、observables）才比較適合用來處理資料流。\n\n**Q**: 原生 Signals 會比現有的 JS Signals 實作更快嗎？\n\n**A**: 我們希望如此（會有一個小的常數因子提升），但這還有待實際程式驗證。JS 引擎並不是魔法，最終還是需要實作與 JS 版本 Signals 類似的演算法。詳見上文效能相關章節。\n\n#### 為什麼要這樣設計 Signals？\n\n**Q**: 為什麼這份提案沒包含 `effect()` 函式，但實務上使用 Signals 又必須要有 effects？\n\n**A**: Effect 本質上涉及排程與釋放，這是由框架管理、且超出本提案範圍的內容。本提案改以更底層的 `Signal.subtle.Watcher` API 作為實現 effect 的基礎。\n\n**Q**: 為什麼訂閱（subscription）是自動的，而不是提供手動介面？\n\n**A**: 經驗顯示，手動訂閱介面的反應性既不易用又容易出錯。自動追蹤更具組合性，也是 Signals 的核心特性。\n\n**Q**: 為什麼 `Watcher` 的 callback 是同步執行，而不是用 microtask 排程？\n\n**A**: 因為該 callback 不能讀寫 Signals，因此同步呼叫不會帶來健全性問題。典型 callback 會把一個 Signal 加到 Array 以便稍後讀取，或在某處標記一個位元。為這類操作都單獨安排 microtask 既沒必要又成本過高。\n\n**Q**: 這個 API 缺少了我最愛框架所提供、讓 Signal 更好用的某些功能。這些能不能也納入標準？\n\n**A**: 也許。各種擴充功能仍在討論中。如果有發現重要但缺失的功能，請提出 issue 來討論。\n\n**Q**: 這個 API 可以再縮減規模或簡化嗎？\n\n**A**: 我們的確將 API 最小化作為目標，以上所示就是努力的結果。如果你有認為還能刪減的部分，歡迎提出 issue 討論。\n\n#### Signals 如何被標準化？\n\n**Q**: 難道我們不該先從更原始的概念（如 observables）開始進行標準化嗎？",
  "status": "ok"
}