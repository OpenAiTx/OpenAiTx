{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "مع [AsyncContext](https://github.com/tc39/proposal-async-context)، فإن الاستدعاء العكسي (callback) الذي يُمرر إلى `new Signal.subtle.Watcher` لا يغلق (close over) على اللقطة (snapshot) من وقت استدعاء المُنشئ، بحيث تكون المعلومات السياقية حول الكتابة مرئية.\n\n#### الطريقة: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. إذا كانت قيمة `frozen` تساوي true، قم برمي استثناء.\n1. إذا كان أي من الوسائط ليس إشارة (signal)، قم برمي استثناء.\n1. أضف جميع الوسائط إلى نهاية خاصية `signals` لهذا الكائن.\n1. لكل إشارة تتم مراقبتها حديثًا، من اليسار إلى اليمين،\n    1. أضف هذا المراقب (watcher) كـ `sink` لتلك الإشارة.\n    1. إذا كان هذا هو الـ sink الأول، عندها قم بالتكرار تصاعديًا إلى المصادر لإضافة تلك الإشارة كـ sink.\n    1. اضبط `frozen` إلى true.\n    1. استدعِ الاستدعاء العكسي `watched` إذا كان موجودًا.\n    1. أعد قيمة `frozen` إلى false.\n1. إذا كانت حالة الإشارة (Signal) هي `~waiting~`، قم بتغييرها إلى `~watching~`.\n\n#### الطريقة: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. إذا كانت قيمة `frozen` تساوي true، قم برمي استثناء.\n1. إذا كان أي من الوسائط ليس إشارة، أو لا تتم مراقبته بواسطة هذا المراقب، قم برمي استثناء.\n1. لكل إشارة في الوسائط، من اليسار إلى اليمين،\n    1. أزل تلك الإشارة من مجموعة `signals` لهذا المراقب.\n    1. أزل هذا المراقب من مجموعة `sink` لتلك الإشارة.\n    1. إذا أصبحت مجموعة الـ `sink` لتلك الإشارة فارغة، أزل تلك الإشارة كـ sink من كل مصادرها.\n    1. اضبط `frozen` إلى true.\n    1. استدعِ الاستدعاء العكسي `unwatched` إذا كان موجودًا.\n    1. أعد قيمة `frozen` إلى false.\n1. إذا لم يكن لدى المراقب الآن أي `signals`، وكانت حالته `~watching~`، فغيّرها إلى `~waiting~`.\n\n#### الطريقة: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. أعد مصفوفة تحتوي على مجموعة فرعية من `signals` والتي هي إشارات محسوبة (Computed Signals) في حالتي `~dirty~` أو `~pending~`.\n\n### الطريقة: `Signal.subtle.untrack(cb)`\n\n1. دع `c` تساوي حالة `computing` الحالية لسياق التنفيذ.\n1. اضبط `computing` إلى null.\n1. استدعِ `cb`.\n1. أعد قيمة `computing` إلى `c` (حتى لو رمى `cb` استثناءً).\n1. أعد قيمة الإرجاع لـ `cb` (مع إعادة رمي أي استثناء).\n\nملاحظة: `untrack` لا يخرجك من حالة `frozen`، والتي يتم الحفاظ عليها بدقة.\n\n### الطريقة: `Signal.subtle.currentComputed()`\n\n1. أعد قيمة `computing` الحالية.\n\n### الخوارزميات الشائعة\n\n##### خوارزمية: إعادة حساب إشارة محسوبة متسخة (dirty computed Signal)\n\n1. امسح مجموعة `sources` لهذه الإشارة، وأزلها من مجموعات الـ `sinks` لتلك المصادر.\n1. احفظ قيمة `computing` السابقة واضبط `computing` إلى هذه الإشارة.\n1. اضبط حالة هذه الإشارة إلى `~computing~`.\n1. نفذ الاستدعاء العكسي (callback) لهذه الإشارة المحسوبة، باستخدام هذه الإشارة كقيمة this. احفظ قيمة الإرجاع، وإذا رمى الاستدعاء العكسي استثناءً، خزّنه لإعادة رميه لاحقًا.\n1. أعد قيمة `computing` السابقة.\n1. طبق خوارزمية \"تعيين قيمة الإشارة\" على قيمة الإرجاع للاستدعاء العكسي.\n2. اضبط حالة هذه الإشارة إلى `~clean~`.\n1. إذا أعادت تلك الخوارزمية القيمة `~dirty~`: علّم جميع sinks لهذه الإشارة كـ `~dirty~` (ربما كانت sinks سابقًا مزيجًا من checked وdirty). (أو، إذا لم تكن هذه الإشارة مراقبة، اعتمد رقم جيل جديد للدلالة على الاتساخ، أو شيء من هذا القبيل.)\n1. وإلا، إذا أعادت تلك الخوارزمية القيمة `~clean~`: في هذه الحالة، لكل sink بحالة `~checked~` لهذه الإشارة، إذا كانت كل مصادر تلك الإشارة الآن نظيفة، علّم تلك الإشارة كـ `~clean~` أيضًا. طبق هذه الخطوة التنظيفية بشكل متكرر على sinks إضافية، على أي إشارات أصبحت نظيفة حديثًا ولديها sinks بحالة checked. (أو، إذا لم تكن هذه الإشارة مراقبة، أشر إلى نفس الشيء بطريقة ما، بحيث يمكن متابعة عملية التنظيف بشكل كسول.)\n\n##### خوارزمية تعيين قيمة الإشارة (Set Signal value algorithm)\n\n1. إذا تم تمرير قيمة لهذه الخوارزمية (وليس استثناء لإعادة رميه، من خوارزمية إعادة حساب إشارة محسوبة متسخة):\n    1. استدعِ دالة `equals` لهذه الإشارة، مع تمرير القيم الحالية والجديدة وهذه الإشارة كوسائط. إذا تم رمي استثناء، احفظ ذلك الاستثناء (لإعادة رميه عند القراءة) كقيمة للإشارة وواصل كما لو أن الاستدعاء العكسي أعاد false.\n    1. إذا أعادت تلك الدالة true، أعد `~clean~`.\n1. اضبط قيمة `value` لهذه الإشارة إلى الوسيط.\n1. أعد `~dirty~`\n\n## الأسئلة الشائعة (FAQ)\n\n**س**: أليس من المبكر بعض الشيء توحيد شيء متعلق بالإشارات (Signals)، وقد بدأت لتوها تصبح شيئًا رائجًا في عام 2022؟ ألا يجب أن نمنحها مزيدًا من الوقت لتتطور وتستقر؟\n\n**ج**: الحالة الحالية للإشارات في أطر عمل الويب هي نتيجة أكثر من 10 سنوات من التطوير المستمر. مع زيادة الاستثمارات، كما حدث في السنوات الأخيرة، تقترب معظم أطر العمل من نموذج أساسي متشابه جدًا للإشارات. هذا الاقتراح هو نتيجة تمرين تصميم مشترك بين عدد كبير من القادة الحاليين في أطر عمل الويب، ولن يتم دفعه إلى التوحيد القياسي بدون تحقق تلك المجموعة من خبراء المجال في سياقات متنوعة.\n\n#### كيف تُستخدم الإشارات؟\n\n**س**: هل يمكن حتى للأطر (frameworks) استخدام الإشارات المدمجة (built-in Signals)، بالنظر إلى تكاملها الوثيق مع العرض (rendering) والملكية (ownership)؟\n\n**ج**: الأجزاء التي تميل لأن تكون أكثر خصوصية بالإطار تكون في مجال التأثيرات (effects)، والجدولة (scheduling)، والملكية/التخلص (ownership/disposal)، والتي لا يحاول هذا الاقتراح حلها. أولويتنا الأولى مع نمذجة إشارات معيارية هي التحقق من أنه يمكنها العمل \"تحت\" الأطر الحالية بشكل متوافق وبأداء جيد.\n\n**س**: هل من المفترض استخدام واجهة برمجة التطبيقات (API) الخاصة بالإشارة مباشرة من قبل مطوري التطبيقات، أم مغلفة من قبل الأطر؟\n\n**ج**: بينما يمكن لمطوري التطبيقات استخدام هذه الواجهة مباشرة (على الأقل الجزء الذي ليس ضمن مساحة الاسم `Signal.subtle`)، إلا أنها ليست مصممة لتكون مريحة بشكل خاص. بدلاً من ذلك، تم إعطاء الأولوية لاحتياجات مؤلفي المكتبات/الأطر. من المتوقع أن تغلف معظم الأطر حتى واجهات `Signal.State` و`Signal.Computed` الأساسية بشيء يعكس أسلوبها المريح. عمليًا، غالبًا ما يكون من الأفضل استخدام الإشارات عبر إطار، حيث يدير الميزات الأكثر تعقيدًا (مثل Watcher، `untrack`)، بالإضافة إلى إدارة الملكية والتخلص (مثل تحديد متى يجب إضافة الإشارات إلى المراقبين وإزالتها)، وجدولة العرض إلى DOM--هذا الاقتراح لا يحاول حل تلك المشاكل.\n\n**س**: هل يجب علي تفكيك الإشارات المرتبطة بعنصر واجهة المستخدم (widget) عند تدمير ذلك العنصر؟ ما هي واجهة برمجة التطبيقات لذلك؟\n\n**ج**: عملية التفكيك ذات الصلة هنا هي `Signal.subtle.Watcher.prototype.unwatch`. فقط الإشارات المراقبة تحتاج إلى تنظيف (عن طريق إلغاء مراقبتها)، بينما يمكن جمع الإشارات غير المراقبة تلقائيًا عبر الـ garbage collector.\n\n**س**: هل تعمل الإشارات مع VDOM، أم مباشرة مع DOM الـ HTML الأساسي؟\n\n**ج**: نعم! الإشارات مستقلة عن تقنية العرض. أطر جافاسكريبت الحالية التي تستخدم بنى شبيهة بالإشارات تتكامل مع VDOM (مثل Preact)، وDOM الأصلي (مثل Solid)، ومزيج بينهما (مثل Vue). سيكون نفس الشيء ممكنًا مع الإشارات المدمجة.\n\n**س**: هل سيكون من المريح استخدام الإشارات في سياق الأطر المعتمدة على الفئات (class-based) مثل Angular وLit؟ ماذا عن الأطر المعتمدة على المترجم (compiler) مثل Svelte؟\n\n**ج**: يمكن جعل حقول الفئة (class fields) معتمدة على الإشارات بسهولة باستخدام مزين accessors، كما هو موضح في [دليل polyfill للإشارة](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). الإشارات متماشية جدًا مع Runes في Svelte 5--من السهل على المترجم تحويل runes إلى واجهة Signal API المحددة هنا، وفي الواقع هذا ما يفعله Svelte 5 داخليًا (ولكن مع مكتبته الخاصة للإشارات).\n\n**س**: هل تعمل الإشارات مع SSR؟ الترطيب (Hydration)؟ الاستئناف (Resumability)؟\n\n**ج**: نعم. يستخدم Qwik الإشارات بفاعلية مع كل من هذه الخصائص، ولدى أطر أخرى طرق متطورة أخرى للترطيب باستخدام الإشارات مع مفاضلات مختلفة. نعتقد أنه من الممكن نمذجة إشارات Qwik القابلة للاستئناف باستخدام إشارة State وإشارة Computed مرتبطتين معًا، ونخطط لإثبات ذلك في الكود.",
  "status": "ok"
}