{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "Состояние (`state`) вычисляемого сигнала (Computed Signal) может быть одним из следующих:\n\n- `~clean~`: Значение сигнала присутствует и гарантированно не устарело.\n- `~checked~`: (Косвенный) источник этого сигнала изменился; у сигнала есть значение, но оно _может_ быть устаревшим. Является ли оно устаревшим, станет известно только после оценки всех непосредственных источников.\n- `~computing~`: В данный момент выполняется обратный вызов (callback) этого сигнала как побочный эффект вызова `.get()`.\n- `~dirty~`: Либо у этого сигнала есть значение, которое гарантированно устарело, либо он никогда не вычислялся.\n\nГраф переходов выглядит следующим образом:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nПереходы:\n| Номер | Откуда | Куда | Условие | Алгоритм |\n| ----- | ------ | ---- | ------- | -------- |\n| 1 | `~checked~` | `~dirty~` | Был оценен непосредственный источник этого сигнала, который сам является вычисляемым сигналом, и его значение изменилось. | Алгоритм: пересчитать устаревший вычисляемый сигнал |\n| 2 | `~clean~` | `~dirty~` | Был установлен непосредственный источник этого сигнала, который является состоянием (State), с новым значением, не равным предыдущему. | Метод: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Рекурсивный, но не непосредственный, источник этого сигнала, который является состоянием (State), был установлен с новым значением, не равным предыдущему. | Метод: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | Сейчас будет выполнен `callback`. | Алгоритм: пересчитать устаревший вычисляемый сигнал |\n| 5 | `~computing~` | `~clean~` | `callback` завершил вычисление и вернул значение либо сгенерировал исключение. | Алгоритм: пересчитать устаревший вычисляемый сигнал |\n| 6 | `~checked~` | `~clean~` | Все непосредственные источники этого сигнала были оценены, и все остались неизменными, значит, сигнал гарантированно не устарел. | Алгоритм: пересчитать устаревший вычисляемый сигнал |\n\n#### Внутренние слоты `Signal.Computed`\n\n- `value`: Предыдущее кэшированное значение сигнала или `~uninitialized~` для вычисляемого сигнала, который ни разу не читался. Значением может быть исключение, которое будет выброшено при чтении значения. Для сигналов-эффектов всегда `undefined`.\n- `state`: Может быть `~clean~`, `~checked~`, `~computing~` или `~dirty~`.\n- `sources`: Упорядоченное множество сигналов, от которых зависит этот сигнал.\n- `sinks`: Упорядоченное множество сигналов, которые зависят от этого сигнала.\n- `equals`: Метод сравнения, переданный в опциях.\n- `callback`: Функция обратного вызова, вызываемая для получения значения вычисляемого сигнала. Устанавливается первым параметром конструктора.\n\n#### Конструктор `Signal.Computed`\n\nКонструктор устанавливает:\n- `callback` в значение первого параметра\n- `equals` согласно опциям, по умолчанию `Object.is`, если не указано\n- `state` в `~dirty~`\n- `value` в `~uninitialized~`\n\nС использованием [AsyncContext](https://github.com/tc39/proposal-async-context), callback, переданный в `new Signal.Computed`, замыкает снимок состояния (snapshot) на момент вызова конструктора и восстанавливает его во время выполнения.\n\n#### Метод: `Signal.Computed.prototype.get`\n\n1. Если текущий контекст выполнения `frozen` или если у этого сигнала состояние `~computing~`, или если этот сигнал является Watcher и происходит вычисление вычисляемого сигнала, выбросить исключение.\n1. Если `computing` не `null`, добавить этот сигнал в множество `sources` сигнала `computing`.\n1. ПРИМЕЧАНИЕ: Мы не добавляем `computing` в множество `sinks` этого сигнала до тех пор, пока он не будет отслежен (watched) Watcher'ом.\n1. Если состояние этого сигнала `~dirty~` или `~checked~`: Повторять следующие шаги, пока состояние этого сигнала не станет `~clean~`:\n    1. Рекурсивно пройти вверх по `sources`, чтобы найти самый глубокий, левый (то есть самый ранее обнаруженный) рекурсивный источник, который является вычисляемым сигналом в состоянии `~dirty~` (прервать поиск при встрече `~clean~` вычисляемого сигнала; включить этот вычисляемый сигнал как последний элемент поиска).\n    1. Выполнить алгоритм \"пересчитать устаревший вычисляемый сигнал\" для этого сигнала.\n1. На этом этапе состояние сигнала будет `~clean~`, и ни один рекурсивный источник не будет `~dirty~` или `~checked~`. Вернуть значение сигнала (`value`). Если значение — это исключение, выбросить это исключение.\n\n### Класс `Signal.subtle.Watcher`\n\n#### Состояния `Signal.subtle.Watcher`\n\nСостояние (`state`) Watcher может быть одним из следующих:\n\n- `~waiting~`: Колбэк `notify` был вызван, или Watcher только что создан, но в данный момент не отслеживает ни одного сигнала.\n- `~watching~`: Watcher активно отслеживает сигналы, но пока не произошло изменений, требующих вызова `notify`.\n- `~pending~`: Зависимость Watcher изменилась, но колбэк `notify` еще не был вызван.\n\nГраф переходов выглядит следующим образом:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nПереходы:\n| Номер | Откуда | Куда | Условие | Алгоритм |\n| ----- | ------ | ---- | ------- | -------- |\n| 1 | `~waiting~` | `~watching~` | Был вызван метод `watch` Watcher'а. | Метод: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Был вызван метод `unwatch` Watcher'а и последний отслеживаемый сигнал был удален. | Метод: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Отслеживаемый сигнал мог изменить значение. | Метод: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | Был вызван колбэк `notify`. | Метод: `Signal.State.prototype.set(newValue)` |\n\n#### Внутренние слоты `Signal.subtle.Watcher`\n\n- `state`: Может быть `~watching~`, `~pending~` или `~waiting~`\n- `signals`: Упорядоченное множество сигналов, которые отслеживает этот Watcher\n- `notifyCallback`: Колбэк, вызываемый при изменении чего-либо. Устанавливается первым параметром конструктора.\n\n#### Конструктор: `new Signal.subtle.Watcher(callback)`\n\n1. `state` устанавливается в `~waiting~`.\n1. `signals` инициализируется как пустое множество.\n1. `notifyCallback` устанавливается равным параметру callback.",
  "status": "ok"
}