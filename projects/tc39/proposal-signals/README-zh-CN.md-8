{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**问**：Signals 是否能像 React 那样支持单向数据流？\n\n**答**：是的，Signals 是一种实现单向数据流的机制。基于 Signal 的 UI 框架允许你将视图表达为模型的函数（其中模型包含 Signals）。状态和计算 Signal 组成的图在设计上是非循环的。当然，也可以在 Signals 内部重现 React 的反模式（！），例如，在 `useEffect` 内部调用 `setState` 的 Signal 等价物，就是使用 Watcher 来安排对 State Signal 的写入。\n\n**问**：Signals 与 Redux 等状态管理系统有何关系？Signals 是否会导致非结构化状态？\n\n**答**：Signals 可以作为类似 store 的状态管理抽象的高效基础。多个框架中的常见模式是基于 Proxy 的对象，其内部使用 Signals 表示属性，例如 [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive)，或 [Solid stores](https://docs.solidjs.com/concepts/stores)。这些系统使得可以根据具体应用，在合适的抽象层级灵活地组织状态。\n\n**问**：Signals 提供了 `Proxy` 目前无法处理的哪些功能？\n\n**答**：Proxies 和 Signals 是互补的，且可以很好地结合使用。Proxy 允许你拦截浅层对象操作，而 Signal 协调依赖图（cell）。用 Signals 作为 Proxy 的底层支持，是实现高可用性嵌套响应式结构的极佳方式。\n\n在本例中，我们可以使用 proxy 让 signal 拥有 getter 和 setter 属性，而不是使用 `get` 和 `set` 方法：\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// 在假定的响应式上下文中的用法：\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\n当使用针对细粒度响应式优化的渲染器时，点击按钮会导致 `b.value` cell 被更新。\n\n参见：\n- 使用 Signals 和 Proxies 创建的嵌套响应式结构示例：[signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- 展示响应式数据与 proxies 关系的早期实现示例：[tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [讨论](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574)。\n\n#### Signals 是如何工作的？\n\n**问**：Signals 是推送（push-based）还是拉取（pull-based）机制？\n\n**答**：计算 Signal 的求值是拉取式的：只有在调用 `.get()` 时才会对计算 Signal 求值，即使底层状态早已发生变化。同时，改变 State Signal 可能会立即触发 Watcher 的回调，实现“推送”通知。所以可以认为 Signals 是一种“推-拉结合”的结构。\n\n**问**：Signals 会给 JavaScript 执行引入不确定性吗？\n\n**答**：不会。首先，所有 Signal 操作都有明确定义的语义和顺序，不会在符合规范的实现之间有所不同。在更高层面上，Signals 遵循一组不变式，并且在这些方面是“可靠”的。计算 Signal 总是在一致状态下观察 Signal 图，其执行不会被其他 Signal 修改代码中断（除了它自身调用的内容）。见上文描述。\n\n**问**：当我写入 state Signal 时，何时会调度对计算 Signal 的更新？\n\n**答**：并不会调度！计算 Signal 会在下一次被读取时自行重新计算。同步地，Watcher 的 `notify` 回调可能会被调用，使框架能够在合适的时间安排读取。\n\n**问**：写入 state Signals 何时生效？是立即生效还是会被批处理？\n\n**答**：写入 state Signals 会立即反映——下次依赖此 state Signal 的计算 Signal 被读取时，如果需要会立即重新计算，即使是在紧接着的下一行代码中。不过，由于计算 Signal 只有在读取时才会被计算（即惰性机制），实际上这些计算可能会以批处理的方式发生。\n\n**问**：Signals 实现“无毛刺（glitch-free）”执行是什么意思？\n\n**答**：早期基于推送的响应式模型面临冗余计算问题：如果对 state Signal 的更新导致计算 Signal 立即运行，最终可能会推动 UI 更新。但如果在下一帧之前还会有另一个 state Signal 的更改，这种对 UI 的写入就为时过早了。有时，由于这种[毛刺](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)，甚至会向用户展示不准确的中间值。Signals 通过采用拉取式而不是推送式，避免了这种动态：框架在调度 UI 渲染时，会拉取所需的更新，避免了计算和写入 DOM 的无用功。\n\n**问**：Signals 是“有损（lossy）”的是什么意思？\n\n**答**：这是无毛刺执行的另一面：Signals 代表一个数据单元——仅有当前值（可能会更改），而不是随时间流的数据流。因此，如果你连续两次写入 state Signal，而没有做其他操作，第一次写入会“丢失”，不会被任何计算 Signal 或副作用看到。这被认为是一种特性而非缺陷——对于数据流，其他结构（如 async iterables、observables）更为合适。\n\n**问**：原生 Signals 会比现有的 JS Signal 实现更快吗？\n\n**答**：我们希望如此（有一个小的常数因子），但这还需要通过代码验证。JS 引擎并不是魔法，最终也需要实现与 JS 版 Signals 类似的算法。关于性能问题，见上文相关章节。\n\n#### Signals 为什么要这样设计？\n\n**问**：为什么本提案没有包含 `effect()` 函数，而 effect 对于实际使用 Signals 是必须的？\n\n**答**：effect 本质上涉及调度和销毁，这些由框架管理，超出了本提案的范围。本提案通过更底层的 `Signal.subtle.Watcher` API 提供实现 effect 的基础。\n\n**问**：为什么订阅是自动的，而不是提供手动接口？\n\n**答**：经验表明，响应式的手动订阅接口难以使用且容易出错。自动跟踪更具可组合性，也是 Signals 的核心特性。\n\n**问**：为什么 `Watcher` 的回调是同步运行，而不是在微任务中调度？\n\n**答**：因为回调无法读取或写入 Signals，所以同步调用不会带来不一致性。典型的回调只是将 Signal 添加到一个数组中以便稍后读取，或在某处标记一个位。为所有这些操作单独创建微任务既没有必要，也不切实际地昂贵。\n\n**问**：这个 API 缺少了一些我喜欢的框架提供的便捷功能，这些功能让使用 Signals 更方便。标准中也能加入吗？\n\n**答**：也许。各种扩展还在讨论中。请提交 issue，讨论你认为重要但缺失的功能。\n\n**问**：这个 API 是否可以进一步精简或简化？\n\n**答**：保持 API 最小化绝对是目标，我们已经尽量精简了上面展示的内容。如果你有建议可以再删减的部分，请提交 issue 讨论。\n\n#### Signals 是如何标准化的？\n\n**问**：我们在这个领域的标准化工作，是否应该从更原始的概念（如 observables）开始？",
  "status": "ok"
}