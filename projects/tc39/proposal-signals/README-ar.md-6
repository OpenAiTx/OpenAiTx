{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "قد تكون حالة الـ `state` لإشارة محسوبة (Computed Signal) واحدة من الحالات التالية:\n\n- `~clean~`: قيمة الإشارة موجودة ومعروفة بأنها غير قديمة (غير باطلة).\n- `~checked~`: أحد المصادر (غير المباشرة) لهذه الإشارة قد تغيّر؛ هذه الإشارة لديها قيمة ولكن _قد_ تكون قديمة. سيتم معرفة ما إذا كانت قديمة أم لا فقط بعد تقييم جميع المصادر المباشرة.\n- `~computing~`: يتم حالياً تنفيذ رد نداء (callback) هذه الإشارة كأثر جانبي لاستدعاء `.get()`.\n- `~dirty~`: إما أن تكون هذه الإشارة لديها قيمة معروفة بأنها قديمة، أو أنها لم يتم تقييمها أبداً.\n\nمخطط الانتقال كما يلي:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nالانتقالات هي:\n| الرقم | من | إلى | الشرط | الخوارزمية |\n| ----- | --- | -- | ------ | ----------- |\n| 1 | `~checked~` | `~dirty~` | تم تقييم مصدر مباشر لهذه الإشارة، وهو إشارة محسوبة، وتغيّرت قيمته. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |\n| 2 | `~clean~` | `~dirty~` | تم تعيين مصدر مباشر لهذه الإشارة، وهو حالة (State)، بقيمة لا تساوي القيمة السابقة. | الطريقة: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | تم تعيين مصدر متكرر (وليس مباشر) لهذه الإشارة، وهو حالة (State)، بقيمة لا تساوي القيمة السابقة. | الطريقة: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | على وشك تنفيذ الـ `callback`. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |\n| 5 | `~computing~` | `~clean~` | انتهى تقييم الـ `callback` وأعاد قيمة أو رمى استثناء. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |\n| 6 | `~checked~` | `~clean~` | تم تقييم جميع المصادر المباشرة لهذه الإشارة، ولم تتغير أي منها، وبالتالي نعلم الآن أنها ليست قديمة. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |\n\n#### الخانات الداخلية لـ `Signal.Computed`\n\n- `value`: القيمة المخبأة السابقة للإشارة، أو `~uninitialized~` لإشارة محسوبة لم يتم قراءتها أبداً. قد تكون القيمة استثناءً يتم إعادة رميه عند قراءة القيمة. دائماً `undefined` لإشارات التأثير (effect signals).\n- `state`: قد تكون `~clean~` أو `~checked~` أو `~computing~` أو `~dirty~`.\n- `sources`: مجموعة مرتبة من الإشارات التي تعتمد عليها هذه الإشارة.\n- `sinks`: مجموعة مرتبة من الإشارات التي تعتمد على هذه الإشارة.\n- `equals`: طريقة المقارنة المقدمة في الخيارات.\n- `callback`: رد النداء الذي يتم استدعاؤه لجلب قيمة الإشارة المحسوبة. يتم تعيينه إلى أول وسيط يُمرر إلى الباني.\n\n#### باني `Signal.Computed`\n\nيقوم الباني بتعيين\n- `callback` إلى أول وسيط يُمرر له\n- `equals` بناءً على الخيارات، الافتراضي هو `Object.is` إذا لم يوجد\n- `state` إلى `~dirty~`\n- `value` إلى `~uninitialized~`\n\nمع [AsyncContext](https://github.com/tc39/proposal-async-context)، يقوم رد النداء الممرر إلى `new Signal.Computed` بالاحتفاظ بلقطة من السياق عند استدعاء الباني، ويعيد هذه اللقطة أثناء التنفيذ.\n\n#### الطريقة: `Signal.Computed.prototype.get`\n\n1. إذا كان سياق التنفيذ الحالي `frozen` أو إذا كانت حالة هذه الإشارة هي `~computing~`، أو إذا كانت هذه الإشارة Watcher و`computing` لإشارة محسوبة، قم برمي استثناء.\n1. إذا لم يكن `computing` يساوي `null`، أضف هذه الإشارة إلى مجموعة `sources` الخاصة بـ `computing`.\n1. ملاحظة: لا نضيف `computing` إلى مجموعة `sinks` لهذه الإشارة حتى/إلا إذا تمت مراقبتها من قبل Watcher.\n1. إذا كانت حالة هذه الإشارة `~dirty~` أو `~checked~`: كرر الخطوات التالية حتى تصبح حالة هذه الإشارة `~clean~`:\n    1. تتبع للأعلى عبر `sources` للعثور على أعمق مصدر متكرر (الأيسر، أي تم ملاحظته أولاً) وهو إشارة محسوبة موسومة بـ `~dirty~` (توقف البحث عند الوصول إلى إشارة محسوبة `~clean~`، وضم هذه الإشارة المحسوبة كآخر شيء يتم البحث عنه).\n    1. نفذ خوارزمية \"إعادة حساب الإشارة المحسوبة القديمة\" على تلك الإشارة.\n1. في هذه المرحلة، ستكون حالة هذه الإشارة `~clean~`، ولن تكون هناك مصادر متكررة حالتها `~dirty~` أو `~checked~`. أعد قيمة الإشارة. إذا كانت القيمة استثناءً، قم بإعادة رمي ذلك الاستثناء.\n\n### صنف `Signal.subtle.Watcher`\n\n#### آلة الحالات لـ `Signal.subtle.Watcher`\n\nقد تكون حالة Watcher واحدة من الحالات التالية:\n\n- `~waiting~`: تم تنفيذ رد النداء `notify`، أو أن الـ Watcher جديد، لكنه لا يراقب أي إشارات نشطة.\n- `~watching~`: الـ Watcher يراقب إشارات بنشاط، ولم يحدث أي تغيير بعد يستلزم رد النداء `notify`.\n- `~pending~`: أحد اعتماديات الـ Watcher قد تغيّر، ولكن لم يتم تنفيذ رد النداء `notify` بعد.\n\nمخطط الانتقال كما يلي:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nالانتقالات هي:\n| الرقم | من | إلى | الشرط | الخوارزمية |\n| ----- | --- | -- | ------ | ----------- |\n| 1 | `~waiting~` | `~watching~` | تم استدعاء طريقة `watch` الخاصة بالـ Watcher. | الطريقة: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | تم استدعاء طريقة `unwatch` الخاصة بالـ Watcher، وتمت إزالة آخر إشارة مراقبة. | الطريقة: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | قد تكون إحدى الإشارات المراقبة قد تغيّرت قيمتها. | الطريقة: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | تم تنفيذ رد النداء `notify`. | الطريقة: `Signal.State.prototype.set(newValue)` |\n\n#### الخانات الداخلية لـ `Signal.subtle.Watcher`\n\n- `state`: قد تكون `~watching~` أو `~pending~` أو `~waiting~`\n- `signals`: مجموعة مرتبة من الإشارات التي يراقبها هذا الـ Watcher\n- `notifyCallback`: رد النداء الذي يتم استدعاؤه عند حدوث تغيير ما. يُعين إلى أول وسيط يُمرر إلى الباني.\n\n#### الباني: `new Signal.subtle.Watcher(callback)`\n\n1. يتم تعيين `state` إلى `~waiting~`.\n1. تهيئة `signals` كمجموعة فارغة.\n1. يتم تعيين `notifyCallback` إلى معامل الـ callback.",
  "status": "ok"
}