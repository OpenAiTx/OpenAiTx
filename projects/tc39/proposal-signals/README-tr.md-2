{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Otomatik Bağımlılık Takibi** - Hesaplanmış bir Signal, ister basit değerler ister başka hesaplamalar olsun, bağımlı olduğu diğer Signal’leri otomatik olarak keşfeder.\n* **Tembel Değerlendirme** - Hesaplamalar, tanımlandıklarında hemen değerlendirilmez, ayrıca bağımlılıkları değiştiğinde de anında değerlendirilmez. Yalnızca değerleri açıkça talep edildiğinde değerlendirilirler.\n* **Önbellekleme (Memoization)** - Hesaplanmış Signal’ler son değerlerini önbelleğe alır, böylece bağımlılıklarında bir değişiklik yoksa, kaç kez erişilirse erişilsin tekrar değerlendirmeye gerek olmaz.\n\n## Signal’lerin Standardize Edilmesi İçin Motivasyon\n\n#### Birlikte Çalışabilirlik\n\nHer Signal implementasyonu, hesaplanmış bir Signal değerlendirilirken karşılaşılan kaynakların takibini yapmak için kendi otomatik takip mekanizmasına sahiptir. Bu durum, modellerin, bileşenlerin ve kütüphanelerin farklı framework’ler arasında paylaşılmasını zorlaştırır—genellikle görünüm motorlarına yanlış bir şekilde bağlı hale gelirler (Signal’ler genellikle JS framework’lerinin bir parçası olarak uygulandığından).\n\nBu teklifin bir amacı, reaktif modeli tamamen görünümlerden ayırmak, geliştiricilerin yeni render teknolojilerine geçiş yaparken UI dışı kodlarını yeniden yazmak zorunda kalmadan taşımalarını sağlamak veya farklı ortamlarda kullanılacak paylaşımlı reaktif modeller geliştirmelerine olanak tanımaktır. Ne yazık ki, sürümleme ve çoğaltma nedeniyle, JS seviyesindeki kütüphaneler yoluyla güçlü bir paylaşım düzeyine ulaşmak pratik değildir—yerleşik (built-in) özellikler daha güçlü bir paylaşım garantisi sunar.\n\n#### Performans/Bellek Kullanımı\n\nYaygın kullanılan kütüphanelerin yerleşik olması nedeniyle daha az kod göndermek küçük bir performans artışı sağlayabilir, ancak Signal implementasyonları genellikle oldukça küçüktür, bu nedenle bu etkinin çok büyük olmasını beklemiyoruz.\n\nSignal ile ilgili veri yapılarının ve algoritmalarının yerel C++ uygulamalarının, JS’de elde edilebilecek olandan sabit bir katsayıyla biraz daha verimli olabileceğini düşünüyoruz. Bununla birlikte, algoritmik olarak bir polyfill’de olacak olanlara göre herhangi bir değişiklik beklenmemektedir; motorlardan burada sihirli bir şey beklenmiyor ve reaktivite algoritmalarının kendisi iyi tanımlanmış ve kesin olacak.\n\nŞampiyon grup, çeşitli Signal implementasyonları geliştirmeyi ve bu performans olanaklarını araştırmak için kullanmayı planlamaktadır.\n\n#### Geliştirici Araçları (DevTools)\n\nMevcut JS dilindeki Signal kütüphaneleriyle aşağıdaki gibi şeyleri izlemek zor olabilir:\n* Hesaplanmış Signal’ler zinciri boyunca çağrı yığını, bir hatanın nedensel zincirini gösterir\n* Bir Signal’in diğerine bağımlı olduğu durumlarda Signal’ler arasındaki referans grafiği -- bellek kullanımı hata ayıklama sırasında önemlidir\n\nYerleşik Signal’ler, JS çalışma zamanlarının ve Geliştirici Araçlarının Signal’leri incelemeye yönelik daha iyi destek sunmasına olanak tanır, özellikle hata ayıklama veya performans analizi için; bu ister tarayıcıda yerleşik olsun ister ortak bir uzantı yoluyla olsun. Mevcut araçlar, örneğin element denetleyici, performans anlık görüntüsü ve bellek profilleri, sunumlarında Signal’leri özellikle vurgulayacak şekilde güncellenebilir.\n\n#### İkincil Faydalara Dair\n\n##### Standart Kütüphanenin Faydaları\n\nGenel olarak, JavaScript oldukça minimal bir standart kütüphaneye sahipti, ancak TC39’da JS’i daha fazla “pilli” (batteries-included) bir dil haline getirme eğilimi var, yani yüksek kaliteli, yerleşik işlevsellik sunma yönünde. Örneğin, Temporal moment.js’in yerini alıyor ve bir dizi küçük özellik, ör. `Array.prototype.flat` ve `Object.groupBy`, birçok lodash kullanım senaryosunun yerini alıyor. Avantajlar arasında daha küçük paket boyutları, artırılmış istikrar ve kalite, yeni bir projeye katılırken öğrenilecek daha az şey ve JS geliştiricileri arasında genel olarak ortak bir sözlük yer alıyor.\n\n##### HTML/DOM Entegrasyonu (ileride bir olasılık)\n\nW3C’deki ve tarayıcı geliştiricilerinin mevcut çalışmaları, HTML’ye yerel şablonlama getirmeye çalışıyor ([DOM Parts][wicg-pr-1023] ve [Template Instantiation][wicg-propsal-template-instantiation]). Ayrıca, W3C Web Components CG, Web Components’i tam deklaratif bir HTML API’si sunacak şekilde genişletme olasılığını araştırıyor. Her iki hedefi de başarmak için, sonunda HTML’nin reaktif bir primitive ihtiyacı olacak. Ayrıca, topluluk tarafından istenen ve Signal’lerin DOM ile entegrasyonu yoluyla hayal edilebilecek birçok ergonomik iyileştirme de mevcut.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Not: Bu entegrasyon, bu teklifin bir parçası olmayan, daha sonra yapılacak ayrı bir çalışma olacaktır.\n\n##### Ekosistem Bilgi Alışverişi (*yayınlama nedeni değildir*)\n\nStandardizasyon çabaları, tarayıcılarda bir değişiklik olmasa bile, sadece “topluluk” düzeyinde bile yardımcı olabilir. Signal’ler üzerindeki çalışma, reaktivitenin doğası, algoritmalar ve birlikte çalışabilirlik hakkında derinlemesine bir tartışma için birçok farklı framework yazarını bir araya getiriyor. Bu zaten faydalı oldu ve JS motorlarına ve tarayıcılara eklemeyi gerekçelendirmez; Signal’ler yalnızca ekosistem bilgi alışverişi dışında *önemli* faydalar sağlıyorsa JavaScript standardına eklenmelidir.\n\n## Signal’ler İçin Tasarım Hedefleri\n\nMevcut Signal kütüphanelerinin temelde birbirinden çok da farklı olmadığı ortaya çıktı. Bu teklif, pek çoğunda bulunan önemli nitelikleri uygulayarak bu başarıdan yararlanmayı amaçlamaktadır.\n\n### Temel Özellikler\n\n* Durumu temsil eden bir Signal türü, yani yazılabilir Signal. Bu, başkalarının okuyabileceği bir değerdir.\n* Diğerlerine bağlı, tembel olarak hesaplanan ve önbelleğe alınan bir hesaplanmış/memo/ türetilmiş Signal türü.\n    * Hesaplama tembeldir, yani hesaplanmış Signal’ler varsayılan olarak bağımlılıklarından biri değiştiğinde tekrar hesaplanmaz, yalnızca biri onları gerçekten okursa çalışır.\n    * Hesaplama “[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free”dir, yani asla gereksiz hesaplama yapılmaz. Bu, bir uygulama bir hesaplanmış Signal’i okuduğunda, çalıştırılacak potansiyel olarak bozuk (dirty) grafik parçalarının topolojik olarak sıralandığı anlamına gelir; böylece herhangi bir tekrar ortadan kaldırılır.\n    * Hesaplama önbelleklidir, yani son bağımlılık değişikliğinden sonra başka bir bağımlılık değişmemişse, hesaplanmış Signal erişildiğinde *yeniden* hesaplanmaz.\n    * Hesaplanmış Signal’ler ve durum Signal’leri için özel karşılaştırmalar mümkündür; böylece onlara bağımlı olan diğer hesaplanmış Signal’lerin ne zaman güncellenmesi gerektiği belirlenebilir.\n* Bir hesaplanmış Signal’in bağımlılıklarından birinin (veya iç içe geçmiş bağımlılıklarından birinin) “bozuk” (dirty) hale gelmesi ve değişmesi durumuna tepkiler; yani Signal’in değeri güncel olmayabilir.\n    * Bu tepki, daha sonra yapılacak önemli bir işin planlanmasını amaçlar.\n    * Efektler bu tepkiler ve framework düzeyinde zamanlayıcılar ile uygulanır.\n    * Hesaplanmış Signal’lerin, bu tepkilerden birinin (iç içe) bağımlılığı olarak kaydedilip kaydedilmediğine tepki verebilme yeteneği olması gerekir.\n* JS framework’lerinin kendi zamanlayıcılarını yapabilmesini sağlamak. Zorunlu Promise-tarzı yerleşik bir zamanlama yok.\n    * Senkron tepkiler, framework mantığına göre daha sonraki işleri zamanlamak için gereklidir.\n    * Yazmalar senkron ve hemen etkilidir (yazmaları topluca işlemek isteyen bir framework, bunu kendi üzerinde inşa edebilir).\n    * Bir efektin “bozuk” olup olmadığını kontrol etmek ile gerçekten çalıştırmak ayrılabilir (bu da iki aşamalı bir efekt zamanlayıcı sağlar).\n* Bağımlılıkların kaydedilmesini tetiklemeden Signal’leri okuyabilme (`untrack`)\n* Signal’leri/reactivity kullanan farklı kod tabanlarının bileşimini mümkün kılmak, örn.,\n    * Takip/reaktivite açısından birden fazla framework’ü birlikte kullanmak (aşağıdaki eksiklikler hariç)\n    * Framework’ten bağımsız reaktif veri yapıları (örn., özyinelemeli reaktif store proxy’si, reaktif Map ve Set ve Array, vb.)\n\n### Tutarlılık\n\n* Senkron tepkilerin naif şekilde yanlış kullanımını caydırmak/yasaklamak.\n    * Tutarlılık riski: yanlış kullanılırsa “[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)” ortaya çıkabilir: Eğer Signal ayarlandığında render işlemi hemen yapılırsa, uygulamanın tamamlanmamış durumu kullanıcıya gösterilebilir. Bu nedenle, bu özellik yalnızca daha sonra yapılacak işleri akıllıca planlamak için kullanılmalıdır.\n    * Çözüm: Senkron tepki geri çağrısı (callback) içinden herhangi bir Signal’i okumak ve yazmak yasaklanır\n* `untrack` kullanımını caydırmak ve güvenli olmayan doğasını belirtmek\n    * Tutarlılık riski: değeri diğer Signal’lere bağlı olan ama bu Signal’ler değiştiğinde güncellenmeyen hesaplanmış Signal’ler oluşturulmasına izin verir. Untracked erişimlerin, hesaplamanın sonucunu değiştirmeyeceği durumlarda kullanılmalıdır.\n    * Çözüm: API adında “unsafe” (güvensiz) olarak işaretlenir.\n* Not: Bu teklif, sinyallerin hesaplanmış ve efekt sinyallerinden hem okunmasına hem de yazılmasına izin verir, okumalardan sonra yapılan yazmalara herhangi bir kısıtlama getirmez, tutarlılık riskine rağmen. Bu karar, framework entegrasyonunda esneklik ve uyumluluğu korumak için alınmıştır.\n\n### Yüzeysel API\n\n* Birden fazla framework’ün Signal/reaktivite mekanizmalarını uygulayabilmesi için sağlam bir temel olmalı.\n    * Özyinelemeli store proxy’leri, dekoratör tabanlı sınıf alanı reaktivitesi ve hem `.value` hem de `[state, setState]`-stili API’ler için iyi bir temel olmalı.\n    * Anlamlar, farklı framework’ler tarafından mümkün kılınan geçerli desenleri ifade edebilmelidir. Örneğin, bu Signal’lerin ya anında yansıtılan yazmaların ya da topluca daha sonra uygulanan yazmaların temeli olması mümkün olmalı.\n* Bu API’nin doğrudan JavaScript geliştiricileri tarafından kullanılabilir olması güzel olurdu.\n    * Bir özellik ekosistem kavramıyla örtüşüyorsa, ortak bir terim kullanmak iyidir.\n        * Ancak, tam olarak aynı isimlerin gölgelenmemesi önemlidir!\n    * “JS geliştiricileri tarafından kullanılabilirlik” ile “framework’lere tüm kancaları sağlamak” arasında bir gerilim var\n        * Fikir: Tüm kancaları sağla, ancak yanlış kullanıldığında hata ver.\n        * Fikir: İnce API’leri [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle) gibi bir `subtle` ad alanına koy, böylece framework veya dev araçları geliştirmek gibi daha ileri düzey kullanımlar için gerekli API’ler ile gündelik uygulama geliştirmede framework ile Signal örneklemek gibi kullanımlar arasındaki çizgi belirlenmiş olur.\n* İyi performansla uygulanabilir ve kullanılabilir olmalı -- yüzeysel API çok fazla ek yük getirmemeli\n    * Alt sınıflamaya olanak tanımalı, böylece framework’ler kendi metotlarını ve alanlarını, özel alanlar dahil ekleyebilsin. Bu, framework düzeyinde ek tahsis ihtiyacını önlemek için önemlidir. Aşağıda “Bellek yönetimi” bölümüne bakınız.\n\n### Bellek yönetimi\n\n* Mümkünse: Eğer gelecekte okunmak üzere hiçbir canlı referans yoksa, bir hesaplanmış Signal, daha geniş bir grafiğe bağlı kalsa bile (örn., canlı kalan bir durumu okuduğu için), çöp toplayıcı tarafından kaldırılabilmelidir.",
  "status": "ok"
}