{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "`Computed Signal` 的 `state` 可能為下列其中之一：\n\n- `~clean~`：此 Signal 的值已存在，且已知不為過時狀態。\n- `~checked~`：此 Signal 的（間接）來源已變更；此 Signal 擁有一個值，但該值_可能_已過時。是否過時僅能在所有直接來源都已評估後得知。\n- `~computing~`：此 Signal 的 callback 目前正因 `.get()` 呼叫而被執行。\n- `~dirty~`：此 Signal 的值已知為過時，或從未被評估過。\n\n狀態轉換圖如下：\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\n狀態轉換說明如下：\n| 編號 | 從 | 到 | 條件 | 演算法 |\n| ---- | -- | -- | ---- | ------ |\n| 1 | `~checked~` | `~dirty~` | 此 Signal 的直接來源為 computed signal，且該來源已被評估且值已變更。 | 演算法：重新計算 dirty 的 computed Signal |\n| 2 | `~clean~` | `~dirty~` | 此 Signal 的直接來源為 State，且該來源被設為與先前不同的值。 | 方法：`Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | 此 Signal 的遞迴（但非直接）來源為 State，且該來源被設為與先前不同的值。 | 方法：`Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | 即將執行 `callback`。 | 演算法：重新計算 dirty 的 computed Signal |\n| 5 | `~computing~` | `~clean~` | `callback` 已完成評估，且已回傳值或丟出例外。 | 演算法：重新計算 dirty 的 computed Signal |\n| 6 | `~checked~` | `~clean~` | 此 Signal 的所有直接來源皆已評估且皆未變更，因此現已確定非過時。 | 演算法：重新計算 dirty 的 computed Signal |\n\n#### `Signal.Computed` 內部欄位\n\n- `value`：Signal 先前快取的值，或若從未讀取則為 `~uninitialized~`。該值可能為例外，若讀取則會重新拋出。對於 effect signals 永遠為 `undefined`。\n- `state`：可能為 `~clean~`、`~checked~`、`~computing~` 或 `~dirty~`。\n- `sources`：此 Signal 所依賴的 Signals 的有序集合。\n- `sinks`：依賴此 Signal 的 Signals 的有序集合。\n- `equals`：於 options 中提供的 equals 方法。\n- `callback`：用以取得 computed Signal 值的 callback，設為建構子傳入的第一個參數。\n\n#### `Signal.Computed` 建構子\n\n建構子將設定\n- `callback` 為其第一個參數\n- `equals` 根據 options 設定，若無則預設為 `Object.is`\n- `state` 為 `~dirty~`\n- `value` 為 `~uninitialized~`\n\n配合 [AsyncContext](https://github.com/tc39/proposal-async-context)，傳入 `new Signal.Computed` 的 callback 會捕捉建構子調用時的快照，並於執行期間恢復該快照。\n\n#### 方法：`Signal.Computed.prototype.get`\n\n1. 若目前執行上下文為 `frozen`，或此 Signal 狀態為 `~computing~`，或此 Signal 為 Watcher 且正在 `computing` 一個 computed Signal，則拋出例外。\n1. 若 `computing` 非 `null`，將此 Signal 加入 `computing` 的 `sources` 集合。\n1. 注意：在此 Signal 尚未被 Watcher 監看前，不會將 `computing` 加入此 Signal 的 `sinks` 集合。\n1. 若此 Signal 的狀態為 `~dirty~` 或 `~checked~`：重複下列步驟直到此 Signal 為 `~clean~`：\n    1. 遞迴往上經由 `sources`，尋找最深、最左（即最早被觀察到）的、標記為 `~dirty~` 的 computed Signal（遇到 `~clean~` 的 computed Signal 則停止搜尋，並將本身作為最後搜尋對象）。\n    1. 對該 Signal 執行「重新計算 dirty 的 computed Signal」演算法。\n1. 此時，此 Signal 的狀態應為 `~clean~`，且所有遞迴來源皆非 `~dirty~` 或 `~checked~`。回傳此 Signal 的 `value`。若該值為例外，則重新拋出該例外。\n\n### `Signal.subtle.Watcher` 類別\n\n#### `Signal.subtle.Watcher` 狀態機\n\nWatcher 的 `state` 可能為下列其中之一：\n\n- `~waiting~`：`notify` callback 已被執行，或 Watcher 為新建立，但尚未主動監看任何 signals。\n- `~watching~`：Watcher 正主動監看 signals，尚未有變更需執行 `notify` callback。\n- `~pending~`：Watcher 的依賴已變更，但尚未執行 `notify` callback。\n\n狀態轉換圖如下：\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\n狀態轉換說明如下：\n| 編號 | 從 | 到 | 條件 | 演算法 |\n| ---- | -- | -- | ---- | ------ |\n| 1 | `~waiting~` | `~watching~` | Watcher 的 `watch` 方法被呼叫。 | 方法：`Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Watcher 的 `unwatch` 方法被呼叫，且最後一個被監看的 signal 已移除。 | 方法：`Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | 某個被監看的 signal 可能已變更值。 | 方法：`Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | `notify` callback 已被執行。 | 方法：`Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` 內部欄位\n\n- `state`：可能為 `~watching~`、`~pending~` 或 `~waiting~`\n- `signals`：此 Watcher 正在監看的 Signals 的有序集合\n- `notifyCallback`：當有變更時會被呼叫的 callback。設為建構子傳入的第一個參數。\n\n#### 建構子：`new Signal.subtle.Watcher(callback)`\n\n1. `state` 設為 `~waiting~`。\n1. 初始化 `signals` 為空集合。\n1. `notifyCallback` 設為傳入的 callback 參數。",
  "status": "ok"
}