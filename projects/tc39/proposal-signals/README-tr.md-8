{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**S**: Sinyaller, React gibi tek yönlü veri akışıyla çalışır mı?\n\n**C**: Evet, Sinyaller tek yönlü veri akışı için bir mekanizmadır. Sinyal tabanlı UI framework'leri, görünümünüzü modelin (modelin Sinyalleri içerdiği yerde) bir fonksiyonu olarak ifade etmenizi sağlar. Durum ve hesaplanmış Sinyallerden oluşan bir grafik, yapısı gereği döngüsüzdür. Sinyaller içinde React antipattern'lerini yeniden oluşturmak da mümkündür (!), örneğin `useEffect` içinde bir `setState`'in Sinyal karşılığı, bir Watcher kullanarak bir State sinyaline yazma planlamaktır.\n\n**S**: Sinyaller, Redux gibi durum yönetim sistemleriyle nasıl ilişkilidir? Sinyaller yapılandırılmamış durumu mu teşvik eder?\n\n**C**: Sinyaller, mağaza-benzeri (store-like) durum yönetimi soyutlamaları için verimli bir temel oluşturabilir. Birden fazla framework'te bulunan yaygın bir desen, dahili olarak özellikleri Sinyaller kullanarak temsil eden, Proxy tabanlı bir nesnedir; örneğin [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive) veya [Solid stores](https://docs.solidjs.com/concepts/stores). Bu sistemler, belirli bir uygulama için doğru soyutlama düzeyinde durumun esnek şekilde gruplanmasını sağlar.\n\n**S**: Sinyallerin sunduğu ama şu anda `Proxy`'nin ele almadığı şey nedir?\n\n**C**: Proxy'ler ve Sinyaller birbirini tamamlar ve birlikte iyi çalışır. Proxy'ler sığ nesne işlemlerini yakalamanıza olanak tanır ve sinyaller bir bağımlılık grafiğini (hücrelerden oluşan) koordine eder. Proxy'yi Sinyaller ile desteklemek, mükemmel ergonomiye sahip iç içe reaktif bir yapı oluşturmanın harika bir yoludur.\n\nBu örnekte, `get` ve `set` yöntemleri yerine sinyalin bir getter ve setter özelliğine sahip olmasını sağlamak için bir proxy kullanabiliriz:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// varsayımsal bir reaktif bağlamda kullanım:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nİnce taneli reaktiviteye optimize edilmiş bir renderlayıcı kullanırken, butona tıklamak `b.value` hücresinin güncellenmesine neden olur.\n\nBakınız:\n- Hem Sinyaller hem de Proxy'lerle oluşturulan iç içe reaktif yapı örnekleri: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- Reaktif veri ile proxy'ler arasındaki ilişkiyi gösteren önceki uygulama örnekleri: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [tartışma](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Sinyaller nasıl çalışır?\n\n**S**: Sinyaller push-tabanlı mı yoksa pull-tabanlı mı çalışır?\n\n**C**: Hesaplanmış Sinyallerin değerlendirilmesi pull-tabanlıdır: Hesaplanmış Sinyaller yalnızca `.get()` çağrıldığında değerlendirilir, temel durum çok daha önce değişmiş olsa bile. Aynı zamanda, bir State sinyalini değiştirmek hemen bir Watcher'ın callback'ini tetikleyebilir, bildirimi \"iterek\" iletebilir. Bu nedenle, Sinyaller \"push-pull\" bir yapı olarak düşünülebilir.\n\n**S**: Sinyaller JavaScript çalışmasına belirlenimsizlik (nondeterminism) getirir mi?\n\n**C**: Hayır. Birincisi, tüm Sinyal işlemlerinin iyi tanımlanmış anlamları ve sıralamaları vardır ve uyumlu uygulamalar arasında farklılık göstermezler. Daha yüksek seviyede, Sinyaller belirli bir dizi değişmez kurala uyar ve bu kurallara göre \"sağlamdır\". Bir hesaplanmış Sinyal, Sinyal grafiğini her zaman tutarlı bir durumda gözlemler ve yürütmesi, başka bir Sinyal'i değiştiren kodlar tarafından (kendi çağrıları hariç) kesintiye uğratılmaz. Yukarıdaki açıklamaya bakınız.\n\n**S**: Bir state Sinyaline yazdığımda, hesaplanmış Sinyal için güncelleme ne zaman planlanır?\n\n**C**: Planlanmaz! Hesaplanmış Sinyal, bir sonraki okunduğunda kendini yeniden hesaplayacaktır. Senkron olarak, bir Watcher'ın `notify` callback'i çağrılabilir, bu da framework'lerin uygun gördükleri zamanda bir okuma planlamasına olanak tanır.\n\n**S**: State Sinyaline yapılan yazmalar ne zaman etkili olur? Hemen mi, yoksa toplu olarak mı?\n\n**C**: State Sinyaline yapılan yazmalar hemen yansıtılır—state Sinyaline bağımlı bir hesaplanmış Sinyal bir sonraki okunduğunda, gerekirse kendini hemen yeniden hesaplar, hatta kodun hemen ardından gelen satırda bile. Bununla birlikte, bu mekanizmanın doğasında bulunan tembellik (hesaplanmış Sinyaller yalnızca okunduğunda hesaplanır), pratikte hesaplamaların toplu şekilde gerçekleşmesine yol açabilir.\n\n**S**: Sinyallerin \"glitch-free\" (aksaklıksız) çalışmayı mümkün kılması ne anlama gelir?\n\n**C**: Reaktivite için önceki push-tabanlı modeller, gereksiz hesaplama sorunu yaşardı: Bir state Sinyaline yapılan bir güncelleme, hesaplanmış Sinyalin isteksizce çalışmasına neden olursa, nihayetinde bu, UI'ya bir güncelleme gönderebilir. Ancak, eğer bir sonraki kareden önce kaynak state Sinyaline başka bir değişiklik olacaksa, bu UI'ya yapılan yazma erken olabilir. Bazen, bu tür [glitch'ler](https://en.wikipedia.org/wiki/Reactive_programming#Glitches) nedeniyle kullanıcıya hatalı ara değerler bile gösterilirdi. Sinyaller, push-tabanlı olmak yerine pull-tabanlı olarak bu dinamiği önler: Framework, UI'nın renderlanmasını planladığı anda, uygun güncellemeleri çeker ve hem hesaplamada hem de DOM'a yazmada boşa harcanan işi önler.\n\n**S**: Sinyallerin \"lossy\" (kayıplı) olması ne anlama gelir?\n\n**C**: Bu, aksaklıksız çalışmanın ters yüzüdür: Sinyaller, bir veri hücresini temsil eder—yalnızca anlık mevcut değeri (değişebilir), zaman içinde bir veri akışını değil. Yani, bir state Sinyaline arka arkaya iki kez yazarsanız ve başka bir şey yapmazsanız, ilk yazma \"kaybolur\" ve hiçbir hesaplanmış Sinyal veya etki tarafından görülmez. Bunun bir hata değil, bir özellik olduğu anlaşılır—diğer yapılar (ör. async iterables, observables) veri akışları için daha uygundur.\n\n**S**: Yerel Sinyaller, mevcut JS Sinyal uygulamalarından daha hızlı olacak mı?\n\n**C**: Umarız öyle olur (küçük bir sabit katsayıyla), fakat bunun kodla kanıtlanması gerekir. JS motorları sihirli değildir ve nihayetinde Sinyallerin JS uygulamalarındakiyle aynı tür algoritmaları uygulamaları gerekecektir. Performans ile ilgili yukarıdaki bölüme bakınız.\n\n#### Sinyaller neden bu şekilde tasarlandı?\n\n**S**: Etkiler, Sinyallerin pratikte kullanılabilmesi için gerekli iken, neden bu teklif bir `effect()` fonksiyonu içermiyor?\n\n**C**: Etkiler, doğası gereği planlama ve yok etmeye (disposal) bağlıdır ve bunlar framework'ler tarafından yönetilir; bu teklifin kapsamı dışındadır. Bunun yerine, bu teklif, etkilerin daha düşük seviyeli `Signal.subtle.Watcher` API'siyle uygulanmasının temelini sunar.\n\n**S**: Neden abonelikler otomatik, elle bir arayüz sağlanmıyor?\n\n**C**: Deneyimler, reaktivite için manuel abonelik arayüzlerinin ergonomik olmadığını ve hata yapmaya açık olduğunu göstermiştir. Otomatik izleme daha fazla bileşenleştirilebilir ve Sinyallerin temel bir özelliğidir.\n\n**S**: Neden `Watcher`'ın callback'i senkron çalışıyor, bir mikro görevde planlanmıyor?\n\n**C**: Çünkü callback Sinyalleri okuyamaz veya yazamaz, senkron olarak çağrılması herhangi bir tutarsızlığa yol açmaz. Tipik bir callback, daha sonra okunacak bir Sinyali bir Array'e ekleyecek veya bir yerde bir biti işaretleyecektir. Bu tür işlemler için ayrı bir mikro görev yapmak gereksiz ve pratikte oldukça pahalıdır.\n\n**S**: Bu API, favori framework'ümün sağladığı ve Sinyallerle programlamayı kolaylaştıran bazı güzel şeyleri eksik bırakmış. Bunlar da standarda eklenebilir mi?\n\n**C**: Belki. Çeşitli uzantılar hâlâ değerlendiriliyor. Önemli bulduğunuz eksik bir özellik için lütfen tartışma başlatmak üzere bir issue açın.\n\n**S**: Bu API boyut veya karmaşıklık açısından azaltılabilir mi?\n\n**C**: Bu API'yi minimumda tutmak kesinlikle bir hedef, ve yukarıda sunulanlarla bunu yapmaya çalıştık. Çıkarılabilecek başka şeyler için fikirleriniz varsa, tartışmak üzere lütfen bir issue açın.\n\n#### Sinyaller nasıl standartlaştırılıyor?\n\n**S**: Bu alanda standardizasyon çalışmasına, gözlemlenebilirler (observables) gibi daha ilkel bir kavramla başlamamız gerekmez mi?",
  "status": "ok"
}