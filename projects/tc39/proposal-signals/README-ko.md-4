{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// isWatched가 이전에 false였다가 true가 될 때 호출되는 콜백\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// isWatched가 이전에 true였다가 false가 될 때마다 호출되는 콜백\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### 시그널의 작동 방식\n\n시그널(Signal)은 시간이 지남에 따라 변경될 수 있는 데이터 셀을 나타냅니다. 시그널은 \"state\"(수동으로 설정되는 값) 또는 \"computed\"(다른 시그널을 기반으로 한 공식)일 수 있습니다.\n\nComputed 시그널은 평가 과정에서 참조된 다른 시그널들을 자동으로 추적함으로써 동작합니다. Computed가 읽힐 때, 이전에 기록된 의존성 중 어떤 것이 변경되었는지 확인하고, 변경된 경우 자신을 다시 평가합니다. 여러 개의 computed 시그널이 중첩될 경우, 추적의 귀속은 가장 안쪽에 있는 시그널로 집중됩니다.\n\nComputed 시그널은 지연(lazy), 즉 풀(Pull) 기반입니다. 즉, 의존성이 이전에 변경되었더라도 실제로 접근할 때만 다시 평가가 이루어집니다.\n\nComputed 시그널에 전달되는 콜백은 일반적으로 \"순수(pure)\"해야 하며, 접근하는 다른 시그널의 결정적이고 부작용이 없는 함수여야 합니다. 동시에, 콜백이 호출되는 타이밍은 결정적이므로, 신중하게 사용할 경우 부작용도 허용될 수 있습니다.\n\n시그널은 강력한 캐싱/메모이제이션 기능을 제공합니다. state와 computed 시그널 모두 현재 값을 기억하고, 그 값을 참조하는 computed 시그널에 실제로 변경이 있을 때만 재계산을 트리거합니다. 이전 값과 새로운 값을 반복적으로 비교할 필요도 없으며, 소스 시그널이 리셋/재평가될 때 한 번만 비교가 이루어지고, 시그널 메커니즘이 해당 시그널을 참조하는 것들 중 아직 새로운 값으로 업데이트되지 않은 것들을 추적합니다. 내부적으로는 (Milo의 블로그 포스트에서 설명한) \"그래프 컬러링\"을 통해 표현됩니다.\n\nComputed 시그널은 의존성을 동적으로 추적합니다. 즉, 실행될 때마다 서로 다른 것에 의존할 수 있으며, 정확한 의존성 집합이 시그널 그래프에 신선하게 유지됩니다. 예를 들어, 특정 분기에서만 필요한 의존성이 있고, 이전 계산에서 다른 분기를 택했다면, 그 임시로 사용되지 않는 값이 변경되어도 computed 시그널이 재계산되지 않습니다(심지어 pull 되었을 때도).\n\n자바스크립트의 프라미스(Promise)와 달리, 시그널에서 일어나는 모든 작업은 동기적으로 실행됩니다.\n- 시그널에 새 값을 설정하는 것은 동기적이며, 이후 해당 값을 참조하는 모든 computed 시그널에서 즉시 반영됩니다. 이 변이에 대한 내장 배치(batching)는 없습니다.\n- computed 시그널을 읽는 것도 동기적이며, 해당 값은 항상 즉시 사용할 수 있습니다.\n- 아래에서 설명할 Watcher의 `notify` 콜백은 동기적으로 실행되며, `.set()` 호출 중(단, 그래프 컬러링이 완료된 후) 트리거됩니다.\n\n프라미스처럼, 시그널도 오류 상태를 나타낼 수 있습니다. 만약 computed 시그널의 콜백이 예외를 던지면, 그 오류도 값처럼 캐시되며, 해당 시그널이 읽힐 때마다 재차 예외가 발생합니다.\n\n### Signal 클래스 이해하기\n\n`Signal` 인스턴스는 시간에 따라 추적되는 동적으로 변경되는 값을 읽을 수 있는 기능을 나타냅니다. 또한, 다른 computed 시그널에서 추적된 접근을 통해 암묵적으로 시그널에 구독하는 기능도 포함되어 있습니다.\n\n여기의 API는 \"signal\", \"computed\", \"state\"와 같은 이름 사용에 있어서 시그널 라이브러리 생태계의 대략적인 합의와 일치하도록 설계되었습니다. 하지만, Computed와 State 시그널 접근은 `.get()` 메서드를 통해 이루어지며, 이는 `.value` 스타일 접근자나 `signal()` 호출 문법을 사용하는 기존 인기 시그널 API와는 다릅니다.\n\n이 API는 할당(allocation) 수를 줄이도록 설계되어, 시그널이 자바스크립트 프레임워크에 내장될 수 있으면서 기존 프레임워크 특화 시그널보다 동등하거나 더 나은 성능을 낼 수 있도록 합니다. 이는 다음을 의미합니다:\n- State 시그널은 단일 쓰기 가능한 객체이며, 동일한 참조로 접근 및 설정이 모두 가능합니다. (아래 \"Capability separation\" 섹션 참고)\n- State와 Computed 시그널 모두 서브클래싱이 가능하도록 설계되어, 프레임워크에서 퍼블릭/프라이빗 클래스 필드(및 해당 상태를 사용하는 메서드)를 통해 추가 프로퍼티를 쉽게 추가할 수 있습니다.\n- 다양한 콜백(예: `equals`, computed 콜백)은 관련 시그널을 `this` 값으로 하여 호출되므로, 시그널마다 새로운 클로저를 생성할 필요가 없습니다. 대신, 컨텍스트는 시그널 자체의 추가 프로퍼티에 저장할 수 있습니다.\n\n이 API에서 강제되는 일부 에러 조건:\n- computed를 재귀적으로 읽는 것은 에러입니다.\n- Watcher의 `notify` 콜백에서는 어떤 시그널도 읽거나 쓸 수 없습니다.\n- computed 시그널의 콜백이 예외를 던지면, 의존성 중 하나가 변경되어 재계산되기 전까지는 해당 시그널 접근 시마다 캐시된 예외가 재차 발생합니다.\n\n*강제되지 않는* 일부 조건:\n- computed 시그널 콜백 내부에서 다른 시그널에 동기적으로 값을 쓸 수 있습니다.\n- Watcher의 `notify` 콜백에서 큐잉된 작업은 시그널을 읽거나 쓸 수 있으므로, 시그널을 활용하여 [고전적인 React 안티패턴](https://react.dev/learn/you-might-not-need-an-effect)을 재현할 수 있습니다!\n\n### 이펙트 구현하기\n\n위에 정의된 `Watcher` 인터페이스는 효과를 위한 전형적인 JS API(즉, 다른 시그널이 변경될 때 부수 효과를 위해 콜백이 재실행됨)를 구현하는 기반을 제공합니다. 처음 예시에서 사용한 `effect` 함수는 다음과 같이 정의할 수 있습니다:\n\n```ts\n// 이 함수는 일반적으로 라이브러리/프레임워크에 위치하며, 애플리케이션 코드에는 두지 않습니다.\n// 참고: 이 스케줄링 로직은 너무 기본적이므로 실사용에는 부적합합니다. 복사/붙여넣기 금지.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// 의존성 중 하나가 변경될 수 있을 때마다 마이크로태스크 큐에서 자기 자신을 읽도록 스케줄하는,\n// cb로 평가되는 effect 시그널\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\n시그널 API는 `effect`와 같은 내장 함수를 제공하지 않습니다. 이는 이펙트 스케줄링이 미묘하며, 종종 프레임워크 렌더링 사이클, 기타 고수준 프레임워크 특화 상태나 전략과 연계되기 때문인데, JS에서는 이에 접근할 수 없습니다.\n\n여기서 사용된 다양한 연산들을 살펴보면: `Watcher` 생성자에 전달된 `notify` 콜백은 시그널이 \"clean\" 상태(캐시가 초기화되고 유효함이 보장된 상태)에서 \"checked\" 또는 \"dirty\" 상태(최소 하나의 상태가 변경되어 더 이상 캐시가 유효하지 않을 수 있음)로 전환될 때 호출되는 함수입니다.\n\n`notify` 호출은 궁극적으로 어떤 state 시그널의 `.set()` 호출에 의해 트리거됩니다. 이 호출은 동기적으로 이뤄지며, `.set`이 반환되기 전에 발생합니다. 그러나 이 콜백이 시그널 그래프를 처리 중간 상태에서 관찰할까봐 걱정할 필요는 없습니다. `notify` 콜백 중에는 어떤 시그널도 읽거나 쓸 수 없으며, `untrack` 호출 중에도 마찬가지입니다. `notify`는 `.set()` 중에 호출되므로, 아직 끝나지 않은 다른 논리 흐름을 중단하고 실행됩니다. `notify`에서 시그널을 읽거나 쓰려면 위 예시처럼 시그널을 리스트에 적어두었다가 나중에 접근하거나, `queueMicrotask`로 작업을 예약하는 등 나중에 실행되도록 해야 합니다.\n\n사실, `Signal.subtle.Watcher` 없이도 computed 시그널의 폴링을 스케줄링하여(예: Glimmer에서처럼) 시그널을 효과적으로 사용할 수 있습니다. 그러나 많은 프레임워크에서는 이러한 스케줄링 로직을 동기적으로 실행하는 것이 매우 유용하다고 판단했으며, 그래서 Signals API에 이를 포함시켰습니다.\n\ncomputed와 state 시그널 모두 JS 값처럼 가비지 컬렉션됩니다. 하지만 Watcher는 대상을 특별하게 유지하는 방식이 있습니다. Watcher가 감시하는 모든 시그널은 기본 상태 중 하나라도 도달 가능(reachable)한 한 계속 살아있게 됩니다. 이는 향후 `notify` 호출(그리고 그 후의 `.get()`)을 트리거할 수 있기 때문입니다. 따라서 효과를 정리(clean up)하려면 반드시 `Watcher.prototype.unwatch`를 호출해야 합니다.\n\n### 비정상적인 이스케이프 해치\n\n`Signal.subtle.untrack`은 시그널을 *추적 없이* 읽을 수 있게 해주는 이스케이프 해치입니다. 이 기능은, 추적되지 않는 상태에서 시그널을 참조하는 computed 시그널을 만들 수 있게 하므로 안전하지 않습니다. 그 결과가 변경되지 않을 때만 untrack 접근을 사용해야 합니다.\n\n<!--\nTODO: untrack을 잘 활용할 수 있는 예시 추가\n\n### watched/unwatched 사용하기\n",
  "status": "ok"
}