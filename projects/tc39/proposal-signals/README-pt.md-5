{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Mostrar exemplo de conversão de um Observable para um sinal computado, inscrito apenas quando usado por um efeito\n\nTODO: Mostrar exemplo de um sinal computado que representa o resultado de um fetch direcionado a um estado, que é cancelado\n\n### Introspecção para SSR\n\nTODO: Mostrar como funciona a serialização do grafo de sinais\n\nTODO: Mostrar como você pode \"hidratar\" um sinal de estado para computado depois, usando alguns sinais.\n-->\n\n### Omitido por enquanto\n\nEsses recursos podem ser adicionados posteriormente, mas não estão incluídos no rascunho atual. Sua omissão se deve à falta de consenso estabelecido no espaço de design entre frameworks, bem como à capacidade demonstrada de contornar sua ausência com mecanismos baseados na noção de Sinais descrita neste documento. No entanto, infelizmente, a omissão limita o potencial de interoperabilidade entre frameworks. À medida que protótipos de Sinais, conforme descrito neste documento, forem produzidos, haverá um esforço para reexaminar se essas omissões foram a decisão adequada.\n\n* **Assíncrono**: Os sinais estão sempre disponíveis para avaliação de forma síncrona, neste modelo. No entanto, é frequentemente útil ter certos processos assíncronos que levam a um sinal ser definido, e entender quando um sinal ainda está \"carregando\". Uma maneira simples de modelar o estado de carregamento é com exceções, e o comportamento de cache de exceções dos sinais computados compõe razoavelmente com essa técnica. Técnicas aprimoradas são discutidas na [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transações**: Para transições entre visualizações, muitas vezes é útil manter um estado ativo tanto para o estado \"de\" quanto para o \"para\". O estado \"para\" é renderizado em segundo plano, até que esteja pronto para a troca (cometendo a transação), enquanto o estado \"de\" permanece interativo. Manter ambos os estados ao mesmo tempo requer \"forkar\" o estado do grafo de sinais, e pode até ser útil suportar múltiplas transições pendentes ao mesmo tempo. Discussão em [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nAlguns possíveis [métodos de conveniência](https://github.com/proposal-signals/proposal-signals/issues/32) também foram omitidos.\n\n## Status e plano de desenvolvimento\n\nEsta proposta está na agenda do TC39 de abril de 2024 para o Estágio 1. Atualmente, pode ser considerada como \"Estágio 0\".\n\n[Um polyfill](https://github.com/proposal-signals/signal-polyfill) para esta proposta está disponível, com alguns testes básicos. Alguns autores de frameworks começaram a experimentar a substituição desta implementação de sinal, mas esse uso está em estágio inicial.\n\nOs colaboradores da proposta de Sinais querem ser especialmente **conservadores** em como avançam com esta proposta, para evitar cair na armadilha de aprovar algo que acabaremos nos arrependendo e não usando de fato. Nosso plano é realizar as seguintes tarefas extras, não exigidas pelo processo do TC39, para garantir que esta proposta está no caminho certo:\n\nAntes de propor para o Estágio 2, planejamos:\n- Desenvolver múltiplas implementações de polyfill de nível de produção que sejam sólidas, bem testadas (por exemplo, passando testes de vários frameworks, bem como testes do estilo test262) e competitivas em termos de desempenho (como verificado com um conjunto abrangente de benchmarks de sinais/frameworks).\n- Integrar a API de Sinais proposta em um grande número de frameworks JS que consideramos representativos, e fazer com que algumas aplicações grandes funcionem com essa base. Testar se ela funciona de forma eficiente e correta nesses contextos.\n- Ter uma compreensão sólida do espaço de possíveis extensões da API, e concluir quais (se houver) devem ser adicionadas a esta proposta.\n\n## Algoritmos de Sinal\n\nEsta seção descreve cada uma das APIs expostas ao JavaScript, em termos dos algoritmos que implementam. Isso pode ser considerado como uma proto-especificação, e está incluído neste ponto inicial para definir um possível conjunto de semânticas, estando muito aberto a mudanças.\n\nAlguns aspectos do algoritmo:\n- A ordem de leitura dos Sinais dentro de um computado é significativa e é observável na ordem em que certos callbacks (quando `Watcher` é invocado, `equals`, o primeiro parâmetro para `new Signal.Computed` e os callbacks `watched`/`unwatched`) são executados. Isso significa que as fontes de um Sinal computado devem ser armazenadas ordenadas.\n- Esses quatro callbacks podem lançar exceções, e essas exceções são propagadas de maneira previsível para o código JS chamador. As exceções *não* interrompem a execução deste algoritmo nem deixam o grafo em um estado parcialmente processado. Para erros lançados no callback `notify` de um Watcher, essa exceção é enviada para a chamada `.set()` que a acionou, usando um AggregateError se várias exceções forem lançadas. As outras (incluindo `watched`/`unwatched`?) são armazenadas no valor do Sinal, para serem relançadas quando lidas, e tal Sinal relançado pode ser marcado como `~clean~` assim como qualquer outro com um valor normal.\n- Cuidados são tomados para evitar circularidades em casos de sinais computados que não são \"observados\" (sendo observados por algum Watcher), para que possam ser coletados pelo garbage collector de forma independente de outras partes do grafo de sinais. Internamente, isso pode ser implementado com um sistema de números de geração que são sempre coletados; observe que implementações otimizadas também podem incluir números de geração locais por nó, ou evitar rastrear alguns números em sinais observados.\n\n### Estado global oculto\n\nOs algoritmos de Sinal precisam referenciar certos estados globais. Esse estado é global para toda a thread, ou \"agente\".\n\n- `computing`: O Sinal computado ou de efeito mais interno atualmente sendo reavaliado devido a uma chamada `.get` ou `.run`, ou `null`. Inicialmente `null`.\n- `frozen`: Booleano que denota se há um callback atualmente em execução que exige que o grafo não seja modificado. Inicialmente `false`.\n- `generation`: Um inteiro incremental, começando em 0, usado para rastrear quão atual é um valor enquanto evita circularidades.\n\n### O namespace `Signal`\n\n`Signal` é um objeto comum que serve como um namespace para classes e funções relacionadas a Sinais.\n\n`Signal.subtle` é um objeto de namespace interno semelhante.\n\n### A classe `Signal.State`\n\n#### Slots internos de `Signal.State`\n\n- `value`: O valor atual do sinal de estado\n- `equals`: A função de comparação usada ao alterar valores\n- `watched`: O callback chamado quando o sinal passa a ser observado por um efeito\n- `unwatched`: O callback chamado quando o sinal deixa de ser observado por um efeito\n- `sinks`: Conjunto de sinais observados que dependem deste\n\n#### Construtor: `Signal.State(initialValue, options)`\n\n1. Defina o `value` deste Sinal como `initialValue`.\n1. Defina o `equals` deste Sinal como options?.equals\n1. Defina o `watched` deste Sinal como options?.[Signal.subtle.watched]\n1. Defina o `unwatched` deste Sinal como options?.[Signal.subtle.unwatched]\n1. Defina o `sinks` deste Sinal como o conjunto vazio\n\n#### Método: `Signal.State.prototype.get()`\n\n1. Se `frozen` for true, lance uma exceção.\n1. Se `computing` não for `undefined`, adicione este Sinal ao conjunto `sources` de `computing`.\n1. NOTA: Não adicionamos `computing` ao conjunto `sinks` deste Sinal até que ele seja observado por um Watcher.\n1. Retorne o `value` deste Sinal.\n\n#### Método: `Signal.State.prototype.set(newValue)`\n\n1. Se o contexto de execução atual for `frozen`, lance uma exceção.\n1. Execute o algoritmo \"definir valor do Sinal\" com este Sinal e o primeiro parâmetro para o valor.\n1. Se esse algoritmo retornar `~clean~`, então retorne undefined.\n1. Defina o `state` de todos os `sinks` deste Sinal como (se for um Sinal Computado) `~dirty~` se estavam previamente clean, ou (se for um Watcher) `~pending~` se estava previamente `~watching~`.\n1. Defina o `state` de todas as dependências de Sinal Computado dos sinks (recursivamente) como `~checked~` se estavam previamente `~clean~` (ou seja, mantenha as marcações de dirty), ou para Watchers, `~pending~` se previamente `~watching~`.\n1. Para cada Watcher previamente `~watching~` encontrado nessa busca recursiva, em ordem de profundidade,\n    1. Defina `frozen` como true.\n    1. Chame seu callback `notify` (salvando separadamente qualquer exceção lançada, mas ignorando o valor de retorno de `notify`).\n    1. Restaure `frozen` para false.\n    1. Defina o `state` do Watcher para `~waiting~`.\n1. Se alguma exceção foi lançada dos callbacks `notify`, propague-a para o chamador após todos os callbacks `notify` terem sido executados. Se houver múltiplas exceções, agrupe-as em um AggregateError e lance-o.\n1. Retorne undefined.\n\n### A classe `Signal.Computed`\n\n#### Máquina de estados de `Signal.Computed`",
  "status": "ok"
}