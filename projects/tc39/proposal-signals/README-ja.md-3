{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* 現在のほとんどのフレームワークでは、他の Signal グラフと相互に参照を持つ計算 Signal が生き続ける場合、明示的な破棄が必要であることに注意してください。\n* これらのライフタイムが UI コンポーネントのライフタイムに結び付いている場合や、いずれにせよ副作用の破棄が必要な場合、それほど悪くはありません。\n* もしこのセマンティクスでの実行コストが高すぎる場合は、下記 API（現状では未対応）に計算 Signal の明示的な破棄（または「unlink」）を追加すべきです。\n* 関連する別の目標：アロケーション回数の最小化、例：\n    * 書き込み可能な Signal の作成時（2つの独立したクロージャ＋配列を避ける）\n    * 副作用の実装時（すべてのリアクションごとのクロージャを避ける）\n    * Signal 変更監視 API で追加の一時データ構造の生成を避ける\n    * 解決策：サブクラスで定義されたメソッドやフィールドの再利用を可能にするクラスベース API\n\n## API スケッチ\n\nSignal API の初期案を以下に示します。これはあくまで初期ドラフトであり、今後変更が加わることが予想されます。全体像を把握するために、まず `.d.ts` の全体を掲載し、その後詳細について説明します。\n\n```ts\ninterface Signal<T> {\n    // Signal の値を取得\n    get(): T;\n}\n\nnamespace Signal {\n    // 読み書き可能な Signal\n    class State<T> implements Signal<T> {\n        // 値 t で State Signal を生成\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Signal の値を取得\n        get(): T;\n\n        // State Signal の値を t に設定\n        set(t: T): void;\n    }\n\n    // 他の Signal を元にした式となる Signal\n    class Computed<T = unknown> implements Signal<T> {\n        // コールバックが返す値を評価する Signal を生成\n        // コールバックは this signal を this 値として呼び出される\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Signal の値を取得\n        get(): T;\n    }\n\n    // この namespace には、アプリケーション開発者よりもフレームワーク作者向けの\n    // 「高度な」機能が含まれています。\n    // `crypto.subtle` と類似\n    namespace subtle {\n        // すべてのトラッキングを無効化してコールバックを実行\n        function untrack<T>(cb: () => T): T;\n\n        // Signal の読み取りをトラッキングしている現在の計算 Signal を取得（なければ null）\n        function currentComputed(): Computed | null;\n\n        // 指定した Signal が前回評価時に参照した Signal の順序付きリストを返す\n        // Watcher の場合、監視している Signal の集合を返す\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // 指定した Signal を含む Watcher および、\n        // 前回評価時にこの Signal を読み取った Computed（その Computed が（再帰的に）監視されている場合）を返す\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // この Signal が Watcher に監視されている、または（再帰的に）ライブな Computed Signal に読まれている場合 true\n        function hasSinks(s: State | Computed): boolean;\n\n        // この要素が他の Signal に依存していれば true。hasSources が false の Computed は常に同じ定数を返す\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // Watcher の（再帰的な）ソースが書き換えられたときにこのコールバックを呼び出す\n            // 前回の `watch` 呼び出し以降すでに呼び出されていなければ実行\n            // notify 中は Signal の読み書き不可\n            constructor(notify: (this: Watcher) => void);\n\n            // Watcher の監視セットにこれらの Signal を追加し、任意の Signal（またはその依存関係）が変化した次回に\n            // notify コールバックを実行するように設定\n            // 引数なしで呼ぶことで「通知済み」状態をリセットし、再度 notify コールバックが呼ばれるようにできる\n            watch(...s: Signal[]): void;\n\n            // 監視セットからこれらの Signal を削除（例：dispose された副作用用）\n            unwatch(...s: Signal[]): void;\n\n            // 監視セットのうち、まだ dirty なソース、または dirty/pending で未再評価のソースを持つ Computed Signal の集合を返す\n            getPending(): Signal[];\n        }\n\n        // 監視開始・監視終了時に呼ばれるフック\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // 古い値・新しい値の比較用カスタム関数。デフォルトは Object.is。\n        // this 値として Signal が渡される\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}