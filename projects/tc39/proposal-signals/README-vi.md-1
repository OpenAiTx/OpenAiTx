{
  "id": 1,
  "origin": "# 🚦 JavaScript Signals standard proposal🚦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and more…\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# 🚦 Đề xuất tiêu chuẩn JavaScript Signals 🚦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nGiai đoạn 1 ([giải thích](https://tc39.es/process-document/))\n\nCác đại diện đề xuất TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nTác giả gốc: Rob Eisenberg và Daniel Ehrenberg\n\nTài liệu này mô tả một hướng đi chung ban đầu cho signals trong JavaScript, tương tự như nỗ lực Promises/A+ trước khi Promises được TC39 chuẩn hóa trong ES2015. Hãy tự thử nghiệm với [một polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nTương tự như Promises/A+, nỗ lực này tập trung vào việc đồng bộ hóa hệ sinh thái JavaScript. Nếu sự đồng bộ này thành công, một tiêu chuẩn có thể sẽ xuất hiện dựa trên kinh nghiệm đó. Nhiều tác giả framework đang hợp tác ở đây để xây dựng một mô hình chung có thể hỗ trợ lõi phản ứng của họ. Bản dự thảo hiện tại dựa trên đóng góp thiết kế từ các tác giả/người bảo trì của [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), và nhiều hơn nữa…\n\nKhác với Promises/A+, chúng tôi không cố gắng giải quyết cho một API chung hướng đến lập trình viên, mà thay vào đó là các ngữ nghĩa lõi chính xác của đồ thị signal nền tảng. Đề xuất này bao gồm một API cụ thể, nhưng API này không hướng đến đa số lập trình viên ứng dụng. Thay vào đó, signal API ở đây phù hợp hơn cho các framework xây dựng phía trên, cung cấp khả năng tương tác thông qua đồ thị signal chung và cơ chế tự động theo dõi.\n\nKế hoạch cho đề xuất này là thực hiện nhiều nguyên mẫu thử nghiệm sớm, bao gồm tích hợp vào nhiều framework, trước khi tiến xa hơn Giai đoạn 1. Chúng tôi chỉ quan tâm đến việc chuẩn hóa Signals nếu chúng thực sự phù hợp để sử dụng thực tiễn trong nhiều framework, và mang lại lợi ích thực so với signals do framework cung cấp. Chúng tôi hy vọng thử nghiệm nguyên mẫu sớm sẽ cung cấp cho chúng tôi thông tin này. Xem phần \"Tình trạng và kế hoạch phát triển\" bên dưới để biết thêm chi tiết.\n\n## Bối cảnh: Tại sao lại cần Signals?\n\nĐể phát triển một giao diện người dùng (UI) phức tạp, lập trình viên ứng dụng JavaScript cần lưu trữ, tính toán, làm mất hiệu lực, đồng bộ và đẩy trạng thái đến tầng hiển thị của ứng dụng một cách hiệu quả. UI thường không chỉ dừng lại ở việc quản lý các giá trị đơn giản, mà thường liên quan đến việc render trạng thái tính toán dựa trên một cây phức tạp các giá trị hoặc trạng thái khác cũng được tính toán. Mục tiêu của Signals là cung cấp hạ tầng để quản lý trạng thái ứng dụng như vậy để lập trình viên có thể tập trung vào logic nghiệp vụ thay vì các chi tiết lặp đi lặp lại này.\n\nCác cấu trúc tương tự signals đã được chứng minh là hữu ích ngay cả trong các ngữ cảnh ngoài UI, đặc biệt là trong các hệ thống build để tránh build lại không cần thiết.\n\nSignals được sử dụng trong lập trình phản ứng để loại bỏ nhu cầu quản lý cập nhật trong ứng dụng.\n\n> Một mô hình lập trình khai báo để cập nhật dựa trên sự thay đổi của trạng thái.\n\ntrích từ _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Ví dụ – Bộ đếm VanillaJS\n\nGiả sử bạn có một biến, `counter`, bạn muốn render vào DOM xem bộ đếm là chẵn hay lẻ. Mỗi khi `counter` thay đổi, bạn muốn cập nhật DOM với trạng thái chẵn lẻ mới nhất. Trong Vanilla JS, bạn có thể có đoạn mã như sau:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Giả lập cập nhật từ bên ngoài cho counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Các biến toàn cục được sử dụng ở đây chỉ để minh họa. Quản lý trạng thái đúng cách có nhiều giải pháp, và các ví dụ trong đề xuất này nhằm tối giản nhất có thể. Đề xuất này không khuyến khích sử dụng biến toàn cục.\n\nĐiều này có một số vấn đề...\n\n* Thiết lập `counter` lộn xộn và nhiều mã mẫu lặp đi lặp lại.\n* Trạng thái `counter` bị gắn chặt với hệ thống render.\n* Nếu `counter` thay đổi nhưng `parity` không đổi (ví dụ counter từ 2 lên 4), ta vẫn tính toán lại parity và render không cần thiết.\n* Nếu một phần khác của UI chỉ muốn render khi `counter` cập nhật thì sao?\n* Nếu một phần khác của UI phụ thuộc riêng vào `isEven` hoặc `parity` thì sao?\n\nNgay cả trong kịch bản khá đơn giản này, nhiều vấn đề đã phát sinh nhanh chóng. Chúng ta có thể cố gắng giải quyết bằng cách thêm pub/sub cho `counter`. Điều này cho phép các thành phần khác có thể đăng ký nhận thay đổi của `counter` và thêm phản ứng của riêng mình.\n\nTuy nhiên, ta vẫn gặp phải các vấn đề sau:\n\n* Hàm render, vốn chỉ phụ thuộc vào `parity`, lại phải “biết” rằng nó thực ra cần đăng ký với `counter`.\n* Không thể cập nhật UI chỉ dựa trên `isEven` hoặc `parity`, mà không tương tác trực tiếp với `counter`.\n* Chúng ta lại tăng thêm mã mẫu lặp lại. Bất cứ khi nào sử dụng một thứ gì đó, không chỉ là gọi hàm hay đọc biến, mà phải đăng ký, cập nhật. Việc quản lý hủy đăng ký cũng đặc biệt phức tạp.\n\nBây giờ, ta có thể giải quyết một số vấn đề bằng cách thêm pub/sub không chỉ cho `counter` mà còn cho cả `isEven` và `parity`. Khi đó, phải đăng ký `isEven` với `counter`, `parity` với `isEven`, và `render` với `parity`. Thật không may, mã mẫu của chúng ta lại bùng nổ, và phải quản lý rất nhiều đăng ký, dễ xảy ra rò rỉ bộ nhớ nếu không dọn dẹp đúng cách. Vậy là ta giải quyết được một số vấn đề nhưng lại tạo ra một loạt vấn đề mới và nhiều mã hơn. Tệ hơn, phải làm lại quy trình này cho mọi trạng thái trong hệ thống.\n\n### Giới thiệu về Signals\n\nCác trừu tượng hóa binding dữ liệu giữa model và view trong UI từ lâu đã là cốt lõi của các framework UI trên nhiều ngôn ngữ lập trình, dù JS hay nền tảng web không tích hợp sẵn cơ chế nào như vậy. Trong các framework và thư viện JS, đã có rất nhiều thử nghiệm về cách biểu diễn binding này, và thực tiễn đã cho thấy sức mạnh của luồng dữ liệu một chiều kết hợp với kiểu dữ liệu hạng nhất đại diện cho ô trạng thái hoặc phép tính dẫn xuất từ dữ liệu khác, nay thường gọi là “Signals”.\nCách tiếp cận giá trị phản ứng hạng nhất này dường như lần đầu trở nên phổ biến trong các framework web mã nguồn mở JavaScript với [Knockout](https://knockoutjs.com/) [năm 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). Những năm sau đó, nhiều biến thể và triển khai đã được tạo ra. Trong 3-4 năm gần đây, primitive Signal và các cách tiếp cận liên quan càng được chú ý, với gần như mọi thư viện hoặc framework JavaScript hiện đại đều có thứ gì đó tương tự, dưới nhiều tên gọi khác nhau.\n\nĐể hiểu Signals, hãy xem lại ví dụ trên, được tái hiện với Signal API được trình bày dưới đây.\n\n#### Ví dụ – Bộ đếm sử dụng Signals\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// Thư viện hoặc framework định nghĩa effect dựa trên các Signal primitive khác\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Giả lập cập nhật từ bên ngoài cho counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nCó một số điều chúng ta có thể thấy ngay:\n* Đã loại bỏ mã mẫu lặp đi lặp lại quanh biến `counter` như ví dụ trước.\n* Có một API thống nhất để xử lý giá trị, tính toán và hiệu ứng phụ.\n* Không còn vấn đề tham chiếu vòng hoặc phụ thuộc ngược giữa `counter` và `render`.\n* Không có đăng ký thủ công, cũng không cần phải ghi nhận các đăng ký.\n* Có phương tiện kiểm soát thời điểm/lịch trình thực hiện hiệu ứng phụ.\n\nSignals mang lại nhiều hơn những gì có thể thấy trên bề mặt API:",
  "status": "ok"
}