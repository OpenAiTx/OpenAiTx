{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**س**: هل تعمل Signals مع تدفق البيانات أحادي الاتجاه كما يفعل React؟\n\n**ج**: نعم، Signals هي آلية لتدفق البيانات أحادي الاتجاه. تتيح لك أطر عمل واجهات المستخدم المعتمدة على Signals التعبير عن العرض الخاص بك كدالة للنموذج (حيث يدمج النموذج Signals). رسم بياني للحالة وSignals المحسوبة يكون غير دوري بطبيعته. من الممكن أيضًا إعادة إنشاء أنماط مضادة لـ React داخل Signals (!)؛ على سبيل المثال، ما يعادل `setState` داخل `useEffect` هو استخدام Watcher لجدولة كتابة إلى إشارة State.\n\n**س**: كيف ترتبط Signals بأنظمة إدارة الحالة مثل Redux؟ هل تشجع Signals على الحالة غير المنظمة؟\n\n**ج**: يمكن أن تشكل Signals أساسًا فعالًا لتجريدات إدارة الحالة المشابهة للمخزن (store-like). نمط شائع موجود في العديد من الأطر هو كائن يعتمد على Proxy والذي يمثل داخليًا الخصائص باستخدام Signals، مثل [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive)، أو [Solid stores](https://docs.solidjs.com/concepts/stores). تتيح هذه الأنظمة تجميع الحالة بشكل مرن على المستوى المناسب من التجريد للتطبيق المعني.\n\n**س**: ما الذي تقدمه Signals ولا يمكن لـ `Proxy` التعامل معه حاليًا؟\n\n**ج**: Proxies و Signals يكملان بعضهما البعض ويتوافقان معًا بشكل جيد. تتيح لك Proxies اعتراض العمليات السطحية على الكائنات بينما تنسق signals رسم بياني للاعتمادية (الخلايا). دعم Proxy باستخدام Signals هو طريقة رائعة لإنشاء بنية متداخلة تفاعلية مع سهولة كبيرة في الاستخدام.\n\nفي هذا المثال، يمكننا استخدام proxy لجعل الإشارة تحتوي على خاصية getter وsetter بدلاً من استخدام طريقتي `get` و `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// الاستخدام في سياق تفاعلي افتراضي:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nعند استخدام عارض (renderer) مُحسّن للتفاعلية الدقيقة، سيؤدي النقر على الزر إلى تحديث خلية `b.value`.\n\nراجع:\n- أمثلة على البنى التفاعلية المتداخلة التي تم إنشاؤها باستخدام Signals وProxies معًا: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- مثال على تطبيقات سابقة توضح العلاقة بين البيانات التفاعلية وproxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [نقاش](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### كيف تعمل Signals؟\n\n**س**: هل Signals تعتمد على الدفع (push) أم السحب (pull)؟\n\n**ج**: تقييم Signals المحسوبة يعتمد على السحب: يتم تقييم Signals المحسوبة فقط عندما يتم استدعاء `.get()`، حتى لو تغيرت الحالة الأساسية في وقت سابق بكثير. في نفس الوقت، قد يؤدي تغيير إشارة State إلى استدعاء رد الاتصال الخاص بـ Watcher فورًا، \"دافعًا\" الإشعار. لذا يمكن اعتبار Signals على أنها بنية \"دفع-سحب\".\n\n**س**: هل تقدم Signals عدم تحديد في تنفيذ جافاسكريبت؟\n\n**ج**: لا. جميع عمليات Signal لها دلالات وترتيب محددين جيدًا، ولن تختلف بين تطبيقات متوافقة. على مستوى أعلى، تتبع Signals مجموعة معينة من الثوابت (invariants)، والتي تكون بالنسبة لها \"صحيحة\". دائماً تلاحظ Signal المحسوبة رسم الإشارة في حالة متسقة، ولا يتم مقاطعة تنفيذها بواسطة أكواد أخرى تغير Signals (باستثناء الأشياء التي تستدعيها بنفسها). راجع الوصف أعلاه.\n\n**س**: متى تتم جدولة تحديث Signal المحسوبة عند الكتابة إلى إشارة State؟\n\n**ج**: لا يتم جدولة ذلك! ستعيد Signal المحسوبة حساب نفسها في المرة التالية التي يقرأها فيها أحدهم. بشكل متزامن، قد يتم استدعاء رد الاتصال `notify` الخاص بـ Watcher، مما يمكّن الأطر من جدولة قراءة في الوقت المناسب لهم.\n\n**س**: متى تصبح الكتابات إلى Signals الحالة فعالة؟ فورًا أم يتم تجميعها؟\n\n**ج**: تنعكس الكتابات إلى Signals الحالة فورًا--في المرة التالية التي تتم فيها قراءة Signal المحسوبة التي تعتمد على Signal الحالة، ستعيد حساب نفسها إذا لزم الأمر، حتى لو كان ذلك في السطر التالي من الكود مباشرةً. ومع ذلك، فإن الكسل المتأصل في هذه الآلية (حيث يتم حساب Signals المحسوبة فقط عند قراءتها) يعني أنه في الواقع، قد تحدث الحسابات بطريقة مجمعة.\n\n**س**: ماذا يعني أن Signals تتيح تنفيذًا \"خاليًا من العيوب\" (glitch-free)؟\n\n**ج**: واجهت نماذج الدفع (push-based) القديمة للتفاعلية مشكلة الحسابات المتكررة غير الضرورية: إذا أدى تحديث Signal الحالة إلى تشغيل Signal المحسوبة بشكل متلهف، فقد يؤدي ذلك في النهاية إلى تحديث واجهة المستخدم. لكن هذه الكتابة إلى الواجهة قد تكون مبكرة، إذا كان هناك تغيير آخر على وشك الحدوث في Signal الحالة الأصلية قبل الإطار التالي. أحيانًا، قد تظهر للمستخدمين النهائيين قيم وسيطة غير دقيقة بسبب مثل هذه [العيوب](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). تتجنب Signals هذا السلوك من خلال اعتمادها على السحب بدلاً من الدفع: في الوقت الذي يحدد فيه الإطار الزمني لعرض واجهة المستخدم، سيقوم النظام بسحب التحديثات المناسبة، مما يتجنب العمل المهدور سواء في الحساب أو في الكتابة إلى DOM.\n\n**س**: ماذا يعني أن Signals \"تفقد\" البيانات (lossy)؟\n\n**ج**: هذا هو الجانب الآخر من التنفيذ الخالي من العيوب: تمثل Signals خلية من البيانات--القيمة الحالية الفورية فقط (التي قد تتغير)، وليس تدفق بيانات عبر الزمن. لذلك، إذا كتبت إلى إشارة State مرتين متتاليتين، دون القيام بأي شيء آخر، فإن الكتابة الأولى \"تُفقد\" ولا تُرى أبدًا من قبل أي Signal محسوبة أو تأثيرات. ويُعتبر هذا ميزة وليس خطأ--البُنى الأخرى (مثل async iterables، أو observables) أكثر ملاءمة للتدفقات.\n\n**س**: هل ستكون Signals الأصلية أسرع من تطبيقات Signals في جافاسكريبت الحالية؟\n\n**ج**: نأمل ذلك (بمقدار ثابت صغير)، لكن هذا لا يزال بحاجة لإثباته في الكود. محركات جافاسكريبت ليست سحرية، وفي النهاية ستحتاج إلى تنفيذ نفس أنواع الخوارزميات الموجودة في تطبيقات Signals في جافاسكريبت. راجع القسم أعلاه حول الأداء.\n\n#### لماذا تم تصميم Signals بهذه الطريقة؟\n\n**س**: لماذا لا تتضمن هذه المقترحات دالة `effect()`، مع أن التأثيرات ضرورية لأي استخدام عملي لـ Signals؟\n\n**ج**: التأثيرات ترتبط بطبيعتها بالجدولة والإلغاء، والتي تديرها الأطر وتخرج عن نطاق هذا المقترح. بدلاً من ذلك، يتضمن هذا المقترح الأساس لتنفيذ التأثيرات من خلال API منخفض المستوى `Signal.subtle.Watcher`.\n\n**س**: لماذا الاشتراكات تلقائية بدلاً من توفير واجهة يدوية؟\n\n**ج**: أظهرت التجربة أن واجهات الاشتراك اليدوي للتفاعلية غير عملية وعرضة للأخطاء. التتبع التلقائي أكثر قابلية للتكوين وهو ميزة أساسية في Signals.\n\n**س**: لماذا يتم تشغيل رد الاتصال الخاص بـ `Watcher` بشكل متزامن، وليس مجدولًا في مهمة صغيرة (microtask)؟\n\n**ج**: لأن رد الاتصال لا يمكنه قراءة أو كتابة Signals، فلا يوجد خلل في استدعائه بشكل متزامن. غالبًا ما يضيف رد الاتصال Signal إلى مصفوفة ليتم قراءتها لاحقًا، أو يضع علامة في مكان ما. من غير الضروري ومكلف جدًا إنشاء مهمة صغيرة منفصلة لجميع هذه الإجراءات.\n\n**س**: تفتقد هذه الواجهة البرمجية لبعض الميزات الجميلة التي يوفرها إطاري المفضل، والتي تسهّل البرمجة باستخدام Signals. هل يمكن إضافتها إلى المعيار أيضًا؟\n\n**ج**: ربما. لا تزال هناك امتدادات متنوعة قيد الدراسة. يرجى فتح قضية لمناقشة أي ميزة مفقودة تراها مهمة.\n\n**س**: هل يمكن تقليل حجم أو تعقيد هذه الواجهة البرمجية؟\n\n**ج**: من المؤكد أن الحفاظ على هذه الواجهة البرمجية بسيطة هو هدف، وقد حاولنا القيام بذلك فيما عُرض أعلاه. إذا كانت لديك أفكار حول أشياء أخرى يمكن إزالتها، يرجى فتح قضية للنقاش.\n\n#### كيف يتم توحيد Signals؟\n\n**س**: أليس من الأفضل أن نبدأ أعمال التوحيد في هذا المجال بمفهوم أكثر بدائية، مثل observables؟\n",
  "status": "ok"
}