{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback llamado cuando isWatched se vuelve true, si previamente era false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback llamado cuando isWatched se vuelve false, si previamente era true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Cómo funcionan los Signals\n\nUn Signal representa una celda de datos que puede cambiar con el tiempo. Los Signals pueden ser de tipo \"state\" (simplemente un valor que se establece manualmente) o \"computed\" (una fórmula basada en otros Signals).\n\nLos Signals computados funcionan rastreando automáticamente qué otros Signals son leídos durante su evaluación. Cuando se lee un computed, verifica si alguna de sus dependencias registradas previamente ha cambiado y se reevalúa si es así. Cuando varios Signals computados están anidados, toda la atribución del rastreo va al más interno.\n\nLos Signals computados son perezosos, es decir, basados en demanda: solo se reevalúan cuando se accede a ellos, incluso si una de sus dependencias cambió anteriormente.\n\nEl callback pasado a los Signals computados generalmente debe ser \"puro\" en el sentido de ser una función determinista y sin efectos secundarios de los otros Signals a los que accede. Al mismo tiempo, el momento en que se llama al callback es determinista, permitiendo que los efectos secundarios se usen con cuidado.\n\nLos Signals presentan un destacado almacenamiento en caché/memoización: tanto los Signals de estado como los computados recuerdan su valor actual y solo desencadenan el recálculo de los Signals computados que los referencian si realmente cambian. Ni siquiera se necesita una comparación repetida de los valores antiguos y nuevos: la comparación se realiza una vez cuando el Signal fuente se reinicia/reevalúa, y el mecanismo de Signal lleva el seguimiento de qué cosas que referencian ese Signal aún no se han actualizado según el nuevo valor. Internamente, esto generalmente se representa mediante \"coloreado de grafos\" como se describe en (la publicación del blog de Milo).\n\nLos Signals computados rastrean sus dependencias dinámicamente: cada vez que se ejecutan, pueden terminar dependiendo de cosas diferentes, y ese conjunto de dependencias preciso se mantiene actualizado en el grafo de Signals. Esto significa que si tienes una dependencia necesaria solo en una rama, y el cálculo anterior tomó la otra rama, entonces un cambio en ese valor temporalmente no utilizado no hará que el Signal computado se recalcule, incluso cuando se acceda a él.\n\nA diferencia de las Promesas de JavaScript, todo en Signals se ejecuta de manera síncrona:\n- Establecer un Signal a un nuevo valor es síncrono, y esto se refleja inmediatamente al leer cualquier Signal computado que dependa de él después. No hay ningún agrupamiento (\"batching\") incorporado para esta mutación.\n- Leer Signals computados es síncrono: su valor está siempre disponible.\n- El callback `notify` en los Watchers, como se explica a continuación, se ejecuta de manera síncrona, durante la llamada a `.set()` que lo desencadenó (pero después de que se haya completado el coloreado del grafo).\n\nAl igual que las Promesas, los Signals pueden representar un estado de error: si el callback de un Signal computado lanza una excepción, ese error se almacena en caché como cualquier otro valor y se vuelve a lanzar cada vez que se lee el Signal.\n\n### Entendiendo la clase Signal\n\nUna instancia de `Signal` representa la capacidad de leer un valor que cambia dinámicamente y cuyos cambios se rastrean con el tiempo. También incluye implícitamente la capacidad de suscribirse al Signal, de manera implícita a través de un acceso rastreado desde otro Signal computado.\n\nLa API aquí está diseñada para coincidir con el consenso muy general de la comunidad entre una gran fracción de las librerías de Signals en el uso de nombres como \"signal\", \"computed\" y \"state\". Sin embargo, el acceso a los Signals Computed y State es a través de un método `.get()`, lo cual difiere de todas las APIs populares de Signals, que usan un accesor `.value` o una sintaxis de llamada `signal()`.\n\nLa API está diseñada para reducir el número de asignaciones, para hacer los Signals adecuados para su integración en frameworks de JavaScript mientras se logra el mismo o mejor rendimiento que los Signals personalizados de los frameworks existentes. Esto implica:\n- Los Signals de estado son un único objeto escribible, que puede ser accedido y modificado desde la misma referencia. (Ver implicaciones más abajo en la sección \"Separación de capacidades\").\n- Tanto los Signals de estado como los computados están diseñados para poder ser subclaseados, para facilitar que los frameworks agreguen propiedades adicionales a través de campos de clase públicos y privados (así como métodos para usar ese estado).\n- Varios callbacks (por ejemplo, `equals`, el callback de los computados) se llaman con el Signal relevante como el valor de `this` para contexto, de modo que no se necesita una nueva closure por Signal. En su lugar, el contexto puede guardarse en propiedades extra del propio Signal.\n\nAlgunas condiciones de error impuestas por esta API:\n- Es un error leer un Signal computado recursivamente.\n- El callback `notify` de un Watcher no puede leer ni escribir ningún Signal.\n- Si el callback de un Signal computado lanza una excepción, los accesos posteriores a ese Signal vuelven a lanzar ese error almacenado, hasta que una de las dependencias cambie y se recalcule.\n\nAlgunas condiciones que *no* se imponen:\n- Los Signals computados pueden escribir en otros Signals, de forma síncrona dentro de su callback.\n- El trabajo que es puesto en cola por el callback `notify` de un Watcher puede leer o escribir signals, permitiendo replicar [antipatrones clásicos de React](https://react.dev/learn/you-might-not-need-an-effect) en términos de Signals.\n\n### Implementando efectos\n\nLa interfaz `Watcher` definida arriba da la base para implementar las típicas APIs JS para efectos: callbacks que se vuelven a ejecutar cuando otros Signals cambian, únicamente por su efecto secundario. La función `effect` usada arriba en el ejemplo inicial puede definirse así:\n\n```ts\n// Esta función usualmente viviría en una librería/framework, no en código de aplicación\n// NOTA: Esta lógica de programación es demasiado básica para ser útil. No copiar/pegar.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Un Signal de efecto que evalúa cb, que programa una lectura de\n// sí mismo en la cola de microtareas cada vez que una de sus dependencias podría cambiar\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nLa API de Signal no incluye ninguna función incorporada como `effect`. Esto se debe a que la programación de efectos es sutil y a menudo se integra con los ciclos de renderizado del framework y otros estados o estrategias específicas de alto nivel de los frameworks a los que JS no tiene acceso.\n\nRepasando las diferentes operaciones utilizadas aquí: El callback `notify` pasado al constructor de `Watcher` es la función que se llama cuando el Signal pasa de un estado \"limpio\" (donde sabemos que la caché está inicializada y es válida) a un estado \"checked\" o \"dirty\" (donde la caché podría o no ser válida porque al menos uno de los estados de los que depende recursivamente ha cambiado).\n\nLas llamadas a `notify` son desencadenadas en última instancia por una llamada a `.set()` en algún Signal de estado. Esta llamada es síncrona: sucede antes de que `.set` retorne. Pero no hay que preocuparse de que este callback observe el grafo de Signals en un estado a medio procesar, porque durante un callback `notify`, no se puede leer ni escribir ningún Signal, ni siquiera en una llamada a `untrack`. Como `notify` se llama durante `.set()`, está interrumpiendo otro hilo de lógica, que podría no estar completo. Para leer o escribir Signals desde `notify`, programa el trabajo para que se ejecute después, por ejemplo, escribiendo el Signal en una lista para acceder a él más tarde, o usando `queueMicrotask` como arriba.\n\nTen en cuenta que es perfectamente posible usar Signals eficazmente sin `Signal.subtle.Watcher` programando el sondeo de Signals computados, como hace Glimmer. Sin embargo, muchos frameworks han descubierto que es muy útil que esta lógica de programación se ejecute de forma síncrona, por lo que la API de Signals la incluye.\n\nTanto los Signals computados como los de estado son recolectados por el recolector de basura como cualquier valor JS. Pero los Watchers tienen una manera especial de mantener vivos los objetos: cualquier Signal observado por un Watcher se mantendrá vivo mientras cualquiera de los estados subyacentes sea accesible, ya que estos pueden desencadenar una futura llamada a `notify` (y luego a un futuro `.get()`). Por este motivo, recuerda llamar a `Watcher.prototype.unwatch` para limpiar efectos.\n\n### Una vía de escape insegura\n\n`Signal.subtle.untrack` es una vía de escape que permite leer Signals *sin* rastrear esas lecturas. Esta capacidad es insegura porque permite la creación de Signals computados cuyo valor depende de otros Signals, pero que no se actualizan cuando esos Signals cambian. Debe usarse cuando los accesos no rastreados no cambien el resultado del cálculo.\n\n<!--\nTODO: Mostrar ejemplo donde es buena idea usar untrack\n\n### Usando watched/unwatched",
  "status": "ok"
}