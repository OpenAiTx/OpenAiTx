{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback được gọi khi isWatched trở thành true, nếu trước đó là false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback được gọi mỗi khi isWatched trở thành false, nếu trước đó là true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Cách Signals hoạt động\n\nMột Signal đại diện cho một ô dữ liệu có thể thay đổi theo thời gian. Signals có thể là \"state\" (chỉ là một giá trị được thiết lập thủ công) hoặc \"computed\" (một công thức dựa trên các Signal khác).\n\nCác Signal tính toán (Computed Signals) hoạt động bằng cách tự động theo dõi các Signal khác được đọc trong quá trình đánh giá của chúng. Khi một computed được đọc, nó kiểm tra xem bất kỳ phụ thuộc đã ghi nhận trước đó nào có thay đổi không, và tự đánh giá lại nếu có. Khi nhiều computed Signals được lồng nhau, tất cả việc ghi nhận sự phụ thuộc sẽ thuộc về cái lồng trong cùng nhất.\n\nComputed Signals là lười biếng, tức là dựa trên cơ chế pull: chúng chỉ được đánh giá lại khi được truy cập, ngay cả khi một trong các phụ thuộc của chúng đã thay đổi trước đó.\n\nCallback truyền vào computed Signals thường nên \"thuần khiết\" (pure) theo nghĩa là một hàm xác định, không có hiệu ứng phụ với các Signal khác mà nó truy cập. Đồng thời, thời điểm callback được gọi là xác định, cho phép sử dụng hiệu ứng phụ một cách cẩn trọng.\n\nSignals có tính năng nổi bật là caching/memoization: cả state và computed Signals đều ghi nhớ giá trị hiện tại của chúng, và chỉ kích hoạt việc tính toán lại của các computed Signals tham chiếu chúng nếu chúng thực sự thay đổi. Không cần so sánh lặp lại giá trị cũ và mới—so sánh chỉ được thực hiện một lần khi Signal nguồn được thiết lập lại/đánh giá lại, và cơ chế Signal sẽ theo dõi những gì tham chiếu đến Signal đó chưa được cập nhật dựa trên giá trị mới. Nội bộ, điều này thường được biểu diễn qua \"graph coloring\" như được mô tả trong (bài blog của Milo).\n\nComputed Signals theo dõi phụ thuộc của chúng một cách động—mỗi lần chúng được chạy, chúng có thể phụ thuộc vào những thứ khác nhau, và tập phụ thuộc chính xác đó luôn được cập nhật mới trong đồ thị Signal. Điều này có nghĩa là nếu bạn có một phụ thuộc chỉ cần thiết ở một nhánh, và lần tính trước chọn nhánh khác, thì một thay đổi tới giá trị tạm thời không sử dụng đó sẽ không khiến computed Signal bị tính lại, ngay cả khi được truy cập.\n\nKhông giống như JavaScript Promises, mọi thứ trong Signals đều chạy đồng bộ:\n- Thiết lập một Signal với giá trị mới là đồng bộ, và điều này được phản ánh ngay lập tức khi đọc bất kỳ computed Signal nào phụ thuộc vào nó sau đó. Không có việc gom nhóm (batching) tích hợp cho thao tác này.\n- Đọc các computed Signals là đồng bộ—giá trị của chúng luôn sẵn có.\n- Callback `notify` trong Watchers, như giải thích bên dưới, chạy đồng bộ, trong quá trình gọi `.set()` đã kích hoạt nó (nhưng sau khi quá trình graph coloring đã hoàn tất).\n\nGiống như Promises, Signals có thể đại diện cho trạng thái lỗi: Nếu callback của một computed Signal ném lỗi, thì lỗi đó sẽ được cache giống như giá trị khác, và ném lại mỗi lần Signal được đọc.\n\n### Tìm hiểu lớp Signal\n\nMột instance `Signal` đại diện cho khả năng đọc một giá trị thay đổi động mà các cập nhật của nó được theo dõi theo thời gian. Nó cũng ngầm bao gồm khả năng đăng ký (subscribe) vào Signal, một cách ngầm qua việc truy cập có theo dõi từ một computed Signal khác.\n\nAPI ở đây được thiết kế để phù hợp với sự đồng thuận chung trong hệ sinh thái giữa nhiều thư viện Signal về việc sử dụng các tên như \"signal\", \"computed\" và \"state\". Tuy nhiên, truy cập vào Computed và State Signals thông qua phương thức `.get()`, điều này không giống với các API Signal phổ biến hiện tại, vốn sử dụng cú pháp truy cập `.value` hoặc gọi `signal()`.\n\nAPI được thiết kế để giảm số lượng phân bổ bộ nhớ, nhằm làm cho Signals phù hợp để nhúng vào các framework JavaScript trong khi đạt hiệu năng tương đương hoặc tốt hơn các Signals tùy biến của framework hiện tại. Điều này có nghĩa là:\n- State Signals là một đối tượng có thể ghi đơn lẻ, có thể được truy cập và thiết lập từ cùng một tham chiếu. (Xem các hệ quả bên dưới trong phần \"Phân tách khả năng\".)\n- Cả State và Computed Signals đều được thiết kế để có thể kế thừa, nhằm tạo điều kiện cho các framework có thể thêm các thuộc tính bổ sung thông qua trường class công khai hoặc riêng tư (cũng như các phương thức sử dụng trạng thái đó).\n- Nhiều callback khác nhau (ví dụ, `equals`, callback của computed) được gọi với Signal liên quan là giá trị `this` để làm ngữ cảnh, vì vậy không cần closure mới cho mỗi Signal. Thay vào đó, ngữ cảnh có thể được lưu trong các thuộc tính bổ sung của chính Signal đó.\n\nMột số điều kiện lỗi được API này áp đặt:\n- Đọc một computed một cách đệ quy là lỗi.\n- Callback `notify` của Watcher không thể đọc hoặc ghi bất kỳ signal nào.\n- Nếu callback của một computed Signal ném lỗi, thì các lần truy cập tiếp theo vào Signal đó sẽ ném lại lỗi đã cache, cho đến khi một trong các phụ thuộc thay đổi và nó được tính lại.\n\nMột số điều kiện *không* bị áp đặt:\n- Computed Signals có thể ghi vào các Signals khác, đồng bộ trong callback của chúng.\n- Công việc được xếp hàng bởi callback `notify` của Watcher có thể đọc hoặc ghi signals, khiến có thể tái tạo các [anti-pattern React kinh điển](https://react.dev/learn/you-might-not-need-an-effect) bằng Signals!\n\n### Triển khai effects\n\nGiao diện `Watcher` được định nghĩa ở trên cung cấp cơ sở để triển khai các API JS điển hình cho effects: các callback được chạy lại khi các Signal khác thay đổi, chỉ để thực hiện hiệu ứng phụ. Hàm `effect` được sử dụng ở ví dụ ban đầu phía trên có thể được định nghĩa như sau:\n\n```ts\n// Hàm này thường nằm trong thư viện/framework, không phải mã ứng dụng\n// LƯU Ý: Logic lập lịch này quá đơn giản để sử dụng thực tế. Không copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Một effect Signal đánh giá thành cb, lập lịch đọc chính nó trên hàng đợi microtask\n// bất cứ khi nào một trong các phụ thuộc của nó có thể thay đổi\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nAPI Signal không bao gồm bất kỳ hàm tích hợp nào như `effect`. Điều này là vì việc lập lịch effect rất tinh vi và thường gắn liền với vòng lặp render của framework và các trạng thái hoặc chiến lược đặc thù framework cấp cao khác mà JS không truy cập được.\n\nGiải thích các thao tác khác nhau được sử dụng ở đây: Callback `notify` truyền vào constructor của `Watcher` là hàm được gọi khi Signal chuyển từ trạng thái \"clean\" (biết cache đã được khởi tạo và hợp lệ) sang trạng thái \"checked\" hoặc \"dirty\" (cache có thể hợp lệ hoặc không vì ít nhất một trạng thái mà nó phụ thuộc đệ quy đã bị thay đổi).\n\nCác cuộc gọi tới `notify` cuối cùng được kích hoạt bởi một cuộc gọi tới `.set()` trên một state Signal nào đó. Cuộc gọi này là đồng bộ: nó xảy ra trước khi `.set` trả về. Tuy nhiên, không cần lo lắng về việc callback này quan sát đồ thị Signal ở trạng thái xử lý dở, vì trong suốt callback `notify`, không Signal nào có thể được đọc hoặc ghi, ngay cả trong một cuộc gọi `untrack`. Vì `notify` được gọi trong quá trình `.set()`, nó đang chen ngang một luồng logic khác, có thể chưa hoàn thành. Để đọc hoặc ghi Signals từ `notify`, hãy lập lịch công việc để chạy sau, ví dụ, bằng cách ghi Signal vào một danh sách để truy cập sau, hoặc dùng `queueMicrotask` như trên.\n\nLưu ý rằng hoàn toàn có thể sử dụng Signals một cách hiệu quả mà không cần `Signal.subtle.Watcher` bằng cách lập lịch polling các computed Signals, như Glimmer đã làm. Tuy nhiên, nhiều framework nhận thấy rất hữu ích khi logic lập lịch này chạy đồng bộ, nên API Signals đã bao gồm điều đó.\n\nCả computed và state Signals đều được thu gom bộ nhớ (garbage-collected) như bất kỳ giá trị JS nào khác. Nhưng Watchers có một cách đặc biệt để giữ mọi thứ tồn tại: Bất kỳ Signals nào được Watcher theo dõi sẽ được giữ sống miễn là bất kỳ state nền tảng nào còn truy cập được, vì chúng có thể kích hoạt một cuộc gọi `notify` trong tương lai (và sau đó là `.get()`). Vì lý do này, hãy nhớ gọi `Watcher.prototype.unwatch` để dọn dẹp effects.\n\n### Lối thoát không an toàn (unsound escape hatch)\n\n`Signal.subtle.untrack` là một lối thoát cho phép đọc Signals *mà không* theo dõi các lần đọc đó. Khả năng này không an toàn vì nó cho phép tạo ra các computed Signals mà giá trị của chúng phụ thuộc vào các Signal khác, nhưng lại không được cập nhật khi các Signal đó thay đổi. Nên dùng khi các truy cập không theo dõi này sẽ không làm thay đổi kết quả phép tính.\n\n<!--\nTODO: Minh họa ví dụ khi nào nên dùng untrack\n\n### Sử dụng watched/unwatched",
  "status": "ok"
}