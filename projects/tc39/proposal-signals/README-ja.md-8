{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q**: Signalsは、Reactのような一方向データフローと連携しますか？\n\n**A**: はい。Signalsは一方向データフローのための仕組みです。SignalベースのUIフレームワークでは、ビューをモデル（モデルがSignalsを含む）の関数として表現できます。状態と計算済みSignalのグラフは構造上非循環（acyclic）です。また、Signals内でReactのアンチパターンを再現することも可能です（！）。例えば、`useEffect`内の`setState`のSignal版は、Watcherを使ってState Signalへの書き込みをスケジューリングすることです。\n\n**Q**: SignalsはReduxのような状態管理システムとどのような関係にありますか？Signalsは無構造な状態を助長しますか？\n\n**A**: Signalsはストアのような状態管理抽象の効率的な基盤となります。複数のフレームワークで見られる一般的なパターンは、内部的にプロパティをSignalとして表現するProxyベースのオブジェクトです。例としては [Vueの`reactive()`](https://vuejs.org/api/reactivity-core.html#reactive) や [Solid stores](https://docs.solidjs.com/concepts/stores) があります。これらのシステムは、アプリケーションごとに適切な抽象レベルで状態を柔軟にグループ化することを可能にします。\n\n**Q**: Signalsが現在`Proxy`で扱えないものは何ですか？\n\n**A**: ProxyとSignalsは相補的であり、非常に相性が良いです。Proxyはオブジェクトの浅い操作をインターセプトし、Signalsは依存グラフ（セルのグラフ）を調整します。Proxyの裏にSignalsを持たせることで、使いやすいネストされたリアクティブ構造を作ることができます。\n\nこの例では、Signalに`get`や`set`メソッドの代わりにゲッター・セッタープロパティを持たせるためにProxyを使っています：\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// 仮想的なリアクティブコンテキストでの使用例:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nきめ細かいリアクティビティに最適化されたレンダラーを使う場合、ボタンをクリックすると`b.value`セルが更新されます。\n\n参照：\n- SignalsとProxyの両方で作成されたネストされたリアクティブ構造の例：[signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- リアクティブデータとプロキシ間の関係を示す過去の実装例：[tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [ディスカッション](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574)。\n\n#### Signalsはどのように動作しますか？\n\n**Q**: Signalsはプッシュ型ですか、それともプル型ですか？\n\n**A**: 計算済みSignalの評価はプル型です：計算済みSignalは`.get()`が呼ばれたときのみ評価され、基となる状態が以前に変化していても評価されません。同時に、State Signalを変更するとWatcherのコールバックが即座にトリガーされ、「プッシュ」通知が行われることもあります。したがって、Signalsは「プッシュ・プル」構造と考えることができます。\n\n**Q**: SignalsはJavaScript実行に非決定性を導入しますか？\n\n**A**: いいえ。すべてのSignal操作には明確なセマンティクスと順序があり、適合する実装間で異なることはありません。より高いレベルでは、Signalsはいくつかの不変条件に従っており、それに対して「健全」です。計算済みSignalは常にSignalグラフの一貫した状態を観測し、その実行は他のSignalを変更するコードによって中断されません（ただし自分自身が呼び出すものは除きます）。詳細は上記の説明を参照してください。\n\n**Q**: State Signalに書き込んだとき、計算済みSignalの更新はいつスケジュールされますか？\n\n**A**: スケジュールされません！計算済みSignalは、次に誰かがそれを読み込んだときに再計算されます。同時に、Watcherの`notify`コールバックが呼ばれることがあり、フレームワークは適切と判断したタイミングで読み込みをスケジュールできます。\n\n**Q**: State Signalへの書き込みは、即時反映されますか？それともバッチ処理されますか？\n\n**A**: State Signalへの書き込みは即時に反映されます——State Signalに依存する計算済みSignalが次に読み込まれたとき、必要に応じて即座に再計算されます（たとえ直後のコード行であっても）。ただし、この仕組みの遅延性（計算済みSignalは読み込み時のみ計算される）により、実際には計算がバッチ的に行われる場合もあります。\n\n**Q**: Signalsが「グリッチフリー」な実行を可能にするとはどういう意味ですか？\n\n**A**: 以前のプッシュ型リアクティビティモデルでは、冗長な計算という問題がありました。State Signalの更新が計算済みSignalを即座に実行させると、最終的にUIに更新がプッシュされることがあります。しかし、もし次のフレームまでに元のState Signalに別の変更が加わる場合、そのUIへの書き込みは時期尚早となります。時には、このような[グリッチ](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)により不正確な中間値がユーザーに表示されることもありました。Signalsはプル型であることでこの動作を回避します：フレームワークがUIのレンダリングをスケジュールする時点で適切な更新をプルし、計算やDOMへの書き込みの無駄な作業を避けます。\n\n**Q**: Signalsが「ロスイー（lossy）」であるとはどういう意味ですか？\n\n**A**: これはグリッチフリー実行の裏返しです。Signalsはデータセル——すなわち直近の現在値のみ（変化する可能性あり）を表現し、時系列のデータストリームを表現しません。したがって、何もせずにState Signalに2回連続で書き込むと、最初の書き込みは「失われ」、計算済みSignalやエフェクトには決して見られません。これはバグではなく機能だと理解されています。ストリームには他の構造（例えばasync iterableやobservable）のほうが適しています。\n\n**Q**: ネイティブSignalsは既存のJS Signal実装より高速になりますか？\n\n**A**: そうなることを期待しています（小さな定数倍程度）が、これは実際のコードで証明される必要があります。JSエンジンは魔法ではなく、最終的にはJSによるSignal実装と同種のアルゴリズムを実装する必要があります。パフォーマンスに関する前述のセクションも参照してください。\n\n#### Signalsはなぜこのように設計されたのですか？\n\n**Q**: エフェクトはSignalsの実用的な利用に不可欠であるにもかかわらず、この提案には`effect()`関数が含まれていないのはなぜですか？\n\n**A**: エフェクトは本質的にスケジューリングや破棄処理と結びついており、これらはフレームワークによって管理され、この提案の範囲外です。代わりに、この提案にはより低レベルな`Signal.subtle.Watcher` APIを通じてエフェクト実装の基礎が含まれています。\n\n**Q**: なぜ購読（subscription）は自動で、手動インターフェースが提供されないのですか？\n\n**A**: 経験上、リアクティビティのための手動サブスクリプションインターフェースは使いにくく、エラーを招きやすいことがわかっています。自動トラッキングはより合成可能であり、Signalsの中核的な特徴です。\n\n**Q**: なぜ`Watcher`のコールバックは同期的に実行され、マイクロタスクでスケジュールされないのですか？\n\n**A**: コールバックがSignalの読み書きをできないため、同期的に呼び出しても不整合が生じません。典型的なコールバックはSignalを後で読み込むために配列に追加したり、どこかのビットをマークしたりします。これらすべてのアクションのために個別のマイクロタスクを作るのは不要かつ非現実的に高コストです。\n\n**Q**: このAPIには、私のお気に入りのフレームワークが提供しているSignalsでのプログラミングを簡単にする便利な機能が欠けています。これも標準に加えられますか？\n\n**A**: 可能性はあります。さまざまな拡張が検討中です。重要だと考える機能が欠けている場合はissueを立てて議論を提起してください。\n\n**Q**: このAPIをもっと小さく、または単純化できますか？\n\n**A**: このAPIをミニマルに保つことは確かな目標であり、上記の内容でできる限りそうしています。さらに削除できそうな点があれば、issueを立てて議論してください。\n\n#### Signalsはどのように標準化されているのですか？\n\n**Q**: この分野の標準化作業は、observableなどのよりプリミティブな概念から始めるべきではありませんか？",
  "status": "ok"
}