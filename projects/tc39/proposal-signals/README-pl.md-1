{
  "id": 1,
  "origin": "# ğŸš¦ JavaScript Signals standard proposalğŸš¦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and moreâ€¦\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# ğŸš¦ Propozycja standardu JavaScript Signals ğŸš¦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\nEtap 1 ([wyjaÅ›nienie](https://tc39.es/process-document/))\n\nLiderzy propozycji TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOryginalni autorzy: Rob Eisenberg i Daniel Ehrenberg\n\nTen dokument opisuje wczesny wspÃ³lny kierunek dla sygnaÅ‚Ã³w w JavaScript, podobnie jak wysiÅ‚ek Promises/A+, ktÃ³ry poprzedziÅ‚ ustandaryzowanie Promise przez TC39 w ES2015. WyprÃ³buj samodzielnie, korzystajÄ…c z [polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nPodobnie jak Promises/A+, ten wysiÅ‚ek koncentruje siÄ™ na ujednoliceniu ekosystemu JavaScript. JeÅ›li to ujednolicenie siÄ™ powiedzie, na podstawie tych doÅ›wiadczeÅ„ moÅ¼e powstaÄ‡ standard. Kilku autorÃ³w frameworkÃ³w wspÃ³Å‚pracuje tutaj nad wspÃ³lnym modelem, ktÃ³ry mÃ³gÅ‚by stanowiÄ‡ podstawÄ™ ich mechanizmÃ³w reaktywnoÅ›ci. Aktualny szkic opiera siÄ™ na wkÅ‚adzie projektowym autorÃ³w/opiekunÃ³w [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a) i innychâ€¦\n\nW odrÃ³Å¼nieniu od Promises/A+, nie prÃ³bujemy rozwiÄ…zywaÄ‡ wspÃ³lnego API dla deweloperÃ³w, ale raczej precyzyjne, podstawowe semantyki leÅ¼Ä…cego u podstaw grafu sygnaÅ‚Ã³w. Propozycja ta zawiera w peÅ‚ni konkretny interfejs API, ale nie jest on przeznaczony dla wiÄ™kszoÅ›ci programistÃ³w aplikacji. Zamiast tego, przedstawione tu API sygnaÅ‚Ã³w lepiej nadaje siÄ™ jako podstawa do budowy frameworkÃ³w, zapewniajÄ…c interoperacyjnoÅ›Ä‡ poprzez wspÃ³lny graf sygnaÅ‚Ã³w i mechanizm automatycznego Å›ledzenia zaleÅ¼noÅ›ci.\n\nPlan dla tej propozycji zakÅ‚ada przeprowadzenie znacznych wczesnych prototypÃ³w, w tym integracjÄ™ z kilkoma frameworkami, zanim wyjdziemy poza Etap 1. JesteÅ›my zainteresowani standaryzacjÄ… Signals tylko wtedy, gdy bÄ™dÄ… one praktycznie uÅ¼yteczne w wielu frameworkach i zapewniÄ… realne korzyÅ›ci w porÃ³wnaniu do sygnaÅ‚Ã³w dostarczanych przez frameworki. Mamy nadziejÄ™, Å¼e szeroko zakrojone prototypowanie dostarczy nam tych informacji. Zobacz \"Status i plan rozwoju\" poniÅ¼ej, aby uzyskaÄ‡ wiÄ™cej szczegÃ³Å‚Ã³w.\n\n## TÅ‚o: Dlaczego Signals?\n\nAby stworzyÄ‡ zÅ‚oÅ¼ony interfejs uÅ¼ytkownika (UI), programiÅ›ci aplikacji JavaScript muszÄ… przechowywaÄ‡, obliczaÄ‡, uniewaÅ¼niaÄ‡, synchronizowaÄ‡ i przekazywaÄ‡ stan do warstwy widoku aplikacji w efektywny sposÃ³b. UI zwykle obejmuje wiÄ™cej niÅ¼ tylko zarzÄ…dzanie prostymi wartoÅ›ciami; czÄ™sto wymaga renderowania stanu wyliczonego na podstawie zÅ‚oÅ¼onego drzewa innych wartoÅ›ci lub stanu, ktÃ³ry rÃ³wnieÅ¼ jest obliczany. Celem Signals jest zapewnienie infrastruktury do zarzÄ…dzania takim stanem aplikacji, aby programiÅ›ci mogli skupiÄ‡ siÄ™ na logice biznesowej, zamiast na powtarzalnych detalach.\n\nKonstrukcje podobne do sygnaÅ‚Ã³w okazaÅ‚y siÄ™ przydatne takÅ¼e w kontekstach nie zwiÄ…zanych z UI, szczegÃ³lnie w systemach budowania, aby unikaÄ‡ niepotrzebnych przebudÃ³w.\n\nSygnaÅ‚y sÄ… uÅ¼ywane w programowaniu reaktywnym, aby wyeliminowaÄ‡ potrzebÄ™ rÄ™cznego zarzÄ…dzania aktualizacjÄ… w aplikacjach.\n\n> Deklaratywny model programowania do aktualizacji na podstawie zmian stanu.\n\nz _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### PrzykÅ‚ad â€“ licznik w VanillaJS\n\nMajÄ…c zmiennÄ… `counter`, chcesz wyrenderowaÄ‡ w DOM informacjÄ™, czy licznik jest parzysty czy nieparzysty. Za kaÅ¼dym razem, gdy `counter` siÄ™ zmienia, chcesz zaktualizowaÄ‡ DOM z najnowszÄ… parzystoÅ›ciÄ…. W czystym JS moÅ¼esz mieÄ‡ coÅ› takiego:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Symulacja zewnÄ™trznych aktualizacji licznika...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Zmienne globalne sÄ… tutaj uÅ¼ywane wyÅ‚Ä…cznie do celÃ³w demonstracyjnych. PrawidÅ‚owe zarzÄ…dzanie stanem ma wiele rozwiÄ…zaÅ„, a przykÅ‚ady w tej propozycji majÄ… byÄ‡ jak najbardziej minimalne. Propozycja nie zaleca uÅ¼ywania zmiennych globalnych.\n\n\nTo rozwiÄ…zanie ma kilka problemÃ³w...\n\n* Konfiguracja `counter` jest rozbudowana i peÅ‚na powtarzalnego kodu.\n* Stan `counter` jest silnie powiÄ…zany z systemem renderowania.\n* JeÅ›li `counter` siÄ™ zmienia, ale `parity` nie (np. licznik przechodzi z 2 na 4), wykonujemy niepotrzebne obliczenia parzystoÅ›ci i zbÄ™dne renderowanie.\n* Co jeÅ›li inna czÄ™Å›Ä‡ UI chce siÄ™ wyrenderowaÄ‡ tylko podczas aktualizacji `counter`?\n* Co jeÅ›li inna czÄ™Å›Ä‡ UI zaleÅ¼y wyÅ‚Ä…cznie od `isEven` lub `parity`?\n\nNawet w tym stosunkowo prostym scenariuszu szybko pojawia siÄ™ szereg problemÃ³w. MoÅ¼emy prÃ³bowaÄ‡ je obejÅ›Ä‡, wprowadzajÄ…c pub/sub dla `counter`. PozwoliÅ‚oby to dodatkowym odbiorcom `counter` zasubskrybowaÄ‡ i reagowaÄ‡ na zmiany stanu.\n\nJednak nadal pozostajÄ… nastÄ™pujÄ…ce problemy:\n\n* Funkcja renderujÄ…ca, ktÃ³ra zaleÅ¼y tylko od `parity`, musi â€wiedzieÄ‡â€, Å¼e tak naprawdÄ™ powinna subskrybowaÄ‡ `counter`.\n* Nie da siÄ™ aktualizowaÄ‡ UI na podstawie samego `isEven` lub `parity` bez bezpoÅ›redniej interakcji z `counter`.\n* ZwiÄ™kszyliÅ›my iloÅ›Ä‡ powtarzalnego kodu. Za kaÅ¼dym razem, gdy coÅ› wykorzystujemy, nie wystarczy juÅ¼ wywoÅ‚aÄ‡ funkcji lub odczytaÄ‡ zmiennej, ale trzeba subskrybowaÄ‡ i obsÅ‚ugiwaÄ‡ tam aktualizacje. ZarzÄ…dzanie wypisaniem z subskrypcji jest rÃ³wnieÅ¼ szczegÃ³lnie skomplikowane.\n\nMoÅ¼emy rozwiÄ…zaÄ‡ kilka problemÃ³w, dodajÄ…c pub/sub nie tylko do `counter`, ale takÅ¼e do `isEven` i `parity`. Wtedy musielibyÅ›my subskrybowaÄ‡ `isEven` do `counter`, `parity` do `isEven`, a `render` do `parity`. Niestety, nie tylko nasz kod eksplodowaÅ‚ objÄ™toÅ›ciowo, ale mamy mnÃ³stwo pracy z zarzÄ…dzaniem subskrypcjami i potencjalnÄ… katastrofÄ… wyciekÃ³w pamiÄ™ci, jeÅ›li nie posprzÄ…tamy wszystkiego we wÅ‚aÅ›ciwy sposÃ³b. RozwiÄ…zaliÅ›my wiÄ™c czÄ™Å›Ä‡ problemÃ³w, ale stworzyliÅ›my zupeÅ‚nie nowÄ… kategoriÄ™ trudnoÅ›ci i duÅ¼o kodu. Co gorsza, caÅ‚y ten proces trzeba powtarzaÄ‡ dla kaÅ¼dego fragmentu stanu w systemie.\n\n### Wprowadzenie Signals\n\nAbstrakcje wiÄ…zania danych w UI miÄ™dzy modelem a widokiem od dawna sÄ… podstawÄ… frameworkÃ³w UI w rÃ³Å¼nych jÄ™zykach programowania, mimo braku takiego mechanizmu wbudowanego w JS czy platformÄ™ webowÄ…. W ramach frameworkÃ³w i bibliotek JS eksperymentowano z rÃ³Å¼nymi sposobami reprezentacji tego powiÄ…zania, a doÅ›wiadczenie pokazaÅ‚o siÅ‚Ä™ jednokierunkowego przepÅ‚ywu danych w poÅ‚Ä…czeniu z pierwszorzÄ™dnym typem danych reprezentujÄ…cym komÃ³rkÄ™ stanu lub obliczenie pochodne od innych danych, obecnie czÄ™sto nazywane â€Signalsâ€.\nTo podejÅ›cie z pierwszorzÄ™dnymi wartoÅ›ciami reaktywnymi po raz pierwszy pojawiÅ‚o siÄ™ w popularnych open-source'owych frameworkach JavaScript wraz z [Knockout](https://knockoutjs.com/) [w 2010 roku](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). Od tego czasu powstaÅ‚o wiele wariacji i implementacji. W ciÄ…gu ostatnich 3-4 lat prymityw Signal i pokrewne podejÅ›cia zyskaÅ‚y jeszcze wiÄ™kszÄ… popularnoÅ›Ä‡, a niemal kaÅ¼da nowoczesna biblioteka lub framework JavaScript ma coÅ› podobnego â€“ pod jednÄ… lub drugÄ… nazwÄ….\n\nAby zrozumieÄ‡ Signals, spÃ³jrzmy na powyÅ¼szy przykÅ‚ad, przeprojektowany z uÅ¼yciem API Signal opisanym poniÅ¼ej.\n\n#### PrzykÅ‚ad â€“ licznik z Signals\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// Biblioteka lub framework definiuje efekty bazujÄ…ce na innych prymitywach Signal\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Symulacja zewnÄ™trznych aktualizacji licznika...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nOd razu widaÄ‡ kilka rzeczy:\n* WyeliminowaliÅ›my rozbudowanÄ… powtarzalnoÅ›Ä‡ wokÃ³Å‚ zmiennej `counter` z poprzedniego przykÅ‚adu.\n* Jest jednolite API do obsÅ‚ugi wartoÅ›ci, obliczeÅ„ i efektÃ³w ubocznych.\n* Nie ma problemu z cyklicznymi referencjami ani odwrÃ³conymi zaleÅ¼noÅ›ciami pomiÄ™dzy `counter` a `render`.\n* Nie ma rÄ™cznych subskrypcji ani potrzeby prowadzenia ewidencji zaleÅ¼noÅ›ci.\n* Jest moÅ¼liwoÅ›Ä‡ kontrolowania czasu/schedulingu efektÃ³w ubocznych.\n\nSignals dajÄ… nam znacznie wiÄ™cej niÅ¼ to, co widaÄ‡ na powierzchni API:",
  "status": "ok"
}