{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Suivi automatique des dépendances** - Un Signal calculé découvre automatiquement tous les autres Signaux dont il dépend, que ces Signaux soient de simples valeurs ou d’autres calculs.\n* **Évaluation paresseuse** - Les calculs ne sont pas évalués de manière impatiente lors de leur déclaration, ni immédiatement lors d’un changement de leurs dépendances. Ils ne sont évalués que lorsque leur valeur est explicitement demandée.\n* **Mémorisation** - Les Signaux calculés mettent en cache leur dernière valeur afin que les calculs dont les dépendances n’ont pas changé n’aient pas besoin d’être réévalués, quel que soit le nombre d’accès.\n\n## Motivation pour la standardisation des Signaux\n\n#### Interopérabilité\n\nChaque implémentation de Signal possède son propre mécanisme d’auto-suivi pour garder trace des sources rencontrées lors de l’évaluation d’un Signal calculé. Cela rend difficile le partage de modèles, composants et bibliothèques entre différents frameworks — ils ont tendance à être faussement couplés à leur moteur de vue (étant donné que les Signaux sont généralement implémentés comme partie intégrante des frameworks JS).\n\nL’un des objectifs de cette proposition est de découpler complètement le modèle réactif de la vue de rendu, permettant ainsi aux développeurs de migrer vers de nouvelles technologies de rendu sans réécrire leur code non-UI, ou de développer des modèles réactifs partagés en JS à déployer dans différents contextes. Malheureusement, en raison du versionnage et de la duplication, il s’est avéré peu pratique d’atteindre un niveau élevé de partage via des bibliothèques JS — les objets natifs offrent une meilleure garantie de partage.\n\n#### Performance/Utilisation mémoire\n\nIl y a toujours un petit gain potentiel de performance à embarquer moins de code grâce à l’inclusion native de bibliothèques courantes, mais les implémentations de Signaux sont généralement assez petites, donc nous ne nous attendons pas à ce que cet effet soit très important.\n\nNous pensons que des implémentations natives en C++ des structures de données et algorithmes liés aux Signaux peuvent être légèrement plus efficaces que ce qu’il est possible d’atteindre en JS, d’un facteur constant. Cependant, aucun changement algorithmique n’est anticipé par rapport à ce qui serait présent dans un polyfill ; il n’est pas attendu que les moteurs fassent de la magie ici, et les algorithmes de réactivité eux-mêmes seront bien définis et non ambigus.\n\nLe groupe de pilotage prévoit de développer diverses implémentations de Signaux et d’utiliser celles-ci pour étudier ces possibilités de performance.\n\n#### Outils de développement (DevTools)\n\nAvec les bibliothèques de Signaux existantes en JS, il peut être difficile de tracer des éléments comme :\n* La pile d’appels à travers une chaîne de Signaux calculés, montrant la chaîne causale d’une erreur\n* Le graphe de références entre Signaux, lorsqu’un Signal dépend d’un autre — important lors du débogage de l’utilisation mémoire\n\nLes Signaux natifs permettent aux environnements JS et aux outils de développement d’avoir potentiellement un meilleur support pour l’inspection des Signaux, en particulier pour le débogage ou l’analyse de performances, que ce soit intégré aux navigateurs ou via une extension partagée. Les outils existants comme l’inspecteur d’éléments, les instantanés de performance et les profileurs mémoire pourraient être mis à jour pour mettre en évidence spécifiquement les Signaux lors de la présentation des informations.\n\n#### Bénéfices secondaires\n\n##### Bénéfices d’une bibliothèque standard\n\nDe manière générale, JavaScript dispose d’une bibliothèque standard assez minimale, mais une tendance au sein de TC39 est de faire évoluer JS vers un langage « tout compris », avec un ensemble de fonctionnalités intégrées et de haute qualité. Par exemple, Temporal remplace moment.js, et un certain nombre de petites fonctionnalités, comme `Array.prototype.flat` et `Object.groupBy`, remplacent beaucoup de cas d’usage de lodash. Les bénéfices incluent des tailles de bundle réduites, une stabilité et qualité améliorées, moins de choses à apprendre lors de l’arrivée sur un nouveau projet, et un vocabulaire généralement commun entre développeurs JS.\n\n##### Intégration HTML/DOM (possibilité future)\n\nDes travaux actuels au sein du W3C et des implémenteurs de navigateurs cherchent à apporter le templating natif à HTML ([DOM Parts][wicg-pr-1023] et [Template Instantiation][wicg-propsal-template-instantiation]). De plus, le W3C Web Components CG explore la possibilité d’étendre les Web Components pour offrir une API HTML entièrement déclarative. Pour atteindre ces deux objectifs, une primitive réactive sera finalement nécessaire en HTML. Par ailleurs, de nombreuses améliorations ergonomiques du DOM via l’intégration des Signaux peuvent être imaginées et ont été demandées par la communauté.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Remarque : cette intégration constituerait un effort séparé à venir, et ne fait pas partie de cette proposition.\n\n##### Échanges d’informations dans l’écosystème (*ce n’est pas* une raison de standardiser)\n\nLes efforts de standardisation peuvent parfois être utiles au niveau de la « communauté », même sans changement dans les navigateurs. L’initiative sur les Signaux réunit de nombreux auteurs de frameworks pour une discussion approfondie sur la nature de la réactivité, des algorithmes et de l’interopérabilité. Cela s’est déjà avéré utile, mais ne justifie pas l’inclusion dans les moteurs JS et navigateurs ; les Signaux ne devraient être ajoutés au standard JavaScript que s’il existe des avantages significatifs *au-delà* de l’échange d’informations permis dans l’écosystème.\n\n## Objectifs de conception pour les Signaux\n\nIl s’avère que les bibliothèques de Signaux existantes ne sont pas si différentes les unes des autres, au fond. Cette proposition vise à capitaliser sur leur succès en mettant en œuvre les qualités importantes de nombre de ces bibliothèques.\n\n### Fonctionnalités principales\n\n* Un type Signal qui représente un état, c’est-à-dire un Signal modifiable. C’est une valeur que d’autres peuvent lire.\n* Un type Signal calculé/mémo/dérivé, qui dépend d’autres et est calculé paresseusement et mis en cache.\n    * Le calcul est paresseux, ce qui signifie que les Signaux calculés ne sont pas recalculés par défaut lorsqu’une de leurs dépendances change, mais uniquement si quelqu’un les lit réellement.\n    * Le calcul est « sans glitch » ([glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)), ce qui signifie qu’aucun calcul inutile n’est jamais effectué. Cela implique que, lorsqu’une application lit un Signal calculé, il existe un tri topologique des parties potentiellement obsolètes du graphe à exécuter, pour éliminer les doublons.\n    * Le calcul est mis en cache, ce qui signifie que si, après le dernier changement de dépendance, aucune dépendance n’a changé, alors le Signal calculé *n’est pas* recalculé lors de l’accès.\n    * Des comparaisons personnalisées sont possibles pour les Signaux calculés ainsi que pour les Signaux d’état, afin de déterminer à quel moment d’autres Signaux calculés qui en dépendent doivent être mis à jour.\n* Réactions à la situation où un Signal calculé voit l’une de ses dépendances (ou dépendances imbriquées) devenir « sale » et changer, signifiant que la valeur du Signal pourrait être obsolète.\n    * Cette réaction vise à planifier un travail plus important à effectuer plus tard.\n    * Les effets sont implémentés en termes de ces réactions, plus une planification au niveau du framework.\n    * Les signaux calculés doivent pouvoir réagir au fait d’être enregistrés comme dépendance (imbriquée) d’une de ces réactions.\n* Permettre aux frameworks JS de gérer leur propre planification. Pas de planification forcée intégrée de type Promise.\n    * Des réactions synchrones sont nécessaires pour permettre la planification ultérieure de travaux selon la logique du framework.\n    * Les écritures sont synchrones et prennent effet immédiatement (un framework qui regroupe les écritures peut le faire par-dessus).\n    * Il est possible de séparer la vérification qu’un effet peut être « sale » de l’exécution effective de l’effet (permettant un ordonnanceur d’effets en deux étapes).\n* Possibilité de lire des Signaux *sans* déclencher l’enregistrement des dépendances (`untrack`)\n* Permettre la composition de différents bases de code utilisant les Signaux/la réactivité, par exemple,\n    * Utiliser plusieurs frameworks ensemble en ce qui concerne le suivi/la réactivité elle-même (modulo omissions, voir ci-dessous)\n    * Structures de données réactives indépendantes du framework (par exemple, proxy de store récursivement réactif, Map, Set et Array réactifs, etc.)\n\n### Solidité\n\n* Décourager/interdire une mauvaise utilisation naïve des réactions synchrones.\n    * Risque pour la solidité : cela peut exposer des « [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches) » si mal utilisé : si le rendu est effectué immédiatement lorsqu’un Signal est modifié, cela peut exposer un état d’application incomplet à l’utilisateur final. Ainsi, cette fonctionnalité doit uniquement servir à planifier intelligemment du travail pour plus tard, une fois la logique applicative terminée.\n    * Solution : Interdire la lecture et l’écriture de tout Signal depuis un rappel de réaction synchrone.\n* Décourager `untrack` et signaler sa nature non sûre\n    * Risque pour la solidité : permet la création de Signaux calculés dont la valeur dépend d’autres Signaux, mais qui ne sont pas mis à jour lorsque ces Signaux changent. Il doit être utilisé lorsque les accès non suivis ne changent pas le résultat du calcul.\n    * Solution : L’API porte la mention « unsafe » dans son nom.\n* Remarque : Cette proposition permet la lecture et l’écriture de signaux depuis des signaux calculés et d’effet, sans restreindre les écritures qui suivent des lectures, malgré le risque pour la solidité. Cette décision vise à préserver la flexibilité et la compatibilité lors de l’intégration avec des frameworks.\n\n### API de surface\n\n* Doit constituer une base solide pour que plusieurs frameworks implémentent leurs mécanismes de Signaux/réactivité.\n    * Doit être une bonne base pour les proxys de store récursifs, la réactivité des champs de classe basée sur des décorateurs, et les API de style `.value` ou `[state, setState]`.\n    * La sémantique doit permettre d’exprimer les modèles valides proposés par différents frameworks. Par exemple, il doit être possible que ces Signaux servent de base à des écritures immédiatement reflétées ou à des écritures regroupées et appliquées ultérieurement.\n* Il serait appréciable que cette API soit utilisable directement par les développeurs JavaScript.\n    * Si une fonctionnalité correspond à un concept de l’écosystème, utiliser un vocabulaire commun est souhaitable.\n        * Cependant, il est important de ne pas réutiliser exactement les mêmes noms !\n    * Tension entre « utilisabilité par les développeurs JS » et « fournir tous les points d’extension aux frameworks »\n        * Idée : Fournir tous les points d’extension, mais inclure des erreurs en cas de mauvaise utilisation si possible.\n        * Idée : Placer les API subtiles dans un espace de nommage `subtle`, similaire à [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), pour marquer la frontière entre les API nécessaires à un usage avancé (implémentation de framework ou outils de développement) et le développement applicatif courant (instanciation de signaux à utiliser avec un framework).\n* Être implémentable et utilisable avec de bonnes performances — l’API de surface ne doit pas entraîner trop de surcoût.\n    * Permettre l’héritage, afin que les frameworks puissent ajouter leurs propres méthodes et champs, y compris des champs privés. Cela est important pour éviter le besoin d’allocations supplémentaires au niveau du framework. Voir « Gestion mémoire » ci-dessous.\n\n### Gestion mémoire\n\n* Si possible : un Signal calculé devrait pouvoir être collecté par le ramasse-miettes si rien de vivant ne le référence pour de futures lectures, même s’il est lié à un graphe plus large qui reste vivant (par exemple en lisant un état qui reste vivant).",
  "status": "ok"
}