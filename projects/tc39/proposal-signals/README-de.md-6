{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "Der `state` eines Computed Signal kann einer der folgenden sein:\n\n- `~clean~`: Der Wert des Signals ist vorhanden und als nicht veraltet bekannt.\n- `~checked~`: Eine (indirekte) Quelle dieses Signals hat sich geändert; dieses Signal hat einen Wert, aber er _könnte_ veraltet sein. Ob er tatsächlich veraltet ist, wird erst bekannt, wenn alle unmittelbaren Quellen ausgewertet wurden.\n- `~computing~`: Der Callback dieses Signals wird derzeit als Nebeneffekt eines `.get()`-Aufrufs ausgeführt.\n- `~dirty~`: Entweder hat dieses Signal einen Wert, von dem bekannt ist, dass er veraltet ist, oder es wurde noch nie ausgewertet.\n\nDer Übergangsgraph ist wie folgt:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nDie Übergänge sind:\n| Nummer | Von | Nach | Bedingung | Algorithmus |\n| ------ | ---- | -- | --------- | ----------- |\n| 1 | `~checked~` | `~dirty~` | Eine unmittelbare Quelle dieses Signals, die ein berechnetes Signal ist, wurde ausgewertet und ihr Wert hat sich geändert. | Algorithmus: veraltetes berechnetes Signal neu berechnen |\n| 2 | `~clean~` | `~dirty~` | Eine unmittelbare Quelle dieses Signals, die ein State ist, wurde mit einem Wert gesetzt, der sich von ihrem vorherigen Wert unterscheidet. | Methode: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Eine rekursive, aber nicht unmittelbare Quelle dieses Signals, die ein State ist, wurde mit einem Wert gesetzt, der sich von ihrem vorherigen Wert unterscheidet. | Methode: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | Wir sind dabei, den `callback` auszuführen. | Algorithmus: veraltetes berechnetes Signal neu berechnen |\n| 5 | `~computing~` | `~clean~` | Der `callback` hat die Auswertung beendet und entweder einen Wert zurückgegeben oder eine Ausnahme ausgelöst. | Algorithmus: veraltetes berechnetes Signal neu berechnen |\n| 6 | `~checked~` | `~clean~` | Alle unmittelbaren Quellen dieses Signals wurden ausgewertet und es wurde festgestellt, dass sie unverändert sind, daher wissen wir jetzt, dass wir nicht veraltet sind. | Algorithmus: veraltetes berechnetes Signal neu berechnen |\n\n#### `Signal.Computed` Interne Slots\n\n- `value`: Der zuvor zwischengespeicherte Wert des Signals oder `~uninitialized~` für ein noch nie gelesenes berechnetes Signal. Der Wert kann eine Ausnahme sein, die beim Lesen des Werts erneut ausgelöst wird. Immer `undefined` für Effekt-Signale.\n- `state`: Kann `~clean~`, `~checked~`, `~computing~` oder `~dirty~` sein.\n- `sources`: Eine geordnete Menge von Signalen, von denen dieses Signal abhängt.\n- `sinks`: Eine geordnete Menge von Signalen, die von diesem Signal abhängen.\n- `equals`: Die in den Optionen bereitgestellte Vergleichsmethode.\n- `callback`: Der Callback, der aufgerufen wird, um den Wert des berechneten Signals zu erhalten. Wird auf den ersten an den Konstruktor übergebenen Parameter gesetzt.\n\n#### `Signal.Computed` Konstruktor\n\nDer Konstruktor setzt\n- `callback` auf seinen ersten Parameter\n- `equals` basierend auf den Optionen, standardmäßig auf `Object.is`, falls nicht vorhanden\n- `state` auf `~dirty~`\n- `value` auf `~uninitialized~`\n\nMit [AsyncContext](https://github.com/tc39/proposal-async-context) schließt der an `new Signal.Computed` übergebene Callback den Snapshot vom Zeitpunkt des Konstruktorausrufs ein und stellt diesen Snapshot während seiner Ausführung wieder her.\n\n#### Methode: `Signal.Computed.prototype.get`\n\n1. Falls der aktuelle Ausführungskontext `frozen` ist oder dieses Signal den Status `~computing~` hat, oder wenn dieses Signal ein Watcher ist und ein berechnetes Signal `computing` ist, eine Ausnahme auslösen.\n1. Falls `computing` nicht `null` ist, dieses Signal zum `sources`-Set von `computing` hinzufügen.\n1. HINWEIS: Wir fügen `computing` erst dann zum `sinks`-Set dieses Signals hinzu, wenn es von einem Watcher beobachtet wird.\n1. Falls der Status dieses Signals `~dirty~` oder `~checked~` ist: Wiederhole die folgenden Schritte, bis dieses Signal `~clean~` ist:\n    1. Rekursiv über `sources` nach oben gehen, um die tiefste, linkeste (d. h. am frühesten beobachtete) rekursive Quelle zu finden, die ein Computed Signal ist und als `~dirty~` markiert ist (die Suche wird abgebrochen, wenn ein `~clean~` Computed Signal erreicht wird, und dieses Computed Signal wird als Letztes durchsucht).\n    1. Den Algorithmus „veraltetes berechnetes Signal neu berechnen“ auf dieses Signal anwenden.\n1. Zu diesem Zeitpunkt ist der Status dieses Signals `~clean~` und keine rekursiven Quellen sind `~dirty~` oder `~checked~`. Gib den `value` des Signals zurück. Falls der Wert eine Ausnahme ist, löse diese Ausnahme erneut aus.\n\n### Die `Signal.subtle.Watcher` Klasse\n\n#### `Signal.subtle.Watcher` Zustandsautomat\n\nDer `state` eines Watchers kann einer der folgenden sein:\n\n- `~waiting~`: Der `notify`-Callback wurde ausgeführt, oder der Watcher ist neu, beobachtet aber derzeit keine Signale aktiv.\n- `~watching~`: Der Watcher beobachtet aktiv Signale, aber es gab noch keine Änderungen, die einen `notify`-Callback erfordern würden.\n- `~pending~`: Eine Abhängigkeit des Watchers hat sich geändert, aber der `notify`-Callback wurde noch nicht ausgeführt.\n\nDer Übergangsgraph ist wie folgt:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nDie Übergänge sind:\n| Nummer | Von | Nach | Bedingung | Algorithmus |\n| ------ | ---- | -- | --------- | ----------- |\n| 1 | `~waiting~` | `~watching~` | Die `watch`-Methode des Watchers wurde aufgerufen. | Methode: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | Die `unwatch`-Methode des Watchers wurde aufgerufen und das letzte beobachtete Signal wurde entfernt. | Methode: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Ein beobachtetes Signal könnte einen neuen Wert haben. | Methode: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | Der `notify`-Callback wurde ausgeführt. | Methode: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` interne Slots\n\n- `state`: Kann `~watching~`, `~pending~` oder `~waiting~` sein\n- `signals`: Eine geordnete Menge von Signalen, die dieser Watcher beobachtet\n- `notifyCallback`: Der Callback, der aufgerufen wird, wenn sich etwas ändert. Wird auf den ersten an den Konstruktor übergebenen Parameter gesetzt.\n\n#### Konstruktor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` wird auf `~waiting~` gesetzt.\n1. Initialisiere `signals` als leere Menge.\n1. `notifyCallback` wird auf den Callback-Parameter gesetzt.",
  "status": "ok"
}