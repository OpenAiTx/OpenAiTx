{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* Notez que la plupart des frameworks actuels nécessitent une suppression explicite des Signaux calculés s'ils ont une référence vers ou depuis un autre graphe de Signaux qui reste vivant.\n* Cela n'est finalement pas si problématique lorsque leur durée de vie est liée à celle d'un composant UI, et que les effets doivent de toute façon être supprimés.\n* Si l'exécution avec ces sémantiques est trop coûteuse, alors nous devrions ajouter la suppression explicite (ou le \"déliaisonnement\") des Signaux calculés à l'API ci-dessous, qui en est actuellement dépourvue.\n* Un objectif connexe : Minimiser le nombre d'allocations, par exemple :\n    * pour créer un Signal modifiable (éviter deux closures séparées + un tableau)\n    * pour implémenter des effets (éviter une closure pour chaque réaction)\n    * Dans l'API d'observation des changements de Signal, éviter de créer des structures de données temporaires supplémentaires\n    * Solution : API basée sur des classes permettant la réutilisation de méthodes et de champs définis dans les sous-classes\n\n## Ébauche d’API\n\nVoici une première idée d'une API de Signal. Notez qu'il ne s'agit que d'une ébauche préliminaire, et nous prévoyons des modifications au fil du temps. Commençons par le `.d.ts` complet pour avoir une idée de la structure générale, puis nous discuterons des détails de ce que cela signifie.\n\n```ts\ninterface Signal<T> {\n    // Obtenir la valeur du signal\n    get(): T;\n}\n\nnamespace Signal {\n    // Un Signal en lecture-écriture\n    class State<T> implements Signal<T> {\n        // Créer un Signal d'état initialisé avec la valeur t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Obtenir la valeur du signal\n        get(): T;\n\n        // Définir la valeur du Signal d'état à t\n        set(t: T): void;\n    }\n\n    // Un Signal qui est une formule basée sur d'autres Signaux\n    class Computed<T = unknown> implements Signal<T> {\n        // Créer un Signal qui s'évalue à la valeur retournée par le callback.\n        // Le callback est appelé avec ce signal comme valeur de this.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Obtenir la valeur du signal\n        get(): T;\n    }\n\n    // Cet espace de noms inclut des fonctionnalités \"avancées\" qu’il vaut mieux\n    // laisser aux auteurs de frameworks plutôt qu’aux développeurs d’applications.\n    // Analogue à `crypto.subtle`\n    namespace subtle {\n        // Exécuter un callback avec tout le suivi désactivé\n        function untrack<T>(cb: () => T): T;\n\n        // Obtenir le signal calculé courant qui suit toutes les lectures de signal, si existant\n        function currentComputed(): Computed | null;\n\n        // Retourne la liste ordonnée de tous les signaux référencés par celui-ci\n        // lors de sa dernière évaluation.\n        // Pour un Watcher, liste l’ensemble des signaux surveillés.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Retourne les Watchers auxquels ce signal appartient, ainsi que tous les\n        // signaux Computed qui ont lu ce signal lors de leur dernière évaluation,\n        // si ce signal calculé est (récursivement) surveillé.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // Vrai si ce signal est \"vivant\", c’est-à-dire qu’il est surveillé par un Watcher,\n        // ou qu’il est lu par un signal Computed qui est (récursivement) vivant.\n        function hasSinks(s: State | Computed): boolean;\n\n        // Vrai si cet élément est \"réactif\", c’est-à-dire qu’il dépend\n        // d’un autre signal. Un Computed où hasSources est faux\n        // renverra toujours la même constante.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // Lorsqu'une source (récursive) du Watcher est modifiée, appeler ce callback,\n            // s’il n’a pas déjà été appelé depuis le dernier appel à `watch`.\n            // Aucun signal ne peut être lu ou modifié pendant la notification.\n            constructor(notify: (this: Watcher) => void);\n\n            // Ajouter ces signaux à l’ensemble surveillé du Watcher, et configurer le watcher pour exécuter son\n            // callback notify lors du prochain changement de l’un des signaux de l’ensemble (ou de l’une de ses dépendances).\n            // Peut être appelé sans arguments uniquement pour réinitialiser l’état \"notifié\", afin que\n            // le callback notify soit de nouveau invoqué.\n            watch(...s: Signal[]): void;\n\n            // Retirer ces signaux de l’ensemble surveillé (par exemple, pour un effet qui est supprimé)\n            unwatch(...s: Signal[]): void;\n\n            // Retourne l’ensemble des sources dans l’ensemble surveillé du Watcher qui sont encore sales, ou un signal computed\n            // avec une source sale ou en attente et qui n’a pas encore été réévalué\n            getPending(): Signal[];\n        }\n\n        // Hooks pour observer quand un signal est surveillé ou ne l’est plus\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Fonction de comparaison personnalisée entre l’ancienne et la nouvelle valeur. Par défaut : Object.is.\n        // Le signal est passé en tant que valeur this pour le contexte.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}