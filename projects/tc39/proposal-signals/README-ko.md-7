{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "[AsyncContext](https://github.com/tc39/proposal-async-context)와 함께, `new Signal.subtle.Watcher`에 전달된 콜백은 생성자가 호출될 때의 스냅샷을 클로저로 갖지 *않으므로*, 기록 시점의 컨텍스트 정보가 보이게 됩니다.\n\n#### 메서드: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. `frozen`이 true이면 예외를 throw합니다.\n1. 인수 중 하나라도 시그널이 아니면 예외를 throw합니다.\n1. 모든 인수를 이 객체의 `signals` 끝에 추가합니다.\n1. 새로 감시하게 된 각 시그널에 대해, 좌에서 우로 순서대로,\n    1. 해당 시그널에 이 watcher를 `sink`로 추가합니다.\n    1. 이것이 첫 번째 sink였다면, 소스로 재귀적으로 올라가 해당 시그널을 sink로 추가합니다.\n    1. `frozen`을 true로 설정합니다.\n    1. `watched` 콜백이 존재하면 호출합니다.\n    1. `frozen`을 false로 복원합니다.\n1. 시그널의 `state`가 `~waiting~`이면, `~watching~`으로 설정합니다.\n\n#### 메서드: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. `frozen`이 true이면 예외를 throw합니다.\n1. 인수 중 하나라도 시그널이 아니거나, 이 watcher가 감시하지 않는 시그널이면 예외를 throw합니다.\n1. 인수에 있는 각 시그널에 대해, 좌에서 우로 순서대로,\n    1. 해당 시그널을 이 Watcher의 `signals` 집합에서 제거합니다.\n    1. 이 Watcher를 해당 시그널의 `sink` 집합에서 제거합니다.\n    1. 해당 시그널의 `sink` 집합이 비게 되면, 각 소스에서 해당 시그널을 sink로 제거합니다.\n    1. `frozen`을 true로 설정합니다.\n    1. `unwatched` 콜백이 존재하면 호출합니다.\n    1. `frozen`을 false로 복원합니다.\n1. 이제 watcher가 더 이상 `signals`을 갖지 않고, 그 `state`가 `~watching~`이면 `~waiting~`으로 설정합니다.\n\n#### 메서드: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. `signals` 중 상태가 `~dirty~` 또는 `~pending~`인 Computed Signal의 부분집합을 포함하는 Array를 반환합니다.\n\n### 메서드: `Signal.subtle.untrack(cb)`\n\n1. `c`를 실행 컨텍스트의 현재 `computing` 상태로 둡니다.\n1. `computing`을 null로 설정합니다.\n1. `cb`를 호출합니다.\n1. `computing`을 `c`로 복원합니다 (설령 `cb`가 예외를 throw해도).\n1. `cb`의 반환값을 반환합니다 (예외가 발생하면 재throw).\n\n참고: untrack은 엄격하게 유지되는 `frozen` 상태를 해제하지 않습니다.\n\n### 메서드: `Signal.subtle.currentComputed()`\n\n1. 현재의 `computing` 값을 반환합니다.\n\n### 공통 알고리즘\n\n##### 알고리즘: dirty 상태의 computed Signal 재계산\n\n1. 이 시그널의 `sources` 집합을 비우고, 해당 소스들의 `sinks` 집합에서 이 시그널을 제거합니다.\n1. 이전 `computing` 값을 저장하고, `computing`을 이 시그널로 설정합니다.\n1. 이 시그널의 상태를 `~computing~`으로 설정합니다.\n1. 이 computed Signal의 콜백을, this 값을 이 시그널로 하여 실행합니다. 반환값을 저장하고, 콜백이 예외를 throw하면 이를 재throw용으로 저장합니다.\n1. 이전의 `computing` 값을 복원합니다.\n1. 콜백의 반환값에 \"set Signal value\" 알고리즘을 적용합니다.\n2. 이 시그널의 상태를 `~clean~`으로 설정합니다.\n1. 만약 해당 알고리즘이 `~dirty~`를 반환했다면: 이 시그널의 모든 sink를 `~dirty~`로 표시합니다 (이전에는 sink들이 checked와 dirty가 혼재했을 수 있습니다). (또는, 이 시그널이 감시되지 않는 경우, generation number를 새로 할당하여 dirty임을 나타내는 등.)\n1. 그렇지 않고 해당 알고리즘이 `~clean~`을 반환했다면: 이 경우, 이 시그널의 각 `~checked~` sink에 대해, 그 시그널의 모든 소스가 이제 clean이면, 그 시그널도 `~clean~`으로 표시합니다. 이 정리 단계는 checked sink가 있는, 새로 clean 상태가 된 시그널에 대해 재귀적으로 적용합니다. (또는, 감시되지 않는 경우에도 동일하게 표시하여, cleanup이 lazy하게 진행될 수 있게 합니다.)\n\n##### Set Signal value 알고리즘\n\n1. 이 알고리즘이 값(계산된 dirty computed Signal 알고리즘에서 재throw용 예외가 아닌)을 전달받은 경우:\n    1. 이 시그널의 `equals` 함수를 호출하여, 현재 `value`, 새 값, 이 시그널을 인자로 전달합니다. 예외가 throw되면 그 예외를 (read 시 재throw할 값으로) 시그널의 value로 저장하고, 콜백이 false를 반환한 것처럼 계속 진행합니다.\n    1. 해당 함수가 true를 반환했다면, `~clean~`을 반환합니다.\n1. 이 시그널의 `value`를 전달받은 값으로 설정합니다.\n1. `~dirty~`를 반환합니다.\n\n## FAQ\n\n**Q**: 시그널이 2022년에야 본격적으로 주목받기 시작했는데, 지금 표준화하는 건 너무 이른 것 아닌가요? 더 진화하고 안정화될 시간을 줘야 하지 않을까요?\n\n**A**: 웹 프레임워크에서의 시그널의 현재 상태는 10년이 넘는 지속적인 개발의 결과입니다. 최근 몇 년간 투자가 확대되면서, 거의 모든 웹 프레임워크가 매우 유사한 시그널의 핵심 모델에 접근하고 있습니다. 이 제안은 다수의 주요 웹 프레임워크 리더들이 참여한 공동 설계의 결과이며, 다양한 맥락의 도메인 전문가 그룹의 검증 없이 표준화가 추진되지 않을 것입니다.\n\n#### 시그널은 어떻게 사용되나요?\n\n**Q**: 내장 시그널이 렌더링이나 소유권과 긴밀하게 통합되어 있는데, 프레임워크에서 실제로 사용할 수 있나요?\n\n**A**: 프레임워크별로 더 특화된 부분은 이 제안이 해결하려 하지 않는 effect, 스케줄링, 소유권/폐기에 있습니다. 표준화 경로의 시그널을 프로토타이핑할 때의 1차 목표는, 기존 프레임워크 \"아래\"에서 호환성과 성능을 갖고 동작할 수 있음을 검증하는 것입니다.\n\n**Q**: Signal API는 애플리케이션 개발자가 직접 사용하는 것인가요, 아니면 프레임워크에서 래핑해서 써야 하나요?\n\n**A**: 이 API는 (최소한 `Signal.subtle` 네임스페이스 밖의 부분은) 애플리케이션 개발자가 직접 사용할 수도 있지만, 특별히 사용성이 좋게 설계된 것은 아닙니다. 라이브러리/프레임워크 저자의 요구가 우선시됩니다. 대부분의 프레임워크는 기본적인 `Signal.State`와 `Signal.Computed` API조차 그들만의 사용성에 맞게 감쌀 것으로 예상됩니다. 실제로는, 프레임워크를 통해 시그널을 사용하는 것이 일반적으로 더 좋으며, 프레임워크가 Watcher, `untrack`과 같은 복잡한 기능과, 소유권 및 폐기(예: 언제 시그널을 watcher에 추가/제거할지 결정), DOM 렌더링 스케줄링 등을 처리합니다. 이 제안은 그러한 문제를 해결하려 하지 않습니다.\n\n**Q**: 위젯이 파괴될 때 관련 시그널도 반드시 해제해야 하나요? 그 API는 무엇인가요?\n\n**A**: 관련 해제 작업은 `Signal.subtle.Watcher.prototype.unwatch`입니다. 감시 중인 시그널만 unwatch로 정리해주면 되고, 감시 중이지 않은 시그널은 자동으로 가비지 컬렉션될 수 있습니다.\n\n**Q**: 시그널은 VDOM이나, 원래의 HTML DOM과 직접 동작하나요?\n\n**A**: 네! 시그널은 렌더링 기술에 독립적입니다. Signal 유사 구조를 사용하는 기존 JavaScript 프레임워크는 VDOM(예: Preact), 네이티브 DOM(예: Solid), 그리고 혼합(예: Vue)과 연동됩니다. 내장 시그널로도 동일하게 가능합니다.\n\n**Q**: Angular, Lit 같은 클래스 기반 프레임워크에서도 시그널을 사용하기 편할까요? Svelte 같은 컴파일러 기반 프레임워크는 어떤가요?\n\n**A**: [Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators)에서 보듯이, 클래스 필드를 간단한 접근자 데코레이터로 Signal 기반으로 만들 수 있습니다. 시그널은 Svelte 5의 Runes와 매우 밀접하게 연관되어 있습니다. 컴파일러가 rune을 여기서 정의된 Signal API로 변환하는 것은 간단하며, 실제로 Svelte 5는 내부적으로(자체 시그널 라이브러리와 함께) 이렇게 동작합니다.\n\n**Q**: 시그널은 SSR(서버 사이드 렌더링), 하이드레이션, 리주머빌리티(resumability)에 대응하나요?\n\n**A**: 네. Qwik은 이 두 가지 특성과 함께 시그널을 효과적으로 사용하고 있고, 다른 프레임워크들도 시그널을 활용한 하이드레이션에 대해 다양한 트레이드오프를 가진 방식들을 잘 개발해왔습니다. Qwik의 resume 가능한 시그널을 State와 Computed 시그널을 연결하여 모델링할 수 있다고 보고, 이를 코드로 입증할 계획입니다.",
  "status": "ok"
}