{
  "id": 1,
  "origin": "# 🚦 JavaScript Signals standard proposal🚦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and more…\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# 🚦 JavaScript Signals 标准提案 🚦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\n第一阶段（[说明](https://tc39.es/process-document/)）\n\nTC39 提案发起人：Daniel Ehrenberg、Yehuda Katz、Jatin Ramanathan、Shay Lewis、Kristen Hewell Garrett、Dominic Gannaway、Preston Sego、Milo M、Rob Eisenberg\n\n原作者：Rob Eisenberg 和 Daniel Ehrenberg\n\n本文档描述了 JavaScript 中 Signals 的早期通用方向，类似于 Promises/A+ 的努力，后者在 TC39 于 ES2015 标准化 Promises 之前已经存在。你可以通过使用 [polyfill](https://github.com/proposal-signals/signal-polyfill) 亲自试用。\n\n类似于 Promises/A+，本努力专注于使 JavaScript 生态系统保持一致。如果这种一致取得成功，那么基于该经验可能会出现一个标准。多位框架作者正在此协作，共同制定可作为其响应式核心支撑的通用模型。目前的草案基于 [Angular](https://angular.io/)、[Bubble](https://bubble.io/)、[Ember](https://emberjs.com/)、[FAST](https://www.fast.design/)、[MobX](https://mobx.js.org/)、[Preact](https://preactjs.com/)、[Qwik](https://qwik.dev/)、[RxJS](https://rxjs.dev/)、[Solid](https://www.solidjs.com/)、[Starbeam](https://www.starbeamjs.com/)、[Svelte](https://svelte.dev/)、[Vue](https://vuejs.org/)、[Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a) 等作者/维护者的设计输入。\n\n与 Promises/A+ 不同，我们并不试图为开发者提供统一的表层 API，而是专注于底层信号图（signal graph）的精确核心语义。该提案确实包含了完整具体的 API，但该 API 并非面向大多数应用开发者。相反，这里的 signal API 更适合框架在其基础上构建，通过通用信号图和自动追踪机制实现互操作性。\n\n本提案的计划是在推进到第一阶段之后，进行大量早期原型开发，包括集成到多个框架中。我们只会在 Signals 能够在多个框架实际使用且相较于框架自带的信号机制有真正优势的情况下，才考虑将其标准化。我们希望通过大量早期原型开发获得这些信息。详情见下文“状态与开发计划”。\n\n## 背景：为什么需要 Signals？\n\n为开发复杂的用户界面（UI），JavaScript 应用开发者需要高效地存储、计算、失效、同步并推送状态到应用的视图层。UI 通常不仅仅涉及简单值的管理，更多情况下还需要渲染依赖于其他值或状态的复杂计算状态，而这些状态本身也可能是计算得出的。Signals 的目标是为管理这类应用状态提供基础设施，使开发者能专注于业务逻辑，而不是这些重复琐碎的细节。\n\n类似信号的结构在非 UI 场景中也被证明非常有用，特别是在构建系统中用于避免不必要的重构。\n\nSignals 在响应式编程中用来消除在应用程序中手动管理更新的需求。\n\n> 一种基于状态变化进行更新的声明式编程模型。\n\n摘自 _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_。\n\n#### 示例 - 原生 JS 计数器\n\n假设有一个变量 `counter`，你希望渲染到 DOM 中显示该计数器是偶数还是奇数。每当 `counter` 发生变化时，你都想用最新的奇偶性更新 DOM。在原生 JS 中，你可能会这样写：\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// 模拟 counter 的外部更新...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> 这里为演示目的使用了全局变量。正确的状态管理有很多方案，本提案中的示例尽量保持最小化。该提案并不鼓励使用全局变量。\n\n这有很多问题……\n\n* `counter` 的设置很冗长且模板化严重。\n* `counter` 状态与渲染系统紧密耦合。\n* 如果 `counter` 变化但 `parity` 不变（如从 2 变为 4），则我们会不必要地计算奇偶性并重复渲染。\n* 如果 UI 的另一个部分只关心 `counter` 更新怎么办？\n* 如果 UI 的另一个部分只依赖于 `isEven` 或 `parity` 怎么办？\n\n即使在这个相对简单的场景下，也会很快出现许多问题。我们可以尝试通过为 `counter` 引入发布/订阅（pub/sub）机制来规避这些问题，这样 `counter` 的其他消费者就可以订阅并添加自己的状态变更反应。\n\n然而，我们仍然会遇到以下问题：\n\n* 渲染函数实际上只依赖于 `parity`，但却必须“知道”需要订阅 `counter`。\n* 不能仅根据 `isEven` 或 `parity` 更新 UI，而必须直接与 `counter` 交互。\n* 模板代码增多。每次使用变量时，不仅仅是调用函数或读取变量，还要订阅并在那处理更新。取消订阅的管理也尤其复杂。\n\n现在，我们可以通过不仅为 `counter`，还为 `isEven` 和 `parity` 添加发布/订阅机制来解决部分问题。这样就需要将 `isEven` 订阅到 `counter`，`parity` 订阅到 `isEven`，`render` 订阅到 `parity`。不幸的是，我们的模板代码激增，还要管理大量的订阅关系。如果没有正确清理，极易造成内存泄漏灾难。因此，虽然解决了一些问题，却又带来了全新的问题类别和大量代码。更糟糕的是，这一过程要对系统中的每个状态都重复一遍。\n\n### 引入 Signals\n\n在 UI 中，模型与视图间的数据绑定抽象长期以来都是多种编程语言 UI 框架的核心，尽管 JS 或 Web 平台本身没有内建这种机制。在 JS 框架和库中，围绕如何表示这种绑定有大量的探索实践，经验表明，结合一等数据类型（代表状态单元或由其他数据派生的计算单元）的一元数据流动非常强大，这类类型现今通常被称为“Signals”。\n这种一等响应式值的方式，似乎最早在开源 JavaScript Web 框架中由 [Knockout](https://knockoutjs.com/) [于 2010 年](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/) 引入。此后几年，出现了许多变种与实现。在过去的三到四年里，Signal 原语及相关方法进一步流行，几乎所有现代 JavaScript 库或框架都拥有类似机制（名称各异）。\n\n为理解 Signals，让我们用下面即将详述的 Signal API，重新构想上面的例子。\n\n#### 示例 - Signals 计数器\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// 库或框架基于其他 Signal 原语定义副作用\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// 模拟 counter 的外部更新...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\n我们可以立刻看到几点优势：\n* 我们消除了前例中 `counter` 变量周围的冗余模板代码。\n* 有一个统一的 API 处理值、计算和副作用。\n* 不存在 `counter` 与 `render` 间的循环引用或颠倒依赖关系问题。\n* 无需手动订阅，也无需记录管理。\n* 可以控制副作用的时机/调度。\n\n不过，Signals 带来的优势远不止 API 表面看到的这些：",
  "status": "ok"
}