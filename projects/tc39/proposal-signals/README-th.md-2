{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **การติดตามการพึ่งพาโดยอัตโนมัติ** - Signal ที่คำนวณได้จะค้นหา Signal อื่นๆ ที่มันขึ้นอยู่โดยอัตโนมัติ ไม่ว่า Signal เหล่านั้นจะเป็นค่าธรรมดาหรือการคำนวณอื่นๆ\n* **การประเมินค่าแบบ Lazy** - การคำนวณจะไม่ถูกประเมินทันทีเมื่อถูกประกาศ และจะไม่ถูกประเมินในทันทีเมื่อการพึ่งพาของมันเปลี่ยนแปลง จะมีการประเมินค่าเมื่อมีการร้องขอค่าของมันโดยชัดเจนเท่านั้น\n* **การจดจำผลลัพธ์ (Memoization)** - Signal ที่คำนวณได้จะเก็บค่าล่าสุดไว้ ดังนั้นการคำนวณที่ไม่มีการเปลี่ยนแปลงในการพึ่งพาจะไม่ต้องถูกประเมินซ้ำอีก ไม่ว่าจะถูกเข้าถึงกี่ครั้งก็ตาม\n\n## แรงจูงใจในการสร้างมาตรฐาน Signals\n\n#### การทำงานร่วมกัน (Interoperability)\n\nแต่ละการใช้งาน Signal จะมีกลไกการติดตามอัตโนมัติของตัวเอง เพื่อใช้ติดตามแหล่งข้อมูลที่พบเจอเมื่อประเมิน Signal ที่คำนวณได้ สิ่งนี้ทำให้ยากต่อการแบ่งปันโมเดล คอมโพเนนต์ และไลบรารีระหว่างเฟรมเวิร์กต่างๆ—มักจะมีการผูกติดกับ view engine โดยไม่จำเป็น (เนื่องจาก Signal มักถูกใช้งานเป็นส่วนหนึ่งของ JS framework)\n\nเป้าหมายหนึ่งของข้อเสนอนี้คือการแยกโมเดล reactive ออกจาก view rendering อย่างสมบูรณ์ เพื่อให้ผู้พัฒนาสามารถย้ายไปยังเทคโนโลยี rendering ใหม่ๆ ได้โดยไม่ต้องเขียนโค้ด non-UI ใหม่ทั้งหมด หรือสามารถพัฒนาโมเดล reactive ที่ใช้ร่วมกันใน JS เพื่อนำไปใช้งานในบริบทต่างๆ ได้ อย่างไรก็ตาม เนื่องจากปัญหาเวอร์ชันและการซ้ำซ้อน จึงไม่สามารถแบ่งปันในระดับที่เข้มแข็งผ่านไลบรารี JS ได้—built-ins จะให้หลักประกันการใช้งานร่วมกันที่แข็งแรงกว่า\n\n#### ประสิทธิภาพ/การใช้หน่วยความจำ\n\nโดยปกติแล้วจะมีโอกาสเพิ่มประสิทธิภาพเล็กน้อยเมื่อส่งโค้ดน้อยลง เพราะไลบรารีที่ใช้กันทั่วไปถูกรวมเป็น built-in แต่โดยทั่วไปการใช้งาน Signal มักจะมีขนาดเล็กมาก ดังนั้นเราจึงไม่คาดหวังว่าผลนี้จะมีนัยสำคัญมากนัก\n\nเราคาดว่า การใช้งาน Signal และอัลกอริทึมที่เกี่ยวข้องด้วยภาษา C++ แบบ native อาจมีประสิทธิภาพมากกว่าที่ทำได้ใน JS อยู่บ้างในระดับค่าคงที่ อย่างไรก็ตาม จะไม่มีการเปลี่ยนแปลงอัลกอริทึมเมื่อเทียบกับ polyfill ที่มีอยู่ เอ็นจินไม่ได้คาดหวังว่าจะมีเวทมนตร์ และอัลกอริทึม reactivity เองจะถูกกำหนดไว้อย่างชัดเจนและไม่มีความกำกวม\n\nกลุ่มผู้นำขับเคลื่อนข้อเสนอนี้คาดว่าจะพัฒนาการใช้งาน Signal แบบต่างๆ และใช้สิ่งเหล่านี้เพื่อตรวจสอบความเป็นไปได้ด้านประสิทธิภาพ\n\n#### DevTools\n\nสำหรับไลบรารี Signal ที่เป็นภาษา JS ในปัจจุบัน อาจยากที่จะติดตามสิ่งต่างๆ เช่น:\n* สแต็กของการเรียกผ่านชุด chain ของ Signal ที่คำนวณได้ เพื่อแสดงสายเหตุของข้อผิดพลาด\n* กราฟอ้างอิงระหว่าง Signal เมื่อหนึ่งอันขึ้นอยู่กับอีกอัน—สำคัญมากเมื่อ debug การใช้หน่วยความจำ\n\nSignal ที่เป็น built-in จะช่วยให้ JS runtime และ DevTools มีความสามารถในการตรวจสอบ Signal ได้ดีขึ้น โดยเฉพาะสำหรับการ debug หรือวิเคราะห์ประสิทธิภาพ ไม่ว่าจะถูกสร้างไว้ในเบราว์เซอร์หรือผ่านส่วนขยายร่วมกัน เครื่องมือที่มีอยู่เช่น element inspector, performance snapshot และ memory profiler สามารถอัปเดตให้เน้น Signal โดยเฉพาะในหน้าข้อมูล\n\n#### ผลประโยชน์รอง\n\n##### ข้อดีของไลบรารีมาตรฐาน\n\nโดยทั่วไป JavaScript มีไลบรารีมาตรฐานที่ค่อนข้างน้อย แต่แนวโน้มของ TC39 คือการทำให้ JS เป็นภาษา “มีแบตเตอรี่ให้ในตัว” ที่มีฟังก์ชันคุณภาพสูงพร้อมใช้งาน ตัวอย่างเช่น Temporal แทนที่ moment.js และฟีเจอร์ย่อยๆ หลายอย่างเช่น `Array.prototype.flat` และ `Object.groupBy` ก็มาแทนที่การใช้งาน lodash หลายกรณี ข้อดีคือ bundle ขนาดเล็กลง ความเสถียรและคุณภาพดีขึ้น เรียนรู้น้อยลงเมื่อต้องเข้าร่วมโปรเจกต์ใหม่ และมีศัพท์กลางที่ใช้ร่วมกันระหว่างนักพัฒนา JS\n\n##### การบูรณาการ HTML/DOM (เป็นไปได้ในอนาคต)\n\nงานปัจจุบันใน W3C และผู้พัฒนาเบราว์เซอร์กำลังพยายามนำระบบ templating แบบ native มาสู่ HTML ([DOM Parts][wicg-pr-1023] และ [Template Instantiation][wicg-propsal-template-instantiation]) นอกจากนี้ W3C Web Components CG กำลังสำรวจความเป็นไปได้ในการขยาย Web Components เพื่อเสนอตัว API HTML แบบประกาศอย่างสมบูรณ์ เพื่อบรรลุเป้าหมายทั้งสองนี้ ในที่สุด HTML จะต้องมี primitive แบบ reactive นอกจากนี้ ยังมีการร้องขอจากชุมชนและสามารถจินตนาการถึงการปรับปรุง DOM ให้ใช้งานง่ายขึ้นด้วยการบูรณาการ Signal\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> หมายเหตุ การบูรณาการนี้จะเป็นงานแยกออกไปในอนาคต ไม่ใช่ส่วนหนึ่งของข้อเสนอนี้\n\n##### การแลกเปลี่ยนข้อมูลในระบบนิเวศ (*ไม่ใช่* เหตุผลที่ควรจัดส่ง)\n\nการสร้างมาตรฐานสามารถเป็นประโยชน์ในระดับ “ชุมชน” แม้จะไม่มีการเปลี่ยนแปลงในเบราว์เซอร์ ความพยายามเกี่ยวกับ Signals นี้นำผู้พัฒนา framework หลายรายมาหารือกันอย่างลึกซึ้งเกี่ยวกับธรรมชาติของ reactivity อัลกอริทึม และการทำงานร่วมกัน สิ่งนี้เป็นประโยชน์แล้ว แต่ไม่ใช่เหตุผลเพียงพอที่จะนำ Signals ไปใส่ใน JS engine หรือเบราว์เซอร์; ควรเพิ่ม Signal ในมาตรฐาน JavaScript ก็ต่อเมื่อมีประโยชน์อย่างมีนัยสำคัญ *เกินกว่า* การแลกเปลี่ยนข้อมูลในระบบนิเวศที่เกิดขึ้น\n\n## เป้าหมายการออกแบบสำหรับ Signals\n\nปรากฏว่าห้องสมุด Signal ที่มีอยู่ในปัจจุบันไม่ได้แตกต่างกันมากนักในแก่นของมัน ข้อเสนอนี้ต้องการต่อยอดจากความสำเร็จเหล่านั้นด้วยการนำคุณสมบัติสำคัญของไลบรารีเหล่านี้มาใช้\n\n### คุณลักษณะหลัก\n\n* ประเภท Signal ที่เป็นสถานะ (state) หรือ Signal ที่เขียนค่าได้ เป็นค่าที่ผู้อื่นสามารถอ่านได้\n* ประเภท Signal ที่คำนวณ/จดจำ/อนุพันธ์ ซึ่งขึ้นอยู่กับ Signal อื่นและคำนวณแบบ lazy และมีการเก็บ cache\n    * การคำนวณเป็นแบบ lazy หมายถึง Signal ที่คำนวณไม่ได้คำนวณใหม่โดยอัตโนมัติเมื่อมีการเปลี่ยนแปลงของ dependency แต่จะคำนวณเมื่อมีผู้เรียกอ่านเท่านั้น\n    * การคำนวณ \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\" หมายถึงไม่มีการคำนวณที่ไม่จำเป็นเกิดขึ้นเลย สิ่งนี้หมายความว่า เมื่อแอปพลิเคชันอ่าน Signal ที่คำนวณ จะมีการเรียงลำดับ topological ส่วนที่อาจ dirty ของกราฟเพื่อรันและกำจัดข้อมูลซ้ำ\n    * มี cache ในการคำนวณ หมายความว่าถ้าหลังจาก dependency เปลี่ยนครั้งล่าสุด ไม่มี dependency ใดเปลี่ยนอีก Signal ที่คำนวณจะ *ไม่* คำนวณใหม่เมื่อถูกเข้าถึง\n    * สามารถเปรียบเทียบแบบกำหนดเองได้ทั้งกับ Signal ที่คำนวณและ Signal สถานะ เพื่อตรวจสอบว่า Signal ที่คำนวณอื่นที่ขึ้นอยู่กับมันควรอัปเดตหรือไม่\n* ปฏิกิริยาต่อเงื่อนไขที่ Signal ที่คำนวณมี dependency (หรือ dependency ซ้อน) ที่กลายเป็น “dirty” และเปลี่ยนแปลง หมายความว่าค่า Signal อาจล้าสมัย\n    * ปฏิกิริยานี้มีไว้เพื่อจัดตารางงานที่สำคัญขึ้นในภายหลัง\n    * Effects จะถูกสร้างขึ้นจากปฏิกิริยาเหล่านี้ พร้อมกับการจัดตารางงานในระดับ framework\n    * Signal ที่คำนวณต้องสามารถตอบสนองต่อการถูกลงทะเบียนเป็น dependency (ซ้อน) ของปฏิกิริยาเหล่านี้\n* ให้ framework JS สามารถจัดตารางงานเองได้ ไม่มี built-in แบบ Promise ที่บังคับให้ต้องจัดตารางงาน\n    * ต้องมีปฏิกิริยาแบบ synchronous เพื่อจัดตารางงานในภายหลังตามตรรกะของ framework\n    * การเขียนเป็น synchronous และมีผลทันที (framework ที่ต้อง batch การเขียนสามารถทำเองเพิ่มเติม)\n    * สามารถแยกการตรวจสอบว่า effect อาจ “dirty” ออกจากการรัน effect จริง (ทำให้สามารถสร้าง scheduler แบบ 2 ขั้นตอนได้)\n* สามารถอ่าน Signal *โดยไม่* ทำให้เกิดการบันทึก dependency (`untrack`)\n* สามารถประกอบโค้ดที่ใช้ Signal/reactivity จากหลาย codebase ได้ เช่น\n    * ใช้ framework หลายตัวร่วมกันในแง่ของ tracking/reactivity (ยกเว้นข้อจำกัดที่กล่าวไว้ด้านล่าง)\n    * โครงสร้างข้อมูล reactive ที่ framework-independent (เช่น store proxy แบบ recursive, reactive Map, Set, Array ฯลฯ)\n\n### ความถูกต้อง (Soundness)\n\n* ป้องกัน/ไม่สนับสนุนการใช้ synchronous reactions แบบผิดๆ\n    * ความเสี่ยงต่อ soundness: อาจเกิด \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" ถ้าใช้งานผิด หาก rendering เกิดขึ้นทันทีเมื่อ set Signal อาจทำให้ผู้ใช้เห็น state แอปที่ไม่สมบูรณ์ ดังนั้นฟีเจอร์นี้ควรใช้เพื่อจัดตารางงานอย่างชาญฉลาดภายหลัง เมื่อตรรกะแอปเสร็จสิ้นแล้วเท่านั้น\n    * ทางแก้: ไม่อนุญาตให้อ่านหรือเขียน Signal ใดๆ จากใน synchronous reaction callback\n* ไม่สนับสนุนการใช้ `untrack` และแสดงให้เห็นถึงลักษณะที่ไม่ sound\n    * ความเสี่ยงต่อ soundness: อนุญาตให้สร้าง Signal ที่คำนวณซึ่งค่าขึ้นอยู่กับ Signal อื่น แต่จะไม่อัปเดตเมื่อ Signal เหล่านั้นเปลี่ยน ควรใช้เมื่อการเข้าถึงแบบ untracked จะไม่เปลี่ยนผลลัพธ์ของการคำนวณ\n    * ทางแก้: API นี้จะถูกระบุว่า “unsafe” ในชื่อ\n* หมายเหตุ: ข้อเสนอนี้อนุญาตให้ Signal ถูกอ่านและเขียนจาก computed และ effect signal ได้โดยไม่จำกัดการเขียนที่เกิดหลังการอ่าน แม้จะมีความเสี่ยงด้าน soundness ก็ตาม ตัดสินใจเช่นนี้เพื่อคงความยืดหยุ่นและความเข้ากันได้กับ framework\n\n### Surface API\n\n* ต้องเป็นรากฐานที่ดีสำหรับหลาย framework เพื่อนำไปใช้กับ Signal/reactivity ของตน\n    * ควรเหมาะกับ store proxy แบบ recursive, reactivity ใน class field แบบ decorator และทั้งแบบ `.value` และ `[state, setState]`-style API\n    * semantics ต้องสามารถแสดงรูปแบบที่ framework ต่างๆ ใช้งานได้ เช่น สามารถเป็นพื้นฐานสำหรับทั้งการเขียนที่สะท้อนค่าทันทีหรือการเขียนที่ batch และนำไปใช้ภายหลัง\n* ควรใช้งานได้โดยตรงกับนักพัฒนา JavaScript\n    * ถ้าฟีเจอร์ตรงกับแนวคิดใน ecosystem การใช้ศัพท์ที่ใช้ร่วมกันเป็นสิ่งดี\n        * แต่สำคัญที่ไม่ควรใช้ชื่อเดียวกันกับที่มีอยู่!\n    * ความตึงเครียดระหว่าง “ใช้งานได้จริงกับ dev JS” กับ “ให้ hook ครบสำหรับ framework”\n        * แนวคิด: ให้ hook ครบ แต่รวม error เมื่อใช้ผิด\n        * แนวคิด: นำ API ที่ซับซ้อนไว้ใน namespace `subtle` คล้ายกับ [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle) เพื่อแยกเส้นระหว่าง API ที่จำเป็นสำหรับการใช้งานขั้นสูง เช่น สร้าง framework หรือ dev tools กับการใช้งานในงานประจำวัน เช่น สร้าง signal เพื่อใช้กับ framework\n* สามารถนำไปใช้งานและให้ประสิทธิภาพดี—Surface API ไม่เพิ่ม overhead มากเกินไป\n    * รองรับ subclassing เพื่อให้ framework สามารถเพิ่ม method และ field ของตัวเอง (รวมถึง private field) ซึ่งสำคัญต่อการหลีกเลี่ยง allocation ส่วนเกินในระดับ framework ดูรายละเอียด “การจัดการหน่วยความจำ” ด้านล่าง\n\n### การจัดการหน่วยความจำ\n\n* ถ้าเป็นไปได้: Signal ที่คำนวณควรสามารถถูกเก็บขยะ (garbage-collect) ได้หากไม่มีสิ่งใดอ้างอิงแบบมีชีวิตเพื่ออ่านในอนาคต แม้ว่าจะยังเชื่อมต่ออยู่ในกราฟที่ใหญ่กว่าซึ่งยังคงมีชีวิต (เช่น โดยการอ่าน state ที่ยังคงมีชีวิตอยู่)",
  "status": "ok"
}