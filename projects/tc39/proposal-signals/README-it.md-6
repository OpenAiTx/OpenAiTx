{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "Lo `state` di un Computed Signal può essere uno dei seguenti:\n\n- `~clean~`: Il valore del Signal è presente e noto come non obsoleto.\n- `~checked~`: Una fonte (indiretta) di questo Signal è cambiata; questo Signal ha un valore ma _potrebbe_ essere obsoleto. Se sia o meno obsoleto sarà noto solo quando tutte le fonti immediate saranno state valutate.\n- `~computing~`: Il callback di questo Signal è attualmente in esecuzione come effetto collaterale di una chiamata `.get()`.\n- `~dirty~`: O questo Signal ha un valore che si sa essere obsoleto, oppure non è mai stato valutato.\n\nIl grafico delle transizioni è il seguente:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nLe transizioni sono:\n| Numero | Da | A | Condizione | Algoritmo |\n| ------ | -- | - | ---------- | ---------- |\n| 1 | `~checked~` | `~dirty~` | Una fonte immediata di questo signal, che è un computed signal, è stata valutata, e il suo valore è cambiato. | Algoritmo: ricalcolo di un Signal computed dirty |\n| 2 | `~clean~` | `~dirty~` | Una fonte immediata di questo signal, che è uno State, è stata impostata con un valore diverso dal precedente. | Metodo: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Una fonte ricorsiva, ma non immediata, di questo signal, che è uno State, è stata impostata con un valore diverso dal precedente. | Metodo: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | Stiamo per eseguire il `callback`. | Algoritmo: ricalcolo di un Signal computed dirty |\n| 5 | `~computing~` | `~clean~` | Il `callback` ha terminato la valutazione e ha restituito un valore o sollevato un'eccezione. | Algoritmo: ricalcolo di un Signal computed dirty |\n| 6 | `~checked~` | `~clean~` | Tutte le fonti immediate di questo signal sono state valutate, e tutte sono risultate invariate, quindi ora sappiamo che non è obsoleto. | Algoritmo: ricalcolo di un Signal computed dirty |\n\n#### Slot interni di `Signal.Computed`\n\n- `value`: Il valore precedente memorizzato del Signal, oppure `~uninitialized~` per un computed Signal mai letto. Il valore può essere un'eccezione che viene rilanciata quando il valore viene letto. Sempre `undefined` per gli effect signals.\n- `state`: Può essere `~clean~`, `~checked~`, `~computing~` o `~dirty~`.\n- `sources`: Un insieme ordinato di Signals da cui questo Signal dipende.\n- `sinks`: Un insieme ordinato di Signals che dipendono da questo Signal.\n- `equals`: Il metodo di confronto fornito nelle opzioni.\n- `callback`: Il callback che viene chiamato per ottenere il valore del computed Signal. Impostato al primo parametro passato al costruttore.\n\n#### Costruttore di `Signal.Computed`\n\nIl costruttore imposta\n- `callback` al suo primo parametro\n- `equals` in base alle opzioni, predefinito a `Object.is` se assente\n- `state` a `~dirty~`\n- `value` a `~uninitialized~`\n\nCon [AsyncContext](https://github.com/tc39/proposal-async-context), il callback passato a `new Signal.Computed` chiude sullo snapshot del momento in cui è stato chiamato il costruttore, e ripristina questo snapshot durante la sua esecuzione.\n\n#### Metodo: `Signal.Computed.prototype.get`\n\n1. Se il contesto di esecuzione corrente è `frozen` o se questo Signal ha lo stato `~computing~`, o se questo signal è un Watcher e sta `computing` un computed Signal, solleva un'eccezione.\n1. Se `computing` non è `null`, aggiungi questo Signal all'insieme `sources` di `computing`.\n1. NOTA: Non aggiungiamo `computing` all'insieme `sinks` di questo Signal finché non viene osservato da un Watcher.\n1. Se lo stato di questo Signal è `~dirty~` o `~checked~`: Ripeti i seguenti passaggi fino a quando questo Signal è `~clean~`:\n    1. Risali ricorsivamente tramite `sources` per trovare la fonte ricorsiva più profonda e più a sinistra (cioè osservata per prima) che è un Computed Signal segnato come `~dirty~` (interrompendo la ricerca quando si trova un Computed Signal `~clean~`, e includendo questo Computed Signal come ultimo elemento da cercare).\n    1. Esegui l'algoritmo \"ricalcolo di un Signal computed dirty\" su quel Signal.\n1. A questo punto, lo stato di questo Signal sarà `~clean~`, e nessuna fonte ricorsiva sarà `~dirty~` o `~checked~`. Restituisci il `value` del Signal. Se il valore è un'eccezione, rilancia quell'eccezione.\n\n### La classe `Signal.subtle.Watcher`\n\n#### Macchina a stati di `Signal.subtle.Watcher`\n\nLo `state` di un Watcher può essere uno dei seguenti:\n\n- `~waiting~`: Il callback `notify` è stato eseguito, oppure il Watcher è nuovo, ma non sta osservando attivamente nessun signal.\n- `~watching~`: Il Watcher sta osservando attivamente dei signals, ma non sono ancora avvenuti cambiamenti che richiedano una chiamata a `notify`.\n- `~pending~`: Una dipendenza del Watcher è cambiata, ma il callback `notify` non è ancora stato eseguito.\n\nIl grafico delle transizioni è il seguente:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nLe transizioni sono:\n| Numero | Da | A | Condizione | Algoritmo |\n| ------ | -- | - | ---------- | ---------- |\n| 1 | `~waiting~` | `~watching~` | È stato chiamato il metodo `watch` del Watcher. | Metodo: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | È stato chiamato il metodo `unwatch` del Watcher e l'ultimo signal osservato è stato rimosso. | Metodo: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Un signal osservato potrebbe aver cambiato valore. | Metodo: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | Il callback `notify` è stato eseguito. | Metodo: `Signal.State.prototype.set(newValue)` |\n\n#### Slot interni di `Signal.subtle.Watcher`\n\n- `state`: Può essere `~watching~`, `~pending~` o `~waiting~`\n- `signals`: Un insieme ordinato di Signals che questo Watcher sta osservando\n- `notifyCallback`: Il callback che viene chiamato quando qualcosa cambia. Impostato al primo parametro passato al costruttore.\n\n#### Costruttore: `new Signal.subtle.Watcher(callback)`\n\n1. `state` viene impostato a `~waiting~`.\n1. Inizializza `signals` come insieme vuoto.\n1. `notifyCallback` è impostato al parametro callback.",
  "status": "ok"
}