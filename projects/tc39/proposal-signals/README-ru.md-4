{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback вызывается, когда isWatched становится true, если ранее было false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback вызывается каждый раз, когда isWatched становится false, если ранее было true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Как работают сигналы\n\nСигнал представляет собой ячейку данных, которые могут изменяться со временем. Сигналы могут быть либо \"состоянием\" (просто значение, устанавливаемое вручную), либо \"вычисляемым\" (формула на основе других сигналов).\n\nВычисляемые сигналы работают путем автоматического отслеживания, какие другие сигналы были прочитаны во время их вычисления. Когда происходит чтение вычисляемого сигнала, он проверяет, изменились ли какие-либо из его ранее зафиксированных зависимостей, и, если да — переоценивает себя. Когда несколько вычисляемых сигналов вложены друг в друга, вся атрибуция отслеживания уходит к самому внутреннему.\n\nВычисляемые сигналы являются ленивыми, то есть работают по принципу \"pull\": они пересчитываются только тогда, когда к ним обращаются, даже если одна из их зависимостей изменилась ранее.\n\nCallback, передаваемый в вычисляемые сигналы, должен быть, как правило, \"чистым\" в смысле детерминированной, не имеющей побочных эффектов функции от других сигналов, к которым осуществляется доступ. В то же время, момент вызова callback является детерминированным, что позволяет использовать побочные эффекты с осторожностью.\n\nСигналы имеют заметное кеширование/мемоизацию: как состояние, так и вычисляемые сигналы запоминают свое текущее значение и инициируют пересчет только тех вычисляемых сигналов, которые на них ссылаются, если они действительно изменились. Повторное сравнение старых и новых значений даже не требуется — сравнение производится один раз при сбросе/переоценке исходного сигнала, и механизм сигналов отслеживает, какие элементы, ссылающиеся на этот сигнал, еще не обновились на основе нового значения. Внутренне это, как правило, реализуется с помощью \"раскраски графа\", как описано в (блоге Milo).\n\nВычисляемые сигналы динамически отслеживают свои зависимости — каждый раз при запуске они могут зависеть от разных элементов, и этот точный набор зависимостей поддерживается в актуальном состоянии в графе сигналов. Это означает, что если у вас есть зависимость, необходимая только на одной ветке, а предыдущее вычисление шло по другой ветке, то изменение этой временно неиспользуемой переменной не вызовет пересчета вычисляемого сигнала, даже если будет обращение к нему.\n\nВ отличие от JavaScript Promise, все в сигналах выполняется синхронно:\n- Установка нового значения сигнала происходит синхронно, и это немедленно отражается при чтении любого вычисляемого сигнала, который от него зависит. Встроенной пакетной обработки изменений нет.\n- Чтение вычисляемых сигналов синхронно — их значение всегда доступно.\n- Callback `notify` в Watchers, как объяснено ниже, выполняется синхронно во время вызова `.set()`, который его вызвал (но после завершения раскраски графа).\n\nКак и Promises, сигналы могут представлять состояние ошибки: если callback вычисляемого сигнала выбрасывает исключение, то эта ошибка кешируется как обычное значение и будет выбрасываться снова при каждом чтении сигнала.\n\n### Понимание класса Signal\n\nЭкземпляр `Signal` представляет возможность читать динамически изменяющееся значение, обновления которого отслеживаются во времени. Он также неявно включает возможность подписки на сигнал через отслеживаемый доступ из другого вычисляемого сигнала.\n\nДанный API разработан, чтобы соответствовать приблизительному консенсусу в экосистеме сигналов относительно использования таких названий, как \"signal\", \"computed\" и \"state\". Однако доступ к вычисляемым и состояниям сигналам осуществляется через метод `.get()`, что расходится со всеми популярными API сигналов, которые используют либо аксессор `.value`, либо синтаксис вызова `signal()`.\n\nAPI спроектирован для уменьшения числа выделений памяти, чтобы сделать сигналы пригодными для внедрения в JavaScript-фреймворки с производительностью, не уступающей или превосходящей существующие специализированные сигналы. Это означает:\n- Сигналы состояния — это один изменяемый объект, к которому можно обращаться и который можно изменять из одной и той же ссылки. (См. последствия ниже в разделе \"Разделение возможностей\".)\n- Как сигналы состояния, так и вычисляемые сигналы спроектированы так, чтобы их можно было наследовать, облегчая фреймворкам добавление дополнительных свойств через публичные и приватные поля класса (а также методы для работы с этим состоянием).\n- Различные callback (например, `equals`, callback вычисляемого сигнала) вызываются с соответствующим сигналом в качестве значения `this` для контекста, чтобы не создавать новую замыкание для каждого сигнала. Вместо этого контекст можно хранить в дополнительных свойствах самого сигнала.\n\nНекоторые условия ошибок, обеспечиваемые этим API:\n- Ошибка — рекурсивное чтение вычисляемого сигнала.\n- Callback `notify` у Watcher не может читать или записывать любые сигналы.\n- Если callback вычисляемого сигнала выбрасывает исключение, то все последующие обращения к сигналу будут выбрасывать сохраненную ошибку, пока одна из зависимостей не изменится и не произойдет пересчет.\n\nНекоторые условия, которые *не* контролируются:\n- Вычисляемые сигналы могут записывать в другие сигналы синхронно в своем callback.\n- Работа, поставленная в очередь callback-ом `notify` Watcher, может читать или записывать сигналы, что позволяет воспроизвести [классические антипаттерны React](https://react.dev/learn/you-might-not-need-an-effect) в терминах сигналов!\n\n### Реализация эффектов\n\nИнтерфейс `Watcher`, определенный выше, служит основой для реализации типичных JS-API для эффектов: callback-ов, которые повторно выполняются при изменении других сигналов, исключительно ради побочных эффектов. Функция `effect`, используемая выше в исходном примере, может быть определена следующим образом:\n\n```ts\n// Эта функция обычно живет в библиотеке/фреймворке, а не в прикладном коде\n// ПРИМЕЧАНИЕ: Эта логика планирования слишком проста для реального использования. Не копируйте.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Эффектный сигнал, который вычисляется до cb и планирует чтение себя в микротаске,\n// всякий раз, когда одна из его зависимостей может измениться\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nВ API сигналов не включена никакая встроенная функция вроде `effect`. Это связано с тем, что планирование эффектов тонко и часто связано с циклами рендеринга фреймворков и другим специфическим для фреймворков состоянием или стратегиями, к которым JS не имеет доступа.\n\nРазберем различные операции, используемые здесь: Callback `notify`, переданный в конструктор `Watcher`, — это функция, вызываемая, когда сигнал переходит из \"чистого\" состояния (когда мы знаем, что кеш инициализирован и валиден) в \"проверенное\" или \"грязное\" состояние (когда кеш может быть или не быть валидным, потому что хотя бы одно из состояний, от которых он рекурсивно зависит, изменено).\n\nВызовы `notify` в конечном итоге инициируются вызовом `.set()` на каком-либо сигнале состояния. Этот вызов синхронный: происходит до возврата из `.set`. Но не нужно беспокоиться о том, что этот callback увидит граф сигналов в полупереработанном состоянии, потому что во время callback-а `notify` никакой сигнал не может быть прочитан или записан, даже в вызове `untrack`. Поскольку `notify` вызывается в процессе `.set()`, это прерывает другой поток логики, который может быть еще не завершен. Чтобы читать или записывать сигналы из `notify`, планируйте работу на потом, например, записав сигнал в список для последующего доступа или с помощью `queueMicrotask`, как показано выше.\n\nОбратите внимание, что вполне возможно эффективно использовать сигналы без `Signal.subtle.Watcher`, планируя опрос вычисляемых сигналов, как это делает Glimmer. Однако многие фреймворки обнаружили, что часто бывает полезно выполнять такую логику синхронно, поэтому API сигналов ее включает.\n\nКак вычисляемые, так и сигналы состояния собираются сборщиком мусора как любые значения JS. Но Watcher имеют особый способ удержания объектов: любые сигналы, отслеживаемые Watcher, будут удерживаться в памяти до тех пор, пока какие-либо из нижележащих состояний достижимы, так как они могут инициировать будущий вызов `notify` (и затем будущий вызов `.get()`). Поэтому не забывайте вызывать `Watcher.prototype.unwatch` для очистки эффектов.\n\n### Небезопасный escape hatch\n\n`Signal.subtle.untrack` — это лазейка, позволяющая читать сигналы *без* отслеживания этих чтений. Эта возможность небезопасна, потому что позволяет создавать вычисляемые сигналы, чье значение зависит от других сигналов, но которые не обновляются при изменении этих сигналов. Ее следует использовать только тогда, когда неотслеживаемые обращения не повлияют на результат вычисления.\n\n<!--\nTODO: Привести пример, где имеет смысл использовать untrack\n\n### Использование watched/unwatched",
  "status": "ok"
}