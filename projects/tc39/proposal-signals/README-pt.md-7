{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Com [AsyncContext](https://github.com/tc39/proposal-async-context), o callback passado para `new Signal.subtle.Watcher` *não* encerra o snapshot do momento em que o construtor foi chamado, para que informações contextuais ao redor da gravação fiquem visíveis.\n\n#### Método: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Se `frozen` for true, lance uma exceção.\n1. Se algum dos argumentos não for um sinal, lance uma exceção.\n1. Adicione todos os argumentos ao final do `signals` deste objeto.\n1. Para cada sinal recém-observado, da esquerda para a direita,\n    1. Adicione este watcher como um `sink` para esse sinal.\n    1. Se este foi o primeiro sink, então faça a recursão até as sources para adicionar esse sinal como sink.\n    1. Defina `frozen` como true.\n    1. Chame o callback `watched` se existir.\n    1. Restaure `frozen` para false.\n1. Se o `state` do Signal for `~waiting~`, então defina como `~watching~`.\n\n#### Método: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Se `frozen` for true, lance uma exceção.\n1. Se algum dos argumentos não for um sinal, ou não estiver sendo observado por este watcher, lance uma exceção.\n1. Para cada sinal nos argumentos, da esquerda para a direita,\n    1. Remova esse sinal do conjunto `signals` deste Watcher.\n    1. Remova este Watcher do conjunto `sink` deste Signal.\n    1. Se o conjunto `sink` desse Signal ficou vazio, remova esse Signal como sink de cada uma de suas sources.\n    1. Defina `frozen` como true.\n    1. Chame o callback `unwatched` se existir.\n    1. Restaure `frozen` para false.\n1. Se o watcher agora não tiver `signals` e seu `state` for `~watching~`, então defina como `~waiting~`.\n\n#### Método: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Retorne um Array contendo o subconjunto de `signals` que são Computed Signals nos estados `~dirty~` ou `~pending~`.\n\n### Método: `Signal.subtle.untrack(cb)`\n\n1. Deixe `c` ser o estado atual de `computing` do contexto de execução.\n1. Defina `computing` como null.\n1. Chame `cb`.\n1. Restaure `computing` para `c` (mesmo se `cb` lançar uma exceção).\n1. Retorne o valor de retorno de `cb` (relançando qualquer exceção).\n\nNota: untrack não tira você do estado `frozen`, que é mantido estritamente.\n\n### Método: `Signal.subtle.currentComputed()`\n\n1. Retorne o valor atual de `computing`.\n\n### Algoritmos comuns\n\n##### Algoritmo: recalcular um Signal computed dirty\n\n1. Limpe o conjunto `sources` deste Signal e remova-o dos conjuntos `sinks` dessas sources.\n1. Salve o valor anterior de `computing` e defina `computing` como este Signal.\n1. Defina o estado deste Signal como `~computing~`.\n1. Execute o callback deste computed Signal, usando este Signal como valor de this. Salve o valor de retorno e, se o callback lançar uma exceção, armazene-a para relançar.\n1. Restaure o valor anterior de `computing`.\n1. Aplique o algoritmo \"set Signal value\" ao valor de retorno do callback.\n2. Defina o estado deste Signal como `~clean~`.\n1. Se esse algoritmo retornou `~dirty~`: marque todos os sinks deste Signal como `~dirty~` (anteriormente, os sinks poderiam estar misturados entre checked e dirty). (Ou, se este não estiver sendo observado, então adote um novo número de geração para indicar dirty, ou algo assim.)\n1. Caso contrário, se o algoritmo retornou `~clean~`: nesse caso, para cada sink `~checked~` deste Signal, se todas as sources desse Signal agora estiverem limpas, então marque esse Signal como `~clean~` também. Aplique essa etapa de limpeza recursivamente para sinks adicionais, para quaisquer Signals recém-limpos que tenham sinks checked. (Ou, se este não estiver sendo observado, indique o mesmo de alguma forma, para que a limpeza possa ser feita de forma preguiçosa.)\n\n##### Algoritmo de atribuição de valor do Signal\n\n1. Se este algoritmo recebeu um valor (ao contrário de uma exceção para ser relançada, do algoritmo de recalcular computed Signal dirty):\n    1. Chame a função `equals` deste Signal, passando como parâmetros o valor atual, o novo valor e este Signal. Se uma exceção for lançada, salve essa exceção (para relançar quando lido) como o valor do Signal e continue como se o callback tivesse retornado false.\n    1. Se essa função retornar true, retorne `~clean~`.\n1. Defina o `value` deste Signal como o parâmetro.\n1. Retorne `~dirty~`\n\n## FAQ\n\n**P**: Não é um pouco cedo para padronizar algo relacionado a Signals, quando eles acabaram de se tornar populares em 2022? Não deveríamos dar mais tempo para evoluírem e se estabilizarem?\n\n**R**: O estado atual dos Signals em frameworks web é resultado de mais de 10 anos de desenvolvimento contínuo. À medida que o investimento aumentou, como tem acontecido nos últimos anos, quase todos os frameworks web estão convergindo para um modelo central muito semelhante de Signals. Esta proposta é resultado de um exercício de design compartilhado entre um grande número de líderes atuais em frameworks web, e não avançará para padronização sem a validação desse grupo de especialistas em diferentes contextos.\n\n#### Como os Signals são usados?\n\n**P**: Signals nativos podem ser usados por frameworks, considerando sua integração estreita com renderização e propriedade?\n\n**R**: As partes mais específicas de frameworks tendem a estar na área de efeitos, agendamento e propriedade/eliminação, que esta proposta não tenta resolver. Nossa prioridade inicial ao prototipar Signals no padrão é validar que eles podem funcionar \"por baixo\" dos frameworks existentes de forma compatível e com bom desempenho.\n\n**P**: A API de Signal foi projetada para ser usada diretamente por desenvolvedores de aplicações, ou envolvida por frameworks?\n\n**R**: Embora esta API possa ser usada diretamente por desenvolvedores de aplicações (pelo menos a parte que não está no namespace `Signal.subtle`), ela não foi projetada para ser especialmente ergonômica. Em vez disso, as necessidades de autores de bibliotecas/frameworks são prioridade. Espera-se que a maioria dos frameworks envolva até mesmo as APIs básicas de `Signal.State` e `Signal.Computed` com algo que expresse sua abordagem ergonômica. Na prática, normalmente é melhor usar Signals por meio de um framework, que gerencia recursos mais complexos (por exemplo, Watcher, `untrack`), bem como gerenciamento de propriedade e eliminação (por exemplo, decidir quando os signals devem ser adicionados e removidos de watchers) e agendamento de renderização para o DOM — esta proposta não tenta resolver esses problemas.\n\n**P**: Preciso desmontar Signals relacionados a um widget quando esse widget é destruído? Qual é a API para isso?\n\n**R**: A operação de desmontagem relevante aqui é `Signal.subtle.Watcher.prototype.unwatch`. Apenas Signals observados precisam ser limpos (desobservados), enquanto Signals não observados podem ser coletados automaticamente pelo garbage collector.\n\n**P**: Signals funcionam com VDOM ou diretamente com o DOM HTML subjacente?\n\n**R**: Sim! Signals são independentes da tecnologia de renderização. Frameworks JavaScript existentes que usam construções semelhantes a Signals integram-se com VDOM (por exemplo, Preact), DOM nativo (por exemplo, Solid) e uma combinação (por exemplo, Vue). O mesmo será possível com Signals nativos.\n\n**P**: Será ergonômico usar Signals no contexto de frameworks baseados em classes como Angular e Lit? E quanto a frameworks baseados em compilador, como Svelte?\n\n**R**: Campos de classe podem ser baseados em Signal com um simples decorator de acessor, como mostrado no [readme do polyfill de Signal](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals estão muito alinhados com as Runes do Svelte 5 — é simples para um compilador transformar runes na API de Signal definida aqui, e de fato é isso que o Svelte 5 faz internamente (mas com sua própria biblioteca de Signals).\n\n**P**: Signals funcionam com SSR? Hidratação? Resumibilidade?\n\n**R**: Sim. Qwik usa Signals com bons resultados em ambas as propriedades, e outros frameworks têm abordagens bem desenvolvidas para hidratação com Signals e diferentes trade-offs. Achamos que é possível modelar os Signals resumíveis do Qwik usando um State e um Computed signal conectados, e planejamos provar isso em código.",
  "status": "ok"
}