{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Seguimiento Automático de Dependencias** - Una Signal computada descubre automáticamente cualquier otra Signal de la que dependa, ya sean estos valores simples u otros cálculos.\n* **Evaluación Perezosa** - Los cálculos no se evalúan anticipadamente cuando se declaran, ni se evalúan inmediatamente cuando cambian sus dependencias. Solo se evalúan cuando su valor es solicitado explícitamente.\n* **Memoización** - Las Signals computadas almacenan en caché su último valor, de modo que los cálculos cuyas dependencias no hayan cambiado no necesitan ser reevaluados, sin importar cuántas veces sean accedidos.\n\n## Motivación para estandarizar Signals\n\n#### Interoperabilidad\n\nCada implementación de Signal tiene su propio mecanismo de seguimiento automático, para llevar el control de las fuentes encontradas al evaluar una Signal computada. Esto dificulta compartir modelos, componentes y librerías entre diferentes frameworks—tienden a venir con un acoplamiento falso a su motor de vista (dado que las Signals suelen implementarse como parte de frameworks de JS).\n\nUno de los objetivos de esta propuesta es desacoplar completamente el modelo reactivo del renderizado de la vista, permitiendo a los desarrolladores migrar a nuevas tecnologías de renderizado sin reescribir su código no relacionado a UI, o desarrollar modelos reactivos compartidos en JS para desplegar en diferentes contextos. Desafortunadamente, debido a versiones y duplicación, ha resultado impráctico lograr un alto nivel de compartición mediante librerías a nivel de JS—las funcionalidades integradas ofrecen una garantía de compartición más fuerte.\n\n#### Rendimiento/Uso de memoria\n\nSiempre existe un pequeño potencial de mejora en el rendimiento al enviar menos código gracias a que librerías comúnmente usadas vienen integradas, pero las implementaciones de Signals suelen ser bastante pequeñas, por lo que no esperamos que este efecto sea muy grande.\n\nSospechamos que las implementaciones nativas en C++ de las estructuras de datos y algoritmos relacionados con Signals pueden ser ligeramente más eficientes que lo que se puede lograr en JS, por un factor constante. Sin embargo, no se anticipan cambios algorítmicos frente a lo que estaría presente en un polyfill; no se espera que los motores hagan magia aquí, y los algoritmos de reactividad estarán bien definidos y serán inequívocos.\n\nEl grupo promotor espera desarrollar varias implementaciones de Signals y usar estas para investigar estas posibilidades de rendimiento.\n\n#### DevTools\n\nCon las librerías de Signals existentes en lenguaje JS, puede ser difícil rastrear cosas como:\n* La pila de llamadas a través de una cadena de Signals computadas, mostrando la cadena causal de un error\n* El grafo de referencias entre Signals, cuando una depende de otra—importante cuando se depura el uso de memoria\n\nLas Signals integradas permiten que los entornos de ejecución de JS y DevTools puedan tener un soporte mejorado para inspeccionar Signals, particularmente para depuración o análisis de rendimiento, ya sea integrado en los navegadores o a través de una extensión compartida. Herramientas existentes como el inspector de elementos, la captura de rendimiento y los perfiladores de memoria podrían actualizarse para resaltar específicamente las Signals en su presentación de información.\n\n#### Beneficios secundarios\n\n##### Beneficios de una librería estándar\n\nEn general, JavaScript ha tenido una librería estándar bastante mínima, pero una tendencia en TC39 ha sido hacer de JS un lenguaje más \"con pilas incluidas\", con un conjunto de funcionalidades integradas y de alta calidad disponible. Por ejemplo, Temporal está reemplazando moment.js, y varias pequeñas funciones, por ejemplo, `Array.prototype.flat` y `Object.groupBy` están reemplazando muchos casos de uso de lodash. Los beneficios incluyen tamaños de bundle más pequeños, mayor estabilidad y calidad, menos cosas que aprender al unirse a un nuevo proyecto, y un vocabulario común entre desarrolladores de JS.\n\n##### Integración HTML/DOM (una posibilidad futura)\n\nEl trabajo actual en el W3C y por parte de los implementadores de navegadores busca llevar la plantillas nativas a HTML ([DOM Parts][wicg-pr-1023] y [Template Instantiation][wicg-propsal-template-instantiation]). Además, el W3C Web Components CG está explorando la posibilidad de extender los Web Components para ofrecer una API HTML totalmente declarativa. Para lograr ambos objetivos, eventualmente HTML necesitará una primitiva reactiva. Además, se pueden imaginar muchas mejoras ergonómicas al DOM mediante la integración de Signals, las cuales han sido solicitadas por la comunidad.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Nota, esta integración sería un esfuerzo separado para el futuro, no parte de esta propuesta en sí.\n\n##### Intercambio de información en el ecosistema (*no* es una razón para incluirlo)\n\nLos esfuerzos de estandarización a veces pueden ser útiles solo a nivel \"comunidad\", incluso sin cambios en los navegadores. El esfuerzo de Signals está reuniendo a muchos autores de frameworks diferentes para una discusión profunda sobre la naturaleza de la reactividad, los algoritmos y la interoperabilidad. Esto ya ha sido útil, y no justifica la inclusión en los motores JS y navegadores; las Signals solo deberían agregarse al estándar de JavaScript si existen beneficios significativos *más allá* del intercambio de información del ecosistema que permite.\n\n## Objetivos de diseño para Signals\n\nResulta que las librerías de Signals existentes no son tan diferentes entre sí, en su núcleo. Esta propuesta busca aprovechar su éxito implementando las cualidades importantes de muchas de esas librerías.\n\n### Funcionalidades principales\n\n* Un tipo Signal que representa estado, es decir, Signal escribible. Este es un valor que otros pueden leer.\n* Un tipo Signal computada/memo/derivada, que depende de otras y se calcula y almacena en caché de manera perezosa.\n    * El cálculo es perezoso, lo que significa que las Signals computadas no se recalculan por defecto cuando cambia una de sus dependencias, sino que solo se ejecutan si alguien realmente las lee.\n    * El cálculo es \"[libre de glitches](https://es.wikipedia.org/wiki/Programaci%C3%B3n_reactiva#Glitches)\", es decir, nunca se realizan cálculos innecesarios. Esto implica que, cuando una aplicación lee una Signal computada, hay un ordenamiento topológico de las partes potencialmente sucias del grafo para ejecutar, eliminando duplicados.\n    * El cálculo se almacena en caché, lo que significa que si, después de la última vez que una dependencia cambió, ninguna dependencia ha cambiado, entonces la Signal computada *no* se recalcula al accederla.\n    * Es posible realizar comparaciones personalizadas para Signals computadas así como para las de estado, para determinar cuándo Signals computadas adicionales que dependen de ellas deben actualizarse.\n* Reacciones a la condición donde una Signal computada tiene una de sus dependencias (o dependencias anidadas) marcada como \"sucia\" y cambia, lo que significa que el valor de la Signal podría estar desactualizado.\n    * Esta reacción está pensada para programar trabajo más importante que se realizará más tarde.\n    * Los efectos se implementan en términos de estas reacciones, más la programación a nivel de framework.\n    * Las Signals computadas necesitan la capacidad de reaccionar a si están registradas como una dependencia (anidada) de una de estas reacciones.\n* Permitir que los frameworks de JS realicen su propia programación. No hay una programación forzada integrada al estilo Promise.\n    * Se necesitan reacciones síncronas para permitir programar trabajo posterior basado en la lógica del framework.\n    * Las escrituras son síncronas y tienen efecto inmediato (un framework que agrupe escrituras puede hacerlo por encima).\n    * Es posible separar la comprobación de si un efecto puede estar \"sucio\" de la ejecución real del efecto (permitiendo un programador de efectos en dos etapas).\n* Capacidad de leer Signals *sin* activar el registro de dependencias (`untrack`)\n* Permitir la composición de diferentes bases de código que usen Signals/reactividad, por ejemplo,\n    * Usar múltiples frameworks juntos en cuanto al seguimiento/reactividad en sí (salvo omisiones, ver más abajo)\n    * Estructuras de datos reactivas independientes de framework (por ejemplo, proxy de almacén recursivamente reactivo, Map y Set y Array reactivos, etc.)\n\n### Solidez\n\n* Desalentar/prohibir el uso ingenuo de reacciones síncronas.\n    * Riesgo de solidez: puede exponer \"[glitches](https://es.wikipedia.org/wiki/Programaci%C3%B3n_reactiva#Glitches)\" si se usa incorrectamente: Si el renderizado se realiza inmediatamente cuando se establece una Signal, puede exponer un estado de aplicación incompleto al usuario final. Por tanto, esta función solo debe usarse para programar trabajo inteligentemente para más adelante, una vez que la lógica de la aplicación haya terminado.\n    * Solución: No permitir leer ni escribir ninguna Signal desde dentro de un callback de reacción síncrona.\n* Desalentar el uso de `untrack` y marcar su naturaleza no sólida\n    * Riesgo de solidez: permite la creación de Signals computadas cuyo valor depende de otras Signals, pero que no se actualizan cuando esas Signals cambian. Debe usarse cuando los accesos no rastreados no cambiarán el resultado del cálculo.\n    * Solución: La API está marcada como \"insegura\" en el nombre.\n* Nota: Esta propuesta sí permite que las signals sean leídas y escritas tanto desde signals computadas como de efectos, sin restringir escrituras que ocurran después de lecturas, a pesar del riesgo de solidez. Esta decisión fue tomada para preservar flexibilidad y compatibilidad en la integración con frameworks.\n\n### API superficial\n\n* Debe ser una base sólida para que múltiples frameworks implementen sus mecanismos de Signals/reactividad.\n    * Debe ser una buena base para proxies de almacén recursivos, reactividad basada en decoradores de campos de clase, y para APIs tanto del tipo `.value` como `[state, setState]`.\n    * La semántica debe ser capaz de expresar los patrones válidos habilitados por diferentes frameworks. Por ejemplo, debe ser posible que estas Signals sean la base tanto de escrituras reflejadas inmediatamente como de escrituras agrupadas y aplicadas más tarde.\n* Sería deseable que esta API pueda ser utilizada directamente por desarrolladores JavaScript.\n    * Si una funcionalidad coincide con un concepto del ecosistema, es bueno usar vocabulario común.\n        * Sin embargo, es importante no usar literalmente los mismos nombres exactos.\n    * Tensión entre \"usabilidad para desarrolladores JS\" y \"proveer todos los ganchos para frameworks\"\n        * Idea: Proveer todos los ganchos, pero incluir errores cuando se usen incorrectamente si es posible.\n        * Idea: Colocar las APIs sutiles en un espacio de nombres `subtle`, similar a [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), para marcar la línea entre las APIs necesarias para usos más avanzados como implementar un framework o construir dev tools, versus el desarrollo de aplicaciones cotidiano como instanciar signals para usar con un framework.\n* Ser implementable y utilizable con buen rendimiento—la API superficial no debe causar demasiada sobrecarga.\n    * Permitir subclasificación, de modo que los frameworks puedan añadir sus propios métodos y campos, incluidos los campos privados. Esto es importante para evitar la necesidad de asignaciones adicionales a nivel de framework. Ver \"Gestión de memoria\" más abajo.\n\n### Gestión de memoria\n\n* Si es posible: Una Signal computada debe poder ser recolectada por el recolector de basura si nada vivo la está referenciando para posibles lecturas futuras, incluso si está enlazada en un grafo más grande que permanece vivo (por ejemplo, al leer un estado que permanece vivo).",
  "status": "ok"
}