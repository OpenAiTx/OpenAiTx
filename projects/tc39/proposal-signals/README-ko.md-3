{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* 대부분의 프레임워크에서는 다른 Signal 그래프와 참조 관계가 남아 있는 경우, 계산된 Signal의 명시적 처리가 필요하다는 점에 유의하십시오.\n* 이러한 Signal의 수명 주기가 UI 컴포넌트의 수명과 연결되어 있고, 효과 역시 결국에는 처분(dispose)되어야 하므로, 실제로는 그렇게 심각한 문제가 되지 않습니다.\n* 이러한 의미론으로 실행하는 것이 너무 비용이 크다면, 아래의 API에 계산된 Signal의 명시적 처분(또는 \"언링킹\") 기능을 추가해야 합니다. (현재는 해당 기능이 없습니다.)\n* 별도의 관련 목표: 할당 횟수를 최소화하기\n    * writable Signal을 만들 때 (두 개의 별도 클로저와 배열을 피함)\n    * effect를 구현할 때 (반응마다 클로저 생성을 피함)\n    * Signal 변경 관찰 API에서 임시 데이터 구조 생성을 피함\n    * 해결책: 하위 클래스에서 정의된 메서드와 필드를 재사용할 수 있는 클래스 기반 API\n\n## API 스케치\n\nSignal API의 초기 아이디어는 아래와 같습니다. 이는 초기 초안일 뿐이며, 시간이 지나면서 변경될 수 있습니다. 전체 `.d.ts`부터 살펴보면서 전체적인 구조를 파악하고, 이후에 각 세부 사항을 논의하겠습니다.\n\n```ts\ninterface Signal<T> {\n    // 시그널의 값을 가져옵니다.\n    get(): T;\n}\n\nnamespace Signal {\n    // 읽기-쓰기 가능한 Signal\n    class State<T> implements Signal<T> {\n        // 값 t로 시작하는 상태 Signal을 생성합니다.\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // 시그널의 값을 가져옵니다.\n        get(): T;\n\n        // 상태 Signal의 값을 t로 설정합니다.\n        set(t: T): void;\n    }\n\n    // 다른 Signal을 기반으로 한 수식 Signal\n    class Computed<T = unknown> implements Signal<T> {\n        // 콜백이 반환하는 값으로 평가되는 Signal을 생성합니다.\n        // 콜백은 이 Signal을 this 값으로 받아 호출됩니다.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // 시그널의 값을 가져옵니다.\n        get(): T;\n    }\n\n    // 이 네임스페이스에는 프레임워크 작성자를 위한 \"고급\" 기능이 포함되어 있습니다.\n    // 애플리케이션 개발자보다는 프레임워크 작성자가 사용하는 것이 좋습니다.\n    // `crypto.subtle`과 유사\n    namespace subtle {\n        // 모든 추적을 비활성화한 상태로 콜백 실행\n        function untrack<T>(cb: () => T): T;\n\n        // 현재 시그널 읽기를 추적하고 있는 Computed Signal을 가져옴 (없으면 null)\n        function currentComputed(): Computed | null;\n\n        // 마지막 평가 시 참조된 모든 Signal의 순서 있는 목록 반환\n        // Watcher의 경우, 감시 중인 Signal 집합을 나열함\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // 이 시그널이 포함된 Watcher와, 마지막 평가 시 이 시그널을 읽었던\n        // (재귀적으로) 감시 중인 Computed Signal을 반환\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // 이 시그널이 \"live\" 상태인지(Watcher에 의해 감시 중이거나,\n        // (재귀적으로) live인 Computed Signal에 의해 읽힘) 여부 반환\n        function hasSinks(s: State | Computed): boolean;\n\n        // 이 요소가 \"반응성\"인지(다른 시그널에 의존하는지) 여부 반환\n        // hasSources가 false인 Computed는 항상 동일한 상수를 반환\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // Watcher의 (재귀적) 소스가 쓰여질 때, notify 콜백 호출\n            // (이전에 이미 호출되지 않은 경우에만)\n            // notify 중에는 어떠한 시그널도 읽거나 쓸 수 없음\n            constructor(notify: (this: Watcher) => void);\n\n            // Watcher의 집합에 이 시그널들을 추가하고,\n            // 집합 내(또는 의존성 내) 어느 시그널이 변경될 때마다 notify 콜백이 실행되도록 설정\n            // 인자 없이 호출하면 \"notified\" 상태만 초기화하여\n            // notify 콜백이 다시 호출되게 할 수 있음\n            watch(...s: Signal[]): void;\n\n            // 감시 집합에서 이 시그널들을 제거함 (예: 처분된 effect의 경우)\n            unwatch(...s: Signal[]): void;\n\n            // Watcher의 집합 내 아직 dirty 상태이거나,\n            // dirty/pending 상태인 소스를 가진 Computed Signal 집합 반환\n            // (아직 재평가되지 않은 경우)\n            getPending(): Signal[];\n        }\n\n        // 감시 시작/종료 시 호출되는 hook\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // 이전 값과 새로운 값 간의 사용자 정의 비교 함수. 기본값: Object.is.\n        // 이 시그널이 this 값으로 전달됩니다.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}