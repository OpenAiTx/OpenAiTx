{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "Avec [AsyncContext](https://github.com/tc39/proposal-async-context), le callback passé à `new Signal.subtle.Watcher` ne ferme *pas* sur l’instantané du moment où le constructeur a été appelé, afin que l’information contextuelle autour de l’écriture soit visible.\n\n#### Méthode : `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Si `frozen` est vrai, lancez une exception.\n1. Si l’un des arguments n’est pas un signal, lancez une exception.\n1. Ajoutez tous les arguments à la fin du champ `signals` de cet objet.\n1. Pour chaque signal nouvellement surveillé, de gauche à droite,\n    1. Ajoutez ce watcher comme un `sink` à ce signal.\n    1. Si c’était le premier sink, alors remontez vers les sources pour ajouter ce signal comme un sink.\n    1. Définissez `frozen` à true.\n    1. Appelez le callback `watched` s’il existe.\n    1. Restaurez `frozen` à false.\n1. Si l’état du Signal est `~waiting~`, alors définissez-le à `~watching~`.\n\n#### Méthode : `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Si `frozen` est vrai, lancez une exception.\n1. Si l’un des arguments n’est pas un signal, ou n’est pas surveillé par ce watcher, lancez une exception.\n1. Pour chaque signal dans les arguments, de gauche à droite,\n    1. Retirez ce signal de l’ensemble `signals` de ce Watcher.\n    1. Retirez ce Watcher de l’ensemble `sink` de ce Signal.\n    1. Si l’ensemble `sink` de ce Signal devient vide, retirez ce Signal comme un sink de chacune de ses sources.\n    1. Définissez `frozen` à true.\n    1. Appelez le callback `unwatched` s’il existe.\n    1. Restaurez `frozen` à false.\n1. Si le watcher n’a maintenant plus de `signals`, et que son état est `~watching~`, alors définissez-le à `~waiting~`.\n\n#### Méthode : `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Retournez un tableau contenant le sous-ensemble des `signals` qui sont des Signaux Calculés dans les états `~dirty~` ou `~pending~`.\n\n### Méthode : `Signal.subtle.untrack(cb)`\n\n1. Laissez `c` être l’état `computing` courant du contexte d’exécution.\n1. Définissez `computing` à null.\n1. Appelez `cb`.\n1. Restaurez `computing` à `c` (même si `cb` a lancé une exception).\n1. Retournez la valeur de retour de `cb` (en relançant toute exception).\n\nRemarque : `untrack` ne vous sort pas de l’état `frozen`, qui est strictement maintenu.\n\n### Méthode : `Signal.subtle.currentComputed()`\n\n1. Retournez la valeur actuelle de `computing`.\n\n### Algorithmes communs\n\n##### Algorithme : recalculer un Signal Calculé sale\n\n1. Videz l’ensemble `sources` de ce Signal, et retirez-le des ensembles `sinks` de ces sources.\n1. Sauvegardez la valeur précédente de `computing` et définissez `computing` à ce Signal.\n1. Définissez l’état de ce Signal à `~computing~`.\n1. Exécutez le callback de ce Signal Calculé, en utilisant ce Signal comme valeur de `this`. Sauvegardez la valeur de retour, et si le callback a lancé une exception, stockez-la pour la relancer.\n1. Restaurez la valeur précédente de `computing`.\n1. Appliquez l’algorithme \"définir la valeur du Signal\" à la valeur de retour du callback.\n2. Définissez l’état de ce Signal à `~clean~`.\n1. Si cet algorithme a retourné `~dirty~` : marquez tous les sinks de ce Signal comme `~dirty~` (auparavant, les sinks pouvaient être un mélange de checked et dirty). (Ou, si ce Signal n’est pas surveillé, adoptez un nouveau numéro de génération pour indiquer la saleté, ou quelque chose de ce genre.)\n1. Sinon, si l’algorithme a retourné `~clean~` : dans ce cas, pour chaque sink `~checked~` de ce Signal, si toutes les sources de ce Signal sont maintenant propres, marquez ce Signal comme `~clean~` également. Appliquez cette étape de nettoyage aux autres sinks récursivement, à tout Signal nouvellement propre qui a des sinks checked. (Ou, si ce Signal n’est pas surveillé, indiquez-le d’une manière ou d’une autre, afin que le nettoyage puisse se faire de manière paresseuse.)\n\n##### Algorithme définir la valeur du Signal\n\n1. Si cet algorithme a reçu une valeur (par opposition à une exception à relancer, depuis l’algorithme de recalcul d’un Signal Calculé sale) :\n    1. Appelez la fonction `equals` de ce Signal, en passant comme paramètres la `value` courante, la nouvelle valeur, et ce Signal. Si une exception est lancée, sauvegardez cette exception (pour la relancer lors de la lecture) comme valeur du Signal et continuez comme si le callback avait retourné false.\n    1. Si cette fonction a retourné true, retournez `~clean~`.\n1. Définissez la `value` de ce Signal à la valeur passée en paramètre.\n1. Retournez `~dirty~`\n\n## FAQ\n\n**Q** : N’est-il pas un peu tôt pour standardiser quelque chose lié aux Signaux, alors qu’ils viennent tout juste de devenir tendance en 2022 ? Ne devrait-on pas leur laisser plus de temps pour évoluer et se stabiliser ?\n\n**R** : L’état actuel des Signaux dans les frameworks web est le fruit de plus de 10 ans de développement continu. À mesure que les investissements augmentent, comme c’est le cas ces dernières années, quasiment tous les frameworks web convergent vers un modèle de base très similaire pour les Signaux. Cette proposition est le résultat d’un exercice de conception partagé entre un grand nombre de leaders actuels des frameworks web, et elle ne sera pas poussée vers la standardisation sans validation par ce groupe d’experts du domaine dans divers contextes.\n\n#### Comment les Signaux sont-ils utilisés ?\n\n**Q** : Les Signaux intégrés peuvent-ils même être utilisés par les frameworks, étant donné leur forte intégration avec le rendu et la gestion de la propriété ?\n\n**R** : Les parties les plus spécifiques aux frameworks concernent généralement les effets, la planification (scheduling), et la gestion/propriété, ce que cette proposition ne tente pas de résoudre. Notre première priorité avec la standardisation des Signaux est de valider qu’ils peuvent fonctionner \"en dessous\" des frameworks existants de manière compatible et avec de bonnes performances.\n\n**Q** : L’API Signal est-elle destinée à être utilisée directement par les développeurs d’applications, ou enveloppée par des frameworks ?\n\n**R** : Bien que cette API puisse être utilisée directement par les développeurs d’applications (au moins la partie qui n’est pas dans l’espace de noms `Signal.subtle`), elle n’est pas conçue pour être particulièrement ergonomique. À la place, les besoins des auteurs de bibliothèques/frameworks sont prioritaires. La plupart des frameworks devraient envelopper même les API de base `Signal.State` et `Signal.Computed` avec quelque chose d’adapté à leur ergonomie. En pratique, il est généralement préférable d’utiliser les Signaux via un framework, qui gère les fonctionnalités plus complexes (par exemple, Watcher, `untrack`), ainsi que la gestion de la propriété et la destruction (par exemple, déterminer quand les signaux doivent être ajoutés ou retirés des watchers), et la planification du rendu vers le DOM — cette proposition ne tente pas de résoudre ces problèmes.\n\n**Q** : Dois-je détruire les Signaux liés à un widget lorsque ce widget est détruit ? Quelle est l’API pour cela ?\n\n**R** : L’opération de destruction pertinente ici est `Signal.subtle.Watcher.prototype.unwatch`. Seuls les Signaux surveillés doivent être nettoyés (en les désurveillance), tandis que les Signaux non surveillés peuvent être collectés automatiquement par le garbage collector.\n\n**Q** : Les Signaux fonctionnent-ils avec le VDOM, ou directement avec le DOM HTML sous-jacent ?\n\n**R** : Oui ! Les Signaux sont indépendants de la technologie de rendu. Les frameworks JavaScript existants qui utilisent des constructions proches des Signaux s’intègrent avec le VDOM (par exemple, Preact), le DOM natif (par exemple, Solid) et une combinaison des deux (par exemple, Vue). Il en sera de même pour les Signaux natifs.\n\n**Q** : Est-ce que l’utilisation des Signaux sera ergonomique dans le contexte de frameworks à base de classes comme Angular et Lit ? Qu’en est-il des frameworks basés sur un compilateur comme Svelte ?\n\n**R** : Les champs de classe peuvent être rendus basés sur les Signaux via un simple décorateur d’accesseur, comme montré dans [le readme du polyfill Signal](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Les Signaux sont très proches des Runes de Svelte 5 — il est simple pour un compilateur de transformer les runes en API Signal telle que définie ici, et en fait c’est ce que fait Svelte 5 en interne (mais avec sa propre bibliothèque de Signaux).\n\n**Q** : Les Signaux fonctionnent-ils avec le SSR ? L’hydratation ? La résumabilité ?\n\n**R** : Oui. Qwik utilise les Signaux avec succès pour ces deux propriétés, et d’autres frameworks ont d’autres approches bien développées pour l’hydratation avec les Signaux, avec différents compromis. Nous pensons qu’il est possible de modéliser les Signaux résumables de Qwik en utilisant un Signal State et un Signal Computed reliés ensemble, et nous prévoyons de le prouver en code.",
  "status": "ok"
}