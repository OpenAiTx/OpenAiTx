{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "L’`état` d’un Signal Calculé peut être l’un des suivants :\n\n- `~clean~` : La valeur du Signal est présente et connue pour ne pas être obsolète.\n- `~checked~` : Une source (indirecte) de ce Signal a changé ; ce Signal a une valeur mais elle _peut_ être obsolète. On ne saura si elle est effectivement obsolète que lorsque toutes les sources immédiates auront été évaluées.\n- `~computing~` : Le callback de ce Signal est actuellement en cours d’exécution suite à un appel `.get()`.\n- `~dirty~` : Ce Signal a soit une valeur connue pour être obsolète, soit il n’a jamais été évalué.\n\nLe graphe de transition est le suivant :\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nLes transitions sont :\n| Numéro | De | À | Condition | Algorithme |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | Une source immédiate de ce signal, qui est un signal calculé, a été évaluée et sa valeur a changé. | Algorithme : recalculer un signal calculé obsolète |\n| 2 | `~clean~` | `~dirty~` | Une source immédiate de ce signal, qui est un State, a été définie avec une valeur différente de sa précédente valeur. | Méthode : `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | Une source récursive, mais pas immédiate, de ce signal, qui est un State, a été définie avec une valeur différente de sa précédente valeur. | Méthode : `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | On est sur le point d’exécuter le `callback`. | Algorithme : recalculer un signal calculé obsolète |\n| 5 | `~computing~` | `~clean~` | Le `callback` a terminé son évaluation et a soit retourné une valeur, soit levé une exception. | Algorithme : recalculer un signal calculé obsolète |\n| 6 | `~checked~` | `~clean~` | Toutes les sources immédiates de ce signal ont été évaluées, et toutes ont été découvertes inchangées, donc on sait maintenant qu’il n’est pas obsolète. | Algorithme : recalculer un signal calculé obsolète |\n\n#### Slots internes de `Signal.Computed`\n\n- `value` : La précédente valeur en cache du Signal, ou `~uninitialized~` pour un Signal calculé jamais lu. La valeur peut être une exception qui sera relancée lors de la lecture de la valeur. Toujours `undefined` pour les effect signals.\n- `state` : Peut être `~clean~`, `~checked~`, `~computing~` ou `~dirty~`.\n- `sources` : Un ensemble ordonné de Signaux dont dépend ce Signal.\n- `sinks` : Un ensemble ordonné de Signaux qui dépendent de ce Signal.\n- `equals` : La méthode d’égalité fournie dans les options.\n- `callback` : Le callback appelé pour obtenir la valeur du Signal calculé. Défini au premier paramètre passé au constructeur.\n\n#### Constructeur de `Signal.Computed`\n\nLe constructeur définit :\n- `callback` à son premier paramètre\n- `equals` basé sur les options, par défaut à `Object.is` si absent\n- `state` à `~dirty~`\n- `value` à `~uninitialized~`\n\nAvec [AsyncContext](https://github.com/tc39/proposal-async-context), le callback passé à `new Signal.Computed` ferme sur le snapshot du moment de l’appel du constructeur, et restaure ce snapshot pendant son exécution.\n\n#### Méthode : `Signal.Computed.prototype.get`\n\n1. Si le contexte d’exécution courant est `frozen` ou si ce Signal a l’état `~computing~`, ou si ce signal est un Watcher et `computing` un Signal calculé, lever une exception.\n1. Si `computing` n’est pas `null`, ajouter ce Signal à l’ensemble `sources` de `computing`.\n1. REMARQUE : On n’ajoute pas `computing` à l’ensemble `sinks` de ce Signal tant qu’il n’est pas observé par un Watcher.\n1. Si l’état de ce Signal est `~dirty~` ou `~checked~` : Répéter les étapes suivantes jusqu’à ce que ce Signal soit `~clean~` :\n    1. Remonter via `sources` pour trouver la source récursive la plus profonde et la plus à gauche (c’est-à-dire la première observée) qui est un Signal Calculé marqué `~dirty~` (arrêter la recherche en atteignant un Signal Calculé `~clean~`, et inclure ce Signal Calculé comme dernier à chercher).\n    1. Exécuter l’algorithme « recalculer un signal calculé obsolète » sur ce Signal.\n1. À ce stade, l’état de ce Signal sera `~clean~`, et aucune source récursive ne sera `~dirty~` ni `~checked~`. Retourner la `value` du Signal. Si la valeur est une exception, relancer cette exception.\n\n### La classe `Signal.subtle.Watcher`\n\n#### Machine à états de `Signal.subtle.Watcher`\n\nL’`état` d’un Watcher peut être l’un des suivants :\n\n- `~waiting~` : Le callback `notify` a été exécuté, ou le Watcher est nouveau, mais il ne surveille activement aucun signal.\n- `~watching~` : Le Watcher surveille activement des signaux, mais aucun changement n’a encore eu lieu nécessitant un callback `notify`.\n- `~pending~` : Une dépendance du Watcher a changé, mais le callback `notify` n’a pas encore été exécuté.\n\nLe graphe de transition est le suivant :\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nLes transitions sont :\n| Numéro | De | À | Condition | Algorithme |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | La méthode `watch` du Watcher a été appelée. | Méthode : `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | La méthode `unwatch` du Watcher a été appelée et le dernier signal surveillé a été supprimé. | Méthode : `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | Un signal surveillé a pu changer de valeur. | Méthode : `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | Le callback `notify` a été exécuté. | Méthode : `Signal.State.prototype.set(newValue)` |\n\n#### Slots internes de `Signal.subtle.Watcher`\n\n- `state` : Peut être `~watching~`, `~pending~` ou `~waiting~`\n- `signals` : Un ensemble ordonné de Signaux surveillés par ce Watcher\n- `notifyCallback` : Le callback appelé lorsqu’un changement se produit. Défini au premier paramètre passé au constructeur.\n\n#### Constructeur : `new Signal.subtle.Watcher(callback)`\n\n1. `state` est initialisé à `~waiting~`.\n1. Initialiser `signals` comme un ensemble vide.\n1. `notifyCallback` est défini au paramètre callback.",
  "status": "ok"
}