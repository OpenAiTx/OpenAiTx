{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q**: Signals는 React와 같은 단방향 데이터 플로우와 함께 작동합니까?\n\n**A**: 네, Signals는 단방향 데이터 플로우를 위한 메커니즘입니다. Signal 기반 UI 프레임워크는 모델(여기서 모델은 Signals를 포함합니다)의 함수로 뷰를 표현할 수 있게 해줍니다. 상태와 계산된 Signals의 그래프는 구조적으로 비순환적입니다. Signals 내에서 React의 안티패턴을 재현하는 것도 가능합니다(!), 예를 들어, `useEffect` 내의 `setState`에 해당하는 Signal 방식은 Watcher를 사용하여 State signal에 쓰기를 예약하는 것입니다.\n\n**Q**: signals는 Redux와 같은 상태 관리 시스템과 어떤 관련이 있습니까? signals는 비구조화된 상태를 조장합니까?\n\n**A**: Signals는 저장소와 유사한 상태 관리 추상화의 효율적인 기반이 될 수 있습니다. 여러 프레임워크에서 공통적으로 발견되는 패턴은 내부적으로 속성을 Signals로 표현하는 Proxy 기반 객체입니다. 예를 들어, [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive) 또는 [Solid stores](https://docs.solidjs.com/concepts/stores)가 이에 해당합니다. 이러한 시스템은 특정 애플리케이션에 적합한 추상화 수준에서 상태를 유연하게 그룹화할 수 있게 해줍니다.\n\n**Q**: Signals가 현재 `Proxy`가 처리하지 못하는 점은 무엇입니까?\n\n**A**: Proxy와 Signals는 상호 보완적이며 함께 잘 작동합니다. Proxy는 얕은 객체 조작을 가로채는 역할을 하고, Signals는 의존성 그래프(셀의 그래프)를 조정합니다. Proxy를 Signals로 지원하는 것은 뛰어난 사용성을 가진 중첩 반응형 구조를 만드는 훌륭한 방법입니다.\n\n이 예시에서 Proxy를 사용하면 signal에 `get` 및 `set` 메서드 대신 getter 및 setter 속성을 부여할 수 있습니다:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// 가상의 반응형 컨텍스트에서의 사용 예시:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\n세밀한 반응성을 위해 최적화된 렌더러를 사용할 때, 버튼을 클릭하면 `b.value` 셀이 업데이트됩니다.\n\n참고:\n- Signals와 Proxies를 모두 사용하여 생성된 중첩 반응형 구조의 예시: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- 반응형 데이터와 프록시 간의 관계를 보여주는 이전 구현 예시: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [논의](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Signals는 어떻게 작동합니까?\n\n**Q**: Signals는 push 기반입니까, pull 기반입니까?\n\n**A**: 계산된 Signals의 평가 방식은 pull 기반입니다: 계산된 Signal은 `.get()`이 호출될 때만 평가되며, 해당 상태가 훨씬 이전에 변경되었더라도 마찬가지입니다. 동시에, State signal을 변경하면 Watcher의 콜백이 즉시 트리거되어 알림이 \"푸시\"될 수 있습니다. 따라서 Signals는 \"push-pull\" 방식으로 볼 수 있습니다.\n\n**Q**: Signals는 JavaScript 실행에 비결정성을 도입합니까?\n\n**A**: 아닙니다. 우선, 모든 Signal 연산은 명확하게 정의된 의미와 순서를 가지며, 규격을 준수하는 구현 간에 차이가 없습니다. 더 높은 수준에서 Signals는 일정한 불변성을 따르며, 이에 관해서 \"sound\"합니다. 계산된 Signal은 항상 Signal 그래프를 일관된 상태로 관찰하며, 그 실행은 다른 Signal을 변형하는 코드에 의해 중단되지 않습니다(단, 자신이 직접 호출하는 경우는 예외). 위의 설명을 참고하세요.\n\n**Q**: 상태 Signal에 쓸 때, 계산된 Signal의 업데이트는 언제 예약됩니까?\n\n**A**: 예약되지 않습니다! 계산된 Signal은 누군가가 읽을 때 다음 번에 스스로 재계산됩니다. 동기적으로, Watcher의 `notify` 콜백이 호출되어 프레임워크가 적절하다고 판단되는 시점에 읽기를 예약할 수 있습니다.\n\n**Q**: 상태 Signal에 대한 쓰기는 언제 반영됩니까? 즉시입니까, 아니면 배치됩니까?\n\n**A**: 상태 Signal에 대한 쓰기는 즉시 반영됩니다. 해당 State signal에 의존하는 계산된 Signal이 다음 번에 읽힐 때, 필요하다면 바로 재계산됩니다. 이는 코드의 바로 다음 줄이라도 마찬가지입니다. 다만, 이 메커니즘의 지연 특성(계산된 Signal은 읽힐 때만 계산됨)으로 인해 실제로는 계산이 일괄적으로 일어날 수 있습니다.\n\n**Q**: Signals가 \"glitch-free\" 실행을 가능하게 한다는 것은 무슨 의미입니까?\n\n**A**: 이전의 push 기반 반응형 모델은 중복 계산 문제에 직면했습니다. 상태 Signal의 업데이트가 계산된 Signal을 즉시 실행하게 하면, 결국 UI에 업데이트가 푸시됩니다. 하지만 만약 다음 프레임 전에 원본 상태 Signal에 또 다른 변경이 있을 예정이라면, 이 UI로의 쓰기는 시기상조일 수 있습니다. 때로는 이러한 [glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)로 인해 최종 사용자에게 부정확한 중간 값이 표시되기도 했습니다. Signals는 push 기반이 아니라 pull 기반이기 때문에 이러한 현상을 방지합니다. 프레임워크가 UI 렌더링을 예약할 때 적절한 업데이트를 pull하여, 계산 및 DOM에 쓰는 과정 모두에서 불필요한 낭비를 피할 수 있습니다.\n\n**Q**: Signals가 \"lossy\"하다는 것은 무슨 의미입니까?\n\n**A**: 이것은 glitch-free 실행의 이면입니다. Signals는 데이터의 셀, 즉 즉각적인 현재 값(변할 수 있음)만을 나타냅니다. 시간에 따른 데이터 스트림을 나타내지 않습니다. 따라서 상태 Signal에 연달아 두 번 쓴다면, 아무 일도 하지 않고 첫 번째 쓰기는 \"유실\"되어 어떤 계산된 Signal이나 효과에서도 관측되지 않습니다. 이는 버그가 아니라 의도된 기능입니다. 스트림에는 (예: async iterables, observables)과 같은 다른 구조가 더 적합합니다.\n\n**Q**: 네이티브 Signals가 기존 JS Signal 구현보다 더 빠를까요?\n\n**A**: 그렇기를 기대합니다(작은 상수 배 정도), 하지만 이것은 실제 코드에서 증명되어야 합니다. JS 엔진도 마법은 아니며, 궁극적으로 JS로 구현된 Signals와 유사한 알고리즘을 구현해야 합니다. 성능에 관한 위의 섹션을 참고하세요.\n\n#### Signals가 이렇게 설계된 이유는 무엇입니까?\n\n**Q**: 효과(effect)가 Signals의 실질적 사용에 반드시 필요한데, 왜 이 제안에는 `effect()` 함수가 포함되어 있지 않습니까?\n\n**A**: 효과는 본질적으로 스케줄링 및 해제(disposal)와 연결되며, 이는 프레임워크가 관리하는 영역이고 이 제안의 범위를 벗어납니다. 대신, 이 제안은 더 저수준의 `Signal.subtle.Watcher` API를 통해 효과를 구현하는 기반을 제공합니다.\n\n**Q**: 수동 인터페이스를 제공하지 않고 구독이 자동인 이유는 무엇입니까?\n\n**A**: 반응형 프로그래밍에서 수동 구독 인터페이스는 사용성이 떨어지고 오류를 유발하기 쉽다는 경험적 교훈이 있습니다. 자동 추적은 더 조합성이 높으며, Signals의 핵심 기능입니다.\n\n**Q**: `Watcher`의 콜백이 마이크로태스크에 예약되지 않고 동기적으로 실행되는 이유는 무엇입니까?\n\n**A**: 콜백이 Signals를 읽거나 쓸 수 없기 때문에, 동기적으로 호출되어도 불합리한 점이 없습니다. 일반적인 콜백은 읽을 Signal을 배열에 추가하거나, 어딘가의 비트를 마킹하는 용도로 사용됩니다. 이러한 동작마다 별도의 마이크로태스크를 만드는 것은 불필요하며 비실용적으로 비쌉니다.\n\n**Q**: 이 API에는 Signals로 프로그래밍하기 쉽게 만들어주는 내가 좋아하는 프레임워크의 기능이 누락되어 있습니다. 이런 것도 표준에 추가할 수 있습니까?\n\n**A**: 아마도요. 다양한 확장이 여전히 논의 중입니다. 중요하다고 생각되는 누락된 기능이 있다면 이슈를 등록해 논의를 제안해 주세요.\n\n**Q**: 이 API를 더 작거나 단순하게 줄일 수 있을까요?\n\n**A**: 이 API를 최소한으로 유지하는 것이 분명한 목표이며, 위에서 제시한 내용이 그 결과입니다. 더 줄일 수 있는 아이디어가 있다면 이슈를 등록해 논의해 주세요.\n\n#### Signals는 어떻게 표준화되고 있습니까?\n\n**Q**: 이 분야의 표준화 작업을 observables와 같은 더 원시적인 개념으로 시작해야 하지 않나요?",
  "status": "ok"
}