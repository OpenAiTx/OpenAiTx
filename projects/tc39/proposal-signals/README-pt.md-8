{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**Q**: Os Signals funcionam com fluxo de dados unidirecional, como o React?\n\n**A**: Sim, Signals são um mecanismo para fluxo de dados unidirecional. Frameworks de UI baseados em Signals permitem que você expresse sua visualização como uma função do modelo (onde o modelo incorpora Signals). Um grafo de estado e Signals computados é acíclico por construção. Também é possível recriar antipadrões do React dentro dos Signals (!), por exemplo, o equivalente ao `setState` dentro do `useEffect` é usar um Watcher para agendar uma escrita em um Signal de estado.\n\n**Q**: Como os signals se relacionam com sistemas de gerenciamento de estado como Redux? Signals incentivam estado não estruturado?\n\n**A**: Signals podem formar uma base eficiente para abstrações de gerenciamento de estado semelhantes a stores. Um padrão comum encontrado em vários frameworks é um objeto baseado em Proxy que internamente representa propriedades usando Signals, por exemplo, [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), ou [Solid stores](https://docs.solidjs.com/concepts/stores). Esses sistemas permitem o agrupamento flexível do estado no nível certo de abstração para a aplicação em questão.\n\n**Q**: O que os Signals oferecem que o `Proxy` atualmente não lida?\n\n**A**: Proxies e Signals são complementares e funcionam bem juntos. Proxies permitem interceptar operações superficiais de objeto e signals coordenam um grafo de dependências (de células). Usar um Proxy respaldado por Signals é uma ótima maneira de criar uma estrutura reativa aninhada com excelente ergonomia.\n\nNeste exemplo, podemos usar um proxy para fazer com que o signal tenha uma propriedade getter e setter em vez de usar os métodos `get` e `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// uso em um contexto reativo hipotético:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nao usar um renderizador que é otimizado para reatividade de grão fino, clicar no botão fará com que a célula `b.value` seja atualizada.\n\nVeja:\n- exemplos de estruturas reativas aninhadas criadas com Signals e Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- exemplo de implementações anteriores mostrando a relação entre dados reativos e proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussão](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### Como os Signals funcionam?\n\n**Q**: Signals são baseados em push ou pull?\n\n**A**: A avaliação de Signals computados é baseada em pull: Signals computados só são avaliados quando `.get()` é chamado, mesmo que o estado subjacente tenha mudado muito antes. Ao mesmo tempo, mudar um Signal de estado pode imediatamente acionar o callback de um Watcher, \"empurrando\" a notificação. Portanto, Signals podem ser considerados uma construção \"push-pull\".\n\n**Q**: Signals introduzem não determinismo na execução do JavaScript?\n\n**A**: Não. Para começar, todas as operações de Signal têm semânticas e ordenações bem definidas, e não diferirão entre implementações compatíveis. Em um nível mais alto, Signals seguem um certo conjunto de invariantes, em relação aos quais são \"corretos\". Um Signal computado sempre observa o grafo de Signals em um estado consistente, e sua execução não é interrompida por outro código que muta Signals (exceto pelas chamadas dele próprio). Veja a descrição acima.\n\n**Q**: Quando escrevo em um Signal de estado, quando a atualização do Signal computado é agendada?\n\n**A**: Não é agendada! O Signal computado irá se recalcular na próxima vez que alguém o ler. Síncronamente, o callback `notify` de um Watcher pode ser chamado, permitindo que frameworks agendem uma leitura no momento que acharem apropriado.\n\n**Q**: Quando as escritas em Signals de estado têm efeito? Imediatamente ou são agrupadas?\n\n**A**: Escritas em Signals de estado são refletidas imediatamente — na próxima vez que um Signal computado que depende do Signal de estado for lido, ele se recalculará se necessário, mesmo que seja na linha de código imediatamente seguinte. No entanto, a preguiça inerente a esse mecanismo (de que Signals computados só são calculados quando lidos) significa que, na prática, os cálculos podem ocorrer de forma agrupada.\n\n**Q**: O que significa Signals possibilitarem execução \"livre de glitches\"?\n\n**A**: Modelos anteriores baseados em push para reatividade enfrentaram o problema de computação redundante: se uma atualização em um Signal de estado faz com que o Signal computado execute imediatamente, isso pode acabar forçando uma atualização na UI. Mas essa escrita na UI pode ser prematura, se houver outra mudança no Signal de estado original antes do próximo frame. Às vezes, valores intermediários imprecisos eram até mostrados aos usuários finais devido a esses [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals evitam essa dinâmica por serem baseados em pull, e não em push: no momento em que o framework agenda o render da UI, ele irá buscar as atualizações apropriadas, evitando trabalho desperdiçado tanto na computação quanto na escrita no DOM.\n\n**Q**: O que significa Signals serem \"lossy\" (com perda)?\n\n**A**: Esse é o outro lado da execução livre de glitches: Signals representam uma célula de dados — apenas o valor atual imediato (que pode mudar), não um fluxo de dados ao longo do tempo. Então, se você escrever duas vezes seguidas em um Signal de estado, sem fazer mais nada, a primeira escrita é \"perdida\" e nunca será vista por qualquer Signal computado ou efeito. Isso é entendido como uma funcionalidade e não um bug — outros construtos (por exemplo, iteráveis assíncronos, observables) são mais apropriados para fluxos.\n\n**Q**: Signals nativos serão mais rápidos do que implementações JS de Signals já existentes?\n\n**A**: Esperamos que sim (por um pequeno fator constante), mas isso ainda precisa ser comprovado em código. Engines JS não são mágicas, e no final precisarão implementar o mesmo tipo de algoritmos das implementações JS de Signals. Veja a seção acima sobre performance.\n\n#### Por que os Signals são projetados desse jeito?\n\n**Q**: Por que esta proposta não inclui uma função `effect()`, se efeitos são necessários para qualquer uso prático de Signals?\n\n**A**: Efeitos estão inerentemente ligados a agendamento e descarte, que são gerenciados por frameworks e estão fora do escopo desta proposta. Em vez disso, esta proposta inclui a base para implementação de efeitos através da API de mais baixo nível `Signal.subtle.Watcher`.\n\n**Q**: Por que as assinaturas são automáticas ao invés de fornecer uma interface manual?\n\n**A**: A experiência mostrou que interfaces de assinatura manual para reatividade são pouco ergonômicas e propensas a erros. O rastreamento automático é mais composicional e é uma funcionalidade central dos Signals.\n\n**Q**: Por que o callback do `Watcher` roda de forma síncrona, e não agendada em uma microtask?\n\n**A**: Porque o callback não pode ler ou escrever em Signals, não há inconsistências causadas por chamá-lo de forma síncrona. Um callback típico irá adicionar um Signal a um Array para ser lido depois, ou marcar um bit em algum lugar. Não é necessário e seria impraticavelmente caro criar uma microtask separada para todas essas ações.\n\n**Q**: Está faltando nesta API algumas coisas legais que meu framework favorito fornece, e que facilitam programar com Signals. Isso pode ser adicionado ao padrão também?\n\n**A**: Talvez. Várias extensões ainda estão em consideração. Por favor, abra uma issue para discutir qualquer funcionalidade que achar importante e que esteja faltando.\n\n**Q**: Esta API pode ser reduzida em tamanho ou complexidade?\n\n**A**: Definitivamente é um objetivo manter esta API mínima, e tentamos fazer isso com o que foi apresentado acima. Se você tiver ideias de mais coisas que podem ser removidas, por favor, abra uma issue para discutir.\n\n#### Como os Signals estão sendo padronizados?\n\n**Q**: Não deveríamos começar o trabalho de padronização nesta área com um conceito mais primitivo, como observables?",
  "status": "ok"
}