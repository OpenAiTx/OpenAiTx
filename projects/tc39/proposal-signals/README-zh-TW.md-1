{
  "id": 1,
  "origin": "# 🚦 JavaScript Signals standard proposal🚦\n<img align=right src=\"Signals.svg\" alt=\"Signals logo\" width=100>\n\nStage 1 ([explanation](https://tc39.es/process-document/))\n\nTC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg\n\nOriginal authors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript, similar to the Promises/A+ effort which preceded the Promises standardized by TC39 in ES2015. Try it for yourself, using [a polyfill](https://github.com/proposal-signals/signal-polyfill).\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript ecosystem. If this alignment is successful, then a standard could emerge, based on that experience. Several framework authors are collaborating here on a common model which could back their reactivity core. The current draft is based on design input from the authors/maintainers of [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/), [FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/), [Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/), [Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a), and more…\n\nDifferently from Promises/A+, we're not trying to solve for a common developer-facing surface API, but rather the precise core semantics of the underlying signal graph. This proposal does include a fully concrete API, but the API is not targeted to most application developers. Instead, the signal API here is a better fit for frameworks to build on top of, providing interoperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including integration into several frameworks, before advancing beyond Stage 1. We are only interested in standardizing Signals if they are suitable for use in practice in multiple frameworks, and provide real benefits over framework-provided signals. We hope that significant early prototyping will give us this information. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application developers need to store, compute, invalidate, sync, and push state to the application's view layer in an efficient way. UIs commonly involve more than just managing simple values, but often involve rendering computed state which is dependent on a complex tree of other values or state that is also computed itself. The goal of Signals is to provide infrastructure for managing such application state so developers can focus on business logic rather than these repetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI contexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating in applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, `counter`, you want to render into the DOM whether the counter is even or odd. Whenever the `counter` changes, you want to update the DOM with the latest parity. In Vanilla JS, you might have something like this:\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// Simulate external updates to counter...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> Globals are used here for demonstration purposes only. Proper state management has many solutions, and the examples in this proposal are meant to be as minimal as possible. This proposal does not encourage global variables.\n\n\nThis has a number of problems...\n\n* The `counter` setup is noisy and boilerplate-heavy.\n* The `counter` state is tightly coupled to the rendering system.\n* If the `counter` changes but `parity` does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n* What if another part of our UI just wants to render when the `counter` updates?\n* What if another part of our UI is dependent on `isEven` or `parity` alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We could try to work around these by introducing pub/sub for the `counter`. This would allow additional consumers of the `counter` could subscribe to add their own reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n* The render function, which is only dependent on `parity` must instead \"know\" that it actually needs to subscribe to `counter`.\n* It isn't possible to update UI based on either `isEven` or `parity` alone, without directly interacting with `counter`.\n* We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to `counter` but also to `isEven` and `parity`. We would then have to subscribe `isEven` to `counter`,  `parity` to `isEven`, and `render` to `parity`. Unfortunately, not only has our boilerplate code exploded, but we're stuck with a ton of bookkeeping of subscriptions, and a potential memory leak disaster if we don't properly clean everything up in the right way. So, we've solved some issues but created a whole new category of problems and a lot of code. To make matters worse, we have to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to UI frameworks across multiple programming languages, despite the absence of any such mechanism built into JS or the web platform. Within JS frameworks and libraries, there has been a large amount of experimentation across different ways to represent this binding, and experience has shown the power of one-way data flow in conjunction with a first-class data type representing a cell of state or computation derived from other data, now often called \"Signals\".\nThis first-class reactive value approach seems to have made its first popular appearance in open-source JavaScript web frameworks with [Knockout](https://knockoutjs.com/) [in 2010](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/). In the years since, many variations and implementations have been created. Within the last 3-4 years, the Signal primitive and related approaches have gained further traction, with nearly every modern JavaScript library or framework having something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined with a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// A library or framework defines effects based on other Signal primitives\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// Simulate external updates to counter...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\nThere are a few things we can see right away:\n* We've eliminated the noisy boilerplate around the `counter` variable from our previous example.\n* There is a unified API to handle values, computations, and side effects.\n* There's no circular reference problem or upside down dependencies between `counter` and `render`.\n* There are no manual subscriptions, nor is there any need for bookkeeping.\n* There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API though:",
  "translate": "# 🚦 JavaScript Signals 標準提案 🚦\n<img align=right src=\"https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg\" alt=\"Signals logo\" width=100>\n\n第一階段（[說明](https://tc39.es/process-document/)）\n\nTC39 提案推動者：Daniel Ehrenberg、Yehuda Katz、Jatin Ramanathan、Shay Lewis、Kristen Hewell Garrett、Dominic Gannaway、Preston Sego、Milo M、Rob Eisenberg\n\n原始作者：Rob Eisenberg 和 Daniel Ehrenberg\n\n本文檔描述了 JavaScript 中 signals 的早期共識方向，類似於 Promises/A+ 的努力，該標準在 ES2015 中由 TC39 標準化為 Promises。你可以使用 [polyfill](https://github.com/proposal-signals/signal-polyfill) 親自試用。\n\n與 Promises/A+ 類似，本次努力聚焦於協調 JavaScript 生態系統。如果這種協調成功，便有可能基於這些經驗誕生一項標準。多個框架作者正在這裡合作，共同建立一個可支援其反應核心的通用模型。目前草案基於 [Angular](https://angular.io/)、[Bubble](https://bubble.io/)、[Ember](https://emberjs.com/)、[FAST](https://www.fast.design/)、[MobX](https://mobx.js.org/)、[Preact](https://preactjs.com/)、[Qwik](https://qwik.dev/)、[RxJS](https://rxjs.dev/)、[Solid](https://www.solidjs.com/)、[Starbeam](https://www.starbeamjs.com/)、[Svelte](https://svelte.dev/)、[Vue](https://vuejs.org/)、[Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a) 等作者/維護者的設計反饋，以及更多...\n\n與 Promises/A+ 不同的是，我們並不試圖解決一個面向開發者的共通 API，而是精確釐清底層 signal graph 的核心語意。本提案確實包含一個具體的 API，但這個 API 並不是針對大多數應用開發者設計的。相反，這裡的 signal API 更適合框架在其之上構建，通過共通的 signal graph 和自動追蹤機制實現互操作性。\n\n本提案計畫在進入下一階段前，進行大量早期原型驗證，包括整合進多個框架中。我們只會在 Signals 能夠實際適用於多個框架並且能夠帶來實質超越框架自身 signals 的優勢時，才考慮標準化。希望透過大量早期原型驗證取得這些資訊。詳情請見下方「狀態與開發計畫」。\n\n## 背景：為什麼需要 Signals？\n\n為了開發複雜的使用者介面（UI），JavaScript 應用程式開發者需要有效地儲存、計算、失效、同步，並將狀態推送到應用程式的視圖層。UI 通常不僅僅是管理單一值，還常常涉及渲染取決於複雜樹狀結構的計算狀態，而這些狀態本身也可能來自其他計算。Signals 的目標是為這類應用狀態管理提供基礎設施，讓開發者可以專注於業務邏輯，而非這些重複性的細節。\n\n類似 signal 的結構在非 UI 場景下也被證明非常有用，特別是在建構系統（build systems）中用來避免不必要的重建。\n\nSignals 在反應式程式設計中用來消除應用程式中手動更新的需求。\n\n> 一種基於狀態變化進行更新的宣告式程式設計模型。\n\n摘自 _[What is Reactivity?](https://www.pzuraq.com/blog/what-is-reactivity)_。\n\n#### 範例 - 原生 JS 計數器\n\n給定一個變數 `counter`，你想在 DOM 中渲染這個計數器是偶數還是奇數。每當 `counter` 改變時，你希望用最新的奇偶性更新 DOM。在原生 JS 中，可能會這麼寫：\n\n```js\nlet counter = 0;\nconst setCounter = (value) => {\n  counter = value;\n  render();\n};\n\nconst isEven = () => (counter & 1) == 0;\nconst parity = () => isEven() ? \"even\" : \"odd\";\nconst render = () => element.innerText = parity();\n\n// 模擬外部對 counter 的更新...\nsetInterval(() => setCounter(counter + 1), 1000);\n```\n> [!NOTE]  \n> 這裡為示範目的而使用全域變數。正確的狀態管理有很多解決方案，本提案中的範例旨在盡可能精簡。此提案並不鼓勵使用全域變數。\n\n這樣寫有以下幾個問題...\n\n* `counter` 的設置繁瑣且樣板程式碼多。\n* `counter` 狀態與渲染系統高度耦合。\n* 如果 `counter` 改變但 `parity` 沒有（例如 counter 從 2 變為 4），則我們做了不必要的 parity 計算和渲染。\n* 如果我們的 UI 另一部分只想在 `counter` 更新時渲染怎麼辦？\n* 如果我們的 UI 另一部分只依賴於 `isEven` 或 `parity` 呢？\n\n即使在這種相對簡單的情境下，也會很快出現許多問題。我們可以嘗試通過對 `counter` 引入 pub/sub（發布/訂閱）來解決。這樣可以讓更多 `counter` 的消費者訂閱以新增自己的狀態變更反應。\n\n然而，仍然存在以下問題：\n\n* 渲染函式僅依賴於 `parity`，卻必須「知道」實際上需要訂閱 `counter`。\n* 若想只根據 `isEven` 或 `parity` 來更新 UI，不直接與 `counter` 互動是不可能的。\n* 樣板程式碼變多了。每次使用時，不只是呼叫函式或讀取變數，而是還要訂閱並在那裡做更新。管理退訂也特別複雜。\n\n現在，我們可以不僅給 `counter`，也給 `isEven` 和 `parity` 加入 pub/sub。然後必須讓 `isEven` 訂閱 `counter`、`parity` 訂閱 `isEven`、`render` 訂閱 `parity`。不幸的是，我們的樣板程式碼爆炸了，而且還要維護大量訂閱紀錄，如果沒妥善清理，還可能導致記憶體洩漏災難。於是，雖然解決了一些問題，卻又產生了全新類型的問題和大量程式碼。更糟的是，系統中每一個狀態都要經歷這一套。\n\n### Signals 介紹\n\n在 UI 框架中，模型與視圖的資料繫結抽象一直是多種程式語言 UI 框架的核心，儘管 JS 或 Web 平台本身未內建這類機制。在 JS 框架與函式庫內，有大量關於如何表示這種繫結的實驗，經驗證明，單向資料流與一個作為一等公民的資料類型（代表某個狀態單元或由其他資料推導出的計算單元，現在常稱為「Signal」）結合，有極大的威力。\n這種一等公民的反應值方法，似乎最早在 2010 年 [Knockout](https://knockoutjs.com/) [開源 JavaScript Web 框架](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/) 中流行起來。此後，產生了許多不同的變體與實作。在過去 3-4 年間，Signal 原語與相關方法獲得更多關注，幾乎每個現代 JavaScript 函式庫或框架都有類似概念，名稱各異。\n\n要了解 Signals，讓我們以 Signal API（詳見下文）重構上述範例。\n\n#### 範例 - Signals 計數器\n\n```js\nconst counter = new Signal.State(0);\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconst parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\");\n\n// 函式庫或框架根據其他 Signal 原語定義副作用\ndeclare function effect(cb: () => void): (() => void);\n\neffect(() => element.innerText = parity.get());\n\n// 模擬外部對 counter 的更新...\nsetInterval(() => counter.set(counter.get() + 1), 1000);\n```\n\n我們可以立刻看出幾點：\n\n* 已經消除了前例中 `counter` 變數周圍的繁雜樣板。\n* 有一個統一的 API 來處理值、計算和副作用。\n* 不再有 `counter` 與 `render` 之間的循環參考問題或顛倒的依賴關係。\n* 不需手動訂閱，也無需額外的紀錄管理。\n* 有控制副作用時機/排程的手段。\n\nSignals 帶來的好處，遠不止 API 表面看到的這些：",
  "status": "ok"
}