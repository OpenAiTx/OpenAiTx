{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Tunjukkan contoh mengonversi sebuah Observable menjadi sebuah computed signal, yang hanya berlangganan ketika digunakan oleh sebuah efek\n\nTODO: Tunjukkan contoh sebuah computed signal yang merepresentasikan hasil dari fetch yang diarahkan ke sebuah state, yang dapat dibatalkan\n\n### Introspeksi untuk SSR\n\nTODO: Tunjukkan bagaimana proses serialisasi grafik signal bekerja\n\nTODO: Tunjukkan bagaimana Anda dapat \"menghidupkan kembali\" (hydrate) sebuah signal dari state ke computed di kemudian hari, menggunakan beberapa signal.\n-->\n\n### Diabaikan untuk saat ini\n\nFitur-fitur ini mungkin akan ditambahkan nanti, namun tidak termasuk dalam draft saat ini. Penghilangan ini disebabkan oleh kurangnya konsensus yang mapan di ruang desain antar framework, serta kemampuan yang telah terbukti untuk mengatasi ketidakhadiran mereka dengan mekanisme di atas konsep Signals yang dijelaskan dalam dokumen ini. Namun, sayangnya, penghilangan ini membatasi potensi interoperabilitas antar framework. Seiring dengan diproduksinya prototipe Signals seperti yang dijelaskan dalam dokumen ini, akan ada upaya untuk meninjau kembali apakah penghilangan ini adalah keputusan yang tepat.\n\n* **Async**: Signals selalu tersedia secara sinkron untuk evaluasi, dalam model ini. Namun, sering kali berguna untuk memiliki proses asinkron tertentu yang menyebabkan sebuah signal diset, dan untuk mengetahui kapan sebuah signal masih dalam keadaan \"loading\". Salah satu cara sederhana untuk memodelkan keadaan loading adalah dengan pengecualian (exception), dan perilaku caching exception pada computed signal cukup masuk akal dikombinasikan dengan teknik ini. Teknik yang lebih baik dibahas di [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: Untuk transisi antar tampilan, sering kali berguna untuk mempertahankan status aktif untuk kedua state \"from\" dan \"to\". State \"to\" dirender di latar belakang, hingga siap untuk diubah (commit transaction), sementara state \"from\" tetap interaktif. Mempertahankan kedua state secara bersamaan memerlukan \"forking\" state dari grafik signal, dan mungkin juga berguna untuk mendukung beberapa transisi yang sedang berjalan sekaligus. Diskusi di [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nBeberapa [metode kemudahan](https://github.com/proposal-signals/proposal-signals/issues/32) juga dihilangkan.\n\n## Status dan rencana pengembangan\n\nProposal ini ada dalam agenda TC39 April 2024 untuk Tahap 1. Saat ini dapat dianggap sebagai \"Tahap 0\".\n\n[Sebuah polyfill](https://github.com/proposal-signals/signal-polyfill) untuk proposal ini tersedia, dengan beberapa pengujian dasar. Beberapa penulis framework telah mulai bereksperimen dengan mengganti implementasi signal ini, namun penggunaannya masih dalam tahap awal.\n\nKolaborator pada proposal Signal ingin menjadi sangat **konservatif** dalam mendorong proposal ini ke depan, agar tidak terjebak dalam situasi di mana sesuatu sudah dirilis namun akhirnya disesali dan tidak benar-benar digunakan. Rencana kami adalah melakukan tugas-tugas tambahan berikut, yang tidak diwajibkan oleh proses TC39, untuk memastikan bahwa proposal ini berada di jalur yang benar:\n\nSebelum mengajukan ke Tahap 2, kami berencana untuk:\n- Mengembangkan beberapa implementasi polyfill tingkat produksi yang solid, diuji dengan baik (misalnya, lulus pengujian dari berbagai framework serta pengujian bergaya test262), dan kompetitif dalam hal performa (sebagaimana diverifikasi dengan rangkaian benchmark signal/framework yang menyeluruh).\n- Mengintegrasikan API Signal yang diusulkan ke dalam sejumlah besar framework JS yang kami anggap cukup representatif, dan beberapa aplikasi besar bekerja dengan dasar ini. Menguji bahwa ia bekerja secara efisien dan benar dalam konteks-konteks tersebut.\n- Memiliki pemahaman yang solid tentang ruang kemungkinan ekstensi API, dan telah menyimpulkan mana (jika ada) yang harus ditambahkan ke proposal ini.\n\n## Algoritme Signal\n\nBagian ini menjelaskan masing-masing API yang diekspos ke JavaScript, dalam hal algoritme yang mereka implementasikan. Ini dapat dianggap sebagai proto-spesifikasi, dan disertakan pada tahap awal ini untuk menentukan satu set kemungkinan semantik, sambil tetap sangat terbuka untuk perubahan.\n\nBeberapa aspek dari algoritme:\n- Urutan pembacaan Signal dalam sebuah computed itu signifikan, dan dapat diamati dalam urutan callback tertentu (yang mana `Watcher` dipanggil, `equals`, parameter pertama ke `new Signal.Computed`, dan callback `watched`/`unwatched`) dieksekusi. Artinya, sumber dari computed Signal harus disimpan secara berurutan.\n- Keempat callback ini semuanya mungkin melempar pengecualian, dan pengecualian ini diteruskan dengan cara yang dapat diprediksi ke kode JS pemanggil. Pengecualian *tidak* menghentikan eksekusi algoritme ini atau membuat grafik dalam keadaan setengah proses. Untuk error yang dilempar dalam callback `notify` dari Watcher, pengecualian tersebut dikirim ke pemanggilan `.set()` yang memicunya, menggunakan AggregateError jika beberapa pengecualian dilempar. Yang lainnya (termasuk `watched`/`unwatched`?) disimpan dalam nilai Signal, untuk dilempar ulang saat dibaca, dan Signal yang dilempar ulang seperti itu dapat ditandai `~clean~` seperti halnya dengan nilai normal lainnya.\n- Perhatian diberikan untuk menghindari sirkularitas dalam kasus computed signal yang tidak \"watched\" (diamati oleh Watcher manapun), sehingga dapat dikoleksi sampah (garbage collected) secara independen dari bagian lain grafik signal. Secara internal, ini dapat diimplementasikan dengan sistem nomor generasi yang selalu dikoleksi; perlu dicatat bahwa implementasi yang dioptimalkan mungkin juga mencakup nomor generasi lokal per-node, atau menghindari pelacakan beberapa nomor pada signal yang sedang diawasi.\n\n### Status global tersembunyi\n\nAlgoritme Signal perlu mereferensikan status global tertentu. Status ini bersifat global untuk seluruh thread, atau \"agent\".\n\n- `computing`: Computed atau Effect Signal terdalam yang sedang dievaluasi ulang karena pemanggilan `.get` atau `.run`, atau `null`. Awalnya `null`.\n- `frozen`: Boolean yang menunjukkan apakah saat ini ada callback yang sedang dieksekusi yang mengharuskan grafik tidak dimodifikasi. Awalnya `false`.\n- `generation`: Integer yang meningkat, mulai dari 0, digunakan untuk melacak seberapa mutakhir sebuah nilai sambil menghindari sirkularitas.\n\n### Namespace `Signal`\n\n`Signal` adalah objek biasa yang berfungsi sebagai namespace untuk kelas dan fungsi terkait Signal.\n\n`Signal.subtle` adalah objek namespace dalam yang serupa.\n\n### Kelas `Signal.State`\n\n#### Slot internal `Signal.State`\n\n- `value`: Nilai saat ini dari state signal\n- `equals`: Fungsi pembanding yang digunakan saat mengubah nilai\n- `watched`: Callback yang dipanggil ketika signal mulai diamati oleh efek\n- `unwatched`: Callback yang dipanggil ketika signal tidak lagi diamati oleh efek\n- `sinks`: Set dari signal yang sedang diawasi yang bergantung pada signal ini\n\n#### Konstruktor: `Signal.State(initialValue, options)`\n\n1. Set nilai `value` Signal ini ke `initialValue`.\n1. Set `equals` Signal ini ke options?.equals\n1. Set `watched` Signal ini ke options?.[Signal.subtle.watched]\n1. Set `unwatched` Signal ini ke options?.[Signal.subtle.unwatched]\n1. Set `sinks` Signal ini ke set kosong\n\n#### Metode: `Signal.State.prototype.get()`\n\n1. Jika `frozen` bernilai true, lempar pengecualian.\n1. Jika `computing` tidak `undefined`, tambahkan Signal ini ke set `sources` milik `computing`.\n1. CATATAN: Kita tidak menambahkan `computing` ke set `sinks` Signal ini sampai diawasi oleh Watcher.\n1. Kembalikan nilai `value` Signal ini.\n\n#### Metode: `Signal.State.prototype.set(newValue)`\n\n1. Jika konteks eksekusi saat ini adalah `frozen`, lempar pengecualian.\n1. Jalankan algoritme \"set Signal value\" dengan Signal ini dan parameter pertama sebagai nilainya.\n1. Jika algoritme tersebut mengembalikan `~clean~`, maka kembalikan undefined.\n1. Set `state` semua `sinks` dari Signal ini menjadi (jika sebuah Computed Signal) `~dirty~` jika sebelumnya bersih, atau (jika sebuah Watcher) `~pending~` jika sebelumnya `~watching~`.\n1. Set `state` semua dependensi Computed Signal dari sinks (secara rekursif) menjadi `~checked~` jika sebelumnya `~clean~` (artinya, biarkan penandaan dirty tetap ada), atau untuk Watcher, `~pending~` jika sebelumnya `~watching~`.\n1. Untuk setiap Watcher yang sebelumnya `~watching~` yang ditemukan dalam pencarian rekursif tersebut, lalu dalam urutan depth-first,\n    1. Set `frozen` menjadi true.\n    1. Panggil callback `notify` mereka (simpan pengecualian yang dilempar, tetapi abaikan nilai pengembalian dari `notify`).\n    1. Kembalikan `frozen` menjadi false.\n    1. Set `state` Watcher menjadi `~waiting~`.\n1. Jika ada pengecualian yang dilempar dari callback `notify`, propagasikan ke pemanggil setelah semua callback `notify` dijalankan. Jika ada beberapa pengecualian, maka gabungkan menjadi AggregateError dan lempar itu.\n1. Kembalikan undefined.\n\n### Kelas `Signal.Computed`\n\n#### State machine `Signal.Computed`",
  "status": "ok"
}