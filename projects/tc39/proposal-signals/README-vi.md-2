{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **Theo dõi phụ thuộc tự động** - Một Signal tính toán sẽ tự động phát hiện bất kỳ Signal nào khác mà nó phụ thuộc vào, cho dù các Signal đó là giá trị đơn giản hay các phép tính khác.\n* **Đánh giá lười (Lazy Evaluation)** - Các phép tính không được đánh giá ngay khi chúng được khai báo, cũng như không được đánh giá ngay lập tức khi các phụ thuộc của chúng thay đổi. Chúng chỉ được đánh giá khi giá trị của chúng được yêu cầu rõ ràng.\n* **Ghi nhớ (Memoization)** - Các Signal tính toán lưu vào bộ nhớ đệm giá trị cuối cùng của chúng để các phép tính không có thay đổi trong phụ thuộc sẽ không cần được đánh giá lại, dù chúng được truy cập bao nhiêu lần đi nữa.\n\n## Động lực tiêu chuẩn hóa Signals\n\n#### Tương tác lẫn nhau (Interoperability)\n\nMỗi triển khai Signal đều có cơ chế theo dõi tự động riêng, để theo dõi các nguồn được phát hiện khi đánh giá một Signal tính toán. Điều này gây khó khăn trong việc chia sẻ mô hình, thành phần, và thư viện giữa các framework khác nhau -- chúng thường bị ràng buộc giả tạo với engine hiển thị của chúng (vì Signals thường được triển khai như một phần của các framework JS).\n\nMục tiêu của đề xuất này là tách biệt hoàn toàn mô hình phản ứng khỏi phần hiển thị, cho phép các nhà phát triển chuyển đổi sang công nghệ hiển thị mới mà không phải viết lại mã không liên quan đến UI, hoặc phát triển các mô hình phản ứng dùng chung trong JS để triển khai ở các ngữ cảnh khác nhau. Thật không may, do vấn đề phiên bản và trùng lặp, việc đạt được mức độ chia sẻ cao thông qua các thư viện ở cấp độ JS là không khả thi -- các built-in mang lại đảm bảo chia sẻ mạnh mẽ hơn.\n\n#### Hiệu năng/Sử dụng bộ nhớ\n\nLuôn luôn có một chút cải thiện hiệu năng tiềm năng khi gửi ít mã hơn nhờ các thư viện thường dùng được tích hợp sẵn, nhưng các triển khai của Signals nhìn chung khá nhỏ, nên chúng tôi không kỳ vọng hiệu ứng này quá lớn.\n\nChúng tôi nghi ngờ rằng các triển khai gốc C++ cho các cấu trúc dữ liệu và thuật toán liên quan đến Signal có thể hiệu quả hơn một chút so với những gì đạt được trong JS, ở mức hệ số không đổi. Tuy nhiên, không có thay đổi về thuật toán nào được dự kiến so với những gì có trong polyfill; các engine không được kỳ vọng sẽ làm phép thuật ở đây, và các thuật toán phản ứng tự thân sẽ được định nghĩa rõ ràng và không mơ hồ.\n\nNhóm đề xuất dự kiến sẽ phát triển nhiều triển khai Signals khác nhau, và sử dụng chúng để nghiên cứu các khả năng hiệu năng này.\n\n#### DevTools\n\nVới các thư viện Signal ở ngôn ngữ JS hiện tại, có thể rất khó để truy vết các vấn đề như:\n* Callstack xuyên suốt chuỗi các Signal tính toán, thể hiện chuỗi nguyên nhân cho một lỗi\n* Đồ thị tham chiếu giữa các Signal, khi một cái phụ thuộc vào cái khác -- quan trọng khi gỡ lỗi sử dụng bộ nhớ\n\nCác Signal tích hợp sẵn cho phép các runtime JS và DevTools có thể hỗ trợ tốt hơn cho việc kiểm tra Signal, đặc biệt là cho việc gỡ lỗi hoặc phân tích hiệu năng, dù là được tích hợp vào trình duyệt hay thông qua tiện ích mở rộng dùng chung. Các công cụ hiện có như trình kiểm tra phần tử, snapshot hiệu năng, và bộ phân tích bộ nhớ có thể được cập nhật để làm nổi bật các Signal trong cách trình bày thông tin của chúng.\n\n#### Lợi ích phụ\n\n##### Lợi ích của thư viện chuẩn\n\nNói chung, JavaScript có một thư viện chuẩn khá tối giản, nhưng một xu hướng trong TC39 là biến JS thành một ngôn ngữ \"kèm pin\", với tập chức năng chất lượng cao, tích hợp sẵn. Ví dụ, Temporal đang thay thế moment.js, và một số tính năng nhỏ như `Array.prototype.flat` và `Object.groupBy` đang thay thế nhiều trường hợp dùng lodash. Lợi ích bao gồm kích thước bundle nhỏ hơn, tăng độ ổn định và chất lượng, ít thứ phải học hơn khi gia nhập dự án mới, và một ngôn ngữ chung phổ biến giữa các lập trình viên JS.\n\n##### Tích hợp HTML/DOM (khả năng tương lai)\n\nCông việc hiện tại ở W3C và các nhà phát triển trình duyệt đang hướng đến việc đưa templating gốc vào HTML ([DOM Parts][wicg-pr-1023] và [Template Instantiation][wicg-propsal-template-instantiation]). Thêm vào đó, W3C Web Components CG đang khám phá khả năng mở rộng Web Components để cung cấp API HTML hoàn toàn khai báo. Để đạt được cả hai mục tiêu này, cuối cùng HTML sẽ cần một primitive phản ứng. Ngoài ra, có thể tưởng tượng và cộng đồng cũng đã yêu cầu nhiều cải tiến về trải nghiệm sử dụng DOM thông qua tích hợp Signal.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Lưu ý, việc tích hợp này sẽ là một nỗ lực riêng đến sau, không thuộc phạm vi đề xuất này.\n\n##### Trao đổi thông tin hệ sinh thái (*không* phải lý do để đưa vào chuẩn)\n\nNỗ lực tiêu chuẩn hóa đôi khi có thể hữu ích chỉ ở cấp độ \"cộng đồng\", ngay cả khi không có thay đổi trên trình duyệt. Dự án Signals đang tập hợp nhiều tác giả framework khác nhau để thảo luận sâu về bản chất phản ứng, thuật toán và khả năng tương tác. Điều này đã có ích, nhưng không biện minh cho việc đưa vào các engine JS và trình duyệt; Signals chỉ nên được thêm vào tiêu chuẩn JavaScript nếu có lợi ích đáng kể *vượt ngoài* trao đổi thông tin hệ sinh thái mà nó mang lại.\n\n## Mục tiêu thiết kế cho Signals\n\nHóa ra các thư viện Signal hiện tại ở cốt lõi không khác biệt quá nhiều với nhau. Đề xuất này hướng đến việc xây dựng trên thành công của chúng bằng cách triển khai các phẩm chất quan trọng của nhiều thư viện đó.\n\n### Tính năng cốt lõi\n\n* Một kiểu Signal đại diện cho trạng thái, tức Signal có thể ghi. Đây là một giá trị mà các thành phần khác có thể đọc.\n* Một kiểu Signal tính toán/memo/derived, phụ thuộc vào Signal khác và được tính toán lười biếng và lưu cache.\n    * Tính toán là lười biếng, nghĩa là các Signal tính toán sẽ không được tính lại mặc định khi một trong các phụ thuộc thay đổi, mà chỉ chạy khi có ai đó thật sự đọc chúng.\n    * Tính toán \"không glitch\" ([glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free), nghĩa là không có phép tính không cần thiết nào được thực hiện. Điều này ngụ ý rằng, khi một ứng dụng đọc một Signal tính toán, sẽ có một phép sắp xếp topo các phần có khả năng \"bẩn\" trong đồ thị để loại bỏ bất kỳ sự lặp lại nào.\n    * Tính toán được lưu cache, nghĩa là nếu sau lần cuối cùng một phụ thuộc thay đổi mà không có phụ thuộc nào thay đổi tiếp, thì Signal tính toán *không* được tính lại khi truy cập.\n    * Có thể so sánh tùy chỉnh cho cả Signal tính toán lẫn Signal trạng thái, để xác định khi nào các Signal tính toán phụ thuộc vào chúng nên được cập nhật.\n* Phản ứng với tình huống khi một Signal tính toán có một trong các phụ thuộc (hoặc phụ thuộc lồng nhau) trở nên \"bẩn\" và thay đổi, nghĩa là giá trị của Signal có thể đã lỗi thời.\n    * Phản ứng này nhằm mục đích lên lịch thực hiện công việc quan trọng hơn sau đó.\n    * Các hiệu ứng được triển khai dựa trên các phản ứng này, cộng với logic lên lịch ở cấp framework.\n    * Các Signal tính toán cần có khả năng phản ứng với việc liệu chúng có được đăng ký làm phụ thuộc (lồng nhau) của một trong các phản ứng này hay không.\n* Cho phép các framework JS tự lên lịch công việc của mình. Không ép buộc lên lịch kiểu Promise.\n    * Phản ứng đồng bộ là cần thiết để cho phép lên lịch công việc dựa trên logic framework.\n    * Việc ghi là đồng bộ và có hiệu lực ngay lập tức (một framework muốn batch các ghi có thể làm điều đó ở tầng trên).\n    * Có thể tách kiểm tra xem một hiệu ứng có thể \"bẩn\" hay không khỏi việc thực thi hiệu ứng (cho phép scheduler hiệu ứng hai giai đoạn).\n* Có khả năng đọc Signals *mà không* kích hoạt ghi nhận phụ thuộc (`untrack`)\n* Cho phép kết hợp các codebase khác nhau sử dụng Signals/reactivity, ví dụ:\n    * Sử dụng nhiều framework cùng lúc về mặt theo dõi/phản ứng (trừ các thiếu sót, xem bên dưới)\n    * Các cấu trúc dữ liệu phản ứng độc lập framework (ví dụ, proxy store đệ quy, Map, Set, Array phản ứng,...)\n\n### Tính đúng đắn (Soundness)\n\n* Ngăn ngừa/giới hạn việc lạm dụng phản ứng đồng bộ một cách ngây thơ.\n    * Rủi ro về tính đúng đắn: Có thể phát sinh \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" nếu dùng không đúng: Nếu render được thực hiện ngay khi một Signal được set, có thể làm lộ trạng thái ứng dụng chưa hoàn chỉnh cho người dùng cuối. Do đó, tính năng này chỉ nên được dùng để lên lịch công việc thông minh cho sau này, sau khi logic ứng dụng đã hoàn tất.\n    * Giải pháp: Không cho phép đọc và ghi bất kỳ Signal nào bên trong callback phản ứng đồng bộ\n* Hạn chế `untrack` và đánh dấu bản chất không an toàn của nó\n    * Rủi ro về tính đúng đắn: cho phép tạo Signal tính toán mà giá trị phụ thuộc vào các Signal khác, nhưng không được cập nhật khi các Signal đó thay đổi. Chỉ nên dùng khi các truy cập không được theo dõi sẽ không làm thay đổi kết quả phép tính.\n    * Giải pháp: API được đánh dấu \"unsafe\" trong tên gọi.\n* Lưu ý: Đề xuất này cho phép các signal vừa được đọc vừa được ghi từ các signal tính toán và hiệu ứng, mà không giới hạn việc ghi sau khi đọc, dù có rủi ro về tính đúng đắn. Quyết định này nhằm bảo toàn tính linh hoạt và khả năng tương thích khi tích hợp với các framework.\n\n### API bề mặt (Surface API)\n\n* Phải là nền tảng vững chắc để nhiều framework triển khai cơ chế Signals/reactivity của mình.\n    * Nên là nền tảng tốt cho các proxy store đệ quy, reactivity trường lớp dựa trên decorator, và cả các API kiểu `.value` cũng như `[state, setState]`.\n    * Ngữ nghĩa đủ sức biểu đạt các mẫu hợp lệ mà các framework cho phép. Ví dụ, các Signal này nên có thể là nền tảng cho cả các ghi nhận phản ánh ngay lập tức hoặc các ghi nhận batch và áp dụng sau.\n* Sẽ thật tốt nếu API này có thể được dùng trực tiếp bởi lập trình viên JavaScript.\n    * Nếu một tính năng trùng khớp với một khái niệm trong hệ sinh thái, sử dụng từ vựng chung là tốt.\n        * Tuy nhiên, quan trọng là không nên sao chép y nguyên tên gọi!\n    * Căng thẳng giữa \"dễ dùng cho dev JS\" và \"cung cấp đầy đủ hook cho framework\"\n        * Ý tưởng: Cung cấp đầy đủ hook, nhưng báo lỗi khi dùng sai nếu có thể.\n        * Ý tưởng: Đặt các API tinh vi vào namespace `subtle`, giống như [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), để phân biệt giữa các API cần thiết cho các trường hợp nâng cao (như xây framework hoặc dev tools) với các trường hợp dùng hằng ngày như khởi tạo signals dùng cùng framework.\n* Có thể triển khai và sử dụng với hiệu năng tốt -- API bề mặt không gây quá nhiều overhead\n    * Hỗ trợ kế thừa, để các framework có thể thêm method và field riêng, kể cả field private. Điều này quan trọng để tránh phải cấp phát thêm ở tầng framework. Xem \"Quản lý bộ nhớ\" bên dưới.\n\n### Quản lý bộ nhớ\n\n* Nếu có thể: Một Signal tính toán nên có thể bị thu hồi bộ nhớ (garbage collect) nếu không còn tham chiếu nào còn sống đến nó cho các lần đọc sau này, kể cả khi nó vẫn còn liên kết trong một đồ thị rộng hơn (ví dụ, bằng cách đọc một state vẫn còn sống).",
  "status": "ok"
}