{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Mostrar un ejemplo de cómo convertir un Observable en una señal computada, suscrita solo cuando es utilizada por un efecto\n\nTODO: Mostrar un ejemplo de una señal computada que representa el resultado de un fetch dirigido a un estado, que es cancelado\n\n### Introspección para SSR\n\nTODO: Mostrar cómo funciona la serialización del grafo de señales\n\nTODO: Mostrar cómo se puede \"hidratar\" una señal de estado a computada más tarde, usando algunas señales.\n-->\n\n### Omitido por ahora\n\nEstas características pueden añadirse más adelante, pero no están incluidas en el borrador actual. Su omisión se debe a la falta de consenso establecido en el espacio de diseño entre los frameworks, así como a la capacidad demostrada de solventar su ausencia mediante mecanismos adicionales sobre la noción de señales descrita en este documento. Sin embargo, desafortunadamente, la omisión limita el potencial de interoperabilidad entre frameworks. A medida que se produzcan prototipos de señales tal como se describen en este documento, se hará un esfuerzo por reexaminar si estas omisiones fueron la decisión adecuada.\n\n* **Async**: Las señales siempre están disponibles de forma síncrona para su evaluación, en este modelo. Sin embargo, es frecuentemente útil contar con ciertos procesos asíncronos que llevan a que una señal sea establecida, y poder comprender cuándo una señal aún está \"cargando\". Una forma simple de modelar el estado de carga es mediante excepciones, y el comportamiento de almacenamiento en caché de excepciones de las señales computadas compone de manera razonable con esta técnica. Se discuten técnicas mejoradas en el [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transacciones**: Para transiciones entre vistas, a menudo es útil mantener un estado activo tanto para el estado \"de\" como para el estado \"a\". El estado \"a\" se renderiza en segundo plano, hasta que esté listo para intercambiarse (comprometer la transacción), mientras que el estado \"de\" permanece interactivo. Mantener ambos estados al mismo tiempo requiere \"bifurcar\" el estado del grafo de señales, e incluso puede ser útil admitir múltiples transiciones pendientes a la vez. Discusión en el [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nAlgunos posibles [métodos de conveniencia](https://github.com/proposal-signals/proposal-signals/issues/32) también han sido omitidos.\n\n## Estado y plan de desarrollo\n\nEsta propuesta está en la agenda de TC39 de abril de 2024 para la Etapa 1. Actualmente puede considerarse como \"Etapa 0\".\n\n[Un polyfill](https://github.com/proposal-signals/signal-polyfill) para esta propuesta está disponible, con algunas pruebas básicas. Algunos autores de frameworks han comenzado a experimentar con sustituir esta implementación de señales, pero este uso está en una etapa inicial.\n\nLos colaboradores en la propuesta de señales quieren ser especialmente **conservadores** en cómo impulsamos esta propuesta, para evitar caer en la trampa de aprobar algo que terminemos lamentando y no usemos realmente. Nuestro plan es realizar las siguientes tareas adicionales, no requeridas por el proceso de TC39, para asegurarnos de que esta propuesta esté en el camino correcto:\n\nAntes de proponer para la Etapa 2, planeamos:\n- Desarrollar múltiples implementaciones de polyfill de nivel de producción que sean sólidas, bien probadas (por ejemplo, pasando pruebas de varios frameworks así como pruebas estilo test262), y competitivas en términos de rendimiento (como se verifique con un conjunto exhaustivo de benchmarks de señales/frameworks).\n- Integrar la API de señales propuesta en un gran número de frameworks JS que consideremos representativos, y que algunas aplicaciones grandes funcionen con esta base. Probar que funciona de manera eficiente y correcta en estos contextos.\n- Tener una comprensión sólida sobre el espacio de posibles extensiones para la API, y haber concluido cuáles (si hay alguna) deberían añadirse a esta propuesta.\n\n## Algoritmos de señales\n\nEsta sección describe cada una de las APIs expuestas a JavaScript, en términos de los algoritmos que implementan. Esto puede considerarse como una proto-especificación, y se incluye en este punto temprano para precisar un posible conjunto de semánticas, estando muy abiertos a cambios.\n\nAlgunos aspectos del algoritmo:\n- El orden de lectura de señales dentro de una computada es significativo y es observable en el orden en que se ejecutan ciertos callbacks (cuál `Watcher` es invocado, `equals`, el primer parámetro de `new Signal.Computed`, y los callbacks `watched`/`unwatched`). Esto significa que las fuentes de una señal computada deben almacenarse ordenadas.\n- Estos cuatro callbacks pueden lanzar excepciones, y estas excepciones se propagan de manera predecible al código JS que las llama. Las excepciones *no* detienen la ejecución de este algoritmo ni dejan el grafo en un estado medio procesado. Para los errores lanzados en el callback `notify` de un Watcher, esa excepción se envía a la llamada `.set()` que la disparó, usando un AggregateError si se lanzaron varias excepciones. Las demás (incluyendo `watched`/`unwatched`?) se almacenan en el valor de la señal, para ser relanzadas al leerlas, y una señal que relanza así puede marcarse como `~clean~` igual que cualquier otra con un valor normal.\n- Se tiene cuidado de evitar circularidades en los casos de señales computadas que no están \"observadas\" (siendo observadas por algún Watcher), para que puedan ser recolectadas por el recolector de basura independientemente de otras partes del grafo de señales. Internamente, esto puede implementarse con un sistema de números de generación que siempre se recolectan; cabe señalar que las implementaciones optimizadas también pueden incluir números de generación locales por nodo, o evitar el rastreo de algunos números en señales observadas.\n\n### Estado global oculto\n\nLos algoritmos de señales necesitan hacer referencia a cierto estado global. Este estado es global para todo el hilo, o \"agente\".\n\n- `computing`: La señal computada o de efecto más interna que actualmente está siendo reevaluada debido a una llamada `.get` o `.run`, o `null`. Inicialmente `null`.\n- `frozen`: Booleano que indica si hay un callback actualmente ejecutándose que requiere que el grafo no sea modificado. Inicialmente `false`.\n- `generation`: Un entero incremental, comenzando en 0, usado para rastrear cuán actual es un valor mientras se evitan circularidades.\n\n### El espacio de nombres `Signal`\n\n`Signal` es un objeto ordinario que sirve como espacio de nombres para clases y funciones relacionadas con señales.\n\n`Signal.subtle` es un objeto de espacio de nombres interno similar.\n\n### La clase `Signal.State`\n\n#### Slots internos de `Signal.State`\n\n- `value`: El valor actual de la señal de estado\n- `equals`: La función de comparación usada al cambiar valores\n- `watched`: El callback que se llama cuando la señal pasa a ser observada por un efecto\n- `unwatched`: El callback que se llama cuando la señal deja de ser observada por un efecto\n- `sinks`: Conjunto de señales observadas que dependen de esta\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Establece el `value` de esta señal a `initialValue`.\n1. Establece el `equals` de esta señal a options?.equals\n1. Establece el `watched` de esta señal a options?.[Signal.subtle.watched]\n1. Establece el `unwatched` de esta señal a options?.[Signal.subtle.unwatched]\n1. Establece el `sinks` de esta señal como el conjunto vacío\n\n#### Método: `Signal.State.prototype.get()`\n\n1. Si `frozen` es true, lanza una excepción.\n1. Si `computing` no es `undefined`, agrega esta señal al conjunto `sources` de `computing`.\n1. NOTA: No agregamos `computing` al conjunto `sinks` de esta señal hasta que sea observada por un Watcher.\n1. Devuelve el `value` de esta señal.\n\n#### Método: `Signal.State.prototype.set(newValue)`\n\n1. Si el contexto de ejecución actual es `frozen`, lanza una excepción.\n1. Ejecuta el algoritmo \"establecer valor de señal\" con esta señal y el primer parámetro como valor.\n1. Si ese algoritmo devolvió `~clean~`, entonces retorna undefined.\n1. Establece el estado de todos los `sinks` de esta señal a (si es una señal Computed) `~dirty~` si estaban previamente limpios, o (si es un Watcher) `~pending~` si estaba previamente `~watching~`.\n1. Establece el estado de todas las dependencias Computed Signal de los sinks (recursivamente) a `~checked~` si estaban previamente `~clean~` (es decir, deja las marcas sucias en su lugar), o para Watchers, `~pending~` si previamente `~watching~`.\n1. Para cada Watcher previamente `~watching~` encontrado en esa búsqueda recursiva, luego en orden de profundidad primero,\n    1. Establece `frozen` en true.\n    1. Llama a su callback `notify` (guardando cualquier excepción lanzada, pero ignorando el valor de retorno de `notify`).\n    1. Restaura `frozen` a false.\n    1. Establece el estado del Watcher a `~waiting~`.\n1. Si alguna excepción fue lanzada desde los callbacks `notify`, propágala al llamador después de que todos los callbacks `notify` hayan sido ejecutados. Si hay múltiples excepciones, agrúpalas en un AggregateError y lánzalo.\n1. Retorna undefined.\n\n### La clase `Signal.Computed`\n\n#### Máquina de estados de `Signal.Computed`",
  "status": "ok"
}