{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "使用 [AsyncContext](https://github.com/tc39/proposal-async-context) 時，傳遞給 `new Signal.subtle.Watcher` 的回呼函式*不會*閉包構造函式被呼叫時的快照，因此寫入時的上下文資訊是可見的。\n\n#### 方法：`Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. 如果 `frozen` 為 true，則拋出例外。\n1. 如果任一參數不是 signal，則拋出例外。\n1. 將所有參數附加到此物件的 `signals` 末尾。\n1. 對於每一個新監看的 signal，按照從左到右的順序，\n    1. 將此 watcher 作為 `sink` 加入該 signal。\n    1. 如果這是第一個 sink，則遞迴向上加入來源，將該 signal 加為 sink。\n    1. 設定 `frozen` 為 true。\n    1. 如果有 `watched` 回呼函式則呼叫它。\n    1. 將 `frozen` 回復為 false。\n1. 如果 Signal 的 `state` 為 `~waiting~`，則將其設為 `~watching~`。\n\n#### 方法：`Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. 如果 `frozen` 為 true，則拋出例外。\n1. 如果任一參數不是 signal，或不是此 watcher 監看的 signal，則拋出例外。\n1. 對於參數中的每個 signal，按照從左到右的順序，\n    1. 從此 Watcher 的 `signals` 集合中移除該 signal。\n    1. 從該 Signal 的 `sink` 集合中移除此 Watcher。\n    1. 如果該 Signal 的 `sink` 集合已經變為空，則從其所有來源中移除該 Signal 作為 sink。\n    1. 設定 `frozen` 為 true。\n    1. 如果有 `unwatched` 回呼函式則呼叫它。\n    1. 將 `frozen` 回復為 false。\n1. 如果此 watcher 現在沒有 `signals`，且其 `state` 為 `~watching~`，則將其設為 `~waiting~`。\n\n#### 方法：`Signal.subtle.Watcher.prototype.getPending()`\n\n1. 回傳一個陣列，包含 `signals` 中屬於 Computed Signals 且狀態為 `~dirty~` 或 `~pending~` 的子集。\n\n### 方法：`Signal.subtle.untrack(cb)`\n\n1. 令 `c` 為執行環境目前的 `computing` 狀態。\n1. 將 `computing` 設為 null。\n1. 呼叫 `cb`。\n1. 將 `computing` 回復為 `c`（即使 `cb` 拋出例外也如此）。\n1. 回傳 `cb` 的回傳值（如有例外則重新拋出）。\n\n注意：untrack 並不會讓你脫離 `frozen` 狀態，該狀態被嚴格維護。\n\n### 方法：`Signal.subtle.currentComputed()`\n\n1. 回傳目前的 `computing` 值。\n\n### 通用演算法\n\n##### 演算法：重新計算 dirty 的 computed Signal\n\n1. 清空此 Signal 的 `sources` 集合，並從這些來源的 `sinks` 集合中移除此 Signal。\n1. 儲存先前的 `computing` 值，並將 `computing` 設為此 Signal。\n1. 將此 Signal 的狀態設為 `~computing~`。\n1. 執行此 computed Signal 的回呼函式，並以此 Signal 作為 this 值。儲存回傳值，若回呼函式拋出例外，則儲存該例外以便重新拋出。\n1. 回復先前的 `computing` 值。\n1. 對回呼函式的回傳值套用「設定 Signal 值」演算法。\n2. 將此 Signal 的狀態設為 `~clean~`。\n1. 若該演算法回傳 `~dirty~`：將此 Signal 的所有 sink 標記為 `~dirty~`（之前，sink 可能同時有 checked 和 dirty）。(或者，若此 Signal 無 watcher，則採用新的世代編號表示 dirty 狀態，或類似機制。)\n1. 否則，若該演算法回傳 `~clean~`：此時，對於此 Signal 的每個 `~checked~` sink，如果該 Signal 的所有來源現在都是 clean，則同樣將該 Signal 標記為 `~clean~`。對於任何有 checked sink 的新 clean Signal，遞迴地套用此清理步驟於後續 sink。（或者，若無 watcher，則以某種方式標記，以便延遲清理。）\n\n##### 設定 Signal 值演算法\n\n1. 如果此演算法接收到一個值（而不是從重新計算 dirty 的 computed Signal 演算法傳來的需重新拋出的例外）：\n    1. 呼叫此 Signal 的 `equals` 函式，傳入當前的 `value`、新值及此 Signal 作為參數。如果拋出例外，將該例外（供讀取時重新拋出）儲存為 Signal 的值，並繼續如同回呼回傳 false。\n    1. 如果該函式回傳 true，則回傳 `~clean~`。\n1. 將此 Signal 的 `value` 設為傳入參數。\n1. 回傳 `~dirty~`\n\n## 常見問題\n\n**問**：現在就要將 Signals 標準化會不會太早？Signals 才在 2022 年成為熱門話題，難道不該給它們更多時間演化與穩定嗎？\n\n**答**：目前網頁框架中的 Signals 發展，已經是超過十年持續演進的成果。隨著近年投資加速，幾乎所有主流程式框架都在趨近類似的 Signal 核心模型。本提案是眾多網頁框架領導者共同設計的產物，在未獲得各領域專家於不同上下文驗證前，不會推動標準化。\n\n#### Signals 如何被使用？\n\n**問**：內建 Signals 真的能被框架利用嗎？畢竟它們與渲染和所有權綁定很緊密。\n\n**答**：更偏向框架專屬的部分多半在 effects、排程、以及所有權/釋放資源等領域，而這些並非本提案要解決的問題。我們於標準草案 Signals 原型驗證的首要目標，是確認它們能夠在「底層」與既有框架良好兼容且效能優異。\n\n**問**：Signal API 是設計給應用開發者直接用，還是要被框架包裝？\n\n**答**：雖然此 API（至少 `Signal.subtle` 命名空間以外的部分）可以讓應用開發者直接使用，但設計時並未特別追求易用性。反而是以函式庫／框架作者需求為優先。預期多數框架甚至會將最基本的 `Signal.State` 與 `Signal.Computed` API 包裝出更符合自身語法風格的版本。實務上，最佳方式是透過框架使用 Signals，這樣可由框架管理較複雜的功能（如 Watcher、`untrack`），以及所有權與釋放（例如何時將 signals 加入/移出 watcher），和負責排程 DOM 渲染——這些並非本提案要處理的問題。\n\n**問**：當元件銷毀時，我需要手動釋放與該元件相關的 Signals 嗎？有沒有相關 API？\n\n**答**：相關的釋放操作是 `Signal.subtle.Watcher.prototype.unwatch`。僅需釋放被監看的 Signals（透過 unwatch），未被監看的 Signals 可自動被垃圾回收。\n\n**問**：Signals 能和 VDOM 或直接操作底層 HTML DOM 搭配運作嗎？\n\n**答**：可以！Signals 與渲染技術無關。現有使用類 Signal 概念的 JavaScript 框架，已經能和 VDOM（如 Preact）、原生 DOM（如 Solid）、或混合方式（如 Vue）整合。內建 Signals 也能做到相同。\n\n**問**：在像 Angular、Lit 這樣的 class-based 框架裡使用 Signals 會不會不夠順手？像 Svelte 這樣的編譯器型框架呢？\n\n**答**：Class 欄位只要用簡單的 accessor decorator 就能和 Signals 結合，詳見 [Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators)。Signals 和 Svelte 5 的 Runes 極為契合——編譯器只需將 runes 轉換為這裡定義的 Signal API，事實上 Svelte 5 內部就是這麼做（但用自家的 Signals 函式庫）。\n\n**問**：Signals 能和 SSR、Hydration、Resumability 協作嗎？\n\n**答**：可以。Qwik 已經以 Signals 有效支援這些特性，其他框架也有各自成熟的 hydration 策略，權衡不同設計。我們認為可用 State 和 Computed signal 互連來建構 Qwik 的 resumable Signals，並計劃用程式實作驗證這一點。",
  "status": "ok"
}