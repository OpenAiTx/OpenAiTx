{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Toon een voorbeeld van het omzetten van een Observable naar een computed signal, alleen geabonneerd wanneer gebruikt door een effect\n\nTODO: Toon een voorbeeld van een computed signal dat het resultaat van een fetch naar een state weergeeft, welke wordt geannuleerd\n\n### Introspectie voor SSR\n\nTODO: Toon hoe het serialiseren van de signalgraph werkt\n\nTODO: Toon hoe je een signaal kunt \"hydrateren\" van state naar computed later, met behulp van een paar signalen.\n-->\n\n### Voor nu weggelaten\n\nDeze features kunnen later worden toegevoegd, maar zijn niet opgenomen in het huidige concept. Hun weglating is te wijten aan het ontbreken van gevestigde consensus in het ontwerpveld tussen frameworks, evenals het aangetoonde vermogen om hun afwezigheid te omzeilen met mechanismen bovenop het in dit document beschreven Signals-concept. Helaas beperkt de weglating echter de mogelijkheden tot interoperabiliteit tussen frameworks. Naarmate er prototypes van Signals zoals beschreven in dit document worden geproduceerd, zal er worden getracht opnieuw te beoordelen of deze weglatingen de juiste beslissing waren.\n\n* **Async**: Signals zijn in dit model altijd synchroon beschikbaar voor evaluatie. Het is echter vaak handig om bepaalde asynchrone processen te hebben die ertoe leiden dat een signaal wordt ingesteld, en om te begrijpen wanneer een signaal nog steeds \"aan het laden\" is. Een eenvoudige manier om de laadstatus te modelleren is met uitzonderingen, en het exception-caching gedrag van computed signals werkt redelijk samen met deze techniek. Verbeterde technieken worden besproken in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transacties**: Voor overgangen tussen weergaven is het vaak handig om een live state te behouden voor zowel de \"from\"- als \"to\"-status. De \"to\"-status wordt op de achtergrond gerenderd, totdat deze klaar is om over te schakelen (het committen van de transactie), terwijl de \"from\"-status interactief blijft. Het tegelijkertijd behouden van beide statussen vereist het \"forken\" van de status van de signalgraph, en het kan zelfs nuttig zijn om meerdere lopende overgangen tegelijk te ondersteunen. Discussie in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSommige mogelijke [gemaksfuncties](https://github.com/proposal-signals/proposal-signals/issues/32) zijn ook weggelaten.\n\n## Status en ontwikkelplan\n\nDit voorstel staat op de agenda van TC39 van april 2024 voor Stage 1. Het kan momenteel worden beschouwd als \"Stage 0\".\n\n[Een polyfill](https://github.com/proposal-signals/signal-polyfill) voor dit voorstel is beschikbaar, met enkele basistests. Sommige framework-auteurs zijn begonnen te experimenteren met het vervangen van deze signaalimplementatie, maar dit gebruik bevindt zich nog in een vroeg stadium.\n\nDe samenwerkende partijen aan het Signal-voorstel willen bijzonder **conservatief** zijn in hoe we dit voorstel verder brengen, zodat we niet in de val lopen iets te laten landen dat we uiteindelijk betreuren en niet daadwerkelijk gebruiken. Ons plan is om de volgende extra taken uit te voeren, die niet vereist zijn door het TC39-proces, om ervoor te zorgen dat dit voorstel op koers ligt:\n\nVoordat we voorstellen voor Stage 2, zijn we van plan om:\n- Meerdere productieklare polyfill-implementaties te ontwikkelen die solide, goed getest zijn (bijvoorbeeld het slagen voor tests van verschillende frameworks en test262-achtige tests), en concurrerend zijn qua performance (zoals geverifieerd met een grondige signal/framework benchmarkset).\n- De voorgestelde Signal API te integreren in een groot aantal JS-frameworks die we enigszins representatief achten, en enkele grote applicaties hiermee te laten werken. Testen dat het efficiënt en correct werkt in deze contexten.\n- Een goed begrip te hebben van het spectrum van mogelijke uitbreidingen van de API, en te hebben geconcludeerd welke (indien van toepassing) aan dit voorstel moeten worden toegevoegd.\n\n## Signal-algoritmen\n\nDit gedeelte beschrijft elk van de API's die aan JavaScript worden blootgesteld, in termen van de algoritmen die ze implementeren. Dit kan worden beschouwd als een proto-specificatie, en is in dit vroege stadium opgenomen om één mogelijke set van semantiek vast te leggen, terwijl we nog zeer openstaan voor wijzigingen.\n\nEnkele aspecten van het algoritme:\n- De volgorde van het lezen van Signals binnen een computed is significant, en is waarneembaar in de volgorde waarin bepaalde callbacks (zoals `Watcher` wordt aangeroepen, `equals`, de eerste parameter van `new Signal.Computed`, en de `watched`/`unwatched` callbacks) worden uitgevoerd. Dit betekent dat de bronnen van een computed Signal geordend moeten worden opgeslagen.\n- Deze vier callbacks kunnen allemaal uitzonderingen genereren, en deze uitzonderingen worden op een voorspelbare manier doorgegeven aan de aanroepende JS-code. De uitzonderingen stoppen *niet* de uitvoering van dit algoritme of laten de graph in een half-verwerkte staat achter. Voor fouten die worden gegooid in de `notify`-callback van een Watcher, wordt die uitzondering doorgegeven aan de `.set()`-aanroep die deze veroorzaakte, met gebruik van een AggregateError als er meerdere uitzonderingen zijn gegooid. De overige (inclusief `watched`/`unwatched`?) worden opgeslagen in de waarde van het Signal, om opnieuw te worden gegooid bij het lezen, en zo'n opnieuw gegooid Signal kan worden gemarkeerd als `~clean~` net als elk ander met een normale waarde.\n- Er wordt gezorgd dat er geen circulariteit optreedt bij computed signals die niet \"geobserveerd\" worden (niet door een Watcher worden geobserveerd), zodat ze onafhankelijk van andere delen van de signalgraph kunnen worden opgeruimd door de garbage collector. Intern kan dit worden geïmplementeerd met een systeem van generatienummers die altijd worden verzameld; opmerking: geoptimaliseerde implementaties kunnen ook lokale generatienummers per node bevatten, of het bijhouden van sommige nummers op geobserveerde signals vermijden.\n\n### Verborgen globale status\n\nSignal-algoritmen moeten bepaalde globale status raadplegen. Deze status is globaal voor de gehele thread, of \"agent\".\n\n- `computing`: Het binnenste computed of effect Signal dat momenteel opnieuw wordt geëvalueerd door een `.get` of `.run`-aanroep, of `null`. Aanvankelijk `null`.\n- `frozen`: Boolean die aangeeft of er momenteel een callback wordt uitgevoerd waarvoor geldt dat de graph niet mag worden aangepast. Aanvankelijk `false`.\n- `generation`: Een oplopend geheel getal, beginnend bij 0, gebruikt om bij te houden hoe actueel een waarde is, terwijl circulariteit wordt vermeden.\n\n### De `Signal` namespace\n\n`Signal` is een gewoon object dat dient als namespace voor Signal-gerelateerde klassen en functies.\n\n`Signal.subtle` is een vergelijkbaar intern namespace-object.\n\n### De klasse `Signal.State`\n\n#### `Signal.State` interne slots\n\n- `value`: De huidige waarde van het state signal\n- `equals`: De vergelijkingsfunctie die wordt gebruikt bij het wijzigen van waarden\n- `watched`: De callback die wordt aangeroepen wanneer het signaal wordt geobserveerd door een effect\n- `unwatched`: De callback die wordt aangeroepen wanneer het signaal niet langer wordt geobserveerd door een effect\n- `sinks`: Set van geobserveerde signals die afhankelijk zijn van deze\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Stel de `value` van dit Signal in op `initialValue`.\n1. Stel de `equals` van dit Signal in op options?.equals\n1. Stel de `watched` van dit Signal in op options?.[Signal.subtle.watched]\n1. Stel de `unwatched` van dit Signal in op options?.[Signal.subtle.unwatched]\n1. Stel de `sinks` van dit Signal in op de lege set\n\n#### Methode: `Signal.State.prototype.get()`\n\n1. Als `frozen` waar is, gooi een uitzondering.\n1. Als `computing` niet `undefined` is, voeg dit Signal toe aan de `sources` set van `computing`.\n1. OPMERKING: We voegen `computing` pas toe aan de `sinks` set van dit Signal wanneer het wordt geobserveerd door een Watcher.\n1. Geef de `value` van dit Signal terug.\n\n#### Methode: `Signal.State.prototype.set(newValue)`\n\n1. Als de huidige uitvoeringscontext `frozen` is, gooi een uitzondering.\n1. Voer het \"set Signal value\"-algoritme uit met dit Signal en de eerste parameter voor de waarde.\n1. Als dat algoritme `~clean~` retourneerde, geef dan undefined terug.\n1. Zet de `state` van alle `sinks` van dit Signal op (indien het een Computed Signal is) `~dirty~` als ze eerder schoon waren, of (indien het een Watcher is) `~pending~` als het eerder `~watching~` was.\n1. Zet de `state` van alle Computed Signal-afhankelijkheden van de sinks (recursief) op `~checked~` als ze eerder `~clean~` waren (laat dirty-markeringen staan), of voor Watchers, `~pending~` als eerder `~watching~`.\n1. Voor elke eerder `~watching~` Watcher die bij die recursieve zoekopdracht wordt gevonden, in depth-first volgorde,\n    1. Stel `frozen` in op true.\n    1. Roep hun `notify`-callback aan (sla eventuele uitzonderingen op, maar negeer de returnwaarde van `notify`).\n    1. Zet `frozen` terug op false.\n    1. Zet de `state` van de Watcher op `~waiting~`.\n1. Als er een uitzondering is gegooid vanuit de `notify`-callbacks, geef die dan door aan de aanroeper nadat alle `notify`-callbacks zijn uitgevoerd. Als er meerdere uitzonderingen zijn, bundel ze dan samen in een AggregateError en gooi die.\n1. Geef undefined terug.\n\n### De klasse `Signal.Computed`\n\n#### `Signal.Computed` State machine",
  "status": "ok"
}