{
  "id": 6,
  "origin": "\nThe `state` of a Computed Signal may be one of the following:\n\n- `~clean~`: The Signal's value is present and known not to be stale.\n- `~checked~`: An (indirect) source of this Signal has changed; this Signal has a value but it _may_ be stale. Whether or it not is stale will be known only when all immediate sources have been evaluated.\n- `~computing~`: This Signal's callback is currently being executed as a side-effect of a `.get()` call.\n- `~dirty~`: Either this Signal has a value which is known to be stale, or it has never been evaluated.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~checked~` | `~dirty~` | An immediate source of this signal, which is a computed signal, has been evaluated, and its value has changed. | Algorithm: recalculate dirty computed Signal |\n| 2 | `~clean~` | `~dirty~` | An immediate source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | A recursive, but not immediate, source of this signal, which is a State, has been set, with a value which is not equal to its previous value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | We are about to execute the `callback`. | Algorithm: recalculate dirty computed Signal |\n| 5 | `~computing~` | `~clean~` | The `callback` has finished evaluating and either returned a value or thrown an exception. | Algorithm: recalculate dirty computed Signal |\n| 6 | `~checked~` | `~clean~` | All immediate sources of this signal have been evaluated, and all have been discovered unchanged, so we are now known not to be stale. | Algorithm: recalculate dirty computed Signal |\n\n#### `Signal.Computed` Internal slots\n\n- `value`: The previous cached value of the Signal, or `~uninitialized~` for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always `undefined` for effect signals.\n- `state`: May be `~clean~`, `~checked~`, `~computing~`, or `~dirty~`.\n- `sources`: An ordered set of Signals which this Signal depends on.\n- `sinks`: An ordered set of Signals which depend on this Signal.\n- `equals`: The equals method provided in the options.\n- `callback`: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### `Signal.Computed` Constructor\n\nThe constructor sets\n- `callback` to its first parameter\n- `equals` based on options, defaulting to `Object.is` if absent\n- `state` to `~dirty~`\n- `value` to `~uninitialized~`\n\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.Computed` closes over the snapshot from when the constructor was called, and restores this snapshot during its execution.\n\n#### Method: `Signal.Computed.prototype.get`\n\n1. If the current execution context is `frozen` or if this Signal has the state `~computing~`, or if this signal is a Watcher and `computing` a computed Signal, throw an exception.\n1. If `computing` is not `null`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until/unless it becomes watched by a Watcher.\n1. If this Signal's state is `~dirty~` or `~checked~`: Repeat the following steps until this Signal is `~clean~`:\n    1. Recurse up via `sources` to find the deepest, left-most (i.e. earliest observed) recursive source which is a Computed Signal marked `~dirty~` (cutting off search when hitting a `~clean~` Computed Signal, and including this Computed Signal as the last thing to search).\n    1. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n1. At this point, this Signal's state will be `~clean~`, and no recursive sources will be `~dirty~` or `~checked~`. Return the Signal's `value`. If the value is an exception, rethrow that exception.\n\n### The `Signal.subtle.Watcher` class\n\n#### `Signal.subtle.Watcher` State machine\n\nThe `state` of a Watcher may be one of the following:\n\n- `~waiting~`: The `notify` callback has been run, or the Watcher is new, but is not actively watching any signals.\n- `~watching~`: The Watcher is actively watching signals, but no changes have yet happened which would necessitate a `notify` callback.\n- `~pending~`: A dependency of the Watcher has changed, but the `notify` callback has not yet been run.\n\nThe transition graph is as follows:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nThe transitions are:\n| Number | From | To | Condition | Algorithm |\n| ------ | ---- | -- | --------- | --------- |\n| 1 | `~waiting~` | `~watching~` | The Watcher's `watch` method has been called. | Method: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | The Watcher's `unwatch` method has been called, and the last watched signal has been removed. | Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | A watched signal may have changed value. | Method: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | The `notify` callback has been run. | Method: `Signal.State.prototype.set(newValue)` |\n\n#### `Signal.subtle.Watcher` internal slots\n\n- `state`: May be `~watching~`, `~pending~` or `~waiting~`\n- `signals`: An ordered set of Signals which this Watcher is watching\n- `notifyCallback`: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: `new Signal.subtle.Watcher(callback)`\n\n1. `state` is set to `~waiting~`.\n1. Initialize `signals` as an empty set.\n1. `notifyCallback` is set to the callback parameter.",
  "translate": "وضعیت (`state`) یک سیگنال محاسبه‌شده (Computed Signal) می‌تواند یکی از موارد زیر باشد:\n\n- `~clean~`: مقدار سیگنال موجود است و مطمئناً کهنه (stale) نیست.\n- `~checked~`: یک منبع (غیرمستقیم) از این سیگنال تغییر کرده است؛ این سیگنال مقدار دارد اما _ممکن است_ کهنه باشد. اینکه واقعاً کهنه است یا نه فقط زمانی مشخص می‌شود که تمام منابع مستقیم ارزیابی شوند.\n- `~computing~`: فراخوانی بازگشتی این سیگنال هم‌اکنون به عنوان یک اثر جانبی از یک فراخوانی `.get()` در حال اجرا است.\n- `~dirty~`: یا این سیگنال مقدار دارد که مشخصاً کهنه است، یا هرگز ارزیابی نشده است.\n\nنمودار انتقال وضعیت به شرح زیر است:\n\n```mermaid\nstateDiagram-v2\n    [*] --> dirty\n    dirty --> computing: [4]\n    computing --> clean: [5]\n    clean --> dirty: [2]\n    clean --> checked: [3]\n    checked --> clean: [6]\n    checked --> dirty: [1]\n```\n\nانتقال‌ها به شرح زیر است:\n| شماره | از | به | شرط | الگوریتم |\n| ----- | --- | -- | ---- | -------- |\n| 1 | `~checked~` | `~dirty~` | یک منبع مستقیم این سیگنال، که خود یک سیگنال محاسبه‌شده است، ارزیابی شده و مقدارش تغییر کرده است. | الگوریتم: محاسبه مجدد سیگنال محاسبه‌شده‌ی کهنه |\n| 2 | `~clean~` | `~dirty~` | یک منبع مستقیم این سیگنال، که یک State است، با مقداری تنظیم شده که با مقدار قبلی متفاوت است. | متد: `Signal.State.prototype.set(newValue)` |\n| 3 | `~clean~` | `~checked~` | یک منبع بازگشتی (اما نه مستقیم) این سیگنال، که یک State است، با مقداری تنظیم شده که با مقدار قبلی متفاوت است. | متد: `Signal.State.prototype.set(newValue)` |\n| 4 | `~dirty~` | `~computing~` | در شرف اجرای `callback` هستیم. | الگوریتم: محاسبه مجدد سیگنال محاسبه‌شده‌ی کهنه |\n| 5 | `~computing~` | `~clean~` | `callback` ارزیابی را به پایان رسانده و یا مقداری برگردانده یا استثنا پرتاب کرده است. | الگوریتم: محاسبه مجدد سیگنال محاسبه‌شده‌ی کهنه |\n| 6 | `~checked~` | `~clean~` | تمام منابع مستقیم این سیگنال ارزیابی شده‌اند و هیچکدام تغییر نکرده‌اند، بنابراین اکنون مشخص است که سیگنال کهنه نیست. | الگوریتم: محاسبه مجدد سیگنال محاسبه‌شده‌ی کهنه |\n\n#### اسلات‌های داخلی `Signal.Computed`\n\n- `value`: مقدار کش‌شده قبلی سیگنال، یا `~uninitialized~` برای سیگنال محاسبه‌شده‌ای که هرگز خوانده نشده است. مقدار می‌تواند یک استثنا باشد که هنگام خواندن مقدار مجدداً پرتاب می‌شود. برای سیگنال‌های اثر (effect signals) همیشه `undefined` است.\n- `state`: می‌تواند یکی از `~clean~`، `~checked~`، `~computing~` یا `~dirty~` باشد.\n- `sources`: یک مجموعه مرتب از سیگنال‌هایی که این سیگنال به آن‌ها وابسته است.\n- `sinks`: یک مجموعه مرتب از سیگنال‌هایی که به این سیگنال وابسته‌اند.\n- `equals`: متد مقایسه‌ای که در گزینه‌ها ارائه شده است.\n- `callback`: تابعی که برای دریافت مقدار سیگنال محاسبه‌شده فراخوانی می‌شود. به اولین پارامتر سازنده اختصاص داده می‌شود.\n\n#### سازنده‌ی `Signal.Computed`\n\nسازنده موارد زیر را تنظیم می‌کند:\n- `callback` را به اولین پارامتر خود\n- `equals` را بر اساس گزینه‌ها (در صورت نبود، پیش‌فرض `Object.is`)\n- `state` را به `~dirty~`\n- `value` را به `~uninitialized~`\n\nبا [AsyncContext](https://github.com/tc39/proposal-async-context)، تابع callback که به `new Signal.Computed` داده می‌شود، snapshot را از زمانی که سازنده فراخوانی شده، به ارث می‌برد و این snapshot را هنگام اجرا بازمی‌گرداند.\n\n#### متد: `Signal.Computed.prototype.get`\n\n1. اگر کانتکست اجرایی فعلی `frozen` باشد یا این سیگنال وضعیت `~computing~` داشته باشد، یا اگر این سیگنال یک Watcher باشد و در حال `computing` یک سیگنال محاسبه‌شده باشد، یک استثنا پرتاب کن.\n1. اگر `computing` مقدار `null` ندارد، این سیگنال را به مجموعه‌ی `sources` متعلق به `computing` اضافه کن.\n1. توجه: تا زمانی که این سیگنال توسط یک Watcher مشاهده نشود، ما `computing` را به مجموعه‌ی `sinks` این سیگنال اضافه نمی‌کنیم.\n1. اگر وضعیت این سیگنال `~dirty~` یا `~checked~` است: مراحل زیر را تا زمانی که وضعیت این سیگنال `~clean~` شود تکرار کن:\n    1. به وسیله‌ی `sources` بازگشتی بالا برو تا عمیق‌ترین، چپ‌ترین (یعنی زودترین) منبع بازگشتی که یک سیگنال محاسبه‌شده و با وضعیت `~dirty~` است را بیابی (جستجو هنگام رسیدن به سیگنال محاسبه‌شده با وضعیت `~clean~` متوقف می‌شود و این سیگنال محاسبه‌شده به عنوان آخرین مورد جستجو قرار می‌گیرد).\n    1. الگوریتم \"محاسبه مجدد سیگنال محاسبه‌شده‌ی کهنه\" را روی آن سیگنال اجرا کن.\n1. در این نقطه، وضعیت این سیگنال `~clean~` خواهد بود و هیچ منبع بازگشتی `~dirty~` یا `~checked~` نخواهد بود. مقدار سیگنال را بازگردان. اگر مقدار یک استثنا باشد، همان استثنا را مجدداً پرتاب کن.\n\n### کلاس `Signal.subtle.Watcher`\n\n#### ماشین حالت `Signal.subtle.Watcher`\n\nوضعیت (`state`) یک Watcher می‌تواند یکی از موارد زیر باشد:\n\n- `~waiting~`: فراخوانی `notify` اجرا شده، یا Watcher جدید است، اما در حال حاضر هیچ سیگنالی را فعالانه مشاهده نمی‌کند.\n- `~watching~`: Watcher به صورت فعال سیگنال‌هایی را مشاهده می‌کند اما هنوز هیچ تغییری رخ نداده که نیاز به اجرای `notify` داشته باشد.\n- `~pending~`: یکی از وابستگی‌های Watcher تغییر کرده اما فراخوانی `notify` هنوز اجرا نشده است.\n\nنمودار انتقال وضعیت به شرح زیر است:\n\n```mermaid\nstateDiagram-v2\n    [*] --> waiting\n    waiting --> watching: [1]\n    watching --> waiting: [2]\n    watching --> pending: [3]\n    pending --> waiting: [4]\n```\n\nانتقال‌ها به شرح زیر است:\n| شماره | از | به | شرط | الگوریتم |\n| ----- | --- | -- | ---- | -------- |\n| 1 | `~waiting~` | `~watching~` | متد `watch` متعلق به Watcher فراخوانی شده است. | متد: `Signal.subtle.Watcher.prototype.watch(...signals)` |\n| 2 | `~watching~` | `~waiting~` | متد `unwatch` متعلق به Watcher فراخوانی شده و آخرین سیگنال مشاهده‌شده حذف شده است. | متد: `Signal.subtle.Watcher.prototype.unwatch(...signals)` |\n| 3 | `~watching~` | `~pending~` | یک سیگنال مشاهده‌شده ممکن است مقدارش تغییر کرده باشد. | متد: `Signal.State.prototype.set(newValue)` |\n| 4 | `~pending~` | `~waiting~` | فراخوانی `notify` اجرا شده است. | متد: `Signal.State.prototype.set(newValue)` |\n\n#### اسلات‌های داخلی `Signal.subtle.Watcher`\n\n- `state`: می‌تواند `~watching~`، `~pending~` یا `~waiting~` باشد\n- `signals`: یک مجموعه مرتب از سیگنال‌هایی که این Watcher آن‌ها را مشاهده می‌کند\n- `notifyCallback`: تابعی که هنگام رخداد تغییر فراخوانی می‌شود. به اولین پارامتر سازنده اختصاص داده می‌شود.\n\n#### سازنده: `new Signal.subtle.Watcher(callback)`\n\n1. مقدار `state` برابر با `~waiting~` قرار می‌گیرد.\n1. `signals` به عنوان یک مجموعه خالی مقداردهی اولیه می‌شود.\n1. `notifyCallback` به پارامتر callback داده می‌شود.",
  "status": "ok"
}