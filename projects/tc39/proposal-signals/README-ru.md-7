{
  "id": 7,
  "origin": "\nWith [AsyncContext](https://github.com/tc39/proposal-async-context), the callback passed to `new Signal.subtle.Watcher` does *not* close over the snapshot from when the constructor was called, so that contextual information around the write is visible.\n\n#### Method: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, throw an exception.\n1. Append all arguments to the end of this object's `signals`.\n1. For each newly-watched signal, in left-to-right order,\n    1. Add this watcher as a `sink` to that signal.\n    1. If this was the first sink, then recurse up to sources to add that signal as a sink.\n    1. Set `frozen` to true.\n    1. Call the `watched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the Signal's `state` is `~waiting~`, then set it to `~watching~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. If `frozen` is true, throw an exception.\n1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n1. For each signal in the arguments, in left-to-right order,\n    1. Remove that signal from this Watcher's `signals` set.\n    1. Remove this Watcher from that Signal's `sink` set.\n    1. If that Signal's `sink` set has become empty, remove that Signal as a sink from each of its sources.\n    1. Set `frozen` to true.\n    1. Call the `unwatched` callback if it exists.\n    1. Restore `frozen` to false.\n1. If the watcher now has no `signals`, and its `state` is `~watching~`, then set it to `~waiting~`.\n\n#### Method: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Return an Array containing the subset of `signals` which are Computed Signals in the states `~dirty~` or `~pending~`.\n\n### Method: `Signal.subtle.untrack(cb)`\n\n1. Let `c` be the execution context's current `computing` state.\n1. Set `computing` to null.\n1. Call `cb`.\n1. Restore `computing` to `c` (even if `cb` threw an exception).\n1. Return the return value of `cb` (rethrowing any exception).\n\nNote: untrack doesn't get you out of the `frozen` state, which is maintained strictly.\n\n### Method: `Signal.subtle.currentComputed()`\n\n1. Return the current `computing` value.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n1. Clear out this Signal's `sources` set, and remove it from those sources' `sinks` sets.\n1. Save the previous `computing` value and set `computing` to this Signal.\n1. Set this Signal's state to `~computing~`.\n1. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n1. Restore the previous `computing` value.\n1. Apply the \"set Signal value\" algorithm to the callback's return value.\n2. Set this Signal's state to `~clean~`.\n1. If that algorithm returned `~dirty~`: mark all sinks of this Signal as `~dirty~` (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n1. Otherwise, that algorithm returned `~clean~`: In this case, for each `~checked~` sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as `~clean~` as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n    1. Call this Signal's `equals` function, passing as parameters the current `value`, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    1. If that function returned true, return `~clean~`.\n1. Set the `value` of this Signal to the parameter.\n1. Return `~dirty~`\n\n## FAQ\n\n**Q**: Isn't it a little soon to be standardizing something related to Signals, when they just started to be the hot new thing in 2022? Shouldn't we give them more time to evolve and stabilize?\n\n**A**: The current state of Signals in web frameworks is the result of more than 10 years of continuous development. As investment steps up, as it has in recent years, almost all of the web frameworks are approaching a very similar core model of Signals. This proposal is the result of a shared design exercise between a large number of current leaders in web frameworks, and it will not be pushed forward to standardization without the validation of that group of domain experts in various contexts.\n\n#### How are Signals used?\n\n**Q**: Can built-in Signals even be used by frameworks, given their tight integration with rendering and ownership?\n\n**A**: The parts which are more framework-specific tend to be in the area of effects, scheduling, and ownership/disposal, which this proposal does not attempt to solve. Our first priority with prototyping standards-track Signals is to validate that they can sit \"underneath\" existing frameworks compatibly and with good performance.\n\n**Q**: Is the Signal API meant to be used directly by application developers, or wrapped by frameworks?\n\n**A**: While this API could be used directly by application developers (at least the part which is not within the `Signal.subtle` namespace), it is not designed to be especially ergonomic. Instead, the needs of library/framework authors are priorities. Most frameworks are expected to wrap even the basic `Signal.State` and `Signal.Computed` APIs with something expressing their ergonomic slant. In practice, it's typically best to use Signals via a framework, which manages trickier features (e.g., Watcher, `untrack`), as well as managing ownership and disposal (e.g., figuring out when signals should be added to and removed from watchers), and scheduling rendering to DOM--this proposal doesn't attempt to solve those problems.\n\n**Q**: Do I have to tear down Signals related to a widget when that widget is destroyed? What is the API for that?\n\n**A**: The relevant teardown operation here is `Signal.subtle.Watcher.prototype.unwatch`. Only watched Signals need to be cleaned up (by unwatching them), while unwatched Signals can be garbage-collected automatically.\n\n**Q**: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\n**A**: Yes! Signals are independent of rendering technology. Existing JavaScript frameworks which use Signal-like constructs integrate with VDOM (e.g., Preact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same will be possible with built-in Signals.\n\n**Q**: Is it going to be ergonomic to use Signals in the context of class-based frameworks like Angular and Lit? What about compiler-based frameworks like Svelte?\n\n**A**: Class fields can be made Signal-based with a simple accessor decorator, as shown in [the Signal polyfill readme](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Signals are very closely aligned to Svelte 5's Runes--it is simple for a compiler to transform runes to the Signal API defined here, and in fact this is what Svelte 5 does internally (but with its own Signals library).\n\n**Q**: Do Signals work with SSR? Hydration? Resumability?\n\n**A**: Yes. Qwik uses Signals to good effect with both of these properties, and other frameworks have other well-developed approaches to hydration with Signals with different tradeoffs. We think that it is possible to model Qwik's resumable Signals using a State and Computed signal hooked together, and plan to prove this out in code.",
  "translate": "С [AsyncContext](https://github.com/tc39/proposal-async-context) обратный вызов, переданный в `new Signal.subtle.Watcher`, *не* замыкается на снимке состояния в момент вызова конструктора, чтобы контекстная информация вокруг записи оставалась видимой.\n\n#### Метод: `Signal.subtle.Watcher.prototype.watch(...signals)`\n\n1. Если `frozen` истинно, выбросить исключение.\n1. Если какой-либо из аргументов не является сигналом, выбросить исключение.\n1. Добавить все аргументы в конец массива `signals` этого объекта.\n1. Для каждого нового отслеживаемого сигнала, слева направо:\n    1. Добавить этот watcher как `sink` к этому сигналу.\n    1. Если это был первый sink, то рекурсивно пройтись по источникам, чтобы добавить этот сигнал как sink.\n    1. Установить `frozen` в true.\n    1. Вызвать обратный вызов `watched`, если он существует.\n    1. Восстановить `frozen` в false.\n1. Если `state` сигнала — `~waiting~`, то установить его в `~watching~`.\n\n#### Метод: `Signal.subtle.Watcher.prototype.unwatch(...signals)`\n\n1. Если `frozen` истинно, выбросить исключение.\n1. Если какой-либо из аргументов не является сигналом или не отслеживается этим watcher, выбросить исключение.\n1. Для каждого сигнала из аргументов, слева направо:\n    1. Удалить этот сигнал из множества `signals` этого Watcher.\n    1. Удалить этот Watcher из множества `sink` этого сигнала.\n    1. Если множество `sink` этого сигнала стало пустым, удалить этот сигнал как sink из каждого его источника.\n    1. Установить `frozen` в true.\n    1. Вызвать обратный вызов `unwatched`, если он существует.\n    1. Восстановить `frozen` в false.\n1. Если у watcher больше нет сигналов в `signals`, и его `state` — `~watching~`, установить его в `~waiting~`.\n\n#### Метод: `Signal.subtle.Watcher.prototype.getPending()`\n\n1. Вернуть массив, содержащий подмножество сигналов из `signals`, которые являются вычисляемыми сигналами в состояниях `~dirty~` или `~pending~`.\n\n### Метод: `Signal.subtle.untrack(cb)`\n\n1. Пусть `c` — текущее значение `computing` в контексте исполнения.\n1. Установить `computing` в null.\n1. Вызвать `cb`.\n1. Восстановить `computing` в `c` (даже если `cb` выбросил исключение).\n1. Вернуть результат выполнения `cb` (или пробросить исключение).\n\nПримечание: untrack не выводит из состояния `frozen`, которое поддерживается строго.\n\n### Метод: `Signal.subtle.currentComputed()`\n\n1. Вернуть текущее значение `computing`.\n\n### Общие алгоритмы\n\n##### Алгоритм: пересчитать грязный вычисляемый сигнал\n\n1. Очистить множество `sources` этого сигнала и удалить его из множеств `sinks` этих источников.\n1. Сохранить предыдущее значение `computing` и установить `computing` в этот сигнал.\n1. Установить состояние сигнала в `~computing~`.\n1. Выполнить обратный вызов вычисляемого сигнала, используя этот сигнал как this. Сохранить возвращаемое значение и, если обратный вызов выбросил исключение, сохранить его для повторного выбрасывания.\n1. Восстановить предыдущее значение `computing`.\n1. Применить алгоритм \"установки значения сигнала\" к возвращаемому значению обратного вызова.\n2. Установить состояние сигнала в `~clean~`.\n1. Если алгоритм вернул `~dirty~`: пометить все sinks этого сигнала как `~dirty~` (ранее sinks могли быть смесью checked и dirty). (Или, если сигнал не отслеживается, принять новое поколение для указания \"грязности\" или что-то подобное.)\n1. Иначе, если алгоритм вернул `~clean~`: для каждого sink этого сигнала в состоянии `~checked~`, если все его источники теперь чисты, то пометить этот сигнал как `~clean~` также. Применить этот шаг очистки к последующим sinks рекурсивно, для всех новых чистых сигналов, имеющих checked sinks. (Или, если сигнал не отслеживается, как-то обозначить это, чтобы очистка могла производиться лениво.)\n\n##### Алгоритм установки значения сигнала\n\n1. Если алгоритму передано значение (в отличие от исключения для повторного выбрасывания из алгоритма пересчёта грязного вычисляемого сигнала):\n    1. Вызвать функцию `equals` этого сигнала, передав текущий `value`, новое значение и сам сигнал. Если выброшено исключение, сохранить его (для повторного выбрасывания при чтении) как значение сигнала и продолжить, как если бы функция вернула false.\n    1. Если функция вернула true, вернуть `~clean~`.\n1. Установить `value` этого сигнала в переданное значение.\n1. Вернуть `~dirty~`\n\n## FAQ\n\n**В:** Не слишком ли рано стандартизировать что-то, связанное с сигналами, когда они только начали набирать популярность в 2022 году? Не стоит ли дать им больше времени на развитие и стабилизацию?\n\n**О:** Текущее состояние сигналов во фреймворках для веба — результат более чем 10-летнего непрерывного развития. По мере того как инвестиции растут, как это было в последние годы, почти все фреймворки приходят к очень похожей основной модели сигналов. Это предложение — результат совместного проектирования между большим количеством лидеров современных веб-фреймворков, и оно не будет продвигаться к стандартизации без валидации этой группы экспертов в разных контекстах.\n\n#### Как используются сигналы?\n\n**В:** Могут ли встроенные сигналы вообще использоваться фреймворками, учитывая их тесную интеграцию с рендерингом и владением?\n\n**О:** Части, которые больше зависят от фреймворков, обычно касаются эффектов, планирования и владения/освобождения ресурсов, и это предложение не пытается их решать. Наш главный приоритет при прототипировании сигналов для стандартизации — убедиться, что они могут \"лежать в основе\" существующих фреймворков совместимо и с хорошей производительностью.\n\n**В:** Предполагается ли, что API Signal будет использоваться напрямую разработчиками приложений или он предназначен для обёртывания фреймворками?\n\n**О:** Хотя этот API может использоваться напрямую разработчиками приложений (по крайней мере, та его часть, что не находится в пространстве имён `Signal.subtle`), он не рассчитан на особую эргономику. Вместо этого приоритеты отданы авторам библиотек/фреймворков. Ожидается, что большинство фреймворков обернут даже базовые API `Signal.State` и `Signal.Computed` в что-то более удобное. На практике обычно лучше использовать сигналы через фреймворк, который управляет сложными функциями (например, Watcher, `untrack`), а также владением и освобождением ресурсов (например, определяет, когда сигналы должны быть добавлены в watcher и удалены из них), и планированием рендеринга в DOM — это предложение не пытается решать эти задачи.\n\n**В:** Нужно ли явно уничтожать сигналы, связанные с виджетом, когда этот виджет уничтожается? Какой API для этого существует?\n\n**О:** Соответствующая операция уничтожения здесь — `Signal.subtle.Watcher.prototype.unwatch`. Только отслеживаемые сигналы нужно очищать (путём unwatch), а неотслеживаемые сигналы могут быть автоматически собраны сборщиком мусора.\n\n**В:** Работают ли сигналы с VDOM или напрямую с HTML DOM?\n\n**О:** Да! Сигналы независимы от технологии рендеринга. Существующие фреймворки на JavaScript, использующие конструкции, подобные сигналам, интегрируются с VDOM (например, Preact), нативным DOM (например, Solid) и их комбинациями (например, Vue). То же самое будет возможно и со встроенными сигналами.\n\n**В:** Будет ли удобно использовать сигналы во фреймворках, основанных на классах, таких как Angular и Lit? А как насчёт фреймворков на основе компилятора, таких как Svelte?\n\n**О:** Поля классов могут быть основаны на сигналах с помощью простого декоратора-аксессора, как показано в [readme Signal polyfill](https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators). Сигналы очень тесно связаны с рунами Svelte 5 — компилятору легко преобразовать руны в API сигналов, определённый здесь, и на самом деле именно так и поступает Svelte 5 (но со своей собственной библиотекой сигналов).\n\n**В:** Работают ли сигналы с SSR? Гидрацией? Восстанавливаемостью?\n\n**О:** Да. Qwik эффективно использует сигналы и для этих свойств, а другие фреймворки имеют хорошо проработанные подходы к гидрации с сигналами с разными компромиссами. Мы считаем, что можно смоделировать восстанавливаемые сигналы Qwik, используя связку State и Computed сигнала, и планируем доказать это на практике в коде.",
  "status": "ok"
}