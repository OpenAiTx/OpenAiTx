{
  "id": 8,
  "origin": "\n**Q**: Do Signals work with one-way data flow like React does?\n\n**A**: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI frameworks let you express your view as a function of the model (where the model incorporates Signals). A graph of state and computed Signals is acyclic by construction. It is also possible to recreate React antipatterns within Signals (!), e.g., the Signal equivalent of a `setState` inside of `useEffect` is to use a Watcher to schedule a write to a State signal.\n\n**Q**: How do signals relate to state management systems like Redux? Do signals encourage unstructured state?\n\n**A**: Signals can form an efficient basis for store-like state management abstractions. A common pattern found in multiple frameworks is an object based on a Proxy which internally represents properties using Signals, e.g., [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive), or [Solid stores](https://docs.solidjs.com/concepts/stores). These systems enable flexible grouping of state at the right level of abstraction for the particular application.\n\n**Q**: What are Signals offering that `Proxy` doesn't currently handle?\n\n**A**: Proxies and Signals are complementary and go well together. Proxies let you intercept shallow object operations and signals coordinate a dependency graph (of cells). Backing a Proxy with Signals is a great way to make a nested reactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and setter property instead of using the `get` and `set` methods:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// usage in a hypothetical reactive context:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nwhen using a renderer that is optimized for fine-grained reactivity, clicking the button will cause the `b.value` cell to be updated.\n\nSee:\n- examples of nested reactive structures created with both Signals and Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- example prior implementations showing the relationship between reactive data atd proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [discussion](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574).\n\n#### How do Signals work?\n\n**Q**: Are Signals push-based or pull-based?\n\n**A**: Evaluation of computed Signals is pull-based: computed Signals are only evaluated when `.get()` is called, even if the underlying state changed much earlier. At the same time, changing a State signal may immediately trigger a Watcher's callback, \"pushing\" the notification. So Signals may be thought of as a \"push-pull\" construction.\n\n**Q**: Do Signals introduce nondeterminism into JavaScript execution?\n\n**A**: No. For one, all Signal operations have well-defined semantics and ordering, and will not differ among conformant implementations. At a higher level, Signals follow a certain set of invariants, with respect to which they are \"sound\". A computed Signal always observes the Signal graph in a consistent state, and its execution is not interrupted by other Signal-mutating code (except for things it calls itself). See the description above.\n\n**Q**: When I write to a state Signal, when is the update to the computed Signal scheduled?\n\n**A**: It isn't scheduled! The computed Signal will recalculate itself the next time someone reads it. Synchronously, a Watcher's `notify` callback may be called, enabling frameworks to schedule a read at the time that they find appropriate.\n\n**Q**: When do writes to state Signals take effect? Immediately, or are they batched?\n\n**A**: Writes to state Signals are reflected immediately--the next time a computed Signal which depends on the state Signal is read, it will recalculate itself if needed, even if in the immediately following line of code. However, the laziness inherent in this mechanism (that computed Signals are only computed when read) means that, in practice, the calculations may happen in a batched way.\n\n**Q**: What does it mean for Signals to enable \"glitch-free\" execution?\n\n**A**: Earlier push-based models for reactivity faced an issue of redundant computation: If an update to a state Signal causes the computed Signal to eagerly run, ultimately this may push an update to the UI. But this write to the UI may be premature, if there was going to be another change to the originating state Signal before the next frame. Sometimes, inaccurate intermediate values were even shown to end-users due to such [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches). Signals avoid this dynamic by being pull-based, rather than push-based: At the time the framework schedules the rendering of the UI, it will pull the appropriate updates, avoiding wasted work both in computation as well as in writing to the DOM.\n\n**Q**: What does it mean for Signals to be \"lossy\"?\n\n**A**: This is the flipside of glitch-free execution: Signals represent a cell of data--just the immediate current value (which may change), not a stream of data over time. So, if you write to a state Signal twice in a row, without doing anything else, the first write is \"lost\" and never seen by any computed Signals or effects. This is understood to be a feature rather than a bug--other constructs (e.g., async iterables, observables) are more appropriate for streams.\n\n**Q**: Will native Signals be faster than existing JS Signal implementations?\n\n**A**: We hope so (by a small constant factor), but this remains to be proven in code. JS engines aren't magic, and will ultimately need to implement the same kinds of algorithms as JS implementations of Signals. See above section about performance.\n\n#### Why are Signals designed this way?\n\n**Q**: Why doesn't this proposal include an `effect()` function, when effects are necessary for any practical usage of Signals?\n\n**A**: Effects inherently tie into scheduling and disposal, which are managed by frameworks and outside the scope of this proposal. Instead, this proposal includes the basis for implementing effects through the more low-level `Signal.subtle.Watcher` API.\n\n**Q**: Why are subscriptions automatic rather than providing a manual interface?\n\n**A**: Experience has shown that manual subscription interfaces for reactivity are un-ergonomic and error-prone. Automatic tracking is more composable and is a core feature of Signals.\n\n**Q**: Why does the `Watcher`'s callback run synchronously, rather than scheduled in a microtask?\n\n**A**: Because the callback cannot read or write Signals, there is no unsoundness brought on by calling it synchronously. A typical callback will add a Signal to an Array to be read later, or mark a bit somewhere. It is unnecessary and impractically expensive to make a separate microtask for all of these sorts of actions.\n\n**Q**: This API is missing some nice things that my favorite framework provides, which makes it easier to program with Signals. Can that be added to the standard too?\n\n**A**: Maybe. Various extensions are still under consideration. Please file an issue to raise discussion on any missing feature you find to be important.\n\n**Q**: Can this API be reduced in size or complexity?\n\n**A**: It's definitely a goal to keep this API minimal, and we've tried to do so with what's presented above. If you have ideas for more things that can be removed, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\n**Q**: Shouldn't we start standardization work in this area with a more primitive concept, such as observables?",
  "translate": "**ถาม**: Signals ทำงานร่วมกับการไหลของข้อมูลทางเดียวแบบที่ React ทำได้หรือไม่?\n\n**ตอบ**: ใช่, Signals เป็นกลไกสำหรับการไหลของข้อมูลทางเดียว เฟรมเวิร์ก UI ที่ใช้ Signal ช่วยให้คุณสามารถแสดงผลมุมมองของคุณเป็นฟังก์ชันของโมเดล (ซึ่งโมเดลมี Signals อยู่ด้วย) กราฟของสถานะและ Signals ที่คำนวณจะไม่มีวงจรโดยโครงสร้าง นอกจากนี้ยังสามารถสร้างรูปแบบที่ไม่แนะนำของ React ใน Signals ได้ (!) เช่น การใช้ Watcher เพื่อกำหนดเวลาการเขียนไปยัง State signal ซึ่งเทียบเท่ากับการใช้ `setState` ใน `useEffect`\n\n**ถาม**: Signals เกี่ยวข้องกับระบบการจัดการสถานะอย่าง Redux อย่างไร? Signals ส่งเสริมการจัดการสถานะที่ไม่มีโครงสร้างหรือไม่?\n\n**ตอบ**: Signals สามารถเป็นพื้นฐานที่มีประสิทธิภาพสำหรับนามธรรมการจัดการสถานะแบบ store ได้ รูปแบบที่พบได้ทั่วไปในหลายเฟรมเวิร์กคือตัววัตถุที่สร้างจาก Proxy ที่ภายในแทนคุณสมบัติโดยใช้ Signals เช่น [Vue `reactive()`](https://vuejs.org/api/reactivity-core.html#reactive) หรือ [Solid stores](https://docs.solidjs.com/concepts/stores) ระบบเหล่านี้ช่วยให้สามารถจัดกลุ่มสถานะได้อย่างยืดหยุ่นในระดับนามธรรมที่เหมาะสมกับแอปพลิเคชันแต่ละประเภท\n\n**ถาม**: Signals มีข้อเสนออะไรที่ `Proxy` ยังไม่สามารถจัดการได้ในปัจจุบัน?\n\n**ตอบ**: Proxy และ Signals เป็นสิ่งที่เสริมกันและทำงานร่วมกันได้ดี Proxy ช่วยให้คุณดักจับการทำงานกับวัตถุแบบตื้นและ signals ช่วยประสานกราฟของการพึ่งพา (dependency graph) การใช้ Proxy รองรับด้วย Signals เป็นวิธีที่ยอดเยี่ยมในการสร้างโครงสร้างแบบ reactive ซ้อนกันที่ใช้งานง่าย\n\nในตัวอย่างนี้, เราสามารถใช้ proxy เพื่อให้ signal มี property getter และ setter แทนการใช้เมธอด `get` และ `set`:\n```js\nconst a = new Signal.State(0);\nconst b = new Proxy(a, {\n  get(target, property, receiver) {\n    if (property === 'value') {\n      return target.get():\n    }\n  }\n  set(target, property, value, receiver) {\n    if (property === 'value') {\n      target.set(value)!\n    }\n  }\n});\n\n// การใช้งานใน context ที่เป็น reactive สมมุติ:\n<template>\n  {b.value}\n\n  <button onclick={() => {\n    b.value++;\n  }}>change</button>\n</template>\n```\nเมื่อใช้ renderer ที่ถูกปรับให้เหมาะสมกับ reactivity แบบละเอียด การคลิกปุ่มจะทำให้เซลล์ `b.value` ถูกอัปเดต\n\nดู:\n- ตัวอย่างโครงสร้าง reactive ซ้อนกันที่สร้างด้วยทั้ง Signals และ Proxies: [signal-utils](https://github.com/NullVoxPopuli/signal-utils/tree/main/src)\n- ตัวอย่างการใช้งานก่อนหน้านี้ที่แสดงความสัมพันธ์ระหว่างข้อมูล reactive และ proxies: [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private)\n- [การอภิปราย](https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574)\n\n#### Signals ทำงานอย่างไร?\n\n**ถาม**: Signals เป็นแบบ push-based หรือ pull-based?\n\n**ตอบ**: การประเมิน Signals ที่คำนวณเป็นแบบ pull-based: Signals ที่คำนวณจะถูกประเมินก็ต่อเมื่อมีการเรียก `.get()` เท่านั้น แม้ว่าสถานะที่อยู่ข้างใต้จะเปลี่ยนแปลงไปนานแล้วก็ตาม ขณะเดียวกัน การเปลี่ยนแปลง State signal อาจทำให้ callback ของ Watcher ทำงานทันที, \"push\" การแจ้งเตือน ดังนั้น Signals อาจถูกมองว่าเป็นโครงสร้างแบบ \"push-pull\"\n\n**ถาม**: Signals ทำให้เกิดความไม่แน่นอนในการทำงานของ JavaScript หรือไม่?\n\n**ตอบ**: ไม่ ทั้งหมดของการดำเนินการกับ Signal มี semantics และลำดับที่นิยามไว้อย่างดี และจะไม่แตกต่างกันระหว่างการ implement ที่สอดคล้องกัน ในระดับที่สูงขึ้น Signals จะมี invariants ชุดหนึ่งที่ทำให้มัน \"sound\" เสมอ Signals ที่คำนวณจะสังเกตกราฟ Signal ในสถานะที่สอดคล้องกันเสมอ และการทำงานของมันจะไม่ถูกขัดจังหวะโดยโค้ดที่เปลี่ยน Signal อื่น ๆ (ยกเว้นสิ่งที่มันเรียกเอง) ดูคำอธิบายข้างต้น\n\n**ถาม**: เมื่อเขียนค่าลง state Signal, การอัปเดตไปยัง computed Signal จะถูกกำหนดเวลาไว้เมื่อใด?\n\n**ตอบ**: ไม่มีการกำหนดเวลา! Computed Signal จะคำนวณตัวเองใหม่ครั้งต่อไปที่มีผู้เรียกอ่านมัน Synchronously, อาจมีการเรียก callback ของ Watcher เพื่อให้เฟรมเวิร์กสามารถกำหนดเวลาในการอ่านได้ตามต้องการ\n\n**ถาม**: การเขียนลง state Signals มีผลทันทีหรือไม่ หรือมีการ batch?\n\n**ตอบ**: การเขียนลง state Signals จะสะท้อนผลทันที—Signal ที่คำนวณซึ่งพึ่งพา state Signal นั้นจะคำนวณตัวเองใหม่หากจำเป็นในการอ่านครั้งถัดไป แม้จะเป็นบรรทัดโค้ดถัดไปก็ตาม อย่างไรก็ตาม, ความ lazy ของกลไกนี้ (คือ computed Signals จะคำนวณเมื่อมีการอ่านเท่านั้น) ทำให้โดยปฏิบัติแล้ว การคำนวณอาจเกิดขึ้นแบบ batch\n\n**ถาม**: การที่ Signals ช่วยให้ \"glitch-free\" execution หมายถึงอะไร?\n\n**ตอบ**: โมเดล push-based แบบเก่าสำหรับ reactivity เจอปัญหาการคำนวณซ้ำซ้อน: ถ้าการอัปเดต state Signal ทำให้ computed Signal รันทันที สุดท้ายอาจผลักการอัปเดตไปยัง UI แต่การเขียนไปยัง UI นี้อาจเกิดก่อนเวลา หากจะมีการเปลี่ยนแปลง state Signal ต้นทางอีกก่อนเฟรมถัดไป บางครั้งค่ากลางที่ไม่ถูกต้องยังถูกแสดงต่อผู้ใช้เนื่องจาก [glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches) ดังกล่าว Signals หลีกเลี่ยงปัญหานี้โดยเป็น pull-based แทน push-based: เมื่อเฟรมเวิร์กกำหนดเวลาการ render UI, มันจะ pull การอัปเดตที่เหมาะสม, หลีกเลี่ยงงานซ้ำทั้งในการคำนวณและการเขียนลง DOM\n\n**ถาม**: การที่ Signals เป็น \"lossy\" หมายถึงอะไร?\n\n**ตอบ**: นี่คืออีกด้านของ glitch-free execution: Signals แทนข้อมูลเซลล์เดียว—แค่ค่าปัจจุบันทันที (ซึ่งอาจเปลี่ยนแปลงได้) ไม่ใช่สตรีมข้อมูลตลอดเวลา ดังนั้น ถ้าคุณเขียนลง state Signal สองครั้งติดกันโดยไม่ทำอย่างอื่น การเขียนครั้งแรกจะ \"หาย\" ไปและไม่มี Signal ที่คำนวณหรือเอฟเฟกต์ใด ๆ เห็น นี่ถือเป็นฟีเจอร์มากกว่าบั๊ก—โครงสร้างอื่น ๆ (เช่น async iterables, observables) เหมาะสำหรับสตรีมมากกว่า\n\n**ถาม**: Signals แบบ native จะเร็วกว่า Signal implementation ใน JS ที่มีอยู่แล้วหรือไม่?\n\n**ตอบ**: เราหวังว่าจะเป็นเช่นนั้น (ด้วยตัวคูณค่าคงที่เล็กน้อย) แต่ยังต้องพิสูจน์ในโค้ด เอนจิน JS ไม่ใช่เวทมนตร์ และสุดท้ายก็ต้อง implement algorithm แบบเดียวกับ Signal ที่เขียนด้วย JS ดูหัวข้อข้างบนเกี่ยวกับประสิทธิภาพ\n\n#### Signals ถูกออกแบบเช่นนี้เพราะอะไร?\n\n**ถาม**: ทำไมข้อเสนอนี้จึงไม่มีฟังก์ชัน `effect()` ในเมื่อ effect จำเป็นสำหรับการใช้งาน Signals ในทางปฏิบัติ?\n\n**ตอบ**: Effect ผูกกับ scheduling และ disposal โดยเนื้อแท้ ซึ่งถูกจัดการโดยเฟรมเวิร์กและอยู่นอกขอบเขตของข้อเสนอนี้ ข้อเสนอนี้จึงมีเพียงพื้นฐานสำหรับการ implement effect ผ่าน API ระดับต่ำอย่าง `Signal.subtle.Watcher`\n\n**ถาม**: ทำไม subscription จึงเป็นแบบอัตโนมัติแทนที่จะให้ interface แบบ manual?\n\n**ตอบ**: ประสบการณ์แสดงให้เห็นว่า interface subscription แบบ manual สำหรับ reactivity ใช้งานยากและเกิดข้อผิดพลาดได้ง่าย การ tracking แบบอัตโนมัติสามารถนำไปประกอบต่อได้สะดวกกว่าและเป็นคุณสมบัติหลักของ Signals\n\n**ถาม**: ทำไม callback ของ `Watcher` จึงรันแบบ synchronous แทนที่จะกำหนดเวลาไว้ใน microtask?\n\n**ตอบ**: เพราะ callback ไม่สามารถอ่านหรือเขียน Signals ได้ จึงไม่มีความไม่แน่นอนที่เกิดจากการรัน synchronous โดยปกติ callback จะเพิ่ม Signal ลงใน Array เพื่ออ่านภายหลัง หรือ mark บิตที่ไหนสักแห่ง จึงไม่จำเป็นและสิ้นเปลืองเกินไปที่จะสร้าง microtask แยกสำหรับการกระทำเหล่านี้\n\n**ถาม**: API นี้ขาดฟีเจอร์ดี ๆ ที่เฟรมเวิร์กโปรดของฉันมี ซึ่งทำให้เขียนโค้ดกับ Signals ง่ายขึ้น สามารถเพิ่มเข้าในมาตรฐานได้ไหม?\n\n**ตอบ**: อาจจะได้ มีส่วนขยายต่าง ๆ อยู่ในระหว่างการพิจารณา กรุณาแจ้ง issue เพื่ออภิปรายเกี่ยวกับฟีเจอร์ที่คุณเห็นว่าสำคัญ\n\n**ถาม**: API นี้สามารถลดขนาดหรือความซับซ้อนได้หรือไม่?\n\n**ตอบ**: แน่นอนว่าเป้าหมายคือให้ API นี้เล็กที่สุดเท่าที่จะทำได้ และเราก็พยายามทำเช่นนั้นกับที่นำเสนอข้างต้น หากคุณมีไอเดียเพิ่มเติมว่าสามารถตัดอะไรออกได้อีก กรุณาแจ้ง issue เพื่ออภิปราย\n\n#### Signals กำลังเข้าสู่มาตรฐานอย่างไร?\n\n**ถาม**: เราควรเริ่มทำมาตรฐานในเรื่องนี้ด้วยแนวคิดที่เป็น primitive กว่านี้ เช่น observables หรือไม่?",
  "status": "ok"
}