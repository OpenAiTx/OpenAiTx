{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n    // 当 isWatched 从 false 变为 true 时调用的回调\n    [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n    // 当 isWatched 从 true 变为 false 时调用的回调\n    [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n```\n\n### 信号（Signals）如何工作\n\nSignal 表示一个可能随时间变化的数据单元。Signal 可以是“状态”（仅手动设置的值）或“计算值”（基于其他 Signal 的公式）。\n\n计算型 Signal 通过自动跟踪在其计算过程中被读取的其他 Signal 来工作。当读取计算型 Signal 时，它会检查其先前记录的依赖项是否有变化，如果有，则会重新计算自身。当多个计算型 Signal 嵌套时，所有的跟踪归属于最内层的那个。\n\n计算型 Signal 是惰性的，即基于拉取：只有在被访问时才会重新计算，即使其某个依赖项之前已发生变化。\n\n传递给计算型 Signal 的回调通常应该是“纯函数”，即对其访问的其他 Signal 的确定性、无副作用的函数。同时，回调被调用的时机是确定性的，因此可以谨慎地使用副作用。\n\nSignal 具有显著的缓存/记忆化特性：状态和计算型 Signal 都会记住其当前值，只有当它们实际变化时，才会触发引用它们的计算型 Signal 的重新计算。甚至不需要反复比较旧值和新值 —— 当源 Signal 被重置/重新计算时只比较一次，并且 Signal 机制会跟踪哪些引用了该 Signal 的内容还未基于新值更新。在内部，这通常通过“图着色”（graph coloring）实现，如（Milo 的博客文章）所述。\n\n计算型 Signal 动态跟踪其依赖 —— 每次运行时，它们最终可能依赖于不同的内容，并且精确的依赖集会在 Signal 图中保持最新。这意味着，如果某个依赖只在一个分支中需要，而上一次计算走了另一个分支，那么对该临时未使用值的更改不会导致计算型 Signal 被重新计算，即使被拉取。\n\n与 JavaScript 的 Promise 不同，Signal 中的一切都是同步运行的：\n- 将 Signal 设置为新值是同步的，并且这会立即反映在之后读取的任何依赖于它的计算型 Signal 上。此变更没有内置的批处理机制。\n- 读取计算型 Signal 是同步的 —— 它们的值始终可用。\n- 如下所述，Watcher 的 `notify` 回调在触发它的 `.set()` 调用期间同步运行（但在图着色完成之后）。\n\n与 Promise 类似，Signal 可以表示错误状态：如果计算型 Signal 的回调抛出异常，则该错误会像其他值一样被缓存，并在每次读取 Signal 时重新抛出。\n\n### 理解 Signal 类\n\n一个 `Signal` 实例表示读取一个动态变化值的能力，其更新会随时间被跟踪。它还隐式包含了通过另一个计算型 Signal 的跟踪访问来订阅该 Signal 的能力。\n\n这里的 API 设计旨在与大量 Signal 库在使用“signal”、“computed”和“state”等名称上的生态粗略共识保持一致。然而，对计算型和状态型 Signal 的访问是通过 `.get()` 方法，这与所有流行的 Signal API 不同，后者要么使用 `.value` 风格的访问器，要么使用 `signal()` 调用语法。\n\n该 API 设计目的是减少分配次数，使 Signal 适合嵌入到 JavaScript 框架中，并达到与现有框架定制 Signal 相同或更好的性能。这意味着：\n- 状态型 Signal 是一个可写对象，可以通过同一个引用进行读取和设置。（见下文“能力分离”部分的影响。）\n- 状态型和计算型 Signal 都设计为可被子类化，方便框架通过公共或私有类字段（以及用于操作该状态的方法）添加额外属性。\n- 各种回调（如 `equals`、计算型回调）会以相关 Signal 作为 `this` 上下文调用，因此每个 Signal 不需要新建闭包。相反，可以将上下文保存在 Signal 本身的额外属性中。\n\n本 API 强制执行的一些错误条件：\n- 递归读取计算型 Signal 是错误的。\n- Watcher 的 `notify` 回调不能读取或写入任何 Signal。\n- 如果计算型 Signal 的回调抛出异常，则对 Signal 的后续访问会重新抛出该缓存错误，直到某个依赖项发生变化并重新计算为止。\n\n一些*未*强制执行的条件：\n- 计算型 Signal 可以在其回调内部同步写入其他 Signal。\n- 由 Watcher 的 `notify` 回调排队的任务可以读取或写入 Signal，这使得可以用 Signal 复现[经典 React 反模式](https://react.dev/learn/you-might-not-need-an-effect)。\n\n### 实现副作用（effects）\n\n上面定义的 `Watcher` 接口为实现典型的 JS 副作用 API 提供了基础：当其他 Signal 发生变化时，重新运行回调，仅用于其副作用。初始示例中使用的 `effect` 函数可以如下定义：\n\n```ts\n// 这个函数通常会存在于库/框架中，而不是应用代码中\n// 注意：本调度逻辑过于基础，不建议直接复制粘贴。\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// 一个 effect Signal，每当其依赖项可能发生变化时，\n// 会在微任务队列中安排对自身的读取\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nSignal API 不包括类似 `effect` 的内置函数。这是因为副作用的调度比较微妙，通常与框架的渲染周期及其他高级框架特有的状态或策略有关，而 JS 无法访问这些内容。\n\n下面解释这里用到的各种操作：传递给 `Watcher` 构造函数的 `notify` 回调是在 Signal 从“干净”状态（缓存已初始化且有效）变为“已检查”或“脏”状态（由于递归依赖的某个状态被更改，缓存可能有效也可能无效）时被调用的函数。\n\n`notify` 的调用最终由某个状态型 Signal 上的 `.set()` 调用触发。该调用是同步的：在 `.set` 返回之前发生。但无需担心此回调会观察到半处理状态下的 Signal 图，因为在 `notify` 回调期间，任何 Signal 都不能被读取或写入，即使在 `untrack` 调用中也不行。由于 `notify` 在 `.set()` 期间被调用，它会中断另一条尚未完成的逻辑线程。要在 `notify` 中读取或写入 Signal，请安排稍后运行的任务，例如将 Signal 写入一个列表以便稍后访问，或如上例所示使用 `queueMicrotask`。\n\n请注意，完全可以不使用 `Signal.subtle.Watcher`，而通过调度对计算型 Signal 的轮询（如 Glimmer 所做）来高效使用 Signal。不过，许多框架发现让此调度逻辑同步运行通常非常有用，因此 Signal API 包含了它。\n\n计算型和状态型 Signal 都像任何 JS 值一样被垃圾回收。但 Watcher 有一种特殊的持有方式：任何被 Watcher 监听的 Signal 只要其底层状态仍可达，就会被保持存活，因为这些状态可能会触发未来的 `notify` 调用（进而触发未来的 `.get()`）。因此，请记得调用 `Watcher.prototype.unwatch` 来清理副作用。\n\n### 一个不安全的逃生口\n\n`Signal.subtle.untrack` 是一个允许*不*跟踪读取 Signal 的逃生口。该能力不安全，因为它允许创建依赖于其他 Signal 却不会在这些 Signal 发生变化时更新的计算型 Signal。只有在未跟踪访问不会改变计算结果时才应使用。\n\n<!--\nTODO: 展示何时应该使用 untrack 的示例\n\n### 使用 watched/unwatched",
  "status": "ok"
}