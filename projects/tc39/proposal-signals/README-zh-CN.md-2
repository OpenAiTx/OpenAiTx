{
  "id": 2,
  "origin": "\n* **Automatic Dependency Tracking** - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n* **Lazy Evaluation** - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n* **Memoization** - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track of the sources encountered when evaluating a computed Signal. This makes it hard to share models, components, and libraries between different frameworks--they tend to come with a false coupling to their view engine (given that Signals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the rendering view, enabling developers to migrate to new rendering technologies without rewriting their non-UI code, or develop shared reactive models in JS to be deployed in different contexts. Unfortunately, due to versioning and duplication, it has turned out to be impractical to reach a strong level of sharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to commonly used libraries being built-in, but implementations of Signals are generally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures and algorithms can be slightly more efficient than what is achievable in JS, by a constant factor. However, no algorithmic changes are anticipated vs. what would be present in a polyfill; engines are not expected to be magic here, and the reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and use these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace things like:\n* The callstack across a chain of computed Signals, showing the causal chain for an error\n* The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved support for inspecting Signals, particularly for debugging or performance analysis, whether this is built into browsers or through a shared extension. Existing tools such as the element inspector, performance snapshot, and memory profilers could be updated to specifically highlight Signals in their presentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a \"batteries-included\" language, with a high-quality, built-in set of functionality available. For example, Temporal is replacing moment.js, and a number of small features, e.g., `Array.prototype.flat` and `Object.groupBy` are replacing many lodash use cases. Benefits include smaller bundle sizes, improved stability and quality, less to learn when joining a new project, and a generally common vocabulary across JS developers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native templating to HTML ([DOM Parts][wicg-pr-1023] and [Template Instantiation][wicg-propsal-template-instantiation]). Additionally, the W3C Web Components CG is exploring the possibility of extending Web Components to offer a fully declarative HTML API. To accomplish both of these goals, eventually a reactive primitive will be needed by HTML. Additionally, many ergonomic improvements to the DOM through integration of Signals can be imagined and have been asked for by the community.\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> Note, this integration would be a separate effort to come later, not part of this proposal itself.\n\n##### Ecosystem information exchange (*not* a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\" level, even without changes in browsers. The Signals effort is bringing together many different framework authors for a deep discussion about the nature of reactivity, algorithms and interoperability. This has already been useful, and does not justify inclusion in JS engines and browsers; Signals should only be added to the JavaScript standard if there are significant benefits *beyond* the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from each other, at their core. This proposal aims to build on their success by implementing the important qualities of many of those libraries.\n\n### Core features\n\n* A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n* A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"[glitch](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is *not* recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n* Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n* Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n* Ability to read Signals *without* triggering dependencies to be recorded (`untrack`)\n* Enable composition of different codebases which use Signals/reactivity, e.g.,\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n* Discourage/prohibit naive misuse of synchronous reactions.\n    * Soundness risk: it may expose \"[glitches](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n* Discourage `untrack` and mark its unsound nature\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n* Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n* Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both `.value` and `[state, setState]`-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n* It would be nice if this API is usable directly by JavaScript developers.\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n        * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n        * Idea: Provide all the hooks, but include errors when misused if possible.\n        * Idea: Put subtle APIs in a `subtle` namespace, similar to [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle), to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n* Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n* If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).",
  "translate": "* **自动依赖跟踪** - 计算型 Signal 会自动发现它所依赖的其他 Signal，无论这些 Signal 是简单值还是其他计算结果。\n* **惰性求值** - 计算在声明时不会被急切地执行，依赖项发生变化时也不会立即计算。只有在明确请求其值时才会进行计算。\n* **记忆化** - 计算型 Signal 会缓存其上一次的值，因此在依赖项没有变化的情况下，无论访问多少次，都无需重新计算。\n\n## 将 Signals 标准化的动机\n\n#### 互操作性\n\n每个 Signal 实现都有自己的自动跟踪机制，用于在计算型 Signal 评估时记录所遇到的来源。这导致在不同框架之间共享模型、组件和库变得困难——它们往往与其视图引擎产生了虚假耦合（因为 Signal 通常作为 JS 框架的一部分实现）。\n\n本提案的目标之一是彻底解耦响应式模型与渲染视图，使开发者能够在不重写非 UI 代码的情况下迁移到新的渲染技术，或者在 JS 中开发可在不同环境下部署的共享响应式模型。不幸的是，由于版本和重复问题，通过 JS 层级的库实现强共享是不切实际的——内置功能提供了更强的共享保证。\n\n#### 性能/内存使用\n\n由于常用库变为内置，减少代码体积总是有一定的性能提升潜力，但 Signal 的实现通常非常小，因此我们预计这种效果不会很大。\n\n我们推测，Signal 相关数据结构和算法的原生 C++ 实现，相比于 JS 能实现的，可能会更高效一些，但只是常数级的提升。然而，预计不会有与 polyfill 存在差异的算法性变更；引擎在这里不会有“魔法”，响应式算法本身也将被明确定义。\n\n冠军小组（Champion group）计划开发多种 Signal 实现，并利用这些实现来研究性能的可能性。\n\n#### 开发者工具（DevTools）\n\n对于现有的 JS 语言 Signal 库，追踪如下内容可能会比较困难：\n* 跨多个计算型 Signal 的调用栈，显示错误的因果链\n* Signal 之间的引用图（Reference Graph），即一个 Signal 依赖于另一个 Signal——这在调试内存使用时很重要\n\n内置 Signal 使得 JS 运行时和开发者工具有可能更好地支持对 Signal 的检查，尤其是在调试或性能分析时，无论是集成在浏览器中还是通过共享扩展实现。现有工具如元素检查器、性能快照和内存分析器，都可以针对 Signal 信息进行特别展示。\n\n#### 次要收益\n\n##### 标准库的好处\n\n总体而言，JavaScript 的标准库一直比较精简，但 TC39 的趋势是让 JS 成为一个“自带电池”的语言，具备高质量的内建功能。例如，Temporal 正在替代 moment.js，许多小特性（如 `Array.prototype.flat` 和 `Object.groupBy`）正在替代 lodash 的许多用例。其好处包括更小的包体积、更高的稳定性和质量、加入新项目时的学习成本更低，以及 JS 开发者之间普遍的通用术语。\n\n##### HTML/DOM 集成（未来的可能性）\n\nW3C 和浏览器实现者正在努力为 HTML 引入原生模板功能（[DOM Parts][wicg-pr-1023] 和 [Template Instantiation][wicg-propsal-template-instantiation]）。此外，W3C Web Components 社区组正在探索扩展 Web Components 以提供完全声明式 HTML API 的可能性。要实现这些目标，最终 HTML 需要一种响应式原语。此外，社区已经设想并提出了许多通过集成 Signal 改善 DOM 易用性的需求。\n\n[wicg-pr-1023]: https://github.com/WICG/webcomponents/pull/1023\n[wicg-propsal-template-instantiation]: https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md\n\n> 注意，这类集成将是后续的独立工作，并非本提案的一部分。\n\n##### 生态系统信息交流（*不是* 推出标准的理由）\n\n标准化工作有时即使在浏览器未变的情况下，也能在“社区”层面带来帮助。Signals 的推进汇集了许多不同框架的作者，共同深入讨论响应式的本质、算法和互操作性。这已被证明很有价值，但这本身不足以让其被 JS 引擎和浏览器采纳；只有当 Signal 标准化带来的好处*超越*生态信息交流时，才应纳入 JavaScript 标准。\n\n## Signal 的设计目标\n\n事实证明，现有的 Signal 库在核心上并没有太大区别。本提案旨在借鉴这些库的成功经验，实现它们许多重要特性。\n\n### 核心特性\n\n* 一种表示状态的 Signal 类型，即可写 Signal。这是一个可被他人读取的值。\n* 一种计算型/记忆型/派生 Signal 类型，依赖于其他 Signal，并以惰性方式计算和缓存。\n    * 计算是惰性的，即当某个依赖项变化时，默认不会立即重新计算计算型 Signal，只有当有人真正读取时才会执行。\n    * 计算“[无故障](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)”，即不会执行任何不必要的计算。这意味着，当应用读取计算型 Signal 时，会对可能变脏的图进行拓扑排序以消除重复计算。\n    * 计算是有缓存的，即在依赖项变化后，若没有依赖项再发生变化，则访问时不会重新计算计算型 Signal。\n    * 计算型 Signal 和状态 Signal 都支持自定义比较器，用于判断依赖它们的进一步计算型 Signal 是否需要更新。\n* 针对计算型 Signal 某个依赖（或嵌套依赖）变“脏”并发生变化的情况做出反应，表明该 Signal 的值可能已经过时。\n    * 这种反应用于调度后续更重要的工作。\n    * 副作用（Effects）是通过这些反应以及框架级调度来实现的。\n    * 计算型 Signal 需要能感知自己是否被注册为这些反应的（嵌套）依赖。\n* 允许 JS 框架自行调度。不强制使用 Promise 风格的内建调度。\n    * 需要同步反应以便根据框架逻辑调度后续工作。\n    * 写入操作是同步的并立即生效（如框架希望批量写入，可在其上实现）。\n    * 可以将判断 Effect 是否“脏”与实际运行 Effect 分离（支持两阶段 Effect 调度器）。\n* 能够在不记录依赖的情况下读取 Signal（`untrack`）\n* 支持使用 Signal/响应式机制进行不同代码库的组合，例如：\n    * 就跟踪/响应式本身而言，可以同时使用多个框架（但具体细节见下文）\n    * 跨框架的响应式数据结构（如递归响应式 store 代理、响应式 Map、Set、Array 等）\n\n### 健全性\n\n* 阻止/禁止同步反应的简单误用。\n    * 健全性风险：如果使用不当，可能暴露“[故障](https://en.wikipedia.org/wiki/Reactive_programming#Glitches)”：如果在 Signal 设置时立即渲染，可能会向最终用户暴露不完整的应用状态。因此，此功能应只用于在应用逻辑完成后智能地调度后续工作。\n    * 方案：禁止在同步反应回调中读取或写入任何 Signal\n* 不鼓励使用 `untrack`，并标记其不安全性质\n    * 健全性风险：允许创建值依赖于其他 Signal、但这些 Signal 变化时不会被更新的计算型 Signal。只有在非跟踪访问不会改变计算结果时才应使用。\n    * 方案：API 在命名上标记为“不安全”。\n* 注意：本提案允许信号既可以从计算型和副作用型信号中读取和写入，也不限制先读后写，尽管存在健全性风险。这样做是为了保持与各种框架集成的灵活性和兼容性。\n\n### 表面 API\n\n* 必须为多个框架实现其 Signal/响应式机制提供坚实基础。\n    * 应为递归 store 代理、基于装饰器的类字段响应式，以及 `.value` 和 `[state, setState]` 风格 API 提供良好基础。\n    * 语义能够表达不同框架支持的有效模式。例如，Signal 应能作为立即反映写入或稍后批量应用写入的基础。\n* 如果该 API 能被 JavaScript 开发者直接使用会更好。\n    * 如果某个特性与生态系统概念一致，采用通用术语更好。\n        * 但重要的是不要完全照搬现有名称！\n    * 在“JS 开发者易用性”与“为框架提供全部钩子”之间权衡\n        * 思路：提供全部钩子，但如有误用则抛出错误。\n        * 思路：将细致 API 放在 `subtle` 命名空间下，类似于 [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle)，以区分高级用法（如实现框架或开发者工具）与日常应用开发（如为框架实例化 Signal）。\n* 可实现且能以良好性能使用——表面 API 不会引入过多开销\n    * 支持子类化，让框架能添加自己的方法和字段，包括私有字段。这对于避免框架层额外分配很重要。见下文“内存管理”。\n\n### 内存管理\n\n* 如果可能：若没有任何活动引用可能会读取某个计算型 Signal，则该计算型 Signal 应可被垃圾回收，即使它仍在更大的图中（如依赖于一个仍然存活的状态值）。",
  "status": "ok"
}