{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback chiamato quando isWatched diventa true, se in precedenza era false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback chiamato ogni volta che isWatched diventa false, se in precedenza era true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Come funzionano i Signals\n\nUn Signal rappresenta una cella di dati che può cambiare nel tempo. I Signals possono essere di tipo \"state\" (semplicemente un valore impostato manualmente) o \"computed\" (una formula basata su altri Signals).\n\nI Signals computati funzionano tracciando automaticamente quali altri Signals vengono letti durante la loro valutazione. Quando un computed viene letto, controlla se una delle sue dipendenze precedentemente registrate è cambiata, e in tal caso si ricalcola. Quando più Signals computati sono annidati, tutta l'attribuzione del tracciamento va a quello più interno.\n\nI Signals computati sono lazy, ovvero pull-based: vengono ricalcolati solo quando vengono acceduti, anche se una delle loro dipendenze è cambiata in precedenza.\n\nLa callback passata ai Signals computati dovrebbe generalmente essere \"pura\", nel senso di essere una funzione deterministica e priva di effetti collaterali sugli altri Signals a cui accede. Allo stesso tempo, il momento in cui viene chiamata la callback è deterministico, consentendo l'uso di effetti collaterali con cautela.\n\nI Signals presentano un caching/memorizzazione evidente: sia i Signals di stato che quelli computati memorizzano il loro valore attuale e attivano il ricalcolo dei Signals computati che li referenziano solo se effettivamente cambiano. Non è nemmeno necessario un confronto ripetuto tra vecchi e nuovi valori: il confronto viene effettuato una sola volta quando il Signal sorgente viene reimpostato/ricalcolato, e il meccanismo dei Signal tiene traccia di quali elementi che fanno riferimento a quel Signal non sono ancora stati aggiornati in base al nuovo valore. Internamente, questo viene generalmente rappresentato tramite il \"graph coloring\" come descritto nel [post sul blog di Milo](https://raw.githubusercontent.com/tc39/proposal-signals/main/blog/graph-coloring.md).\n\nI Signals computati tracciano dinamicamente le loro dipendenze: ogni volta che vengono eseguiti, possono finire per dipendere da cose diverse, e quell’insieme preciso di dipendenze viene mantenuto aggiornato nel grafo dei Signal. Questo significa che se hai una dipendenza necessaria solo su un ramo, e il calcolo precedente ha seguito l’altro ramo, allora una modifica a quel valore temporaneamente inutilizzato non causerà il ricalcolo del Signal computato, anche quando viene letto.\n\nA differenza delle Promises JavaScript, tutto nei Signals viene eseguito in modo sincrono:\n- Impostare un Signal su un nuovo valore è sincrono, e ciò si riflette immediatamente quando si legge un qualsiasi Signal computato che vi dipende. Non c'è batching incorporato di questa mutazione.\n- La lettura dei Signals computati è sincrona: il loro valore è sempre disponibile.\n- La callback `notify` nei Watcher, come spiegato di seguito, viene eseguita in modo sincrono, durante la chiamata a `.set()` che l'ha attivata (ma dopo che il graph coloring è stato completato).\n\nCome per le Promises, i Signals possono rappresentare uno stato di errore: se la callback di un Signal computato lancia un'eccezione, quell'errore viene memorizzato nella cache proprio come un altro valore, e rilanciato ogni volta che si legge il Signal.\n\n### Comprendere la classe Signal\n\nUn'istanza di `Signal` rappresenta la capacità di leggere un valore che cambia dinamicamente e i cui aggiornamenti vengono tracciati nel tempo. Include anche implicitamente la capacità di iscriversi al Signal, implicitamente tramite un accesso tracciato da un altro Signal computato.\n\nL'API qui è progettata per corrispondere al consenso, seppur molto approssimativo, dell’ecosistema tra una grande frazione delle librerie Signal, nell’uso di nomi come \"signal\", \"computed\" e \"state\". Tuttavia, l’accesso ai Signals Computed e State avviene tramite un metodo `.get()`, che non è in accordo con tutte le popolari API Signal, che usano invece un accesso in stile `.value` o la sintassi di chiamata `signal()`.\n\nL’API è progettata per ridurre il numero di allocazioni, per rendere i Signals adatti all’incorporamento nei framework JavaScript mantenendo prestazioni pari o superiori ai Signals personalizzati dei framework esistenti. Questo implica:\n- I Signals di stato sono un singolo oggetto scrivibile, che può essere sia letto che scritto dallo stesso riferimento. (Vedi implicazioni sotto nella sezione \"Separazione delle capacità\".)\n- Sia i Signals di stato che quelli computati sono progettati per poter essere sottoclassati, per facilitare la possibilità dei framework di aggiungere proprietà aggiuntive tramite campi di classe pubblici e privati (così come metodi per utilizzare quello stato).\n- Varie callback (ad es. `equals`, la callback computata) sono chiamate con il Signal rilevante come valore `this` per il contesto, in modo che non sia necessaria una nuova closure per ogni Signal. Invece, il contesto può essere salvato in proprietà extra dello stesso signal.\n\nAlcune condizioni di errore imposte da questa API:\n- È un errore leggere un computed in modo ricorsivo.\n- La callback `notify` di un Watcher non può leggere o scrivere alcun Signal.\n- Se la callback di un Signal computato lancia un'eccezione, gli accessi successivi al Signal rilanciano quell'errore memorizzato nella cache, finché una delle dipendenze non cambia e viene ricalcolato.\n\nAlcune condizioni che *non* sono imposte:\n- I Signals computati possono scrivere su altri Signals, in modo sincrono all’interno della loro callback\n- Il lavoro messo in coda dalla callback `notify` di un Watcher può leggere o scrivere Signals, rendendo possibile replicare [antipattern classici di React](https://react.dev/learn/you-might-not-need-an-effect) in termini di Signals!\n\n### Implementazione degli effetti\n\nL’interfaccia `Watcher` definita sopra fornisce la base per implementare le tipiche API JS per gli effetti: callback che vengono rieseguite quando altri Signals cambiano, esclusivamente per il loro effetto collaterale. La funzione `effect` utilizzata sopra nell’esempio iniziale può essere definita come segue:\n\n```ts\n// Questa funzione normalmente vivrebbe in una libreria/framework, non nel codice dell’applicazione\n// NOTA: Questa logica di scheduling è troppo basilare per essere utile. Non copiare/incollare.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Un Signal effetto che si valuta a cb, che programma una lettura di se stesso\n// nella coda di microtask ogni volta che una delle sue dipendenze potrebbe cambiare\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nL’API Signal non include alcuna funzione integrata come `effect`. Questo perché la pianificazione degli effetti è sottile e spesso si lega ai cicli di rendering dei framework e ad altri stati o strategie specifici dei framework di alto livello a cui JS non ha accesso.\n\nEsaminando le diverse operazioni usate qui: la callback `notify` passata al costruttore di `Watcher` è la funzione chiamata quando il Signal passa da uno stato \"clean\" (in cui sappiamo che la cache è inizializzata e valida) a uno stato \"checked\" o \"dirty\" (in cui la cache potrebbe o meno essere valida perché almeno uno degli state da cui dipende ricorsivamente è stato modificato).\n\nLe chiamate a `notify` sono alla fine attivate da una chiamata a `.set()` su un qualche Signal di stato. Questa chiamata è sincrona: avviene prima che `.set` ritorni. Ma non c’è bisogno di preoccuparsi che questa callback osservi il grafo dei Signals in uno stato parzialmente processato, perché durante una callback `notify`, nessun Signal può essere letto o scritto, nemmeno in una chiamata `untrack`. Poiché `notify` viene chiamata durante `.set()`, sta interrompendo un altro flusso logico, che potrebbe non essere completo. Per leggere o scrivere Signals da `notify`, programma il lavoro da eseguire successivamente, ad esempio scrivendo il Signal in una lista che verrà poi acceduta, o usando `queueMicrotask` come sopra.\n\nNota che è perfettamente possibile usare efficacemente i Signals senza `Signal.subtle.Watcher` programmando il polling dei Signals computati, come fa Glimmer. Tuttavia, molti framework hanno scoperto che è molto spesso utile che questa logica di scheduling venga eseguita in modo sincrono, quindi l’API Signals la include.\n\nSia i Signals computati che quelli di stato vengono raccolti dal garbage collector come qualsiasi valore JS. Ma i Watcher hanno un modo speciale di tenere vivi gli oggetti: tutti i Signals osservati da un Watcher verranno mantenuti vivi finché uno degli state sottostanti è raggiungibile, poiché questi possono attivare una futura chiamata a `notify` (e poi una futura `.get()`). Per questo motivo, ricordati di chiamare `Watcher.prototype.unwatch` per ripulire gli effetti.\n\n### Una scappatoia non sicura\n\n`Signal.subtle.untrack` è una scappatoia che consente di leggere Signals *senza* tracciare quelle letture. Questa capacità è insicura perché permette la creazione di Signals computati il cui valore dipende da altri Signals, ma che non vengono aggiornati quando tali Signals cambiano. Dovrebbe essere usata quando gli accessi non tracciati non cambieranno il risultato del calcolo.\n\n<!--\nTODO: Mostrare un esempio in cui è una buona idea usare untrack\n\n### Uso di watched/unwatched",
  "status": "ok"
}