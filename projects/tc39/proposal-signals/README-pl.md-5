{
  "id": 5,
  "origin": "\nTODO: Show example of converting an Observable to a computed signal, subscribed only when used by an effect\n\nTODO: Show example of a computed signal which represents the result of a fetch directed at a state, which is cancelled\n\n### Introspection for SSR\n\nTODO: Show how serializing the signal graph works\n\nTODO: Show how you can \"hydrate\" a signal from state to computed later, using a few signals.\n-->\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current draft. Their omission is due to the lack of established consensus in the design space among frameworks, as well as the demonstrated ability to work around their absence with mechanisms on top of the Signals notion described in this document. However, unfortunately, the omission limits the potential of interoperability among frameworks. As prototypes of Signals as described in this document are produced, there will be an effort to reexamine whether these omissions were the appropriate decision.\n\n* **Async**: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transactions**: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nSome possible [convenience methods](https://github.com/proposal-signals/proposal-signals/issues/32) are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently be thought of as \"Stage 0\".\n\n[A polyfill](https://github.com/proposal-signals/signal-polyfill) for this proposal is available, with some basic tests. Some framework authors have begun experimenting with substituting this signal implementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially **conservative** in how we push this proposal forward, so that we don't land in the trap of getting something shipped which we end up regretting and not actually using. Our plan is to do the following extra tasks, not required by the TC39 process, to make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n- Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n- Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n- Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the algorithms that they implement. This can be thought of as a proto-specification, and is included at this early point to nail down one possible set of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n- The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which `Watcher` is invoked, `equals`, the first parameter to `new Signal.Computed`, and the `watched`/`unwatched` callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n- These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do *not* halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the `notify` callback of a Watcher, that exception is sent to the `.set()` call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including `watched`/`unwatched`?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked `~clean~` just like any other with a normal value.\n- Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global for the entire thread, or \"agent\".\n\n- `computing`: The innermost computed or effect Signal currently being reevaluated due to a `.get` or `.run` call, or `null`. Initially `null`.\n- `frozen`: Boolean denoting whether there is a callback currently executing which requires that the graph not be modified. Initially `false`.\n- `generation`: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The `Signal` namespace\n\n`Signal` is an ordinary object which serves as a namespace for Signal-related classes and functions.\n\n`Signal.subtle` is a similar inner namespace object.\n\n### The `Signal.State` class\n\n#### `Signal.State` internal slots\n\n- `value`: The current value of the state signal\n- `equals`: The comparison function used when changing values\n- `watched`: The callback to be called when the signal becomes observed by an effect\n- `unwatched`: The callback to be called when the signal is no longer observed by an effect\n- `sinks`: Set of watched signals which depend on this one\n\n#### Constructor: `Signal.State(initialValue, options)`\n\n1. Set this Signal's `value` to `initialValue`.\n1. Set this Signal's `equals` to options?.equals\n1. Set this Signal's `watched` to options?.[Signal.subtle.watched]\n1. Set this Signal's `unwatched` to options?.[Signal.subtle.unwatched]\n1. Set this Signal's `sinks` to the empty set\n\n#### Method: `Signal.State.prototype.get()`\n\n1. If `frozen` is true, throw an exception.\n1. If `computing` is not `undefined`, add this Signal to `computing`'s `sources` set.\n1. NOTE: We do not add `computing` to this Signal's `sinks` set until it is watched by a Watcher.\n1. Return this Signal's `value`.\n\n#### Method: `Signal.State.prototype.set(newValue)`\n\n1. If the current execution context is `frozen`, throw an exception.\n1. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n1. If that algorithm returned `~clean~`, then return undefined.\n1. Set the `state` of all `sinks` of this Signal to (if it is a Computed Signal) `~dirty~` if they were previously clean, or (if it is a Watcher) `~pending~` if it was previously `~watching~`.\n1. Set the `state` of all of the sinks' Computed Signal dependencies (recursively) to `~checked~` if they were previously `~clean~` (that is, leave dirty markings in place), or for Watchers, `~pending~` if previously `~watching~`.\n1. For each previously `~watching~` Watcher encountered in that recursive search, then in depth-first order,\n    1. Set `frozen` to true.\n    1. Calling their `notify` callback (saving aside any exception thrown, but ignoring the return value of `notify`).\n    1. Restore `frozen` to false.\n    1. Set the `state` of the Watcher to `~waiting~`.\n1. If any exception was thrown from the `notify` callbacks, propagate it to the caller after all `notify` callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n1. Return undefined.\n\n### The `Signal.Computed` class\n\n#### `Signal.Computed` State machine",
  "translate": "TODO: Pokaż przykład konwersji Observable na sygnał obliczany, subskrybowany tylko wtedy, gdy jest używany przez efekt\n\nTODO: Pokaż przykład sygnału obliczanego, który reprezentuje wynik fetch skierowanego do stanu, który jest anulowany\n\n### Introspekcja dla SSR\n\nTODO: Pokaż, jak działa serializacja grafu sygnałów\n\nTODO: Pokaż, jak można \"zhydratować\" sygnał od stanu do obliczanego później, używając kilku sygnałów.\n-->\n\n### Pominięte na razie\n\nTe funkcje mogą zostać dodane później, ale nie są uwzględnione w obecnym szkicu. Ich pominięcie wynika z braku ustalonego konsensusu w przestrzeni projektowej pomiędzy frameworkami, jak również z wykazanej możliwości obejścia ich braku za pomocą mechanizmów opartych na koncepcji Sygnałów opisanej w tym dokumencie. Niestety jednak, pominięcie tych funkcji ogranicza potencjał interoperacyjności pomiędzy frameworkami. Wraz z powstawaniem prototypów Sygnałów opisanych w tym dokumencie, podejmowane będą wysiłki, aby ponownie ocenić, czy te pominięcia były właściwą decyzją.\n\n* **Async**: Sygnały są zawsze dostępne do ewaluacji synchronicznie, w tym modelu. Jednak często przydatne jest posiadanie pewnych procesów asynchronicznych, które prowadzą do ustawienia sygnału, oraz zrozumienie, kiedy sygnał jest nadal \"wczytywany\". Jednym z prostych sposobów modelowania stanu ładowania jest użycie wyjątków, a zachowanie buforowania wyjątków w sygnałach obliczanych dość dobrze komponuje się z tą techniką. Ulepszone techniki są omówione w [Issue #30](https://github.com/proposal-signals/proposal-signals/issues/30).\n* **Transakcje**: Dla przejść pomiędzy widokami często przydatne jest utrzymanie żywego stanu zarówno dla stanu \"od\", jak i \"do\". Stan \"do\" renderuje się w tle, dopóki nie będzie gotowy do przełączenia (zatwierdzenie transakcji), podczas gdy stan \"od\" pozostaje interaktywny. Utrzymanie obu stanów jednocześnie wymaga \"rozdwojenia\" stanu grafu sygnałów, a czasem nawet przydatne może być wsparcie dla wielu oczekujących przejść naraz. Dyskusja w [Issue #73](https://github.com/proposal-signals/proposal-signals/issues/73).\n\nNiektóre możliwe [metody wygodne](https://github.com/proposal-signals/proposal-signals/issues/32) również zostały pominięte.\n\n## Status i plan rozwoju\n\nTa propozycja znajduje się w agendzie TC39 na kwiecień 2024 jako Etap 1. Obecnie można ją traktować jako \"Etap 0\".\n\n[Dostępny jest polyfill](https://github.com/proposal-signals/signal-polyfill) dla tej propozycji, z podstawowymi testami. Niektórzy autorzy frameworków zaczęli eksperymentować z zastępowaniem tej implementacji sygnału, ale to zastosowanie jest na wczesnym etapie.\n\nWspółpracownicy przy propozycji Sygnałów chcą być szczególnie **konserwatywni** w przesuwaniu tej propozycji naprzód, aby nie wpaść w pułapkę wdrożenia czegoś, czego potem będziemy żałować i nie będziemy faktycznie używać. Nasz plan obejmuje wykonanie następujących dodatkowych zadań, niewymaganych przez proces TC39, aby mieć pewność, że ta propozycja jest na właściwej drodze:\n\nPrzed zaproponowaniem Etapu 2 planujemy:\n- Opracować wiele produkcyjnych implementacji polyfill, które są solidne, dobrze przetestowane (np. przechodzą testy z różnych frameworków oraz testy w stylu test262) i konkurencyjne pod względem wydajności (zweryfikowane za pomocą dokładnego zestawu benchmarków sygnał/framework).\n- Zintegrować proponowane API Sygnałów z wieloma frameworkami JS, które uważamy za w miarę reprezentatywne, oraz sprawić, aby duże aplikacje działały na tej bazie. Przetestować, czy działa to wydajnie i poprawnie w tych kontekstach.\n- Mieć solidne zrozumienie przestrzeni potencjalnych rozszerzeń API oraz ustalić, które (jeśli w ogóle) powinny zostać dodane do tej propozycji.\n\n## Algorytmy sygnałów\n\nTa sekcja opisuje każde z API udostępnionych dla JavaScript, w kategoriach algorytmów, które implementują. Można to traktować jako proto-specyfikację i jest zawarta na tym wczesnym etapie, aby doprecyzować jeden możliwy zestaw semantyki, pozostając jednocześnie otwartym na zmiany.\n\nNiektóre aspekty algorytmu:\n- Kolejność odczytów Sygnałów w sygnale obliczanym ma znaczenie i jest obserwowalna w kolejności, w jakiej wykonywane są pewne callbacki (który `Watcher` jest wywoływany, `equals`, pierwszy parametr dla `new Signal.Computed` oraz callbacki `watched`/`unwatched`). Oznacza to, że źródła sygnału obliczanego muszą być przechowywane w uporządkowanej kolejności.\n- Te cztery callbacki mogą wszystkie rzucać wyjątki, a te wyjątki są propagowane w przewidywalny sposób do wywołującego kodu JS. Wyjątki *nie* zatrzymują wykonywania tego algorytmu ani nie pozostawiają grafu w stanie częściowo przetworzonym. W przypadku błędów rzuconych w callbacku `notify` obiektu Watcher, wyjątek jest przekazywany do wywołania `.set()`, które go wywołało, z użyciem AggregateError, jeśli rzucono wiele wyjątków. Pozostałe (w tym `watched`/`unwatched`?) są przechowywane w wartości Sygnału, aby mogły zostać ponownie rzucone przy odczycie, i taki ponownie rzucany Sygnał może być oznaczony jako `~clean~`, tak jak każdy inny z normalną wartością.\n- Zachowano ostrożność, aby unikać cykliczności w przypadku sygnałów obliczanych, które nie są \"obserwowane\" (przez jakikolwiek Watcher), tak aby mogły być zbierane przez GC niezależnie od innych części grafu sygnałów. Wewnętrznie można to zaimplementować za pomocą systemu numerów generacji, które są zawsze zbierane; należy zauważyć, że zoptymalizowane implementacje mogą także zawierać lokalne numery generacji na węzeł lub nie śledzić niektórych numerów na obserwowanych sygnałach.\n\n### Ukryty stan globalny\n\nAlgorytmy Sygnału muszą odnosić się do pewnego stanu globalnego. Stan ten jest globalny dla całego wątku lub \"agenta\".\n\n- `computing`: Najgłębiej zagnieżdżony sygnał obliczany lub efekt, aktualnie ponownie ewaluowany przez wywołanie `.get` lub `.run`, lub `null`. Początkowo `null`.\n- `frozen`: Wartość boolean oznaczająca, czy aktualnie wykonywany callback wymaga, aby graf nie był modyfikowany. Początkowo `false`.\n- `generation`: Rosnąca liczba całkowita, zaczynająca się od 0, używana do śledzenia, jak aktualna jest wartość przy jednoczesnym unikaniu cykliczności.\n\n### Przestrzeń nazw `Signal`\n\n`Signal` to zwykły obiekt, który służy jako przestrzeń nazw dla klas i funkcji powiązanych z Sygnałami.\n\n`Signal.subtle` jest podobnym wewnętrznym obiektem przestrzeni nazw.\n\n### Klasa `Signal.State`\n\n#### Sloty wewnętrzne `Signal.State`\n\n- `value`: Aktualna wartość sygnału stanu\n- `equals`: Funkcja porównująca używana przy zmianie wartości\n- `watched`: Callback wywoływany, gdy sygnał staje się obserwowany przez efekt\n- `unwatched`: Callback wywoływany, gdy sygnał przestaje być obserwowany przez efekt\n- `sinks`: Zbiór obserwowanych sygnałów, które zależą od tego\n\n#### Konstruktor: `Signal.State(initialValue, options)`\n\n1. Ustaw `value` tego sygnału na `initialValue`.\n1. Ustaw `equals` tego sygnału na options?.equals\n1. Ustaw `watched` tego sygnału na options?.[Signal.subtle.watched]\n1. Ustaw `unwatched` tego sygnału na options?.[Signal.subtle.unwatched]\n1. Ustaw `sinks` tego sygnału na pusty zbiór\n\n#### Metoda: `Signal.State.prototype.get()`\n\n1. Jeśli `frozen` jest prawdziwe, rzuć wyjątek.\n1. Jeśli `computing` nie jest `undefined`, dodaj ten Sygnał do zbioru `sources` obiektu `computing`.\n1. UWAGA: Nie dodajemy `computing` do zbioru `sinks` tego sygnału, dopóki nie zostanie on obserwowany przez Watcher.\n1. Zwróć wartość tego sygnału.\n\n#### Metoda: `Signal.State.prototype.set(newValue)`\n\n1. Jeśli bieżący kontekst wykonania to `frozen`, rzuć wyjątek.\n1. Wykonaj algorytm \"ustawiania wartości Sygnału\" z tym sygnałem i pierwszym parametrem jako wartość.\n1. Jeśli algorytm zwrócił `~clean~`, zwróć undefined.\n1. Ustaw `state` wszystkich `sinks` tego Sygnału na (jeśli jest to sygnał obliczany) `~dirty~`, jeśli wcześniej były czyste, lub (jeśli jest to Watcher) `~pending~`, jeśli wcześniej był `~watching~`.\n1. Ustaw `state` wszystkich zależności sygnałów obliczanych należących do tych `sinks` (rekurencyjnie) na `~checked~`, jeśli wcześniej były `~clean~` (pozostawiając oznaczenia dirty), lub dla Watcherów na `~pending~`, jeśli wcześniej były `~watching~`.\n1. Dla każdego napotkanego w tej rekurencji wcześniej `~watching~` Watchera, w kolejności DFS:\n    1. Ustaw `frozen` na true.\n    1. Wywołaj ich callback `notify` (zachowując każdy rzucony wyjątek, ale ignorując wartość zwracaną przez `notify`).\n    1. Przywróć `frozen` na false.\n    1. Ustaw `state` Watchera na `~waiting~`.\n1. Jeśli jakikolwiek wyjątek został rzucony z callbacków `notify`, przekaż go do wywołującego po wykonaniu wszystkich callbacków `notify`. Jeśli było wiele wyjątków, zapakuj je w AggregateError i rzuć.\n1. Zwróć undefined.\n\n### Klasa `Signal.Computed`\n\n#### Maszyna stanów `Signal.Computed`",
  "status": "ok"
}