{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* Lưu ý rằng hầu hết các framework hiện nay đều yêu cầu phải giải phóng rõ ràng các Signal tính toán (computed Signals) nếu chúng có bất kỳ tham chiếu nào đến hoặc từ một đồ thị Signal khác vẫn còn tồn tại.\n* Điều này không quá tệ khi vòng đời của chúng gắn liền với vòng đời của một thành phần giao diện người dùng, và các hiệu ứng cũng cần được giải phóng dù sao đi nữa.\n* Nếu việc thực thi với các ngữ nghĩa này quá tốn kém, thì chúng ta nên thêm cơ chế giải phóng rõ ràng (hoặc \"hủy liên kết\") cho các Signal tính toán vào API bên dưới, vốn hiện tại chưa có.\n* Một mục tiêu liên quan riêng biệt: Giảm thiểu số lần cấp phát bộ nhớ, ví dụ:\n    * để tạo một Signal có thể ghi (tránh hai closure riêng biệt + mảng)\n    * để triển khai các hiệu ứng (tránh tạo một closure cho mỗi lần phản ứng)\n    * Trong API để quan sát thay đổi của Signal, tránh tạo thêm các cấu trúc dữ liệu tạm thời\n    * Giải pháp: API dựa trên lớp (class-based), cho phép tái sử dụng các phương thức và trường được định nghĩa trong lớp con\n\n## Phác thảo API\n\nDưới đây là ý tưởng ban đầu về một API cho Signal. Lưu ý rằng đây chỉ là bản dự thảo sớm, và chúng tôi dự đoán sẽ có những thay đổi theo thời gian. Hãy bắt đầu với toàn bộ file `.d.ts` để hình dung tổng thể, sau đó chúng ta sẽ thảo luận chi tiết về ý nghĩa của từng phần.\n\n```ts\ninterface Signal<T> {\n    // Lấy giá trị của signal\n    get(): T;\n}\n\nnamespace Signal {\n    // Signal đọc-ghi\n    class State<T> implements Signal<T> {\n        // Tạo một state Signal bắt đầu với giá trị t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Lấy giá trị của signal\n        get(): T;\n\n        // Đặt giá trị của state Signal thành t\n        set(t: T): void;\n    }\n\n    // Một Signal là công thức dựa trên các Signal khác\n    class Computed<T = unknown> implements Signal<T> {\n        // Tạo một Signal đánh giá ra giá trị trả về từ callback.\n        // Callback được gọi với signal này là giá trị this.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Lấy giá trị của signal\n        get(): T;\n    }\n\n    // Namespace này bao gồm các tính năng \"nâng cao\" tốt hơn nên để dành cho tác giả framework hơn là nhà phát triển ứng dụng.\n    // Tương tự như `crypto.subtle`\n    namespace subtle {\n        // Chạy một callback với toàn bộ tracking bị vô hiệu hóa\n        function untrack<T>(cb: () => T): T;\n\n        // Lấy signal tính toán hiện tại đang theo dõi các lần đọc signal, nếu có\n        function currentComputed(): Computed | null;\n\n        // Trả về danh sách có thứ tự của tất cả các signal mà signal này đã tham chiếu\n        // trong lần đánh giá gần nhất.\n        // Đối với Watcher, liệt kê tập hợp các signal mà nó đang theo dõi.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Trả về các Watcher mà signal này nằm trong đó, cùng với bất kỳ\n        // Signal tính toán nào đã đọc signal này lần cuối cùng chúng được đánh giá,\n        // nếu signal tính toán đó (đệ quy) đang được theo dõi.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // Đúng nếu signal này đang \"sống\", tức là nó được theo dõi bởi một Watcher,\n        // hoặc được đọc bởi một Signal tính toán (đệ quy) đang sống.\n        function hasSinks(s: State | Computed): boolean;\n\n        // Đúng nếu phần tử này là \"reactive\", tức là nó phụ thuộc\n        // vào một signal khác. Một Computed mà hasSources là false\n        // sẽ luôn trả về cùng một hằng số.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // Khi một nguồn (đệ quy) của Watcher bị ghi, gọi callback này,\n            // nếu nó chưa được gọi kể từ lần gọi `watch` gần nhất.\n            // Không được đọc hay ghi signal nào trong quá trình notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Thêm các signal này vào tập của Watcher, và đặt Watcher để chạy callback notify\n            // lần tới khi bất kỳ signal nào trong tập (hoặc một trong các phụ thuộc của nó) thay đổi.\n            // Có thể gọi mà không truyền đối số chỉ để đặt lại trạng thái \"đã thông báo\", để callback notify sẽ được gọi lại.\n            watch(...s: Signal[]): void;\n\n            // Loại bỏ các signal này khỏi tập đang theo dõi (ví dụ, cho một effect đã giải phóng)\n            unwatch(...s: Signal[]): void;\n\n            // Trả về tập các nguồn trong tập của Watcher vẫn còn dirty, hoặc là một signal tính toán\n            // có nguồn dirty hoặc đang chờ và chưa được đánh giá lại\n            getPending(): Signal[];\n        }\n\n        // Hook để quan sát khi được theo dõi hoặc không còn được theo dõi\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Hàm so sánh tùy chỉnh giữa giá trị cũ và mới. Mặc định: Object.is.\n        // Signal được truyền vào làm giá trị this cho context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "status": "ok"
}