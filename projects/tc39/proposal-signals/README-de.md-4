{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback, der aufgerufen wird, wenn isWatched zu true wird, falls es zuvor false war\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback, der aufgerufen wird, wenn isWatched zu false wird, falls es zuvor true war\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Wie Signale funktionieren\n\nEin Signal repräsentiert eine Datenzelle, die sich im Laufe der Zeit ändern kann. Signale können entweder „state“ (nur ein Wert, der manuell gesetzt wird) oder „computed“ (eine Formel, die auf anderen Signalen basiert) sein.\n\nBerechnete (Computed) Signale funktionieren, indem sie automatisch verfolgen, welche anderen Signale während ihrer Auswertung gelesen werden. Wenn ein berechnetes Signal gelesen wird, prüft es, ob sich eine seiner zuvor aufgezeichneten Abhängigkeiten geändert hat, und berechnet sich gegebenenfalls neu. Wenn mehrere berechnete Signale geschachtelt sind, wird die gesamte Attribution des Trackings dem innersten Signal zugeordnet.\n\nBerechnete Signale sind lazy, d. h. pull-basiert: Sie werden nur dann neu berechnet, wenn sie abgerufen werden, selbst wenn sich eine ihrer Abhängigkeiten bereits früher geändert hat.\n\nDer Callback, der in berechnete Signale übergeben wird, sollte im Allgemeinen „pure“ sein, also eine deterministische, nebenwirkungsfreie Funktion der anderen Signale, auf die zugegriffen wird. Gleichzeitig ist der Zeitpunkt, zu dem der Callback aufgerufen wird, deterministisch, sodass Nebenwirkungen mit Vorsicht eingesetzt werden können.\n\nSignale verfügen über prominentes Caching/Memoisierung: Sowohl state- als auch computed-Signale merken sich ihren aktuellen Wert und lösen nur dann eine Neuberechnung von berechneten Signalen aus, die auf sie verweisen, wenn sie sich tatsächlich ändern. Ein wiederholter Vergleich von alten und neuen Werten ist nicht einmal nötig – der Vergleich findet einmal statt, wenn das Quellsignal zurückgesetzt/neu berechnet wird, und der Signalmechanismus verfolgt, welche Dinge, die auf dieses Signal verweisen, noch nicht anhand des neuen Werts aktualisiert wurden. Intern wird dies im Allgemeinen durch „Graph Coloring“ dargestellt, wie in (Milos Blogpost) beschrieben.\n\nBerechnete Signale verfolgen ihre Abhängigkeiten dynamisch – jedes Mal, wenn sie ausgeführt werden, können sie von unterschiedlichen Dingen abhängen, und genau diese Abhängigkeitsmenge wird im Signalgraph aktuell gehalten. Das bedeutet: Wenn Sie eine Abhängigkeit nur in einem Zweig benötigen und die vorherige Berechnung den anderen Zweig genommen hat, wird eine Änderung des temporär ungenutzten Werts das berechnete Signal nicht neu berechnen, selbst wenn es abgerufen wird.\n\nIm Gegensatz zu JavaScript-Promises läuft in Signalen alles synchron ab:\n- Das Setzen eines Signals auf einen neuen Wert ist synchron, und dies wird sofort widergespiegelt, wenn anschließend ein berechnetes Signal, das davon abhängt, gelesen wird. Es gibt kein eingebautes Batching dieser Mutation.\n- Das Lesen von berechneten Signalen ist synchron – ihr Wert ist immer verfügbar.\n- Der `notify`-Callback in Watchern, wie unten erklärt, läuft synchron während des `.set()`-Aufrufs, der ihn ausgelöst hat (aber nachdem das Graph Coloring abgeschlossen ist).\n\nWie bei Promises können Signale einen Fehlerzustand darstellen: Wenn der Callback eines berechneten Signals einen Fehler wirft, wird dieser Fehler wie ein anderer Wert zwischengespeichert und bei jedem Lesen des Signals erneut ausgelöst.\n\n### Verständnis der Signal-Klasse\n\nEine `Signal`-Instanz stellt die Fähigkeit dar, einen sich dynamisch ändernden Wert zu lesen, dessen Aktualisierungen im Laufe der Zeit verfolgt werden. Sie beinhaltet implizit auch die Fähigkeit, das Signal zu abonnieren, implizit durch einen getrackten Zugriff von einem anderen berechneten Signal aus.\n\nDie API ist so gestaltet, dass sie dem groben Ökosystem-Konsens unter einem großen Teil der Signal-Bibliotheken bei der Verwendung von Namen wie „signal“, „computed“ und „state“ entspricht. Der Zugriff auf berechnete und state-Signale erfolgt jedoch über eine `.get()`-Methode, was von allen populären Signal-APIs abweicht, die entweder einen `.value`-ähnlichen Accessor oder `signal()`-Aufrufsyntax verwenden.\n\nDie API ist so konzipiert, dass sie die Anzahl der Speicherzuweisungen reduziert, um Signale für die Einbettung in JavaScript-Frameworks geeignet zu machen und dabei die gleiche oder bessere Performance als bestehende framework-spezifische Signale zu erreichen. Dies bedeutet:\n- State-Signale sind ein einzelnes schreibbares Objekt, das sowohl abgerufen als auch gesetzt werden kann, und zwar über dieselbe Referenz. (Siehe Implikationen unten im Abschnitt „Capability separation“.)\n- Sowohl State- als auch Computed-Signale sind so gestaltet, dass sie unterklassenfähig sind, um Frameworks die Möglichkeit zu geben, zusätzliche Eigenschaften über öffentliche und private Klassenfelder (sowie Methoden zur Verwendung dieses Zustands) hinzuzufügen.\n- Verschiedene Callbacks (z. B. `equals`, der Callback für berechnete Signale) werden mit dem jeweiligen Signal als `this`-Wert für den Kontext aufgerufen, sodass pro Signal kein neuer Closure benötigt wird. Der Kontext kann stattdessen in zusätzlichen Eigenschaften des Signals selbst gespeichert werden.\n\nEinige von dieser API durchgesetzte Fehlerbedingungen:\n- Es ist ein Fehler, ein berechnetes Signal rekursiv zu lesen.\n- Der `notify`-Callback eines Watchers darf keine Signale lesen oder schreiben.\n- Wenn der Callback eines berechneten Signals einen Fehler wirft, werden nachfolgende Zugriffe auf das Signal diesen zwischengespeicherten Fehler erneut auslösen, bis sich eine der Abhängigkeiten ändert und es neu berechnet wird.\n\nEinige Bedingungen, die *nicht* erzwungen werden:\n- Berechnete Signale können innerhalb ihres Callbacks synchron auf andere Signale schreiben.\n- Arbeit, die von einem `notify`-Callback eines Watchers eingereiht wird, kann Signale lesen oder schreiben, sodass es möglich ist, [klassische React-Antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in Bezug auf Signale zu replizieren!\n\n### Effekte implementieren\n\nDas oben definierte `Watcher`-Interface bildet die Grundlage für die Implementierung typischer JS-APIs für Effekte: Callbacks, die erneut ausgeführt werden, wenn sich andere Signale ändern, rein aufgrund ihrer Nebenwirkung. Die `effect`-Funktion, die oben im Anfangsbeispiel verwendet wurde, kann wie folgt definiert werden:\n\n```ts\n// Diese Funktion würde normalerweise in einer Bibliothek/einem Framework leben, nicht im Anwendungscode\n// HINWEIS: Diese Scheduling-Logik ist zu einfach, um nützlich zu sein. Nicht kopieren/einfügen.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Ein Effekt-Signal, das cb auswertet und bei jeder potenziellen Änderung einer seiner Abhängigkeiten\n// selbst auf die Microtask-Queue zur erneuten Auswertung plant\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nDie Signal-API enthält keine eingebaute Funktion wie `effect`. Das liegt daran, dass das Scheduling von Effekten subtil ist und oft mit Framework-Rendering-Zyklen und anderen Framework-spezifischen Zuständen oder Strategien zusammenhängt, auf die JS keinen Zugriff hat.\n\nEin Durchgang durch die hier verwendeten Operationen: Der `notify`-Callback, der an den Watcher-Konstruktor übergeben wird, ist die Funktion, die aufgerufen wird, wenn das Signal von einem „clean“-Zustand (bei dem der Cache initialisiert und gültig ist) in einen „checked“- oder „dirty“-Zustand wechselt (bei dem der Cache möglicherweise gültig ist oder nicht, weil sich mindestens einer der Zustände, von denen es rekursiv abhängt, geändert hat).\n\nAufrufe von `notify` werden letztlich durch einen Aufruf von `.set()` auf einem State-Signal ausgelöst. Dieser Aufruf ist synchron: Er erfolgt, bevor `.set` zurückkehrt. Aber es besteht kein Grund zur Sorge, dass dieser Callback den Signalgraphen in einem halbverarbeiteten Zustand beobachtet, da während eines `notify`-Callbacks kein Signal gelesen oder geschrieben werden kann, auch nicht in einem `untrack`-Aufruf. Da `notify` während `.set()` aufgerufen wird, unterbricht es einen anderen Logik-Thread, der möglicherweise nicht abgeschlossen ist. Um Signale aus `notify` zu lesen oder zu schreiben, planen Sie Arbeiten für später ein, z. B. indem Sie das Signal in eine Liste eintragen, damit es später abgerufen werden kann, oder mit `queueMicrotask` wie oben.\n\nBeachten Sie, dass es durchaus möglich ist, Signale effektiv ohne `Signal.subtle.Watcher` zu verwenden, indem man das Polling von berechneten Signalen plant, wie es Glimmer tut. Viele Frameworks haben jedoch festgestellt, dass es sehr oft nützlich ist, diese Scheduling-Logik synchron auszuführen, weshalb die Signals-API dies vorsieht.\n\nSowohl berechnete als auch state-Signale werden wie alle JS-Werte vom Garbage Collector aufgeräumt. Watcher haben jedoch eine besondere Möglichkeit, Dinge am Leben zu halten: Alle Signale, die von einem Watcher beobachtet werden, werden so lange am Leben gehalten, wie einer der zugrundeliegenden States erreichbar ist, da diese einen zukünftigen `notify`-Aufruf (und dann ein zukünftiges `.get()`) auslösen können. Aus diesem Grund sollten Sie daran denken, `Watcher.prototype.unwatch` aufzurufen, um Effekte aufzuräumen.\n\n### Eine unsichere Hintertür\n\n`Signal.subtle.untrack` ist eine Hintertür, die das Lesen von Signalen *ohne* Verfolgung dieser Lesezugriffe ermöglicht. Diese Fähigkeit ist unsicher, weil sie die Erstellung von berechneten Signalen erlaubt, deren Wert von anderen Signalen abhängt, die jedoch nicht aktualisiert werden, wenn sich diese Signale ändern. Sie sollte verwendet werden, wenn die ungetrackten Zugriffe das Ergebnis der Berechnung nicht verändern werden.\n\n<!--\nTODO: Beispiel zeigen, in dem es sinnvoll ist, untrack zu verwenden\n\n### Verwendung von watched/unwatched\n```",
  "status": "ok"
}