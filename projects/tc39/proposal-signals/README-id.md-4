{
  "id": 4,
  "origin": "\n        // Callback called when isWatched becomes true, if it was previously false\n        [Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n        // Callback called whenever isWatched becomes false, if it was previously true\n        [Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n    }\n}\n```\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be either \"state\" (just a value which is set manually) or \"computed\" (a formula based on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read during their evaluation. When a computed is read, it checks whether any of its previously recorded dependencies have changed, and re-evaluates itself if so. When multiple computed Signals are nested, all of the attribution of the tracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when they are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the sense of being a deterministic, side-effect-free function of the other Signals which it accesses. At the same time, the timing of the callback being called is deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals remember their current value, and only trigger recalculation of computed Signals which reference them if they actually change. A repeated comparison of old vs new values isn't even needed--the comparison is made once when the source Signal is reset/re-evaluated, and the Signal mechanism keeps track of which things referencing that Signal have not updated based on the new value yet. Internally, this is generally represented through \"graph coloring\" as described in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run, they may end up depending on different things, and that precise dependency set is kept fresh in the Signal graph. This means that if you have a dependency needed on only one branch, and the previous calculation took the other branch, then a change to that temporarily unused value will not cause the computed Signal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n- Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n- Reading computed Signals is synchronous--their value is always available.\n- The `notify` callback in Watchers, as explained below, runs synchronously, during the `.set()` call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's callback throws, then that error is cached just like another value, and rethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA `Signal` instance represents the capability to read a dynamically changing value whose updates are tracked over time. It also implicitly includes the capability to subscribe to the Signal, implicitly through a tracked access from another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a large fraction of Signal libraries in the use of names like \"signal\", \"computed\" and \"state\". However, access to Computed and State Signals is through a `.get()` method, which disagrees with all popular Signal APIs, which either use a `.value`-style accessor, or `signal()` call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals suitable for embedding in JavaScript frameworks while reaching same or better performance than existing framework-customized Signals. This implies:\n- State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n- Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n- Various callbacks (e.g., `equals`, the computed callback) are called with the relevant Signal as the `this` value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n- It is an error to read a computed recursively.\n- The `notify` callback of a Watcher cannot read or write any signals\n- If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are *not* enforced:\n- Computed Signals can write to other Signals, synchronously within their callback\n- Work which is queued by a Watcher's `notify` callback may read or write signals, making it possible to replicate [classic React antipatterns](https://react.dev/learn/you-might-not-need-an-effect) in terms of Signals!\n\n### Implementing effects\n\nThe `Watcher` interface defined above gives the basis for implementing typical JS APIs for effects: callbacks which are re-run when other Signals change, purely for their side effect. The `effect` function used above in the initial example can be defined as follows:\n\n```ts\n// This function would usually live in a library/framework, not application code\n// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// An effect effect Signal which evaluates to cb, which schedules a read of\n// itself on the microtask queue whenever one of its dependencies might change\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nThe Signal API does not include any built-in function like `effect`. This is because effect scheduling is subtle and often ties into framework rendering cycles and other high-level framework-specific state or strategies which JS does not have access to.\n\nWalking through the different operations used here: The `notify` callback passed into `Watcher` constructor is the function that is called when the Signal goes from a \"clean\" state (where we know the cache is initialized and valid) into a \"checked\" or \"dirty\" state (where the cache might or might not be valid because at least one of the states which this recursively depends on has been changed).\n\nCalls to `notify` are ultimately triggered by a call to `.set()` on some state Signal. This call is synchronous: it happens before `.set` returns. But there's no need to worry about this callback observing the Signal graph in a half-processed state, because during a `notify` callback, no Signal can be read or written, even in an `untrack` call. Because `notify` is called during `.set()`, it is interrupting another thread of logic, which might not be complete. To read or write Signals from `notify`, schedule work to run later, e.g., by writing the Signal down in a list to later be accessed, or with `queueMicrotask` as above.\n\nNote that it is perfectly possible to use Signals effectively without `Signal.subtle.Watcher` by scheduling polling of computed Signals, as Glimmer does. However, many frameworks have found that it is very often useful to have this scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But Watchers have a special way of holding things alive: Any Signals which are watched by a Watcher will be held alive as long as any of the underlying states are reachable, as these may trigger a future `notify` call (and then a future `.get()`). For this reason, remember to call `Watcher.prototype.unwatch` to clean up effects.\n\n### An unsound escape hatch\n\n`Signal.subtle.untrack` is an escape hatch allowing reading Signals *without* tracking those reads. This capability is unsafe because it allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n\n<!--\nTODO: Show example where it's a good idea to use untrack\n\n### Using watched/unwatched",
  "translate": "```ts\n// Callback dipanggil ketika isWatched menjadi true, jika sebelumnya false\n[Signal.subtle.watched]?: (this: Signal<T>) => void;\n\n// Callback dipanggil setiap kali isWatched menjadi false, jika sebelumnya true\n[Signal.subtle.unwatched]?: (this: Signal<T>) => void;\n}\n}\n```\n\n### Cara Kerja Signal\n\nSebuah Signal merepresentasikan sebuah sel data yang dapat berubah seiring waktu. Signal dapat berupa \"state\" (hanya sebuah nilai yang diatur secara manual) atau \"computed\" (sebuah rumus berdasarkan Signal lain).\n\nSignal computed bekerja dengan secara otomatis melacak Signal lain mana yang dibaca selama evaluasinya. Ketika sebuah computed dibaca, ia memeriksa apakah salah satu dependensi yang telah tercatat sebelumnya telah berubah, dan melakukan evaluasi ulang jika ya. Ketika beberapa Signal computed disusun secara bersarang, semua atribusi pelacakan diarahkan ke yang paling dalam.\n\nSignal computed bersifat lazy, yaitu berbasis tarik (pull-based): mereka hanya dievaluasi ulang ketika diakses, meskipun salah satu dependensinya telah berubah sebelumnya.\n\nCallback yang diberikan ke Signal computed sebaiknya \"pure\" dalam arti merupakan fungsi deterministik tanpa efek samping dari Signal lain yang diaksesnya. Namun, waktu callback dipanggil juga deterministik, sehingga efek samping tetap dapat digunakan dengan hati-hati.\n\nSignal memiliki fitur caching/memoisasi yang menonjol: baik Signal state maupun computed mengingat nilai saat ini, dan hanya memicu perhitungan ulang pada Signal computed yang merujuk padanya jika memang terjadi perubahan. Perbandingan berulang antara nilai lama dan baru bahkan tidak diperlukan--perbandingan dilakukan sekali ketika Signal sumber di-reset/dievaluasi ulang, dan mekanisme Signal melacak siapa saja yang merujuk ke Signal tersebut yang belum diperbarui berdasarkan nilai baru. Secara internal, hal ini umumnya direpresentasikan melalui \"graph coloring\" seperti dijelaskan dalam (Milo's blog post).\n\nSignal computed melacak dependensinya secara dinamis--setiap kali dijalankan, mereka mungkin bergantung pada hal yang berbeda, dan himpunan dependensi yang tepat tetap diperbarui dalam graph Signal. Ini berarti jika Anda memiliki dependensi yang hanya dibutuhkan pada satu cabang, dan perhitungan sebelumnya mengambil cabang lain, maka perubahan pada nilai yang sementara tidak digunakan tersebut tidak akan menyebabkan Signal computed dihitung ulang, bahkan ketika diakses.\n\nTidak seperti JavaScript Promises, semua hal dalam Signal berjalan secara sinkron:\n- Mengatur Signal ke nilai baru bersifat sinkron, dan langsung tercermin ketika membaca Signal computed yang bergantung padanya. Tidak ada batching perubahan bawaan.\n- Membaca Signal computed bersifat sinkron--nilainya selalu tersedia.\n- Callback `notify` di Watcher, seperti dijelaskan di bawah, dijalankan secara sinkron, selama pemanggilan `.set()` yang memicunya (tetapi setelah graph coloring selesai).\n\nSeperti Promise, Signal dapat merepresentasikan keadaan error: Jika callback Signal computed melempar error, maka error tersebut disimpan seperti nilai lain, dan dilempar ulang setiap kali Signal dibaca.\n\n### Memahami Kelas Signal\n\nSebuah instance `Signal` merepresentasikan kemampuan untuk membaca nilai yang berubah secara dinamis yang perubahannya dilacak seiring waktu. Ini juga secara implisit mencakup kemampuan untuk subscribe ke Signal, secara implisit melalui akses yang dilacak dari Signal computed lain.\n\nAPI di sini dirancang agar sesuai dengan konsensus ekosistem yang sangat kasar di antara sebagian besar pustaka Signal dalam penggunaan nama seperti \"signal\", \"computed\" dan \"state\". Namun, akses ke Signal Computed dan State melalui metode `.get()`, yang berbeda dengan semua API Signal populer, yang menggunakan akses bergaya `.value` atau sintaks pemanggilan `signal()`.\n\nAPI ini dirancang untuk mengurangi jumlah alokasi, agar Signal cocok untuk disematkan dalam framework JavaScript sambil mencapai performa yang sama atau lebih baik dibandingkan Signal yang dikustomisasi framework. Implikasinya:\n- Signal State adalah satu objek yang dapat ditulis, yang dapat diakses dan diatur dari referensi yang sama. (Lihat implikasi di bawah pada bagian \"Pemilahan Kapabilitas\".)\n- Baik Signal State maupun Computed dirancang agar dapat di-subclass, untuk memudahkan framework menambah properti tambahan melalui field class publik dan privat (juga metode untuk menggunakan state tersebut).\n- Berbagai callback (misal, `equals`, callback computed) dipanggil dengan Signal terkait sebagai nilai `this` untuk konteks, sehingga closure baru tidak diperlukan per Signal. Sebagai gantinya, konteks dapat disimpan dalam properti ekstra pada signal itu sendiri.\n\nBeberapa kondisi error yang dipaksakan oleh API ini:\n- Membaca computed secara rekursif adalah error.\n- Callback `notify` dari Watcher tidak boleh membaca atau menulis signal apa pun.\n- Jika callback Signal computed melempar error, maka akses berikutnya ke Signal akan melempar error yang di-cache, hingga salah satu dependensi berubah dan ia dihitung ulang.\n\nBeberapa kondisi yang *tidak* dipaksakan:\n- Signal computed dapat menulis ke Signal lain, secara sinkron dalam callback-nya.\n- Pekerjaan yang diantrekan oleh callback `notify` Watcher dapat membaca atau menulis signal, sehingga memungkinkan untuk mereplikasi [pola antipattern klasik React](https://react.dev/learn/you-might-not-need-an-effect) dalam istilah Signal!\n\n### Mengimplementasikan efek\n\nInterface `Watcher` yang didefinisikan di atas memberikan dasar untuk mengimplementasikan API JS tipikal untuk efek: callback yang dijalankan ulang ketika Signal lain berubah, semata-mata untuk efek sampingnya. Fungsi `effect` yang digunakan di atas dalam contoh awal dapat didefinisikan sebagai berikut:\n\n```ts\n// Fungsi ini biasanya berada di pustaka/framework, bukan kode aplikasi\n// CATATAN: Logika penjadwalan ini terlalu dasar untuk digunakan. Jangan copy/paste.\nlet pending = false;\n\nlet w = new Signal.subtle.Watcher(() => {\n    if (!pending) {\n        pending = true;\n        queueMicrotask(() => {\n            pending = false;\n            for (let s of w.getPending()) s.get();\n            w.watch();\n        });\n    }\n});\n\n// Sebuah Signal effect yang menilai ke cb, yang menjadwalkan pembacaan dirinya\n// sendiri pada antrean microtask setiap kali salah satu dependensinya mungkin berubah\nexport function effect(cb) {\n    let destructor;\n    let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); });\n    w.watch(c);\n    c.get();\n    return () => { destructor?.(); w.unwatch(c) };\n}\n```\n\nAPI Signal tidak menyertakan fungsi bawaan seperti `effect`. Ini karena penjadwalan efek bersifat rumit dan sering terikat pada siklus rendering framework serta strategi atau state framework tingkat tinggi lain yang tidak dapat diakses JS.\n\nPenjelasan operasi berbeda yang digunakan di sini: Callback `notify` yang diberikan ke konstruktor `Watcher` adalah fungsi yang dipanggil ketika Signal berubah dari status \"clean\" (cache telah diinisialisasi dan valid) menjadi status \"checked\" atau \"dirty\" (cache mungkin valid atau tidak karena setidaknya salah satu state yang secara rekursif bergantung telah berubah).\n\nPemanggilan ke `notify` pada akhirnya dipicu oleh pemanggilan `.set()` pada suatu Signal state. Pemanggilan ini sinkron: terjadi sebelum `.set` mengembalikan nilai. Namun tidak perlu khawatir callback ini mengamati graph Signal dalam keadaan setengah diproses, karena selama callback `notify`, tidak ada Signal yang dapat dibaca atau ditulis, bahkan dalam pemanggilan `untrack`. Karena `notify` dipanggil selama `.set()`, ini menginterupsi thread logika lain, yang mungkin belum selesai. Untuk membaca atau menulis Signal dari `notify`, jadwalkan pekerjaan untuk dijalankan nanti, misal dengan menulis Signal ke dalam list untuk diakses nanti, atau dengan `queueMicrotask` seperti di atas.\n\nPerlu dicatat bahwa sangat mungkin menggunakan Signal secara efektif tanpa `Signal.subtle.Watcher` dengan menjadwalkan polling pada Signal computed, seperti yang dilakukan Glimmer. Namun, banyak framework yang menemukan bahwa seringkali berguna jika logika penjadwalan ini dijalankan secara sinkron, sehingga API Signal menyertakannya.\n\nBaik Signal computed maupun state akan dikumpulkan oleh garbage collector seperti nilai JS lainnya. Namun Watcher memiliki cara khusus untuk menjaga sesuatu tetap hidup: Signal apa pun yang diawasi oleh Watcher akan tetap hidup selama salah satu state dasarnya masih dapat dijangkau, karena ini dapat memicu pemanggilan `notify` di masa depan (dan kemudian pemanggilan `.get()`). Untuk alasan ini, ingatlah untuk memanggil `Watcher.prototype.unwatch` untuk membersihkan efek.\n\n### Jalur pelarian tidak sound\n\n`Signal.subtle.untrack` adalah jalur pelarian yang memungkinkan pembacaan Signal *tanpa* melacak pembacaan tersebut. Kapabilitas ini tidak aman karena memungkinkan pembuatan Signal computed yang nilainya bergantung pada Signal lain, namun tidak diperbarui ketika Signal tersebut berubah. Ini sebaiknya hanya digunakan ketika akses yang tidak dilacak tidak akan mengubah hasil perhitungan.\n\n<!--\nTODO: Tampilkan contoh di mana sebaiknya menggunakan untrack\n\n### Menggunakan watched/unwatched",
  "status": "ok"
}