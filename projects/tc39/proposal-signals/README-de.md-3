{
  "id": 3,
  "origin": "    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n* A separate related goal: Minimize the number of allocations, e.g.,\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early draft, and we anticipate changes over time. Let's start with the full `.d.ts` to get an idea of the overall shape, and then we'll discuss the details of what it all means.\n\n```ts\ninterface Signal<T> {\n    // Get the value of the signal\n    get(): T;\n}\n\nnamespace Signal {\n    // A read-write Signal\n    class State<T> implements Signal<T> {\n        // Create a state Signal starting with the value t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n\n        // Set the state Signal value to t\n        set(t: T): void;\n    }\n\n    // A Signal which is a formula based on other Signals\n    class Computed<T = unknown> implements Signal<T> {\n        // Create a Signal which evaluates to the value returned by the callback.\n        // Callback is called with this signal as the this value.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Get the value of the signal\n        get(): T;\n    }\n\n    // This namespace includes \"advanced\" features that are better to\n    // leave for framework authors rather than application developers.\n    // Analogous to `crypto.subtle`\n    namespace subtle {\n        // Run a callback with all tracking disabled\n        function untrack<T>(cb: () => T): T;\n\n        // Get the current computed signal which is tracking any signal reads, if any\n        function currentComputed(): Computed | null;\n\n        // Returns ordered list of all signals which this one referenced\n        // during the last time it was evaluated.\n        // For a Watcher, lists the set of signals which it is watching.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Returns the Watchers that this signal is contained in, plus any\n        // Computed signals which read this signal last time they were evaluated,\n        // if that computed signal is (recursively) watched.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True if this signal is \"live\", in that it is watched by a Watcher,\n        // or it is read by a Computed signal which is (recursively) live.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True if this element is \"reactive\", in that it depends\n        // on some other signal. A Computed where hasSources is false\n        // will always return the same constant.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // When a (recursive) source of Watcher is written to, call this callback,\n            // if it hasn't already been called since the last `watch` call.\n            // No signals may be read or written during the notify.\n            constructor(notify: (this: Watcher) => void);\n\n            // Add these signals to the Watcher's set, and set the watcher to run its\n            // notify callback next time any signal in the set (or one of its dependencies) changes.\n            // Can be called with no arguments just to reset the \"notified\" state, so that\n            // the notify callback will be invoked again.\n            watch(...s: Signal[]): void;\n\n            // Remove these signals from the watched set (e.g., for an effect which is disposed)\n            unwatch(...s: Signal[]): void;\n\n            // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal\n            // with a source which is dirty or pending and hasn't yet been re-evaluated\n            getPending(): Signal[];\n        }\n\n        // Hooks to observe being watched or no longer watched\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Custom comparison function between old and new value. Default: Object.is.\n        // The signal is passed in as the this value for context.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;",
  "translate": "* Beachten Sie, dass die meisten Frameworks heutzutage eine explizite Entsorgung von berechneten Signals erfordern, wenn sie eine Referenz zu oder von einem anderen Signal-Graphen haben, der weiterhin existiert.\n* Das ist am Ende nicht so schlimm, wenn ihre Lebensdauer an die Lebensdauer einer UI-Komponente gebunden ist und Effekte ohnehin entsorgt werden müssen.\n* Falls die Ausführung mit diesen Semantiken zu aufwendig ist, sollten wir die explizite Entsorgung (oder das „Unlinken“) von berechneten Signals zur untenstehenden API hinzufügen, die dies derzeit nicht vorsieht.\n* Ein weiteres, verwandtes Ziel: Minimierung der Anzahl von Allokationen, z. B.:\n    * um ein beschreibbares Signal zu erstellen (Vermeidung von zwei separaten Closures + Array)\n    * zur Implementierung von Effekten (Vermeidung einer Closure für jede einzelne Reaktion)\n    * In der API zur Beobachtung von Signal-Änderungen die Erstellung zusätzlicher temporärer Datenstrukturen vermeiden\n    * Lösung: Klassenbasierte API, die die Wiederverwendung von Methoden und Feldern ermöglicht, die in Unterklassen definiert sind\n\n## API-Skizze\n\nEine erste Idee einer Signal-API folgt unten. Beachten Sie, dass dies nur ein früher Entwurf ist und wir im Laufe der Zeit mit Änderungen rechnen. Beginnen wir mit dem vollständigen `.d.ts`, um einen Eindruck von der Gesamtstruktur zu bekommen, und anschließend besprechen wir die Details, was das alles bedeutet.\n\n```ts\ninterface Signal<T> {\n    // Den Wert des Signals abrufen\n    get(): T;\n}\n\nnamespace Signal {\n    // Ein les- und schreibbares Signal\n    class State<T> implements Signal<T> {\n        // Erstellt ein State-Signal mit dem Startwert t\n        constructor(t: T, options?: SignalOptions<T>);\n\n        // Den Wert des Signals abrufen\n        get(): T;\n\n        // Den Wert des State-Signals auf t setzen\n        set(t: T): void;\n    }\n\n    // Ein Signal, das eine Formel auf Basis anderer Signals ist\n    class Computed<T = unknown> implements Signal<T> {\n        // Erstellt ein Signal, das auf den vom Callback zurückgegebenen Wert evaluiert wird.\n        // Callback wird mit diesem Signal als this-Wert aufgerufen.\n        constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>);\n\n        // Den Wert des Signals abrufen\n        get(): T;\n    }\n\n    // Dieser Namespace enthält „fortgeschrittene“ Funktionen, die besser\n    // Framework-Autoren als Anwendungsentwicklern überlassen werden.\n    // Analog zu `crypto.subtle`\n    namespace subtle {\n        // Einen Callback ausführen, während jegliches Tracking deaktiviert ist\n        function untrack<T>(cb: () => T): T;\n\n        // Das aktuell berechnete Signal abrufen, das Signal-Lesezugriffe verfolgt, falls vorhanden\n        function currentComputed(): Computed | null;\n\n        // Gibt eine geordnete Liste aller Signals zurück, auf die dieses Signal\n        // bei der letzten Auswertung referenziert hat.\n        // Für einen Watcher listet es die Menge der Signals auf, die überwacht werden.\n        function introspectSources(s: Computed | Watcher): (State | Computed)[];\n\n        // Gibt die Watcher zurück, in denen dieses Signal enthalten ist, sowie alle\n        // Computed-Signals, die dieses Signal beim letzten Mal ausgelesen haben,\n        // falls dieses Computed-Signal (rekursiv) überwacht wird.\n        function introspectSinks(s: State | Computed): (Computed | Watcher)[];\n\n        // True, wenn dieses Signal „live“ ist, d. h. von einem Watcher überwacht wird\n        // oder von einem Computed-Signal ausgelesen wird, das (rekursiv) live ist.\n        function hasSinks(s: State | Computed): boolean;\n\n        // True, wenn dieses Element „reaktiv“ ist, d. h. von einem anderen Signal abhängt.\n        // Ein Computed, bei dem hasSources false ist,\n        // gibt immer denselben konstanten Wert zurück.\n        function hasSources(s: Computed | Watcher): boolean;\n\n        class Watcher {\n            // Wenn eine (rekursive) Quelle des Watchers beschrieben wird, diesen Callback aufrufen,\n            // falls er seit dem letzten `watch`-Aufruf noch nicht aufgerufen wurde.\n            // Während des Notify-Vorgangs dürfen keine Signals gelesen oder beschrieben werden.\n            constructor(notify: (this: Watcher) => void);\n\n            // Diese Signals zum Set des Watchers hinzufügen und festlegen, dass der Watcher seinen\n            // Notify-Callback beim nächsten Mal ausführt, wenn sich eines der Signals im Set\n            // (oder eine ihrer Abhängigkeiten) ändert.\n            // Kann ohne Argumente aufgerufen werden, um lediglich den „notified“-Status zurückzusetzen,\n            // sodass der Notify-Callback erneut aufgerufen wird.\n            watch(...s: Signal[]): void;\n\n            // Diese Signals aus dem überwachten Set entfernen (z. B. für einen entsorgten Effekt)\n            unwatch(...s: Signal[]): void;\n\n            // Gibt die Menge der Quellen im Set des Watchers zurück, die noch „dirty“ sind, oder ein berechnetes Signal,\n            // dessen Quelle „dirty“ oder „pending“ ist und das noch nicht neu ausgewertet wurde\n            getPending(): Signal[];\n        }\n\n        // Hooks, um das Beobachtetwerden oder Nicht-mehr-Beobachtetwerden zu beobachten\n        var watched: Symbol;\n        var unwatched: Symbol;\n    }\n\n    interface SignalOptions<T> {\n        // Benutzerdefinierte Vergleichsfunktion zwischen altem und neuem Wert. Standard: Object.is.\n        // Das Signal wird als this-Wert für den Kontext übergeben.\n        equals?: (this: Signal<T>, t: T, t2: T) => boolean;\n```",
  "status": "ok"
}