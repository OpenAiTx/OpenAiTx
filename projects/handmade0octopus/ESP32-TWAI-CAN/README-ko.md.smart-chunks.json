[
  {
    "Id": 1,
    "Content": "# ESP32-TWAI-CAN\n\nESP32 driver library for TWAI / CAN for Arduino using ESP-IDF drivers.\n\nTested on ESP32 and ESP32-S3.\n\n# Usage\n\nLibrary has everything inside it's header, just include that and then use `ESP32Can` object to send or receive `CanFrame`.\n\n\nHere is simple example how to query and receive OBD2 PID frames:",
    "ContentSha": "06UqwVen0n1s1+SVYRtpns0UjQzRk2FV+7iEr/f5p0s=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# ESP32-TWAI-CAN\n\nESP-IDF 드라이버를 사용한 Arduino용 ESP32 TWAI / CAN 드라이버 라이브러리입니다.\n\nESP32 및 ESP32-S3에서 테스트되었습니다.\n\n# 사용법\n\n라이브러리는 모든 것이 헤더 안에 포함되어 있으므로, 해당 헤더를 포함한 후 `ESP32Can` 객체를 사용하여 `CanFrame`을 송수신할 수 있습니다.\n\n다음은 OBD2 PID 프레임을 쿼리하고 수신하는 간단한 예제입니다:\n",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "zGyARppIf1UK4fewGcS9CcEC52JNXGDaplv4u1y3f3c=",
        "originContent": "# ESP32-TWAI-CAN",
        "translatedContent": "# ESP32-TWAI-CAN"
      },
      {
        "row": 2,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "eu2W6KWFhE3x4yLuR6pFBI9zf0+5CCtH4w5nMdFti2A=",
        "originContent": "ESP32 driver library for TWAI / CAN for Arduino using ESP-IDF drivers.",
        "translatedContent": "ESP-IDF 드라이버를 사용한 Arduino용 ESP32 TWAI / CAN 드라이버 라이브러리입니다."
      },
      {
        "row": 4,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 5,
        "rowsha": "c5T1Yqsrb3jm/fKkMzUGhUsg5zAoAN0ccoT++gIlLAA=",
        "originContent": "Tested on ESP32 and ESP32-S3.",
        "translatedContent": "ESP32 및 ESP32-S3에서 테스트되었습니다."
      },
      {
        "row": 6,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 7,
        "rowsha": "VQl64phXBjjplyWiGKNjjWZLPM0chOlnOxoC73zDU/k=",
        "originContent": "# Usage",
        "translatedContent": "# 사용법"
      },
      {
        "row": 8,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 9,
        "rowsha": "idtRcdlLuW7ptDMToS8MCLVGJXj7XBrH4ctsV1YhhMU=",
        "originContent": "Library has everything inside it's header, just include that and then use `ESP32Can` object to send or receive `CanFrame`.",
        "translatedContent": "라이브러리는 모든 것이 헤더 안에 포함되어 있으므로, 해당 헤더를 포함한 후 `ESP32Can` 객체를 사용하여 `CanFrame`을 송수신할 수 있습니다."
      },
      {
        "row": 10,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 11,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "다음은 OBD2 PID 프레임을 쿼리하고 수신하는 간단한 예제입니다:"
      },
      {
        "row": 12,
        "rowsha": "wviy+2S5ODgLWBe2RM6w7EchquIgDXd5rP+NLgi650M=",
        "originContent": "Here is simple example how to query and receive OBD2 PID frames:",
        "translatedContent": ""
      }
    ],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "```cpp\n#include <ESP32-TWAI-CAN.hpp>\n\n// Default for ESP32\n#define CAN_TX 5\n#define CAN_RX 4\n\nCanFrame rxFrame;\n\nvoid sendObdFrame(uint8_t obdId) {\n    CanFrame obdFrame         = {0};\n    obdFrame.identifier       = 0x7DF; // Default OBD2 address;\n    obdFrame.extd             = 0;\n    obdFrame.data_length_code = 8;\n    obdFrame.data[0]          = 2;\n    obdFrame.data[1]          = 1;\n    obdFrame.data[2]          = obdId;\n    obdFrame.data[3]          = 0xAA; // Best use 0xAA (0b10101010) instead of 0\n    obdFrame.data[4]          = 0xAA; // TWAI / CAN works better this way, as it\n    obdFrame.data[5]          = 0xAA; // needs to avoid bit-stuffing\n    obdFrame.data[6]          = 0xAA;\n    obdFrame.data[7]          = 0xAA;\n    // Accepts both pointers and references\n    ESP32Can.writeFrame(obdFrame); // timeout defaults to 1 ms\n}\n\nvoid setup() {\n    // Setup serial for debbuging.\n    Serial.begin(115200);\n\n    // Set pins\n    ESP32Can.setPins(CAN_TX, CAN_RX);\n\n    // You can set custom size for the queues - those are default\n    ESP32Can.setRxQueueSize(5);\n    ESP32Can.setTxQueueSize(5);\n\n    // .setSpeed() and .begin() functions require to use TwaiSpeed enum,\n    // but you can easily convert it from numerical value using .convertSpeed()\n    ESP32Can.setSpeed(ESP32Can.convertSpeed(500));\n\n    // You can also just use .begin()..\n    if(ESP32Can.begin()) {\n        Serial.println(\"CAN bus started!\");\n    } else {\n        Serial.println(\"CAN bus failed!\");\n    }\n\n    // or override everything in one command;\n    // It is also safe to use .begin() without .end() as it calls it internally\n    if(ESP32Can.begin(ESP32Can.convertSpeed(500), CAN_TX, CAN_RX, 10, 10)) {\n        Serial.println(\"CAN bus started!\");\n    } else {\n        Serial.println(\"CAN bus failed!\");\n    }\n}\n\nvoid loop() {\n    static uint32_t lastStamp    = 0;\n    uint32_t        currentStamp = millis();\n\n    if(currentStamp - lastStamp > 1000) { // sends OBD2 request every second\n        lastStamp = currentStamp;\n        sendObdFrame(5); // For coolant temperature\n    }\n\n    // You can set custom timeout, default is 1000\n    if(ESP32Can.readFrame(rxFrame, 1000)) {\n        // Comment out if too many frames\n        Serial.printf(\"Received frame: %03X  \\r\\n\", rxFrame.identifier);\n        if(rxFrame.identifier == 0x7E8) {                                    // Standard OBD2 frame responce ID\n            Serial.printf(\"Collant temp: %3d°C \\r\\n\", rxFrame.data[3] - 40); // Convert to °C\n        }\n    }\n}\n```",
    "ContentSha": "YhWYkZ9Q8lrxctUrO7FUR1qs/R98oj+tXRTSA6qR8N8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```cpp\n#include <ESP32-TWAI-CAN.hpp>\n\n// Default for ESP32\n#define CAN_TX 5\n#define CAN_RX 4\n\nCanFrame rxFrame;\n\nvoid sendObdFrame(uint8_t obdId) {\n    CanFrame obdFrame         = {0};\n    obdFrame.identifier       = 0x7DF; // Default OBD2 address;\n    obdFrame.extd             = 0;\n    obdFrame.data_length_code = 8;\n    obdFrame.data[0]          = 2;\n    obdFrame.data[1]          = 1;\n    obdFrame.data[2]          = obdId;\n    obdFrame.data[3]          = 0xAA; // Best use 0xAA (0b10101010) instead of 0\n    obdFrame.data[4]          = 0xAA; // TWAI / CAN works better this way, as it\n    obdFrame.data[5]          = 0xAA; // needs to avoid bit-stuffing\n    obdFrame.data[6]          = 0xAA;\n    obdFrame.data[7]          = 0xAA;\n    // Accepts both pointers and references\n    ESP32Can.writeFrame(obdFrame); // timeout defaults to 1 ms\n}\n\nvoid setup() {\n    // Setup serial for debbuging.\n    Serial.begin(115200);\n\n    // Set pins\n    ESP32Can.setPins(CAN_TX, CAN_RX);\n\n    // You can set custom size for the queues - those are default\n    ESP32Can.setRxQueueSize(5);\n    ESP32Can.setTxQueueSize(5);\n\n    // .setSpeed() and .begin() functions require to use TwaiSpeed enum,\n    // but you can easily convert it from numerical value using .convertSpeed()\n    ESP32Can.setSpeed(ESP32Can.convertSpeed(500));\n\n    // You can also just use .begin()..\n    if(ESP32Can.begin()) {\n        Serial.println(\"CAN bus started!\");\n    } else {\n        Serial.println(\"CAN bus failed!\");\n    }\n\n    // or override everything in one command;\n    // It is also safe to use .begin() without .end() as it calls it internally\n    if(ESP32Can.begin(ESP32Can.convertSpeed(500), CAN_TX, CAN_RX, 10, 10)) {\n        Serial.println(\"CAN bus started!\");\n    } else {\n        Serial.println(\"CAN bus failed!\");\n    }\n}\n\nvoid loop() {\n    static uint32_t lastStamp    = 0;\n    uint32_t        currentStamp = millis();\n\n    if(currentStamp - lastStamp > 1000) { // sends OBD2 request every second\n        lastStamp = currentStamp;\n        sendObdFrame(5); // For coolant temperature\n    }\n\n    // You can set custom timeout, default is 1000\n    if(ESP32Can.readFrame(rxFrame, 1000)) {\n        // Comment out if too many frames\n        Serial.printf(\"Received frame: %03X  \\r\\n\", rxFrame.identifier);\n        if(rxFrame.identifier == 0x7E8) {                                    // Standard OBD2 frame responce ID\n            Serial.printf(\"Collant temp: %3d°C \\r\\n\", rxFrame.data[3] - 40); // Convert to °C\n        }\n    }\n}\n```",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "p9kHAsnrYsj1u+Xw/CDKCanha99nrkZazj/wyJwtzUE=",
        "originContent": "```cpp",
        "translatedContent": "```cpp"
      },
      {
        "row": 2,
        "rowsha": "pZDVHya538KcTk5/oRgDm/t4FbPA7byI++M2WkemTR8=",
        "originContent": "#include <ESP32-TWAI-CAN.hpp>",
        "translatedContent": "#include <ESP32-TWAI-CAN.hpp>"
      },
      {
        "row": 3,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 4,
        "rowsha": "eU3e3Pc4OEcOFFyvau4kUV/p3ZPz459k/qPENhZIMCA=",
        "originContent": "// Default for ESP32",
        "translatedContent": "// Default for ESP32"
      },
      {
        "row": 5,
        "rowsha": "+xPQ9rIOVVV1EzCdC6ATDMYbcCKGjUa3V7vTJu6BUHY=",
        "originContent": "#define CAN_TX 5",
        "translatedContent": "#define CAN_TX 5"
      },
      {
        "row": 6,
        "rowsha": "jjgy6OrXRW/H/ien8QqipthIrIyN/LyJ8yBC3qKCkJg=",
        "originContent": "#define CAN_RX 4",
        "translatedContent": "#define CAN_RX 4"
      },
      {
        "row": 7,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 8,
        "rowsha": "itACOgI9OguoDT+UY/qnY0wV6ahrLI5zLpSAZk1DL8M=",
        "originContent": "CanFrame rxFrame;",
        "translatedContent": "CanFrame rxFrame;"
      },
      {
        "row": 9,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 10,
        "rowsha": "ILjQHhsvT9P2p/a95blUwrmpbTin4BMrP5/GAYhjA9Q=",
        "originContent": "void sendObdFrame(uint8_t obdId) {",
        "translatedContent": "void sendObdFrame(uint8_t obdId) {"
      },
      {
        "row": 11,
        "rowsha": "mzTsSaIkhYilUjuJqxBjgF1uYiFKv8yJvcpBl748QX0=",
        "originContent": "    CanFrame obdFrame         = {0};",
        "translatedContent": "    CanFrame obdFrame         = {0};"
      },
      {
        "row": 12,
        "rowsha": "7vgMyAW5tiPeNs/JsNzIWJNv1PBR96EUmahjlnxMqRw=",
        "originContent": "    obdFrame.identifier       = 0x7DF; // Default OBD2 address;",
        "translatedContent": "    obdFrame.identifier       = 0x7DF; // Default OBD2 address;"
      },
      {
        "row": 13,
        "rowsha": "J65dD0Fb8wnfD1mwziSsn1uiFPHF2TAjaQjbarNMc9w=",
        "originContent": "    obdFrame.extd             = 0;",
        "translatedContent": "    obdFrame.extd             = 0;"
      },
      {
        "row": 14,
        "rowsha": "C1SfYxyeK7LTGL81/m5mZOCg9MQa+jXgovLOar7zXdM=",
        "originContent": "    obdFrame.data_length_code = 8;",
        "translatedContent": "    obdFrame.data_length_code = 8;"
      },
      {
        "row": 15,
        "rowsha": "GlOUL1hRXhbIrehEYRr4WgKz8PP9XWrrz7r7h4FlaU8=",
        "originContent": "    obdFrame.data[0]          = 2;",
        "translatedContent": "    obdFrame.data[0]          = 2;"
      },
      {
        "row": 16,
        "rowsha": "kBgqX+ITedaPFRQLWgA1ZpUQKXtXgKpZlmf8UYMFAWo=",
        "originContent": "    obdFrame.data[1]          = 1;",
        "translatedContent": "    obdFrame.data[1]          = 1;"
      },
      {
        "row": 17,
        "rowsha": "TYNC/akm+peq0C0hDO04a0yCP3xXceJboyBCxwMbLVA=",
        "originContent": "    obdFrame.data[2]          = obdId;",
        "translatedContent": "    obdFrame.data[2]          = obdId;"
      },
      {
        "row": 18,
        "rowsha": "UcePRf3RLUiykuApVJgIhtJx44+35G1X0CIHupi4kUY=",
        "originContent": "    obdFrame.data[3]          = 0xAA; // Best use 0xAA (0b10101010) instead of 0",
        "translatedContent": "    obdFrame.data[3]          = 0xAA; // Best use 0xAA (0b10101010) instead of 0"
      },
      {
        "row": 19,
        "rowsha": "wCMHYhhaMip8qXlwEnlum/wdREVf1ABIENyvDDopn24=",
        "originContent": "    obdFrame.data[4]          = 0xAA; // TWAI / CAN works better this way, as it",
        "translatedContent": "    obdFrame.data[4]          = 0xAA; // TWAI / CAN works better this way, as it"
      },
      {
        "row": 20,
        "rowsha": "sZuUR6qYEXPSSfNzSz5sc0bNcxr47PFzGx6yEf1VddY=",
        "originContent": "    obdFrame.data[5]          = 0xAA; // needs to avoid bit-stuffing",
        "translatedContent": "    obdFrame.data[5]          = 0xAA; // needs to avoid bit-stuffing"
      },
      {
        "row": 21,
        "rowsha": "9BXyBfbLzLdNSd4J0NPiDNphRT3SfRJfTRLde62+iqs=",
        "originContent": "    obdFrame.data[6]          = 0xAA;",
        "translatedContent": "    obdFrame.data[6]          = 0xAA;"
      },
      {
        "row": 22,
        "rowsha": "fpTznW5Cb/PWd9SdO9vA08rShDFlDGm1QIMmzRgKDTw=",
        "originContent": "    obdFrame.data[7]          = 0xAA;",
        "translatedContent": "    obdFrame.data[7]          = 0xAA;"
      },
      {
        "row": 23,
        "rowsha": "S1174kLh5YZiST7HMkV+hz8B8ec0iETIw/yWK3uq6h8=",
        "originContent": "    // Accepts both pointers and references",
        "translatedContent": "    // Accepts both pointers and references"
      },
      {
        "row": 24,
        "rowsha": "qMmkakMZr94x545WpP9UyW8M+zyyjgjKhv8d59EPYU4=",
        "originContent": "    ESP32Can.writeFrame(obdFrame); // timeout defaults to 1 ms",
        "translatedContent": "    ESP32Can.writeFrame(obdFrame); // timeout defaults to 1 ms"
      },
      {
        "row": 25,
        "rowsha": "0Qs2qnSlm89KiBhYN/ZYr682Ru/yuxbDko0OkzXpRdI=",
        "originContent": "}",
        "translatedContent": "}"
      },
      {
        "row": 26,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 27,
        "rowsha": "eNHRdfYQN7+UoywGE79DihYerGNB6jMCMUb+mJJjHRA=",
        "originContent": "void setup() {",
        "translatedContent": "void setup() {"
      },
      {
        "row": 28,
        "rowsha": "B5Lc24lNaAuez4fYa9kxI7yifst9e0mDJ0WSA6USqFY=",
        "originContent": "    // Setup serial for debbuging.",
        "translatedContent": "    // Setup serial for debbuging."
      },
      {
        "row": 29,
        "rowsha": "afKatyuru0P3dRQjDU7ivVGpej1jDwfI9/fKrtbziyQ=",
        "originContent": "    Serial.begin(115200);",
        "translatedContent": "    Serial.begin(115200);"
      },
      {
        "row": 30,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 31,
        "rowsha": "V/IKUZpZLxeEA7jNz0mlFu5PJvH/NKT0i4wrInyABAY=",
        "originContent": "    // Set pins",
        "translatedContent": "    // Set pins"
      },
      {
        "row": 32,
        "rowsha": "ut7b79ALXIUZeYeCcmYqtDMGkl4KlyfHk7KMM4QmK1A=",
        "originContent": "    ESP32Can.setPins(CAN_TX, CAN_RX);",
        "translatedContent": "    ESP32Can.setPins(CAN_TX, CAN_RX);"
      },
      {
        "row": 33,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 34,
        "rowsha": "dhjR+35t8ub0xLLTP2vp4A+YtjTlnukQRM3XzG4csZg=",
        "originContent": "    // You can set custom size for the queues - those are default",
        "translatedContent": "    // You can set custom size for the queues - those are default"
      },
      {
        "row": 35,
        "rowsha": "cghU26qp6K2ex6Zu8Ro9A/iy7T+q5peLHxbckD9tPsM=",
        "originContent": "    ESP32Can.setRxQueueSize(5);",
        "translatedContent": "    ESP32Can.setRxQueueSize(5);"
      },
      {
        "row": 36,
        "rowsha": "PT9C9MQaxwl+qfsZwxWI7Hy+mkFXOsb36E2Q9glwbZA=",
        "originContent": "    ESP32Can.setTxQueueSize(5);",
        "translatedContent": "    ESP32Can.setTxQueueSize(5);"
      },
      {
        "row": 37,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 38,
        "rowsha": "RjDRIhYCBe/j4Qadwq+CZxcRxBvsMOYunzRr9rKuMF0=",
        "originContent": "    // .setSpeed() and .begin() functions require to use TwaiSpeed enum,",
        "translatedContent": "    // .setSpeed() and .begin() functions require to use TwaiSpeed enum,"
      },
      {
        "row": 39,
        "rowsha": "NgR4ajQw5xbgJ2zPTOPTvMzQp4x8ffGdwSLfz+Vk6vI=",
        "originContent": "    // but you can easily convert it from numerical value using .convertSpeed()",
        "translatedContent": "    // but you can easily convert it from numerical value using .convertSpeed()"
      },
      {
        "row": 40,
        "rowsha": "HXo/kRKWgKbCfA0Apx1BebwVmIZyeJ2qglpoGEwHumQ=",
        "originContent": "    ESP32Can.setSpeed(ESP32Can.convertSpeed(500));",
        "translatedContent": "    ESP32Can.setSpeed(ESP32Can.convertSpeed(500));"
      },
      {
        "row": 41,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 42,
        "rowsha": "Hwk0cNSNbX5fsIcgpm+9f3W1yaoqAA39MqNetf4Aydk=",
        "originContent": "    // You can also just use .begin()..",
        "translatedContent": "    // You can also just use .begin().."
      },
      {
        "row": 43,
        "rowsha": "QWrn/QGTIpwzD4GrA/PiiRvw8DxrgiaZHtyqdUf/DfY=",
        "originContent": "    if(ESP32Can.begin()) {",
        "translatedContent": "    if(ESP32Can.begin()) {"
      },
      {
        "row": 44,
        "rowsha": "IAQWCg7G4Oi+cp9RnIq2iI/cSxR5GG8jXCUeedonKjA=",
        "originContent": "        Serial.println(\"CAN bus started!\");",
        "translatedContent": "        Serial.println(\"CAN bus started!\");"
      },
      {
        "row": 45,
        "rowsha": "1iXXq0O88YnGJrVGefga2st0aG+9pfvcLwJpmYyV0ls=",
        "originContent": "    } else {",
        "translatedContent": "    } else {"
      },
      {
        "row": 46,
        "rowsha": "kj+E4vFyAJnv2E6hB0+O8hO5zOgpk4hd84l3d5UwonU=",
        "originContent": "        Serial.println(\"CAN bus failed!\");",
        "translatedContent": "        Serial.println(\"CAN bus failed!\");"
      },
      {
        "row": 47,
        "rowsha": "KNhneGFfavR7sbxPQPrOdWdJdo5REfEUz6I0pQYMJa8=",
        "originContent": "    }",
        "translatedContent": "    }"
      },
      {
        "row": 48,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 49,
        "rowsha": "PjXRi2Q1bIL8OsNQC14xEzMyTQcrC7OCxYPLYPE5wXM=",
        "originContent": "    // or override everything in one command;",
        "translatedContent": "    // or override everything in one command;"
      },
      {
        "row": 50,
        "rowsha": "tWZiPz1VEn2rWcNBDgLhWMvR3SJ/yYIwakAsOvJzlSc=",
        "originContent": "    // It is also safe to use .begin() without .end() as it calls it internally",
        "translatedContent": "    // It is also safe to use .begin() without .end() as it calls it internally"
      },
      {
        "row": 51,
        "rowsha": "kzAz63grN47DANJTeYLPOGKSvbKaD01eaOC08fiPup0=",
        "originContent": "    if(ESP32Can.begin(ESP32Can.convertSpeed(500), CAN_TX, CAN_RX, 10, 10)) {",
        "translatedContent": "    if(ESP32Can.begin(ESP32Can.convertSpeed(500), CAN_TX, CAN_RX, 10, 10)) {"
      },
      {
        "row": 52,
        "rowsha": "IAQWCg7G4Oi+cp9RnIq2iI/cSxR5GG8jXCUeedonKjA=",
        "originContent": "        Serial.println(\"CAN bus started!\");",
        "translatedContent": "        Serial.println(\"CAN bus started!\");"
      },
      {
        "row": 53,
        "rowsha": "1iXXq0O88YnGJrVGefga2st0aG+9pfvcLwJpmYyV0ls=",
        "originContent": "    } else {",
        "translatedContent": "    } else {"
      },
      {
        "row": 54,
        "rowsha": "kj+E4vFyAJnv2E6hB0+O8hO5zOgpk4hd84l3d5UwonU=",
        "originContent": "        Serial.println(\"CAN bus failed!\");",
        "translatedContent": "        Serial.println(\"CAN bus failed!\");"
      },
      {
        "row": 55,
        "rowsha": "KNhneGFfavR7sbxPQPrOdWdJdo5REfEUz6I0pQYMJa8=",
        "originContent": "    }",
        "translatedContent": "    }"
      },
      {
        "row": 56,
        "rowsha": "0Qs2qnSlm89KiBhYN/ZYr682Ru/yuxbDko0OkzXpRdI=",
        "originContent": "}",
        "translatedContent": "}"
      },
      {
        "row": 57,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 58,
        "rowsha": "mQrA7EiFQFUZrp3MDfvy12SX7U74Xm63MGq02RK/kgc=",
        "originContent": "void loop() {",
        "translatedContent": "void loop() {"
      },
      {
        "row": 59,
        "rowsha": "6LgtJokBZKf+ZDf7wKIia+t6zexBerU5zwoT71mjf9A=",
        "originContent": "    static uint32_t lastStamp    = 0;",
        "translatedContent": "    static uint32_t lastStamp    = 0;"
      },
      {
        "row": 60,
        "rowsha": "t+uWZBlBa0VE0DfeWeRERUIiQG637NsXJLwwlEGQy9o=",
        "originContent": "    uint32_t        currentStamp = millis();",
        "translatedContent": "    uint32_t        currentStamp = millis();"
      },
      {
        "row": 61,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 62,
        "rowsha": "1CxeY274YKkI0modlgD3EJIAhEXDg2aqvG3LpL0ahGM=",
        "originContent": "    if(currentStamp - lastStamp > 1000) { // sends OBD2 request every second",
        "translatedContent": "    if(currentStamp - lastStamp > 1000) { // sends OBD2 request every second"
      },
      {
        "row": 63,
        "rowsha": "TbJb8ROL+Wo0pzFIEPixNJGVKeHxqZTWQwQVdzqlZko=",
        "originContent": "        lastStamp = currentStamp;",
        "translatedContent": "        lastStamp = currentStamp;"
      },
      {
        "row": 64,
        "rowsha": "xYGkMHhTF+2gfzdiK2Im44s5ucRZnUNRp71nl11lofQ=",
        "originContent": "        sendObdFrame(5); // For coolant temperature",
        "translatedContent": "        sendObdFrame(5); // For coolant temperature"
      },
      {
        "row": 65,
        "rowsha": "KNhneGFfavR7sbxPQPrOdWdJdo5REfEUz6I0pQYMJa8=",
        "originContent": "    }",
        "translatedContent": "    }"
      },
      {
        "row": 66,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 67,
        "rowsha": "PiY0DTtEabSM5Ku5y0cNzOR9k2SnMrM57Pu1CNwlHW4=",
        "originContent": "    // You can set custom timeout, default is 1000",
        "translatedContent": "    // You can set custom timeout, default is 1000"
      },
      {
        "row": 68,
        "rowsha": "kIDiCBtgbPXjttPrL56vClKhAJYf2nT+byovagzbwA8=",
        "originContent": "    if(ESP32Can.readFrame(rxFrame, 1000)) {",
        "translatedContent": "    if(ESP32Can.readFrame(rxFrame, 1000)) {"
      },
      {
        "row": 69,
        "rowsha": "B5F49mtfL2DE89dStlFnR8WH9cYZWwd2PWPiwGX44Po=",
        "originContent": "        // Comment out if too many frames",
        "translatedContent": "        // Comment out if too many frames"
      },
      {
        "row": 70,
        "rowsha": "9PO6EryNJszLcm0a0g3AWYHfo02U+XXR0GfmMl/f4gI=",
        "originContent": "        Serial.printf(\"Received frame: %03X  \\r\\n\", rxFrame.identifier);",
        "translatedContent": "        Serial.printf(\"Received frame: %03X  \\r\\n\", rxFrame.identifier);"
      },
      {
        "row": 71,
        "rowsha": "e8l65kKpiMJpYm8AFGspAiFUfqBrHYzryiJXOhh1WGA=",
        "originContent": "        if(rxFrame.identifier == 0x7E8) {                                    // Standard OBD2 frame responce ID",
        "translatedContent": "        if(rxFrame.identifier == 0x7E8) {                                    // Standard OBD2 frame responce ID"
      },
      {
        "row": 72,
        "rowsha": "Rtb/iRKanrA1lg4jYCJFIZD19pOT592xRaNui6TRUSo=",
        "originContent": "            Serial.printf(\"Collant temp: %3d°C \\r\\n\", rxFrame.data[3] - 40); // Convert to °C",
        "translatedContent": "            Serial.printf(\"Collant temp: %3d°C \\r\\n\", rxFrame.data[3] - 40); // Convert to °C"
      },
      {
        "row": 73,
        "rowsha": "KkQWgxjiJOH4MP6atiCqAN1Pez+xnvQ5mr9ZWTzwdW0=",
        "originContent": "        }",
        "translatedContent": "        }"
      },
      {
        "row": 74,
        "rowsha": "KNhneGFfavR7sbxPQPrOdWdJdo5REfEUz6I0pQYMJa8=",
        "originContent": "    }",
        "translatedContent": "    }"
      },
      {
        "row": 75,
        "rowsha": "0Qs2qnSlm89KiBhYN/ZYr682Ru/yuxbDko0OkzXpRdI=",
        "originContent": "}",
        "translatedContent": "}"
      },
      {
        "row": 76,
        "rowsha": "8bkBhHOQsO1+N058HkZOwXtGpCfEh6WtbL0pBkBQg9U=",
        "originContent": "```",
        "translatedContent": "```"
      }
    ],
    "IsCodeBlock": true
  },
  {
    "Id": 3,
    "Content": "\n# Advanced\nYou can also setup your own masks and configurations:\n",
    "ContentSha": "oCW5UmkiFdMoazv9K0CD+VQkjtTGEHEwYjxRwbD9O3A=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n# 고급\n자신만의 마스크와 구성을 설정할 수도 있습니다:\n",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 2,
        "rowsha": "aY9EG3BbLOGyocdOyzIKC0W3ihXhq1SdNPK4q6gON+0=",
        "originContent": "# Advanced",
        "translatedContent": "# 고급"
      },
      {
        "row": 3,
        "rowsha": "i0pVQpuLKtwnFb8HeyzwuBqY929g8olgLj27EmLtdnI=",
        "originContent": "You can also setup your own masks and configurations:",
        "translatedContent": "자신만의 마스크와 구성을 설정할 수도 있습니다:"
      },
      {
        "row": 4,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      }
    ],
    "IsCodeBlock": false
  },
  {
    "Id": 4,
    "Content": "```cpp\n// Everything is defaulted so you can just call .begin() or .begin(TwaiSpeed)\n// Calling begin() to change speed works, it will disable current driver first\nbool begin(TwaiSpeed twaiSpeed = TWAI_SPEED_500KBPS, \n           int8_t txPin = -1, int8_t rxPin = -1,\n           uint16_t txQueue = 0xFFFF, uint16_t rxQueue = 0xFFFF,\n           twai_filter_config_t*  fConfig = nullptr,\n           twai_general_config_t* gConfig = nullptr,\n           twai_timing_config_t*  tConfig = nullptr);\n```",
    "ContentSha": "Qx2FDVVAWvHpKKrmYB94BrN5WinNrLEX3bhRGoiC3n0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```cpp\n// Everything is defaulted so you can just call .begin() or .begin(TwaiSpeed)\n// Calling begin() to change speed works, it will disable current driver first\nbool begin(TwaiSpeed twaiSpeed = TWAI_SPEED_500KBPS, \n           int8_t txPin = -1, int8_t rxPin = -1,\n           uint16_t txQueue = 0xFFFF, uint16_t rxQueue = 0xFFFF,\n           twai_filter_config_t*  fConfig = nullptr,\n           twai_general_config_t* gConfig = nullptr,\n           twai_timing_config_t*  tConfig = nullptr);\n```",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "p9kHAsnrYsj1u+Xw/CDKCanha99nrkZazj/wyJwtzUE=",
        "originContent": "```cpp",
        "translatedContent": "```cpp"
      },
      {
        "row": 2,
        "rowsha": "ZoqqN96Yf5AD4peRCsYjZewH75X+gl3BA/IsKB0ymks=",
        "originContent": "// Everything is defaulted so you can just call .begin() or .begin(TwaiSpeed)",
        "translatedContent": "// Everything is defaulted so you can just call .begin() or .begin(TwaiSpeed)"
      },
      {
        "row": 3,
        "rowsha": "vc+xAyqyL90nCg4ZizchkoLNyxSalvC4IS2BY811ito=",
        "originContent": "// Calling begin() to change speed works, it will disable current driver first",
        "translatedContent": "// Calling begin() to change speed works, it will disable current driver first"
      },
      {
        "row": 4,
        "rowsha": "8c+tPWykCPwUNS4jr4V71sxxpqdepJjBq+PuV/kCpK4=",
        "originContent": "bool begin(TwaiSpeed twaiSpeed = TWAI_SPEED_500KBPS, ",
        "translatedContent": "bool begin(TwaiSpeed twaiSpeed = TWAI_SPEED_500KBPS, "
      },
      {
        "row": 5,
        "rowsha": "J9wSa9+SdMfd7rcpG21RU2kU8UY3KCNAt+JM8X56/EM=",
        "originContent": "           int8_t txPin = -1, int8_t rxPin = -1,",
        "translatedContent": "           int8_t txPin = -1, int8_t rxPin = -1,"
      },
      {
        "row": 6,
        "rowsha": "hIuyZcIPKazTQINuk3g9HIlIXufky7LMlEHr41+8pzw=",
        "originContent": "           uint16_t txQueue = 0xFFFF, uint16_t rxQueue = 0xFFFF,",
        "translatedContent": "           uint16_t txQueue = 0xFFFF, uint16_t rxQueue = 0xFFFF,"
      },
      {
        "row": 7,
        "rowsha": "1ctcnBU/oAeNOQ/I3IXBbomTWJ5ti0LpPmKUkIGNhi8=",
        "originContent": "           twai_filter_config_t*  fConfig = nullptr,",
        "translatedContent": "           twai_filter_config_t*  fConfig = nullptr,"
      },
      {
        "row": 8,
        "rowsha": "UMZ479PWA7TR/hL579NQQsbYxUmEzLZySrbhpOlIoWg=",
        "originContent": "           twai_general_config_t* gConfig = nullptr,",
        "translatedContent": "           twai_general_config_t* gConfig = nullptr,"
      },
      {
        "row": 9,
        "rowsha": "8oV62DBFRo9IlwFUAum/ITCfpiL9a169ZNPLzIX1ui8=",
        "originContent": "           twai_timing_config_t*  tConfig = nullptr);",
        "translatedContent": "           twai_timing_config_t*  tConfig = nullptr);"
      },
      {
        "row": 10,
        "rowsha": "8bkBhHOQsO1+N058HkZOwXtGpCfEh6WtbL0pBkBQg9U=",
        "originContent": "```",
        "translatedContent": "```"
      }
    ],
    "IsCodeBlock": true
  },
  {
    "Id": 5,
    "Content": "\nFollow `soc/twai_types.h` for more info:\n",
    "ContentSha": "hUeXkXg4ciMfv30tlANLSxLQa1lVrddizjLAbTUxmkE=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n자세한 내용은 `soc/twai_types.h`를 참조하세요:\n",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 2,
        "rowsha": "eH72+JMlSC31E9vxH5IV8OXTT5D5soAmFVXLQP2Nz6g=",
        "originContent": "Follow `soc/twai_types.h` for more info:",
        "translatedContent": "자세한 내용은 `soc/twai_types.h`를 참조하세요:"
      },
      {
        "row": 3,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      }
    ],
    "IsCodeBlock": false
  },
  {
    "Id": 6,
    "Content": "```c\ntypedef struct {\n    union {\n        struct {\n            //The order of these bits must match deprecated message flags for compatibility reasons\n            uint32_t extd: 1;           /**< Extended Frame Format (29bit ID) */\n            uint32_t rtr: 1;            /**< Message is a Remote Frame */\n            uint32_t ss: 1;             /**< Transmit as a Single Shot Transmission. Unused for received. */\n            uint32_t self: 1;           /**< Transmit as a Self Reception Request. Unused for received. */\n            uint32_t dlc_non_comp: 1;   /**< Message's Data length code is larger than 8. This will break compliance with ISO 11898-1 */\n            uint32_t reserved: 27;      /**< Reserved bits */\n        };\n        //Todo: Deprecate flags\n        uint32_t flags;                 /**< Deprecated: Alternate way to set bits using message flags */\n    };\n    uint32_t identifier;                /**< 11 or 29 bit identifier */\n    uint8_t data_length_code;           /**< Data length code */\n    uint8_t data[TWAI_FRAME_MAX_DLC];    /**< Data bytes (not relevant in RTR frame) */\n} twai_message_t;\n\n/**\n * @brief   Structure for bit timing configuration of the TWAI driver\n *\n * @note    Macro initializers are available for this structure\n */\ntypedef struct {\n    uint32_t brp;                   /**< Baudrate prescaler (i.e., APB clock divider). Any even number from 2 to 128 for ESP32, 2 to 32768 for ESP32S2.\n                                         For ESP32 Rev 2 or later, multiples of 4 from 132 to 256 are also supported */\n    uint8_t tseg_1;                 /**< Timing segment 1 (Number of time quanta, between 1 to 16) */\n    uint8_t tseg_2;                 /**< Timing segment 2 (Number of time quanta, 1 to 8) */\n    uint8_t sjw;                    /**< Synchronization Jump Width (Max time quanta jump for synchronize from 1 to 4) */\n    bool triple_sampling;           /**< Enables triple sampling when the TWAI controller samples a bit */\n} twai_timing_config_t;\n\n/**\n * @brief   Structure for acceptance filter configuration of the TWAI driver (see documentation)\n *\n * @note    Macro initializers are available for this structure\n */\ntypedef struct {\n    uint32_t acceptance_code;       /**< 32-bit acceptance code */\n    uint32_t acceptance_mask;       /**< 32-bit acceptance mask */\n    bool single_filter;             /**< Use Single Filter Mode (see documentation) */\n} twai_filter_config_t;\n```",
    "ContentSha": "7S+e1oXBy4L3ziaonZIWVS9XmSdo6yAgoOW4vh3LTMY=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```c\ntypedef struct {\n    union {\n        struct {\n            //The order of these bits must match deprecated message flags for compatibility reasons\n            uint32_t extd: 1;           /**< Extended Frame Format (29bit ID) */\n            uint32_t rtr: 1;            /**< Message is a Remote Frame */\n            uint32_t ss: 1;             /**< Transmit as a Single Shot Transmission. Unused for received. */\n            uint32_t self: 1;           /**< Transmit as a Self Reception Request. Unused for received. */\n            uint32_t dlc_non_comp: 1;   /**< Message's Data length code is larger than 8. This will break compliance with ISO 11898-1 */\n            uint32_t reserved: 27;      /**< Reserved bits */\n        };\n        //Todo: Deprecate flags\n        uint32_t flags;                 /**< Deprecated: Alternate way to set bits using message flags */\n    };\n    uint32_t identifier;                /**< 11 or 29 bit identifier */\n    uint8_t data_length_code;           /**< Data length code */\n    uint8_t data[TWAI_FRAME_MAX_DLC];    /**< Data bytes (not relevant in RTR frame) */\n} twai_message_t;\n\n/**\n * @brief   Structure for bit timing configuration of the TWAI driver\n *\n * @note    Macro initializers are available for this structure\n */\ntypedef struct {\n    uint32_t brp;                   /**< Baudrate prescaler (i.e., APB clock divider). Any even number from 2 to 128 for ESP32, 2 to 32768 for ESP32S2.\n                                         For ESP32 Rev 2 or later, multiples of 4 from 132 to 256 are also supported */\n    uint8_t tseg_1;                 /**< Timing segment 1 (Number of time quanta, between 1 to 16) */\n    uint8_t tseg_2;                 /**< Timing segment 2 (Number of time quanta, 1 to 8) */\n    uint8_t sjw;                    /**< Synchronization Jump Width (Max time quanta jump for synchronize from 1 to 4) */\n    bool triple_sampling;           /**< Enables triple sampling when the TWAI controller samples a bit */\n} twai_timing_config_t;\n\n/**\n * @brief   Structure for acceptance filter configuration of the TWAI driver (see documentation)\n *\n * @note    Macro initializers are available for this structure\n */\ntypedef struct {\n    uint32_t acceptance_code;       /**< 32-bit acceptance code */\n    uint32_t acceptance_mask;       /**< 32-bit acceptance mask */\n    bool single_filter;             /**< Use Single Filter Mode (see documentation) */\n} twai_filter_config_t;\n```",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "RuuC/BIfzzGWnoOVe3nWvvgovSvOfHCkhlSCEmKmxuI=",
        "originContent": "```c",
        "translatedContent": "```c"
      },
      {
        "row": 2,
        "rowsha": "26fGFHJzcQYHKPsAYxPV+0lIgXnYVqX6K+fZ/SWZ9ao=",
        "originContent": "typedef struct {",
        "translatedContent": "typedef struct {"
      },
      {
        "row": 3,
        "rowsha": "f8ZrNPgspq9YeH+QJuZYH2oXtq/csl7Pf7/QUjIY+lk=",
        "originContent": "    union {",
        "translatedContent": "    union {"
      },
      {
        "row": 4,
        "rowsha": "WHdxSmQFk0F2ci0SBJ47lpuR7C6zj5WVDG+fi4abXlE=",
        "originContent": "        struct {",
        "translatedContent": "        struct {"
      },
      {
        "row": 5,
        "rowsha": "r16z8e/dI7J4Zv3n/ahyneqYhTWdYYakccLaPCXeH9A=",
        "originContent": "            //The order of these bits must match deprecated message flags for compatibility reasons",
        "translatedContent": "            //The order of these bits must match deprecated message flags for compatibility reasons"
      },
      {
        "row": 6,
        "rowsha": "b+Q/wmbdCkL/vn1y5P8qrMHzcV9F8XvSeEXmQ6PYnLU=",
        "originContent": "            uint32_t extd: 1;           /**< Extended Frame Format (29bit ID) */",
        "translatedContent": "            uint32_t extd: 1;           /**< Extended Frame Format (29bit ID) */"
      },
      {
        "row": 7,
        "rowsha": "ASECi1znKvLY0cQ9YkHP9TjwAuLVGIESCSVlEMjoXdc=",
        "originContent": "            uint32_t rtr: 1;            /**< Message is a Remote Frame */",
        "translatedContent": "            uint32_t rtr: 1;            /**< Message is a Remote Frame */"
      },
      {
        "row": 8,
        "rowsha": "4+cCaSQl/ql6S196RzZLC3ygHEhlnk/tzHOSjIvADDw=",
        "originContent": "            uint32_t ss: 1;             /**< Transmit as a Single Shot Transmission. Unused for received. */",
        "translatedContent": "            uint32_t ss: 1;             /**< Transmit as a Single Shot Transmission. Unused for received. */"
      },
      {
        "row": 9,
        "rowsha": "NsVxG8MXmtbUYMafyulXOaTXDFuqx7pPFK8qaqh1sDA=",
        "originContent": "            uint32_t self: 1;           /**< Transmit as a Self Reception Request. Unused for received. */",
        "translatedContent": "            uint32_t self: 1;           /**< Transmit as a Self Reception Request. Unused for received. */"
      },
      {
        "row": 10,
        "rowsha": "Ik3++2Wb8bRSrg9lp0DycQlXP75eCK/CSnkzuvPK9xg=",
        "originContent": "            uint32_t dlc_non_comp: 1;   /**< Message's Data length code is larger than 8. This will break compliance with ISO 11898-1 */",
        "translatedContent": "            uint32_t dlc_non_comp: 1;   /**< Message's Data length code is larger than 8. This will break compliance with ISO 11898-1 */"
      },
      {
        "row": 11,
        "rowsha": "O+Ccx/a9+Mwa/0l8qLmmM0rvyzuuhAbTcCOpCzGT/1s=",
        "originContent": "            uint32_t reserved: 27;      /**< Reserved bits */",
        "translatedContent": "            uint32_t reserved: 27;      /**< Reserved bits */"
      },
      {
        "row": 12,
        "rowsha": "8OSK9LfN3EMF8KXXcn/88MTQZvz8cJjzbAD9AoLmCFQ=",
        "originContent": "        };",
        "translatedContent": "        };"
      },
      {
        "row": 13,
        "rowsha": "Rg+5Mapa2FVUbQO61gZJslR0VrZHbi7QauO1/RcloXs=",
        "originContent": "        //Todo: Deprecate flags",
        "translatedContent": "        //Todo: Deprecate flags"
      },
      {
        "row": 14,
        "rowsha": "q6wr9HTY9a5IBgi3+UcTIeGhoFBarLg20QllmoU174Q=",
        "originContent": "        uint32_t flags;                 /**< Deprecated: Alternate way to set bits using message flags */",
        "translatedContent": "        uint32_t flags;                 /**< Deprecated: Alternate way to set bits using message flags */"
      },
      {
        "row": 15,
        "rowsha": "7em+/b2HqM6iEBXxrPSXlZytO/iDgRIZPZigKkf6YTc=",
        "originContent": "    };",
        "translatedContent": "    };"
      },
      {
        "row": 16,
        "rowsha": "zLP/Y11EIFEX+gZRfEDhXnhMp3zZVGa4+JjgnJcHjeY=",
        "originContent": "    uint32_t identifier;                /**< 11 or 29 bit identifier */",
        "translatedContent": "    uint32_t identifier;                /**< 11 or 29 bit identifier */"
      },
      {
        "row": 17,
        "rowsha": "Yye4SHCxBZ9lh7SLMcnZCW6MOUso50oy8JycU7ILI4Y=",
        "originContent": "    uint8_t data_length_code;           /**< Data length code */",
        "translatedContent": "    uint8_t data_length_code;           /**< Data length code */"
      },
      {
        "row": 18,
        "rowsha": "T8Kd4SFSmraIj7pQLvo43ycL1Ikk7t25rm1bL8y8cYo=",
        "originContent": "    uint8_t data[TWAI_FRAME_MAX_DLC];    /**< Data bytes (not relevant in RTR frame) */",
        "translatedContent": "    uint8_t data[TWAI_FRAME_MAX_DLC];    /**< Data bytes (not relevant in RTR frame) */"
      },
      {
        "row": 19,
        "rowsha": "5Ug7cltHbory0VQdWOaCouCEfq1Enr1A2Ddh1iIvoyI=",
        "originContent": "} twai_message_t;",
        "translatedContent": "} twai_message_t;"
      },
      {
        "row": 20,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 21,
        "rowsha": "jWSjDZ3hUbZJAGodmHEDesVkmrYWLqXX/XfFT+0HsVU=",
        "originContent": "/**",
        "translatedContent": "/**"
      },
      {
        "row": 22,
        "rowsha": "du5mj+lo67HOSmwc43slLmc7S7LiKJp+m15djOEk/ww=",
        "originContent": " * @brief   Structure for bit timing configuration of the TWAI driver",
        "translatedContent": " * @brief   Structure for bit timing configuration of the TWAI driver"
      },
      {
        "row": 23,
        "rowsha": "ZOdSZpskc51aaMSdhshu6DcerLueYaRnQfYvL51KtPQ=",
        "originContent": " *",
        "translatedContent": " *"
      },
      {
        "row": 24,
        "rowsha": "kUxGGirfSK9zPWgl5D1a9bFhktD80AKQqHpTCJjU0JE=",
        "originContent": " * @note    Macro initializers are available for this structure",
        "translatedContent": " * @note    Macro initializers are available for this structure"
      },
      {
        "row": 25,
        "rowsha": "UzqfEVVyDl7A7soCH4wmGvTKyNM08SuFbyyPOUGixhE=",
        "originContent": " */",
        "translatedContent": " */"
      },
      {
        "row": 26,
        "rowsha": "26fGFHJzcQYHKPsAYxPV+0lIgXnYVqX6K+fZ/SWZ9ao=",
        "originContent": "typedef struct {",
        "translatedContent": "typedef struct {"
      },
      {
        "row": 27,
        "rowsha": "wv2hQUTRlQdEGTyoO/Zos0l0spsUp67zECpuUUWaKHo=",
        "originContent": "    uint32_t brp;                   /**< Baudrate prescaler (i.e., APB clock divider). Any even number from 2 to 128 for ESP32, 2 to 32768 for ESP32S2.",
        "translatedContent": "    uint32_t brp;                   /**< Baudrate prescaler (i.e., APB clock divider). Any even number from 2 to 128 for ESP32, 2 to 32768 for ESP32S2."
      },
      {
        "row": 28,
        "rowsha": "H8g12BgNoCEWWqAePytooJDpj0rqBX6hdIKeWyS09A8=",
        "originContent": "                                         For ESP32 Rev 2 or later, multiples of 4 from 132 to 256 are also supported */",
        "translatedContent": "                                         For ESP32 Rev 2 or later, multiples of 4 from 132 to 256 are also supported */"
      },
      {
        "row": 29,
        "rowsha": "YCcoVkiDc514eiotzYdSU5a2BU5IXVowVKCCqmi1Xe0=",
        "originContent": "    uint8_t tseg_1;                 /**< Timing segment 1 (Number of time quanta, between 1 to 16) */",
        "translatedContent": "    uint8_t tseg_1;                 /**< Timing segment 1 (Number of time quanta, between 1 to 16) */"
      },
      {
        "row": 30,
        "rowsha": "uBvTAu04jrnp8m/r4Poy1KX+CoEW52DS9pOLtZbcYy4=",
        "originContent": "    uint8_t tseg_2;                 /**< Timing segment 2 (Number of time quanta, 1 to 8) */",
        "translatedContent": "    uint8_t tseg_2;                 /**< Timing segment 2 (Number of time quanta, 1 to 8) */"
      },
      {
        "row": 31,
        "rowsha": "57Y8xo1pg3PkGew4JBH0fxJTZdjMEZLaIJfKJiwbFvU=",
        "originContent": "    uint8_t sjw;                    /**< Synchronization Jump Width (Max time quanta jump for synchronize from 1 to 4) */",
        "translatedContent": "    uint8_t sjw;                    /**< Synchronization Jump Width (Max time quanta jump for synchronize from 1 to 4) */"
      },
      {
        "row": 32,
        "rowsha": "FB7Q5zgLNGndCk0wRBwElHfCWnicdgOLHX6uWn9zy2s=",
        "originContent": "    bool triple_sampling;           /**< Enables triple sampling when the TWAI controller samples a bit */",
        "translatedContent": "    bool triple_sampling;           /**< Enables triple sampling when the TWAI controller samples a bit */"
      },
      {
        "row": 33,
        "rowsha": "S8BK++h4qt/n6Dhw0/v1os9GUPVisDi9WKELpH+mkKo=",
        "originContent": "} twai_timing_config_t;",
        "translatedContent": "} twai_timing_config_t;"
      },
      {
        "row": 34,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 35,
        "rowsha": "jWSjDZ3hUbZJAGodmHEDesVkmrYWLqXX/XfFT+0HsVU=",
        "originContent": "/**",
        "translatedContent": "/**"
      },
      {
        "row": 36,
        "rowsha": "YGPpPKcl4Upbvw2o06VPuYb5oyqxcnYssb8lk2jrsVw=",
        "originContent": " * @brief   Structure for acceptance filter configuration of the TWAI driver (see documentation)",
        "translatedContent": " * @brief   Structure for acceptance filter configuration of the TWAI driver (see documentation)"
      },
      {
        "row": 37,
        "rowsha": "ZOdSZpskc51aaMSdhshu6DcerLueYaRnQfYvL51KtPQ=",
        "originContent": " *",
        "translatedContent": " *"
      },
      {
        "row": 38,
        "rowsha": "kUxGGirfSK9zPWgl5D1a9bFhktD80AKQqHpTCJjU0JE=",
        "originContent": " * @note    Macro initializers are available for this structure",
        "translatedContent": " * @note    Macro initializers are available for this structure"
      },
      {
        "row": 39,
        "rowsha": "UzqfEVVyDl7A7soCH4wmGvTKyNM08SuFbyyPOUGixhE=",
        "originContent": " */",
        "translatedContent": " */"
      },
      {
        "row": 40,
        "rowsha": "26fGFHJzcQYHKPsAYxPV+0lIgXnYVqX6K+fZ/SWZ9ao=",
        "originContent": "typedef struct {",
        "translatedContent": "typedef struct {"
      },
      {
        "row": 41,
        "rowsha": "9p7bVOEde7JcXmiV9t8bJ19t28E83+pcwEtP/7hobks=",
        "originContent": "    uint32_t acceptance_code;       /**< 32-bit acceptance code */",
        "translatedContent": "    uint32_t acceptance_code;       /**< 32-bit acceptance code */"
      },
      {
        "row": 42,
        "rowsha": "1YrdmHrYyOWpasOY3v5ct4xDvXfrR6nymmUa76gacZs=",
        "originContent": "    uint32_t acceptance_mask;       /**< 32-bit acceptance mask */",
        "translatedContent": "    uint32_t acceptance_mask;       /**< 32-bit acceptance mask */"
      },
      {
        "row": 43,
        "rowsha": "d7xzTtouQSslwhu2fUa93dKx5lA3GCj1jNEolP38Aow=",
        "originContent": "    bool single_filter;             /**< Use Single Filter Mode (see documentation) */",
        "translatedContent": "    bool single_filter;             /**< Use Single Filter Mode (see documentation) */"
      },
      {
        "row": 44,
        "rowsha": "kvVmA3yid6jPzVJEAwMjg+ocUO7ue/NBaxz6DAmmdM8=",
        "originContent": "} twai_filter_config_t;",
        "translatedContent": "} twai_filter_config_t;"
      },
      {
        "row": 45,
        "rowsha": "8bkBhHOQsO1+N058HkZOwXtGpCfEh6WtbL0pBkBQg9U=",
        "originContent": "```",
        "translatedContent": "```"
      }
    ],
    "IsCodeBlock": true
  },
  {
    "Id": 7,
    "Content": "\n\n",
    "ContentSha": "daEdpEyAJIa8b2VkCqSKcw8PaExcB6Qro80XNes/sHA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n\n",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 2,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      }
    ],
    "IsCodeBlock": false
  }
]