{
  "id": 4,
  "origin": "```\n\n## üïµÔ∏è Adding HTTP(S) Agent\n\nIn Node.js (>= 18) environments, you can provide a custom dispatcher to intercept requests and support features such as Proxy and self-signed certificates. This feature is enabled by [undici](https://undici.nodejs.org/) built-in Node.js. [read more](https://undici.nodejs.org/#/docs/api/Dispatcher) about the Dispatcher API.\n\nSome available agents:\n\n- `ProxyAgent`: A Proxy Agent class that implements the Agent API. It allows the connection through a proxy in a simple way. ([docs](https://undici.nodejs.org/#/docs/api/ProxyAgent))\n- `MockAgent`: A mocked Agent class that implements the Agent API. It allows one to intercept HTTP requests made through undici and return mocked responses instead. ([docs](https://undici.nodejs.org/#/docs/api/MockAgent))\n- `Agent`: Agent allows dispatching requests against multiple different origins. ([docs](https://undici.nodejs.org/#/docs/api/Agent))\n\n**Example:** Set a proxy agent for one request:\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst data = await ofetch(\"https://icanhazip.com\", { dispatcher: proxyAgent });\n```\n\n**Example:** Create a custom fetch instance that has proxy enabled:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst fetchWithProxy = ofetch.create({ dispatcher: proxyAgent });\n\nconst data = await fetchWithProxy(\"https://icanhazip.com\");\n```\n\n**Example:** Set a proxy agent for all requests:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nsetGlobalDispatcher(proxyAgent);\n\nconst data = await ofetch(\"https://icanhazip.com\");\n```\n\n**Example:** Allow self-signed certificates (USE AT YOUR OWN RISK!)\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\n// Note: This makes fetch unsecure against MITM attacks. USE AT YOUR OWN RISK!\nconst unsecureProxyAgent = new ProxyAgent({ requestTls: { rejectUnauthorized: false } });\nconst unsecureFetch = ofetch.create({ dispatcher: unsecureProxyAgent });\n\nconst data = await unsecureFetch(\"https://www.squid-cache.org/\");\n```\n\nOn older Node.js version (<18), you might also use use `agent`:\n\n```ts\nimport { HttpsProxyAgent } from \"https-proxy-agent\";\n\nawait ofetch(\"/api\", {\n  agent: new HttpsProxyAgent(\"http://example.com\"),\n});\n```\n\n### `keepAlive` support (only works for Node < 18)\n\nBy setting the `FETCH_KEEP_ALIVE` environment variable to `true`, an HTTP/HTTPS agent will be registered that keeps sockets around even when there are no outstanding requests, so they can be used for future requests without having to re-establish a TCP connection.\n\n**Note:** This option can potentially introduce memory leaks. Please check [node-fetch/node-fetch#1325](https://github.com/node-fetch/node-fetch/pull/1325).\n\n## üì¶ Bundler Notes\n\n- All targets are exported with Module and CommonJS format and named exports\n- No export is transpiled for the sake of modern syntax\n  - You probably need to transpile `ofetch`, `destr`, and `ufo` packages with Babel for ES5 support\n- You need to polyfill `fetch` global for supporting legacy browsers like using [unfetch](https://github.com/developit/unfetch)\n\n## ‚ùì FAQ\n\n**Why export is called `ofetch` instead of `fetch`?**\n\nUsing the same name of `fetch` can be confusing since API is different but still, it is a fetch so using the closest possible alternative. You can, however, import `{ fetch }` from `ofetch` which is auto-polyfill for Node.js and using native otherwise.\n\n**Why not have default export?**\n\nDefault exports are always risky to be mixed with CommonJS exports.\n\nThis also guarantees we can introduce more utils without breaking the package and also encourage using `ofetch` name.\n\n**Why not transpiled?**\n\nBy transpiling libraries, we push the web backward with legacy code which is unneeded for most of the users.\n\nIf you need to support legacy users, you can optionally transpile the library in your build pipeline.\n",
  "origin_sha": "aERgTRlscCw9FINz3st04QU8LoGdZrVhR2FMqnTr5aI=",
  "translate": "```\n\n## üïµÔ∏è A√±adiendo Agente HTTP(S)\n\nEn entornos Node.js (>= 18), puedes proporcionar un dispatcher personalizado para interceptar solicitudes y soportar caracter√≠sticas como Proxy y certificados autofirmados. Esta funcionalidad es posible gracias a [undici](https://undici.nodejs.org/) integrado en Node.js. [lee m√°s](https://undici.nodejs.org/#/docs/api/Dispatcher) sobre la API de Dispatcher.\n\nAlgunos agentes disponibles:\n\n- `ProxyAgent`: Una clase de Proxy Agent que implementa la API de Agent. Permite la conexi√≥n a trav√©s de un proxy de manera sencilla. ([docs](https://undici.nodejs.org/#/docs/api/ProxyAgent))\n- `MockAgent`: Una clase Agent simulada que implementa la API de Agent. Permite interceptar solicitudes HTTP hechas a trav√©s de undici y devolver respuestas simuladas en su lugar. ([docs](https://undici.nodejs.org/#/docs/api/MockAgent))\n- `Agent`: Agent permite despachar solicitudes contra m√∫ltiples or√≠genes diferentes. ([docs](https://undici.nodejs.org/#/docs/api/Agent))\n\n**Ejemplo:** Establecer un agente proxy para una solicitud:\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst data = await ofetch(\"https://icanhazip.com\", { dispatcher: proxyAgent });\n```\n\n**Ejemplo:** Crear una instancia personalizada de fetch con proxy habilitado:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst fetchWithProxy = ofetch.create({ dispatcher: proxyAgent });\n\nconst data = await fetchWithProxy(\"https://icanhazip.com\");\n```\n\n**Ejemplo:** Establecer un agente proxy para todas las solicitudes:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nsetGlobalDispatcher(proxyAgent);\n\nconst data = await ofetch(\"https://icanhazip.com\");\n```\n\n**Ejemplo:** Permitir certificados autofirmados (¬°USAR BAJO TU PROPIO RIESGO!)\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\n// Nota: Esto hace que fetch sea inseguro contra ataques MITM. ¬°USAR BAJO TU PROPIO RIESGO!\nconst unsecureProxyAgent = new ProxyAgent({ requestTls: { rejectUnauthorized: false } });\nconst unsecureFetch = ofetch.create({ dispatcher: unsecureProxyAgent });\n\nconst data = await unsecureFetch(\"https://www.squid-cache.org/\");\n```\n\nEn versiones antiguas de Node.js (<18), tambi√©n puedes usar `agent`:\n\n```ts\nimport { HttpsProxyAgent } from \"https-proxy-agent\";\n\nawait ofetch(\"/api\", {\n  agent: new HttpsProxyAgent(\"http://example.com\"),\n});\n```\n\n### Soporte para `keepAlive` (solo funciona para Node < 18)\n\nEstableciendo la variable de entorno `FETCH_KEEP_ALIVE` en `true`, se registrar√° un agente HTTP/HTTPS que mantiene los sockets abiertos incluso cuando no hay solicitudes pendientes, por lo que pueden usarse para futuras solicitudes sin tener que volver a establecer una conexi√≥n TCP.\n\n**Nota:** Esta opci√≥n puede potencialmente introducir fugas de memoria. Por favor revisa [node-fetch/node-fetch#1325](https://github.com/node-fetch/node-fetch/pull/1325).\n\n## üì¶ Notas para Bundlers\n\n- Todos los targets se exportan con formato Module y CommonJS y exports nombrados\n- Ninguna exportaci√≥n est√° transpilada para mantener la sintaxis moderna\n  - Probablemente necesitar√°s transpilar los paquetes `ofetch`, `destr` y `ufo` con Babel para soporte ES5\n- Necesitas hacer un polyfill del global `fetch` para soportar navegadores antiguos, por ejemplo usando [unfetch](https://github.com/developit/unfetch)\n\n## ‚ùì FAQ\n\n**¬øPor qu√© la exportaci√≥n se llama `ofetch` en vez de `fetch`?**\n\nUsar el mismo nombre de `fetch` puede ser confuso ya que la API es diferente, pero sigue siendo un fetch, por lo que se usa la alternativa m√°s cercana posible. Sin embargo, puedes importar `{ fetch }` de `ofetch`, que es un auto-polyfill para Node.js y usa el nativo en otros casos.\n\n**¬øPor qu√© no hay exportaci√≥n por defecto?**\n\nLas exportaciones por defecto siempre son arriesgadas de mezclar con exports CommonJS.\n\nEsto tambi√©n garantiza que podemos introducir m√°s utilidades sin romper el paquete y fomenta el uso del nombre `ofetch`.\n\n**¬øPor qu√© no est√° transpilado?**\n\nAl transpilar librer√≠as, empujamos la web hacia atr√°s con c√≥digo legado que no es necesario para la mayor√≠a de los usuarios.\n\nSi necesitas soportar usuarios antiguos, puedes transpilar la librer√≠a opcionalmente en tu pipeline de construcci√≥n.\n```",
  "status": "ok"
}