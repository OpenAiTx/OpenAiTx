{
  "id": 4,
  "origin": "```\n\n## üïµÔ∏è Adding HTTP(S) Agent\n\nIn Node.js (>= 18) environments, you can provide a custom dispatcher to intercept requests and support features such as Proxy and self-signed certificates. This feature is enabled by [undici](https://undici.nodejs.org/) built-in Node.js. [read more](https://undici.nodejs.org/#/docs/api/Dispatcher) about the Dispatcher API.\n\nSome available agents:\n\n- `ProxyAgent`: A Proxy Agent class that implements the Agent API. It allows the connection through a proxy in a simple way. ([docs](https://undici.nodejs.org/#/docs/api/ProxyAgent))\n- `MockAgent`: A mocked Agent class that implements the Agent API. It allows one to intercept HTTP requests made through undici and return mocked responses instead. ([docs](https://undici.nodejs.org/#/docs/api/MockAgent))\n- `Agent`: Agent allows dispatching requests against multiple different origins. ([docs](https://undici.nodejs.org/#/docs/api/Agent))\n\n**Example:** Set a proxy agent for one request:\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst data = await ofetch(\"https://icanhazip.com\", { dispatcher: proxyAgent });\n```\n\n**Example:** Create a custom fetch instance that has proxy enabled:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst fetchWithProxy = ofetch.create({ dispatcher: proxyAgent });\n\nconst data = await fetchWithProxy(\"https://icanhazip.com\");\n```\n\n**Example:** Set a proxy agent for all requests:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nsetGlobalDispatcher(proxyAgent);\n\nconst data = await ofetch(\"https://icanhazip.com\");\n```\n\n**Example:** Allow self-signed certificates (USE AT YOUR OWN RISK!)\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\n// Note: This makes fetch unsecure against MITM attacks. USE AT YOUR OWN RISK!\nconst unsecureProxyAgent = new ProxyAgent({ requestTls: { rejectUnauthorized: false } });\nconst unsecureFetch = ofetch.create({ dispatcher: unsecureProxyAgent });\n\nconst data = await unsecureFetch(\"https://www.squid-cache.org/\");\n```\n\nOn older Node.js version (<18), you might also use use `agent`:\n\n```ts\nimport { HttpsProxyAgent } from \"https-proxy-agent\";\n\nawait ofetch(\"/api\", {\n  agent: new HttpsProxyAgent(\"http://example.com\"),\n});\n```\n\n### `keepAlive` support (only works for Node < 18)\n\nBy setting the `FETCH_KEEP_ALIVE` environment variable to `true`, an HTTP/HTTPS agent will be registered that keeps sockets around even when there are no outstanding requests, so they can be used for future requests without having to re-establish a TCP connection.\n\n**Note:** This option can potentially introduce memory leaks. Please check [node-fetch/node-fetch#1325](https://github.com/node-fetch/node-fetch/pull/1325).\n\n## üì¶ Bundler Notes\n\n- All targets are exported with Module and CommonJS format and named exports\n- No export is transpiled for the sake of modern syntax\n  - You probably need to transpile `ofetch`, `destr`, and `ufo` packages with Babel for ES5 support\n- You need to polyfill `fetch` global for supporting legacy browsers like using [unfetch](https://github.com/developit/unfetch)\n\n## ‚ùì FAQ\n\n**Why export is called `ofetch` instead of `fetch`?**\n\nUsing the same name of `fetch` can be confusing since API is different but still, it is a fetch so using the closest possible alternative. You can, however, import `{ fetch }` from `ofetch` which is auto-polyfill for Node.js and using native otherwise.\n\n**Why not have default export?**\n\nDefault exports are always risky to be mixed with CommonJS exports.\n\nThis also guarantees we can introduce more utils without breaking the package and also encourage using `ofetch` name.\n\n**Why not transpiled?**\n\nBy transpiling libraries, we push the web backward with legacy code which is unneeded for most of the users.\n\nIf you need to support legacy users, you can optionally transpile the library in your build pipeline.\n",
  "origin_sha": "aERgTRlscCw9FINz3st04QU8LoGdZrVhR2FMqnTr5aI=",
  "translate": "```\n\n## üïµÔ∏è Hinzuf√ºgen eines HTTP(S)-Agents\n\nIn Node.js-Umgebungen (>= 18) k√∂nnen Sie einen benutzerdefinierten Dispatcher bereitstellen, um Anfragen abzufangen und Funktionen wie Proxy und selbstsignierte Zertifikate zu unterst√ºtzen. Diese Funktion wird durch [undici](https://undici.nodejs.org/) bereitgestellt, das in Node.js integriert ist. [Mehr erfahren](https://undici.nodejs.org/#/docs/api/Dispatcher) √ºber die Dispatcher-API.\n\nEinige verf√ºgbare Agents:\n\n- `ProxyAgent`: Eine Proxy-Agent-Klasse, die die Agent-API implementiert. Sie erm√∂glicht die Verbindung √ºber einen Proxy auf einfache Weise. ([Dokumentation](https://undici.nodejs.org/#/docs/api/ProxyAgent))\n- `MockAgent`: Eine gemockte Agent-Klasse, die die Agent-API implementiert. Sie erm√∂glicht das Abfangen von HTTP-Anfragen, die √ºber undici gesendet werden, und gibt stattdessen simulierte Antworten zur√ºck. ([Dokumentation](https://undici.nodejs.org/#/docs/api/MockAgent))\n- `Agent`: Agent erm√∂glicht das Versenden von Anfragen an verschiedene Urspr√ºnge. ([Dokumentation](https://undici.nodejs.org/#/docs/api/Agent))\n\n**Beispiel:** Einen Proxy-Agent f√ºr eine Anfrage setzen:\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst data = await ofetch(\"https://icanhazip.com\", { dispatcher: proxyAgent });\n```\n\n**Beispiel:** Eine benutzerdefinierte Fetch-Instanz mit aktiviertem Proxy erstellen:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst fetchWithProxy = ofetch.create({ dispatcher: proxyAgent });\n\nconst data = await fetchWithProxy(\"https://icanhazip.com\");\n```\n\n**Beispiel:** Einen Proxy-Agent f√ºr alle Anfragen setzen:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nsetGlobalDispatcher(proxyAgent);\n\nconst data = await ofetch(\"https://icanhazip.com\");\n```\n\n**Beispiel:** Selbstsignierte Zertifikate erlauben (NUTZEN AUF EIGENE GEFAHR!)\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\n// Hinweis: Dies macht Fetch anf√§llig f√ºr MITM-Angriffe. NUTZEN AUF EIGENE GEFAHR!\nconst unsecureProxyAgent = new ProxyAgent({ requestTls: { rejectUnauthorized: false } });\nconst unsecureFetch = ofetch.create({ dispatcher: unsecureProxyAgent });\n\nconst data = await unsecureFetch(\"https://www.squid-cache.org/\");\n```\n\nIn √§lteren Node.js-Versionen (<18) k√∂nnen Sie auch `agent` verwenden:\n\n```ts\nimport { HttpsProxyAgent } from \"https-proxy-agent\";\n\nawait ofetch(\"/api\", {\n  agent: new HttpsProxyAgent(\"http://example.com\"),\n});\n```\n\n### `keepAlive`-Unterst√ºtzung (funktioniert nur f√ºr Node < 18)\n\nIndem Sie die Umgebungsvariable `FETCH_KEEP_ALIVE` auf `true` setzen, wird ein HTTP/HTTPS-Agent registriert, der Sockets auch dann offen h√§lt, wenn keine ausstehenden Anfragen bestehen, sodass diese f√ºr zuk√ºnftige Anfragen wiederverwendet werden k√∂nnen, ohne dass eine neue TCP-Verbindung aufgebaut werden muss.\n\n**Hinweis:** Diese Option kann potenziell zu Speicherlecks f√ºhren. Bitte beachten Sie [node-fetch/node-fetch#1325](https://github.com/node-fetch/node-fetch/pull/1325).\n\n## üì¶ Hinweise f√ºr Bundler\n\n- Alle Targets werden mit Modul- und CommonJS-Format sowie als benannte Exporte ausgeliefert\n- Kein Export wird transpiliert, um moderne Syntax beizubehalten\n  - Wahrscheinlich m√ºssen Sie die Pakete `ofetch`, `destr` und `ufo` mit Babel transpiliert werden, um ES5 zu unterst√ºtzen\n- Sie m√ºssen das globale `fetch` polyfillen, um Legacy-Browser wie mit [unfetch](https://github.com/developit/unfetch) zu unterst√ºtzen\n\n## ‚ùì FAQ\n\n**Warum hei√üt der Export `ofetch` statt `fetch`?**\n\nDie Verwendung des gleichen Namens wie `fetch` kann verwirrend sein, da die API unterschiedlich ist, aber es handelt sich dennoch um ein Fetch ‚Äì daher wird die n√§chstm√∂gliche Alternative verwendet. Sie k√∂nnen jedoch `{ fetch }` aus `ofetch` importieren, das f√ºr Node.js automatisch ein Polyfill verwendet und ansonsten das native Fetch nutzt.\n\n**Warum gibt es keinen Default-Export?**\n\nDefault-Exporte sind immer riskant, da sie mit CommonJS-Exporten vermischt werden k√∂nnen.\n\nDies stellt auch sicher, dass wir weitere Utils hinzuf√ºgen k√∂nnen, ohne das Paket zu brechen, und f√∂rdert zudem die Verwendung des Namens `ofetch`.\n\n**Warum nicht transpiliert?**\n\nDurch das Transpilieren von Bibliotheken wird das Web mit Legacy-Code zur√ºckgeworfen, was f√ºr die meisten Nutzer unn√∂tig ist.\n\nWenn Sie Legacy-Nutzer unterst√ºtzen m√ºssen, k√∂nnen Sie die Bibliothek optional in Ihrer Build-Pipeline transpiliert verwenden.\n```",
  "status": "ok"
}