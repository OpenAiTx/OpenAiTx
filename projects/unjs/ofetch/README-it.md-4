{
  "id": 4,
  "origin": "```\n\n## 🕵️ Adding HTTP(S) Agent\n\nIn Node.js (>= 18) environments, you can provide a custom dispatcher to intercept requests and support features such as Proxy and self-signed certificates. This feature is enabled by [undici](https://undici.nodejs.org/) built-in Node.js. [read more](https://undici.nodejs.org/#/docs/api/Dispatcher) about the Dispatcher API.\n\nSome available agents:\n\n- `ProxyAgent`: A Proxy Agent class that implements the Agent API. It allows the connection through a proxy in a simple way. ([docs](https://undici.nodejs.org/#/docs/api/ProxyAgent))\n- `MockAgent`: A mocked Agent class that implements the Agent API. It allows one to intercept HTTP requests made through undici and return mocked responses instead. ([docs](https://undici.nodejs.org/#/docs/api/MockAgent))\n- `Agent`: Agent allows dispatching requests against multiple different origins. ([docs](https://undici.nodejs.org/#/docs/api/Agent))\n\n**Example:** Set a proxy agent for one request:\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst data = await ofetch(\"https://icanhazip.com\", { dispatcher: proxyAgent });\n```\n\n**Example:** Create a custom fetch instance that has proxy enabled:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst fetchWithProxy = ofetch.create({ dispatcher: proxyAgent });\n\nconst data = await fetchWithProxy(\"https://icanhazip.com\");\n```\n\n**Example:** Set a proxy agent for all requests:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nsetGlobalDispatcher(proxyAgent);\n\nconst data = await ofetch(\"https://icanhazip.com\");\n```\n\n**Example:** Allow self-signed certificates (USE AT YOUR OWN RISK!)\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\n// Note: This makes fetch unsecure against MITM attacks. USE AT YOUR OWN RISK!\nconst unsecureProxyAgent = new ProxyAgent({ requestTls: { rejectUnauthorized: false } });\nconst unsecureFetch = ofetch.create({ dispatcher: unsecureProxyAgent });\n\nconst data = await unsecureFetch(\"https://www.squid-cache.org/\");\n```\n\nOn older Node.js version (<18), you might also use use `agent`:\n\n```ts\nimport { HttpsProxyAgent } from \"https-proxy-agent\";\n\nawait ofetch(\"/api\", {\n  agent: new HttpsProxyAgent(\"http://example.com\"),\n});\n```\n\n### `keepAlive` support (only works for Node < 18)\n\nBy setting the `FETCH_KEEP_ALIVE` environment variable to `true`, an HTTP/HTTPS agent will be registered that keeps sockets around even when there are no outstanding requests, so they can be used for future requests without having to re-establish a TCP connection.\n\n**Note:** This option can potentially introduce memory leaks. Please check [node-fetch/node-fetch#1325](https://github.com/node-fetch/node-fetch/pull/1325).\n\n## 📦 Bundler Notes\n\n- All targets are exported with Module and CommonJS format and named exports\n- No export is transpiled for the sake of modern syntax\n  - You probably need to transpile `ofetch`, `destr`, and `ufo` packages with Babel for ES5 support\n- You need to polyfill `fetch` global for supporting legacy browsers like using [unfetch](https://github.com/developit/unfetch)\n\n## ❓ FAQ\n\n**Why export is called `ofetch` instead of `fetch`?**\n\nUsing the same name of `fetch` can be confusing since API is different but still, it is a fetch so using the closest possible alternative. You can, however, import `{ fetch }` from `ofetch` which is auto-polyfill for Node.js and using native otherwise.\n\n**Why not have default export?**\n\nDefault exports are always risky to be mixed with CommonJS exports.\n\nThis also guarantees we can introduce more utils without breaking the package and also encourage using `ofetch` name.\n\n**Why not transpiled?**\n\nBy transpiling libraries, we push the web backward with legacy code which is unneeded for most of the users.\n\nIf you need to support legacy users, you can optionally transpile the library in your build pipeline.\n",
  "origin_sha": "aERgTRlscCw9FINz3st04QU8LoGdZrVhR2FMqnTr5aI=",
  "translate": "```\n\n## 🕵️ Aggiunta di un Agente HTTP(S)\n\nNegli ambienti Node.js (>= 18), è possibile fornire un dispatcher personalizzato per intercettare le richieste e supportare funzionalità come Proxy e certificati self-signed. Questa funzionalità è abilitata da [undici](https://undici.nodejs.org/) integrato in Node.js. [leggi di più](https://undici.nodejs.org/#/docs/api/Dispatcher) sull’API Dispatcher.\n\nAlcuni agenti disponibili:\n\n- `ProxyAgent`: Una classe Proxy Agent che implementa l’API Agent. Permette la connessione tramite proxy in modo semplice. ([documentazione](https://undici.nodejs.org/#/docs/api/ProxyAgent))\n- `MockAgent`: Una classe Agent simulata che implementa l’API Agent. Permette di intercettare le richieste HTTP effettuate tramite undici e restituire risposte simulate invece di quelle reali. ([documentazione](https://undici.nodejs.org/#/docs/api/MockAgent))\n- `Agent`: Agent permette di inviare richieste verso molteplici origini diverse. ([documentazione](https://undici.nodejs.org/#/docs/api/Agent))\n\n**Esempio:** Impostare un proxy agent per una richiesta:\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst data = await ofetch(\"https://icanhazip.com\", { dispatcher: proxyAgent });\n```\n\n**Esempio:** Creare un’istanza fetch personalizzata con proxy abilitato:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nconst fetchWithProxy = ofetch.create({ dispatcher: proxyAgent });\n\nconst data = await fetchWithProxy(\"https://icanhazip.com\");\n```\n\n**Esempio:** Impostare un proxy agent per tutte le richieste:\n\n```ts\nimport { ProxyAgent, setGlobalDispatcher } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\nconst proxyAgent = new ProxyAgent(\"http://localhost:3128\");\nsetGlobalDispatcher(proxyAgent);\n\nconst data = await ofetch(\"https://icanhazip.com\");\n```\n\n**Esempio:** Consentire certificati self-signed (USARE A PROPRIO RISCHIO!)\n\n```ts\nimport { ProxyAgent } from \"undici\";\nimport { ofetch } from \"ofetch\";\n\n// Nota: Questo rende fetch insicuro contro attacchi MITM. USARE A PROPRIO RISCHIO!\nconst unsecureProxyAgent = new ProxyAgent({ requestTls: { rejectUnauthorized: false } });\nconst unsecureFetch = ofetch.create({ dispatcher: unsecureProxyAgent });\n\nconst data = await unsecureFetch(\"https://www.squid-cache.org/\");\n```\n\nSu versioni Node.js più vecchie (<18), puoi anche usare `agent`:\n\n```ts\nimport { HttpsProxyAgent } from \"https-proxy-agent\";\n\nawait ofetch(\"/api\", {\n  agent: new HttpsProxyAgent(\"http://example.com\"),\n});\n```\n\n### Supporto `keepAlive` (funziona solo per Node < 18)\n\nImpostando la variabile d’ambiente `FETCH_KEEP_ALIVE` su `true`, verrà registrato un agente HTTP/HTTPS che mantiene attivi i socket anche quando non ci sono richieste in sospeso, così da poterli riutilizzare per richieste future senza dover ristabilire una connessione TCP.\n\n**Nota:** Questa opzione può potenzialmente introdurre memory leak. Consulta [node-fetch/node-fetch#1325](https://github.com/node-fetch/node-fetch/pull/1325).\n\n## 📦 Note sul Bundler\n\n- Tutti i target sono esportati sia in formato Module che CommonJS ed esportazioni nominate\n- Nessuna esportazione viene transpile per mantenere la sintassi moderna\n  - Probabilmente dovrai transpile i pacchetti `ofetch`, `destr` e `ufo` con Babel per il supporto ES5\n- È necessario effettuare il polyfill della globale `fetch` per supportare browser legacy, ad esempio usando [unfetch](https://github.com/developit/unfetch)\n\n## ❓ FAQ\n\n**Perché l’export si chiama `ofetch` invece di `fetch`?**\n\nUsare lo stesso nome di `fetch` può essere fonte di confusione poiché l’API è diversa, ma è comunque un fetch quindi si è scelto l’alternativa più vicina possibile. Puoi comunque importare `{ fetch }` da `ofetch`, che è un auto-polyfill per Node.js e usa quello nativo altrimenti.\n\n**Perché non c’è un export di default?**\n\nGli export di default sono sempre rischiosi da mischiare con export CommonJS.\n\nQuesto garantisce anche che si possano introdurre altri util senza rompere il pacchetto e inoltre incoraggia l’uso del nome `ofetch`.\n\n**Perché non viene transpile?**\n\nTranspilare le librerie significa rallentare il web con codice legacy, il che non è necessario per la maggior parte degli utenti.\n\nSe hai bisogno di supportare utenti legacy, puoi opzionalmente transpile la libreria nella tua pipeline di build.\n```",
  "status": "ok"
}