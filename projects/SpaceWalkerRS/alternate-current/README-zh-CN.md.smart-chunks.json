[
  {
    "Id": 1,
    "Content": "# Alternate Current\n\nAlternate Current is an efficient and non-locational redstone dust implementation. Its main focus lies in reducing the lag caused by redstone dust, by optimizing the power calculations and reducing the number of shape and block updates emitted. As a side effect of these changes the block update order of redstone dust networks is predictable and intuitive rather than locational and chaotic.\n\n## Performance\n\nMSPT contributions of redstone dust are up to 20 times lower with Alternate Current, all the while maintaining a high level of Vanilla parity. Its low number of code modifications make it minimally invasive, so it is an easy drop-in replacement for Vanilla redstone dust.\n\n## How does it work?\n\nThe algorithm Alternate Current uses was designed with the following goals in mind:\n1. Minimize the number of times a wire checks its surroundings to determine its power level.\n2. Minimize the number of block and shape updates emitted.\n3. Emit block and shape updates in a deterministic, non-locational order, fixing bug MC-11193.\n\nIn Vanilla redstone wire is laggy because it fails on points 1 and 2.\n\nRedstone wire updates recursively and each wire calculates its power level in isolation rather than in the context of the network it is a part of. This means a wire in a grid can change its power level over half a dozen times before settling on its final value. This problem used to be worse in 1.13 and below, where a wire would only decrease its power level by 1 at a time.\n\nIn addition to this, a wire emits 42 block updates and up to 22 shape updates each time it changes its power level.\n\nOf those 42 block updates, 6 are to itself, which are thus not only redundant, but a big source of lag, since those cause the wire to unnecessarily re-calculate its power level. A block only has 24 neighbors within a Manhattan distance of 2, meaning 12 of the remaining 36 block updates are duplicates and thus also redundant.\n\nOf the 22 shape updates, only 6 are strictly necessary. The other 16 are sent to blocks diagonally above and below. These are necessary if a wire changes its connections, but not when it changes its power level.\n\nRedstone wire in Vanilla also fails on point 3, though this is more of a quality-of-life issue than a lag issue. The recursive nature in which it updates, combined with the location-dependent order in which each wire updates its neighbors, makes the order in which neighbors of a wire network are updated incredibly inconsistent and seemingly random.\n\nAlternate Current fixes each of these problems as follows.\n\n(1)\nTo make sure a wire calculates its power level as little as possible, we remove the recursive nature in which redstone wire updates in Vanilla. Instead, we build a network of connected wires, find those wires that receive redstone power from \"outside\" the network, and spread the power from there. This has a few advantages:\n\n- Each wire checks for power from non-wire components at most once, and from nearby wires just twice.\n- Each wire only sets its power level in the world once. This is important, because calls to Level.setBlock are even more expensive than calls to Level.getBlockState.\n\n(2)\nThere are 2 obvious ways in which we can reduce the number of block and shape updates.\n\n- Get rid of the 18 redundant block updates and 16 redundant shape updates, so each wire only emits 24 block updates and 6 shape updates whenever it changes its power level.\n- Only emit block updates and shape updates once a wire reaches its final power level, rather than at each intermediary stage.",
    "ContentSha": "VRjJi4HUXMa7FVUYH4S7auit7tSk45HDVQwws79zOdM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# 交流电\n\n交流电是一种高效且非位置依赖的红石线实现。其主要目标在于通过优化功率计算和减少形状及方块更新的数量，降低由红石线引起的延迟。作为这些改进的副作用，红石线网络的方块更新顺序变得可预测且直观，而非位置依赖且混乱。\n\n## 性能\n\n使用交流电后，红石线的MSPT贡献最多降低20倍，同时保持了与原版高程度的一致性。其较少的代码修改使其侵入性极小，因此是原版红石线的简单替代方案。\n\n## 它是如何工作的？\n\n交流电所采用的算法设计时考虑了以下目标：\n1. 最小化红石线检查周围环境以确定其功率等级的次数。\n2. 最小化发出的方块和形状更新数量。\n3. 以确定性、非位置依赖的顺序发出方块和形状更新，修复了MC-11193错误。\n\n在原版中，红石线因未满足第1和第2点而导致延迟。\n\n红石线以递归方式更新，每根线独立计算其功率等级，而不是在其所在网络的上下文中计算。这意味着网格中的一根线在确定最终值之前，功率等级可能变化超过半打次数。这个问题在1.13及以下版本更为严重，那时一根线每次只能减少1点功率。\n\n此外，每当功率等级变化时，一根线会发出42个方块更新和最多22个形状更新。\n\n在这42个方块更新中，有6个是针对线自身的，这不仅冗余，而且是延迟的重要来源，因为它们导致线不必要地重新计算功率等级。一个方块在曼哈顿距离2内只有24个邻居，因此剩余36个方块更新中有12个是重复的，也属于冗余。\n\n在22个形状更新中，只有6个是严格必要的。其余16个发送给对角线上下的方块。这些更新在红石线改变连接时是必要的，但在其仅改变功率等级时则不需要。\n\n原版红石线也未满足第3点，尽管这更多是用户体验问题而非延迟问题。其递归更新方式，加上每根线按位置依赖顺序更新邻居，使得线网络邻居的更新顺序极其不一致且看似随机。\n\n交流电针对这些问题做出了如下改进。\n\n(1)\n为了确保线尽可能少地计算功率等级，我们去除了原版中红石线的递归更新方式。取而代之的是，我们构建一个连接线的网络，找到从“外部”接收红石电力的线，然后从那里传播电力。这有几个优点：\n\n- 每根线最多检查一次来自非线组件的电力，来自附近线的电力检查仅两次。\n- 每根线只在世界中设置一次功率等级。这一点很重要，因为调用Level.setBlock比调用Level.getBlockState更消耗性能。\n\n(2)\n我们可以通过两种明显方法减少方块和形状更新数量。\n\n- 去除18个冗余方块更新和16个冗余形状更新，使每根线在功率等级变化时只发出24个方块更新和6个形状更新。\n- 仅在线达到最终功率等级时发出方块和形状更新，而非每个中间状态都发出。",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "S5v60qOjWuFN4G2fq28ZcucwSoznr4iTcZjhBRwTfhE=",
        "originContent": "# Alternate Current",
        "translatedContent": "# 交流电"
      },
      {
        "row": 2,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "nVid11heQWt0LorC0m1xgzyM9WegHpjJyL5xmzOYlsA=",
        "originContent": "Alternate Current is an efficient and non-locational redstone dust implementation. Its main focus lies in reducing the lag caused by redstone dust, by optimizing the power calculations and reducing the number of shape and block updates emitted. As a side effect of these changes the block update order of redstone dust networks is predictable and intuitive rather than locational and chaotic.",
        "translatedContent": "交流电是一种高效且非位置依赖的红石线实现。其主要目标在于通过优化功率计算和减少形状及方块更新的数量，降低由红石线引起的延迟。作为这些改进的副作用，红石线网络的方块更新顺序变得可预测且直观，而非位置依赖且混乱。"
      },
      {
        "row": 4,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 5,
        "rowsha": "thorZE5Q53vPYsmFcZnNBj3MzrLAVgB8k3DqGpMonCs=",
        "originContent": "## Performance",
        "translatedContent": "## 性能"
      },
      {
        "row": 6,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 7,
        "rowsha": "jHQni3V/YJTX+Gu/WVqioo/GmwtJBAgTDN8gmr7Un+4=",
        "originContent": "MSPT contributions of redstone dust are up to 20 times lower with Alternate Current, all the while maintaining a high level of Vanilla parity. Its low number of code modifications make it minimally invasive, so it is an easy drop-in replacement for Vanilla redstone dust.",
        "translatedContent": "使用交流电后，红石线的MSPT贡献最多降低20倍，同时保持了与原版高程度的一致性。其较少的代码修改使其侵入性极小，因此是原版红石线的简单替代方案。"
      },
      {
        "row": 8,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 9,
        "rowsha": "yr57TqElHtwjXcJf3z7vIOjG+gIgOGwCk8iSckpPsXc=",
        "originContent": "## How does it work?",
        "translatedContent": "## 它是如何工作的？"
      },
      {
        "row": 10,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 11,
        "rowsha": "v3MMKuPTv0HVKhZXoNemFYBvC7Ub+0EeI7GC9goN/NA=",
        "originContent": "The algorithm Alternate Current uses was designed with the following goals in mind:",
        "translatedContent": "交流电所采用的算法设计时考虑了以下目标："
      },
      {
        "row": 12,
        "rowsha": "OsRYx7ezlL7xcUMx/g8pH/qRMBry6WDFIOv7gmIGIXM=",
        "originContent": "1. Minimize the number of times a wire checks its surroundings to determine its power level.",
        "translatedContent": "1. 最小化红石线检查周围环境以确定其功率等级的次数。"
      },
      {
        "row": 13,
        "rowsha": "Xv7znXAgN+Mm2ILiGNZGyW4E2grTzeGnJbPJ0Ittmcs=",
        "originContent": "2. Minimize the number of block and shape updates emitted.",
        "translatedContent": "2. 最小化发出的方块和形状更新数量。"
      },
      {
        "row": 14,
        "rowsha": "p4RPGC+h4Hy1RY+PPe9qog6iNw9mfYqIspzdN3dAig0=",
        "originContent": "3. Emit block and shape updates in a deterministic, non-locational order, fixing bug MC-11193.",
        "translatedContent": "3. 以确定性、非位置依赖的顺序发出方块和形状更新，修复了MC-11193错误。"
      },
      {
        "row": 15,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 16,
        "rowsha": "vOW0mgMViS3Vx0fdYr6+/TLYsR2I38gYmiwNBnmVGL8=",
        "originContent": "In Vanilla redstone wire is laggy because it fails on points 1 and 2.",
        "translatedContent": "在原版中，红石线因未满足第1和第2点而导致延迟。"
      },
      {
        "row": 17,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 18,
        "rowsha": "TE9N2PZNR7YhZ7jvTt7s6Ek1zIXy8gST0DrrgW2bcDE=",
        "originContent": "Redstone wire updates recursively and each wire calculates its power level in isolation rather than in the context of the network it is a part of. This means a wire in a grid can change its power level over half a dozen times before settling on its final value. This problem used to be worse in 1.13 and below, where a wire would only decrease its power level by 1 at a time.",
        "translatedContent": "红石线以递归方式更新，每根线独立计算其功率等级，而不是在其所在网络的上下文中计算。这意味着网格中的一根线在确定最终值之前，功率等级可能变化超过半打次数。这个问题在1.13及以下版本更为严重，那时一根线每次只能减少1点功率。"
      },
      {
        "row": 19,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 20,
        "rowsha": "8KJApfPTecgO9plKFQ9ipTT2AEqVhO2ans8CZO738Ls=",
        "originContent": "In addition to this, a wire emits 42 block updates and up to 22 shape updates each time it changes its power level.",
        "translatedContent": "此外，每当功率等级变化时，一根线会发出42个方块更新和最多22个形状更新。"
      },
      {
        "row": 21,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 22,
        "rowsha": "V6C9nZSrMCkYtgQw/+1999dPrfq48fMhZ1rELgr9qhU=",
        "originContent": "Of those 42 block updates, 6 are to itself, which are thus not only redundant, but a big source of lag, since those cause the wire to unnecessarily re-calculate its power level. A block only has 24 neighbors within a Manhattan distance of 2, meaning 12 of the remaining 36 block updates are duplicates and thus also redundant.",
        "translatedContent": "在这42个方块更新中，有6个是针对线自身的，这不仅冗余，而且是延迟的重要来源，因为它们导致线不必要地重新计算功率等级。一个方块在曼哈顿距离2内只有24个邻居，因此剩余36个方块更新中有12个是重复的，也属于冗余。"
      },
      {
        "row": 23,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 24,
        "rowsha": "zGDiLcAdYUzmXtkQVvxk1qAKw4OyH0PmEpHyFpADplA=",
        "originContent": "Of the 22 shape updates, only 6 are strictly necessary. The other 16 are sent to blocks diagonally above and below. These are necessary if a wire changes its connections, but not when it changes its power level.",
        "translatedContent": "在22个形状更新中，只有6个是严格必要的。其余16个发送给对角线上下的方块。这些更新在红石线改变连接时是必要的，但在其仅改变功率等级时则不需要。"
      },
      {
        "row": 25,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 26,
        "rowsha": "312LqvfzU1KI8n6UtVxdGOmU5BgFvIPlM0AEUw8Ye2w=",
        "originContent": "Redstone wire in Vanilla also fails on point 3, though this is more of a quality-of-life issue than a lag issue. The recursive nature in which it updates, combined with the location-dependent order in which each wire updates its neighbors, makes the order in which neighbors of a wire network are updated incredibly inconsistent and seemingly random.",
        "translatedContent": "原版红石线也未满足第3点，尽管这更多是用户体验问题而非延迟问题。其递归更新方式，加上每根线按位置依赖顺序更新邻居，使得线网络邻居的更新顺序极其不一致且看似随机。"
      },
      {
        "row": 27,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 28,
        "rowsha": "f+FUDmwkJmZpmJRUHYDKRMskAZox4NzLjTWIZ6bS+yU=",
        "originContent": "Alternate Current fixes each of these problems as follows.",
        "translatedContent": "交流电针对这些问题做出了如下改进。"
      },
      {
        "row": 29,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 30,
        "rowsha": "/QrZAm7uWWtwcqdilB9gvvV+dgojDt1FCzpjSCVoXCo=",
        "originContent": "(1)",
        "translatedContent": "(1)"
      },
      {
        "row": 31,
        "rowsha": "dq/nqrCEoqlzeBUmP2JJkw2uaGPxmjWv/NbJzdppVVg=",
        "originContent": "To make sure a wire calculates its power level as little as possible, we remove the recursive nature in which redstone wire updates in Vanilla. Instead, we build a network of connected wires, find those wires that receive redstone power from \"outside\" the network, and spread the power from there. This has a few advantages:",
        "translatedContent": "为了确保线尽可能少地计算功率等级，我们去除了原版中红石线的递归更新方式。取而代之的是，我们构建一个连接线的网络，找到从“外部”接收红石电力的线，然后从那里传播电力。这有几个优点："
      },
      {
        "row": 32,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 33,
        "rowsha": "QclqCpgw/2SnQgARJPBVTcoY5CbxQAyF8FzqvvSkQGk=",
        "originContent": "- Each wire checks for power from non-wire components at most once, and from nearby wires just twice.",
        "translatedContent": "- 每根线最多检查一次来自非线组件的电力，来自附近线的电力检查仅两次。"
      },
      {
        "row": 34,
        "rowsha": "ZWC5FspNz9R5m62velLY2d4sNkbHwiJjddA6jWqdf6k=",
        "originContent": "- Each wire only sets its power level in the world once. This is important, because calls to Level.setBlock are even more expensive than calls to Level.getBlockState.",
        "translatedContent": "- 每根线只在世界中设置一次功率等级。这一点很重要，因为调用Level.setBlock比调用Level.getBlockState更消耗性能。"
      },
      {
        "row": 35,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 36,
        "rowsha": "Dnfmi6VHPZiEDDIS9KjLgBImSU8RYsgAGp9O17AMuqg=",
        "originContent": "(2)",
        "translatedContent": "(2)"
      },
      {
        "row": 37,
        "rowsha": "S7WymyG/xgySCxHE/mA5tgqP4ahbm101cvCAW1waYpk=",
        "originContent": "There are 2 obvious ways in which we can reduce the number of block and shape updates.",
        "translatedContent": "我们可以通过两种明显方法减少方块和形状更新数量。"
      },
      {
        "row": 38,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 39,
        "rowsha": "6pIMYkaLneNDNPGntO3GFqk+6hKsIayUPV2M1sfluSI=",
        "originContent": "- Get rid of the 18 redundant block updates and 16 redundant shape updates, so each wire only emits 24 block updates and 6 shape updates whenever it changes its power level.",
        "translatedContent": "- 去除18个冗余方块更新和16个冗余形状更新，使每根线在功率等级变化时只发出24个方块更新和6个形状更新。"
      },
      {
        "row": 40,
        "rowsha": "YFtipfPqvRJfOXys9ICbAz4KmzamXvjbXve67HqLbjI=",
        "originContent": "- Only emit block updates and shape updates once a wire reaches its final power level, rather than at each intermediary stage.",
        "translatedContent": "- 仅在线达到最终功率等级时发出方块和形状更新，而非每个中间状态都发出。"
      }
    ],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "\nFor an individual wire, these two optimizations are the best you can do, but for an entire grid, you can do better!\n\nSince we calculate the power of the entire network, sending block and shape updates to the wires in it is redundant. Removing those updates can reduce the number of block and shape updates by up to 20%.\n\n(3)\nTo make the order of block updates to neighbors of a network deterministic, the first thing we must do is to replace the location- dependent order in which a wire updates its neighbors. Instead, we base it on the direction of power flow. This part of the algorithm was heavily inspired by theosib's 'RedstoneWireTurbo', which you can read more about in theosib's comment on Mojira [here](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777) or by checking out its implementation in carpet mod [here](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java).\n\nThe idea is to determine the direction of power flow through a wire based on the power it receives from neighboring wires. For example, if the only power a wire receives is from a neighboring wire to its west, it can be said that the direction of power flow through the wire is east.\n\nWe make the order of block updates to neighbors of a wire depend on what is determined to be the direction of power flow. This not only removes locationality entirely, it even removes directionality in a large number of cases. Unlike in 'RedstoneWireTurbo', however, I have decided to keep a directional element in ambiguous cases, rather than to introduce randomness, though this is trivial to change.\n\nWhile this change fixes the block update order of individual wires, we must still address the overall block update order of a network. This turns out to be a simple fix, because of a change we made earlier: we search through the network for wires that receive power from outside it, and spread the power from there. If we make each wire transmit its power to neighboring wires in an order dependent on the direction of power flow, we end up with a non-locational and largely non-directional wire update order.\n",
    "ContentSha": "tYEeDKb2mWRVtHdg/T/JyblT8/BcI2LcUmJma/nhKDI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "对于单根导线来说，这两种优化已经是最佳选择，但对于整个电网来说，你可以做得更好！\n\n由于我们计算的是整个网络的功率，向其中的导线发送方块和形状更新是多余的。移除这些更新可以减少最多20%的方块和形状更新。\n\n(3)\n为了使网络邻居的方块更新顺序具有确定性，我们首先必须替换导线更新其邻居时依赖位置的顺序。取而代之的是，我们基于电力流动的方向。该算法部分灵感来源于 theosib 的“RedstoneWireTurbo”，你可以在 Mojira 的 theosib 评论中查看更多信息[这里](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777)，或者查看其在 carpet mod 中的实现[这里](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java)。\n\n这个想法是根据导线从相邻导线接收到的电力确定电力流动的方向。例如，如果导线接收到的唯一电力来自其西侧的相邻导线，则可以说电力通过该导线的方向是向东。\n\n我们使导线对邻居的方块更新顺序依赖于确定的电力流动方向。这不仅完全消除了位置依赖性，甚至在许多情况下还消除了方向性。然而，与“RedstoneWireTurbo”不同，我决定在模糊情况下保留方向元素，而不是引入随机性，尽管这很容易更改。\n\n虽然此更改修正了单根导线的方块更新顺序，但我们仍需解决整个网络的方块更新顺序。事实证明这是一个简单的修复，因为我们之前做了一个更改：我们在网络中搜索从外部接收电力的导线，并从那里传播电力。如果我们让每根导线按照电力流动方向依赖的顺序将电力传递给相邻导线，我们最终会得到一个非位置依赖且在很大程度上非方向性的导线更新顺序。\n\n",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "对于单根导线来说，这两种优化已经是最佳选择，但对于整个电网来说，你可以做得更好！"
      },
      {
        "row": 2,
        "rowsha": "3UlRkk41Y6iAeNLsnhK2YFC7vfw9BcF18CzjbMKM3Us=",
        "originContent": "For an individual wire, these two optimizations are the best you can do, but for an entire grid, you can do better!",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "由于我们计算的是整个网络的功率，向其中的导线发送方块和形状更新是多余的。移除这些更新可以减少最多20%的方块和形状更新。"
      },
      {
        "row": 4,
        "rowsha": "Y9t50H//pABe7I7Hwtu+ywXr6ibre8GoQCabGWpOPNk=",
        "originContent": "Since we calculate the power of the entire network, sending block and shape updates to the wires in it is redundant. Removing those updates can reduce the number of block and shape updates by up to 20%.",
        "translatedContent": ""
      },
      {
        "row": 5,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "(3)"
      },
      {
        "row": 6,
        "rowsha": "RveJ0e/u+tCAhGkXpqSnYdDhgEuwpPJ/pGNKiH7CYmU=",
        "originContent": "(3)",
        "translatedContent": "为了使网络邻居的方块更新顺序具有确定性，我们首先必须替换导线更新其邻居时依赖位置的顺序。取而代之的是，我们基于电力流动的方向。该算法部分灵感来源于 theosib 的“RedstoneWireTurbo”，你可以在 Mojira 的 theosib 评论中查看更多信息[这里](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777)，或者查看其在 carpet mod 中的实现[这里](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java)。"
      },
      {
        "row": 7,
        "rowsha": "IVIvp4jDaRM8bw+xrWW7WlmkfA6WbV96u0wF5gHLesg=",
        "originContent": "To make the order of block updates to neighbors of a network deterministic, the first thing we must do is to replace the location- dependent order in which a wire updates its neighbors. Instead, we base it on the direction of power flow. This part of the algorithm was heavily inspired by theosib's 'RedstoneWireTurbo', which you can read more about in theosib's comment on Mojira [here](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777) or by checking out its implementation in carpet mod [here](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java).",
        "translatedContent": ""
      },
      {
        "row": 8,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "这个想法是根据导线从相邻导线接收到的电力确定电力流动的方向。例如，如果导线接收到的唯一电力来自其西侧的相邻导线，则可以说电力通过该导线的方向是向东。"
      },
      {
        "row": 9,
        "rowsha": "F7Jhig5j9BWwDRZDIy8B1KPEgc0E4ae/rJ0KthB6FWE=",
        "originContent": "The idea is to determine the direction of power flow through a wire based on the power it receives from neighboring wires. For example, if the only power a wire receives is from a neighboring wire to its west, it can be said that the direction of power flow through the wire is east.",
        "translatedContent": ""
      },
      {
        "row": 10,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "我们使导线对邻居的方块更新顺序依赖于确定的电力流动方向。这不仅完全消除了位置依赖性，甚至在许多情况下还消除了方向性。然而，与“RedstoneWireTurbo”不同，我决定在模糊情况下保留方向元素，而不是引入随机性，尽管这很容易更改。"
      },
      {
        "row": 11,
        "rowsha": "JRXbA2L65493xA07tBEkMQLNl2ScLj6AZYyDqCBd+PM=",
        "originContent": "We make the order of block updates to neighbors of a wire depend on what is determined to be the direction of power flow. This not only removes locationality entirely, it even removes directionality in a large number of cases. Unlike in 'RedstoneWireTurbo', however, I have decided to keep a directional element in ambiguous cases, rather than to introduce randomness, though this is trivial to change.",
        "translatedContent": ""
      },
      {
        "row": 12,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "虽然此更改修正了单根导线的方块更新顺序，但我们仍需解决整个网络的方块更新顺序。事实证明这是一个简单的修复，因为我们之前做了一个更改：我们在网络中搜索从外部接收电力的导线，并从那里传播电力。如果我们让每根导线按照电力流动方向依赖的顺序将电力传递给相邻导线，我们最终会得到一个非位置依赖且在很大程度上非方向性的导线更新顺序。"
      },
      {
        "row": 13,
        "rowsha": "YEg729gXcHmwNHkIARSjGF4q/eWP1X+6KdNzN2e/iF8=",
        "originContent": "While this change fixes the block update order of individual wires, we must still address the overall block update order of a network. This turns out to be a simple fix, because of a change we made earlier: we search through the network for wires that receive power from outside it, and spread the power from there. If we make each wire transmit its power to neighboring wires in an order dependent on the direction of power flow, we end up with a non-locational and largely non-directional wire update order.",
        "translatedContent": ""
      },
      {
        "row": 14,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      }
    ],
    "IsCodeBlock": false
  }
]