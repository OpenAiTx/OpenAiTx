[
  {
    "Id": 1,
    "Content": "# Alternate Current\n\nAlternate Current is an efficient and non-locational redstone dust implementation. Its main focus lies in reducing the lag caused by redstone dust, by optimizing the power calculations and reducing the number of shape and block updates emitted. As a side effect of these changes the block update order of redstone dust networks is predictable and intuitive rather than locational and chaotic.\n\n## Performance\n\nMSPT contributions of redstone dust are up to 20 times lower with Alternate Current, all the while maintaining a high level of Vanilla parity. Its low number of code modifications make it minimally invasive, so it is an easy drop-in replacement for Vanilla redstone dust.\n\n## How does it work?\n\nThe algorithm Alternate Current uses was designed with the following goals in mind:\n1. Minimize the number of times a wire checks its surroundings to determine its power level.\n2. Minimize the number of block and shape updates emitted.\n3. Emit block and shape updates in a deterministic, non-locational order, fixing bug MC-11193.\n\nIn Vanilla redstone wire is laggy because it fails on points 1 and 2.\n\nRedstone wire updates recursively and each wire calculates its power level in isolation rather than in the context of the network it is a part of. This means a wire in a grid can change its power level over half a dozen times before settling on its final value. This problem used to be worse in 1.13 and below, where a wire would only decrease its power level by 1 at a time.\n\nIn addition to this, a wire emits 42 block updates and up to 22 shape updates each time it changes its power level.\n\nOf those 42 block updates, 6 are to itself, which are thus not only redundant, but a big source of lag, since those cause the wire to unnecessarily re-calculate its power level. A block only has 24 neighbors within a Manhattan distance of 2, meaning 12 of the remaining 36 block updates are duplicates and thus also redundant.\n\nOf the 22 shape updates, only 6 are strictly necessary. The other 16 are sent to blocks diagonally above and below. These are necessary if a wire changes its connections, but not when it changes its power level.\n\nRedstone wire in Vanilla also fails on point 3, though this is more of a quality-of-life issue than a lag issue. The recursive nature in which it updates, combined with the location-dependent order in which each wire updates its neighbors, makes the order in which neighbors of a wire network are updated incredibly inconsistent and seemingly random.\n\nAlternate Current fixes each of these problems as follows.\n\n(1)\nTo make sure a wire calculates its power level as little as possible, we remove the recursive nature in which redstone wire updates in Vanilla. Instead, we build a network of connected wires, find those wires that receive redstone power from \"outside\" the network, and spread the power from there. This has a few advantages:\n\n- Each wire checks for power from non-wire components at most once, and from nearby wires just twice.\n- Each wire only sets its power level in the world once. This is important, because calls to Level.setBlock are even more expensive than calls to Level.getBlockState.\n\n(2)\nThere are 2 obvious ways in which we can reduce the number of block and shape updates.\n\n- Get rid of the 18 redundant block updates and 16 redundant shape updates, so each wire only emits 24 block updates and 6 shape updates whenever it changes its power level.\n- Only emit block updates and shape updates once a wire reaches its final power level, rather than at each intermediary stage.",
    "ContentSha": "VRjJi4HUXMa7FVUYH4S7auit7tSk45HDVQwws79zOdM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# Courant alternatif\n\nLe Courant alternatif est une implémentation efficace de la poussière de redstone non localisée. Son objectif principal est de réduire le lag causé par la poussière de redstone, en optimisant les calculs de puissance et en réduisant le nombre de mises à jour de forme et de bloc émises. Comme effet secondaire de ces changements, l'ordre des mises à jour de bloc des réseaux de poussière de redstone est prévisible et intuitif plutôt que localisé et chaotique.\n\n## Performance\n\nLes contributions MSPT de la poussière de redstone sont jusqu'à 20 fois plus faibles avec Courant alternatif, tout en maintenant un haut niveau de conformité Vanilla. Son faible nombre de modifications de code le rend peu invasif, ce qui en fait un remplacement facile à intégrer pour la poussière de redstone Vanilla.\n\n## Comment ça fonctionne ?\n\nL'algorithme utilisé par Courant alternatif a été conçu avec les objectifs suivants en tête :\n1. Minimiser le nombre de fois qu’un fil vérifie son environnement pour déterminer son niveau de puissance.\n2. Minimiser le nombre de mises à jour de bloc et de forme émises.\n3. Émettre les mises à jour de bloc et de forme dans un ordre déterministe, non localisé, corrigeant le bug MC-11193.\n\nDans Vanilla, le fil de redstone est lent car il échoue aux points 1 et 2.\n\nLe fil de redstone se met à jour de manière récursive et chaque fil calcule son niveau de puissance isolément plutôt que dans le contexte du réseau auquel il appartient. Cela signifie qu’un fil dans une grille peut changer son niveau de puissance plus d’une demi-douzaine de fois avant de se stabiliser à sa valeur finale. Ce problème était pire en 1.13 et versions antérieures, où un fil ne diminuait son niveau de puissance que d’1 à la fois.\n\nEn plus de cela, un fil émet 42 mises à jour de bloc et jusqu’à 22 mises à jour de forme à chaque fois qu’il change son niveau de puissance.\n\nParmi ces 42 mises à jour de bloc, 6 sont pour lui-même, ce qui est donc non seulement redondant, mais aussi une grande source de lag, car cela provoque un recalcul inutile de son niveau de puissance. Un bloc n’a que 24 voisins dans une distance de Manhattan de 2, ce qui signifie que 12 des 36 mises à jour de bloc restantes sont des doublons et donc également redondantes.\n\nSur les 22 mises à jour de forme, seules 6 sont strictement nécessaires. Les 16 autres sont envoyées aux blocs en diagonale au-dessus et en dessous. Celles-ci sont nécessaires si un fil change ses connexions, mais pas lorsqu’il change son niveau de puissance.\n\nLe fil de redstone dans Vanilla échoue aussi au point 3, bien que ce soit plus un problème de confort d’utilisation qu’un problème de lag. La nature récursive de ses mises à jour, combinée à l’ordre dépendant de la localisation dans lequel chaque fil met à jour ses voisins, rend l’ordre des mises à jour des voisins d’un réseau de fils incroyablement incohérent et apparemment aléatoire.\n\nCourant alternatif corrige chacun de ces problèmes de la manière suivante.\n\n(1)\nPour s’assurer qu’un fil calcule son niveau de puissance le moins possible, nous supprimons la nature récursive des mises à jour du fil de redstone dans Vanilla. À la place, nous construisons un réseau de fils connectés, trouvons ceux qui reçoivent de la puissance redstone de \"l’extérieur\" du réseau, et répartissons la puissance à partir de là. Cela présente quelques avantages :\n\n- Chaque fil vérifie la puissance provenant de composants non-fils au maximum une fois, et de fils proches seulement deux fois.\n- Chaque fil ne définit son niveau de puissance dans le monde qu’une seule fois. C’est important, car les appels à Level.setBlock sont encore plus coûteux que les appels à Level.getBlockState.\n\n(2)\nIl y a 2 moyens évidents pour réduire le nombre de mises à jour de bloc et de forme.\n\n- Éliminer les 18 mises à jour de bloc redondantes et les 16 mises à jour de forme redondantes, de sorte que chaque fil n’émette que 24 mises à jour de bloc et 6 mises à jour de forme chaque fois qu’il change de niveau de puissance.\n- N’émettre les mises à jour de bloc et de forme qu’une fois qu’un fil atteint son niveau de puissance final, plutôt qu’à chaque étape intermédiaire.",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "S5v60qOjWuFN4G2fq28ZcucwSoznr4iTcZjhBRwTfhE=",
        "originContent": "# Alternate Current",
        "translatedContent": "# Courant alternatif"
      },
      {
        "row": 2,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "nVid11heQWt0LorC0m1xgzyM9WegHpjJyL5xmzOYlsA=",
        "originContent": "Alternate Current is an efficient and non-locational redstone dust implementation. Its main focus lies in reducing the lag caused by redstone dust, by optimizing the power calculations and reducing the number of shape and block updates emitted. As a side effect of these changes the block update order of redstone dust networks is predictable and intuitive rather than locational and chaotic.",
        "translatedContent": "Le Courant alternatif est une implémentation efficace de la poussière de redstone non localisée. Son objectif principal est de réduire le lag causé par la poussière de redstone, en optimisant les calculs de puissance et en réduisant le nombre de mises à jour de forme et de bloc émises. Comme effet secondaire de ces changements, l'ordre des mises à jour de bloc des réseaux de poussière de redstone est prévisible et intuitif plutôt que localisé et chaotique."
      },
      {
        "row": 4,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 5,
        "rowsha": "thorZE5Q53vPYsmFcZnNBj3MzrLAVgB8k3DqGpMonCs=",
        "originContent": "## Performance",
        "translatedContent": "## Performance"
      },
      {
        "row": 6,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 7,
        "rowsha": "jHQni3V/YJTX+Gu/WVqioo/GmwtJBAgTDN8gmr7Un+4=",
        "originContent": "MSPT contributions of redstone dust are up to 20 times lower with Alternate Current, all the while maintaining a high level of Vanilla parity. Its low number of code modifications make it minimally invasive, so it is an easy drop-in replacement for Vanilla redstone dust.",
        "translatedContent": "Les contributions MSPT de la poussière de redstone sont jusqu'à 20 fois plus faibles avec Courant alternatif, tout en maintenant un haut niveau de conformité Vanilla. Son faible nombre de modifications de code le rend peu invasif, ce qui en fait un remplacement facile à intégrer pour la poussière de redstone Vanilla."
      },
      {
        "row": 8,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 9,
        "rowsha": "yr57TqElHtwjXcJf3z7vIOjG+gIgOGwCk8iSckpPsXc=",
        "originContent": "## How does it work?",
        "translatedContent": "## Comment ça fonctionne ?"
      },
      {
        "row": 10,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 11,
        "rowsha": "v3MMKuPTv0HVKhZXoNemFYBvC7Ub+0EeI7GC9goN/NA=",
        "originContent": "The algorithm Alternate Current uses was designed with the following goals in mind:",
        "translatedContent": "L'algorithme utilisé par Courant alternatif a été conçu avec les objectifs suivants en tête :"
      },
      {
        "row": 12,
        "rowsha": "OsRYx7ezlL7xcUMx/g8pH/qRMBry6WDFIOv7gmIGIXM=",
        "originContent": "1. Minimize the number of times a wire checks its surroundings to determine its power level.",
        "translatedContent": "1. Minimiser le nombre de fois qu’un fil vérifie son environnement pour déterminer son niveau de puissance."
      },
      {
        "row": 13,
        "rowsha": "Xv7znXAgN+Mm2ILiGNZGyW4E2grTzeGnJbPJ0Ittmcs=",
        "originContent": "2. Minimize the number of block and shape updates emitted.",
        "translatedContent": "2. Minimiser le nombre de mises à jour de bloc et de forme émises."
      },
      {
        "row": 14,
        "rowsha": "p4RPGC+h4Hy1RY+PPe9qog6iNw9mfYqIspzdN3dAig0=",
        "originContent": "3. Emit block and shape updates in a deterministic, non-locational order, fixing bug MC-11193.",
        "translatedContent": "3. Émettre les mises à jour de bloc et de forme dans un ordre déterministe, non localisé, corrigeant le bug MC-11193."
      },
      {
        "row": 15,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 16,
        "rowsha": "vOW0mgMViS3Vx0fdYr6+/TLYsR2I38gYmiwNBnmVGL8=",
        "originContent": "In Vanilla redstone wire is laggy because it fails on points 1 and 2.",
        "translatedContent": "Dans Vanilla, le fil de redstone est lent car il échoue aux points 1 et 2."
      },
      {
        "row": 17,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 18,
        "rowsha": "TE9N2PZNR7YhZ7jvTt7s6Ek1zIXy8gST0DrrgW2bcDE=",
        "originContent": "Redstone wire updates recursively and each wire calculates its power level in isolation rather than in the context of the network it is a part of. This means a wire in a grid can change its power level over half a dozen times before settling on its final value. This problem used to be worse in 1.13 and below, where a wire would only decrease its power level by 1 at a time.",
        "translatedContent": "Le fil de redstone se met à jour de manière récursive et chaque fil calcule son niveau de puissance isolément plutôt que dans le contexte du réseau auquel il appartient. Cela signifie qu’un fil dans une grille peut changer son niveau de puissance plus d’une demi-douzaine de fois avant de se stabiliser à sa valeur finale. Ce problème était pire en 1.13 et versions antérieures, où un fil ne diminuait son niveau de puissance que d’1 à la fois."
      },
      {
        "row": 19,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 20,
        "rowsha": "8KJApfPTecgO9plKFQ9ipTT2AEqVhO2ans8CZO738Ls=",
        "originContent": "In addition to this, a wire emits 42 block updates and up to 22 shape updates each time it changes its power level.",
        "translatedContent": "En plus de cela, un fil émet 42 mises à jour de bloc et jusqu’à 22 mises à jour de forme à chaque fois qu’il change son niveau de puissance."
      },
      {
        "row": 21,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 22,
        "rowsha": "V6C9nZSrMCkYtgQw/+1999dPrfq48fMhZ1rELgr9qhU=",
        "originContent": "Of those 42 block updates, 6 are to itself, which are thus not only redundant, but a big source of lag, since those cause the wire to unnecessarily re-calculate its power level. A block only has 24 neighbors within a Manhattan distance of 2, meaning 12 of the remaining 36 block updates are duplicates and thus also redundant.",
        "translatedContent": "Parmi ces 42 mises à jour de bloc, 6 sont pour lui-même, ce qui est donc non seulement redondant, mais aussi une grande source de lag, car cela provoque un recalcul inutile de son niveau de puissance. Un bloc n’a que 24 voisins dans une distance de Manhattan de 2, ce qui signifie que 12 des 36 mises à jour de bloc restantes sont des doublons et donc également redondantes."
      },
      {
        "row": 23,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 24,
        "rowsha": "zGDiLcAdYUzmXtkQVvxk1qAKw4OyH0PmEpHyFpADplA=",
        "originContent": "Of the 22 shape updates, only 6 are strictly necessary. The other 16 are sent to blocks diagonally above and below. These are necessary if a wire changes its connections, but not when it changes its power level.",
        "translatedContent": "Sur les 22 mises à jour de forme, seules 6 sont strictement nécessaires. Les 16 autres sont envoyées aux blocs en diagonale au-dessus et en dessous. Celles-ci sont nécessaires si un fil change ses connexions, mais pas lorsqu’il change son niveau de puissance."
      },
      {
        "row": 25,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 26,
        "rowsha": "312LqvfzU1KI8n6UtVxdGOmU5BgFvIPlM0AEUw8Ye2w=",
        "originContent": "Redstone wire in Vanilla also fails on point 3, though this is more of a quality-of-life issue than a lag issue. The recursive nature in which it updates, combined with the location-dependent order in which each wire updates its neighbors, makes the order in which neighbors of a wire network are updated incredibly inconsistent and seemingly random.",
        "translatedContent": "Le fil de redstone dans Vanilla échoue aussi au point 3, bien que ce soit plus un problème de confort d’utilisation qu’un problème de lag. La nature récursive de ses mises à jour, combinée à l’ordre dépendant de la localisation dans lequel chaque fil met à jour ses voisins, rend l’ordre des mises à jour des voisins d’un réseau de fils incroyablement incohérent et apparemment aléatoire."
      },
      {
        "row": 27,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 28,
        "rowsha": "f+FUDmwkJmZpmJRUHYDKRMskAZox4NzLjTWIZ6bS+yU=",
        "originContent": "Alternate Current fixes each of these problems as follows.",
        "translatedContent": "Courant alternatif corrige chacun de ces problèmes de la manière suivante."
      },
      {
        "row": 29,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 30,
        "rowsha": "/QrZAm7uWWtwcqdilB9gvvV+dgojDt1FCzpjSCVoXCo=",
        "originContent": "(1)",
        "translatedContent": "(1)"
      },
      {
        "row": 31,
        "rowsha": "dq/nqrCEoqlzeBUmP2JJkw2uaGPxmjWv/NbJzdppVVg=",
        "originContent": "To make sure a wire calculates its power level as little as possible, we remove the recursive nature in which redstone wire updates in Vanilla. Instead, we build a network of connected wires, find those wires that receive redstone power from \"outside\" the network, and spread the power from there. This has a few advantages:",
        "translatedContent": "Pour s’assurer qu’un fil calcule son niveau de puissance le moins possible, nous supprimons la nature récursive des mises à jour du fil de redstone dans Vanilla. À la place, nous construisons un réseau de fils connectés, trouvons ceux qui reçoivent de la puissance redstone de \"l’extérieur\" du réseau, et répartissons la puissance à partir de là. Cela présente quelques avantages :"
      },
      {
        "row": 32,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 33,
        "rowsha": "QclqCpgw/2SnQgARJPBVTcoY5CbxQAyF8FzqvvSkQGk=",
        "originContent": "- Each wire checks for power from non-wire components at most once, and from nearby wires just twice.",
        "translatedContent": "- Chaque fil vérifie la puissance provenant de composants non-fils au maximum une fois, et de fils proches seulement deux fois."
      },
      {
        "row": 34,
        "rowsha": "ZWC5FspNz9R5m62velLY2d4sNkbHwiJjddA6jWqdf6k=",
        "originContent": "- Each wire only sets its power level in the world once. This is important, because calls to Level.setBlock are even more expensive than calls to Level.getBlockState.",
        "translatedContent": "- Chaque fil ne définit son niveau de puissance dans le monde qu’une seule fois. C’est important, car les appels à Level.setBlock sont encore plus coûteux que les appels à Level.getBlockState."
      },
      {
        "row": 35,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 36,
        "rowsha": "Dnfmi6VHPZiEDDIS9KjLgBImSU8RYsgAGp9O17AMuqg=",
        "originContent": "(2)",
        "translatedContent": "(2)"
      },
      {
        "row": 37,
        "rowsha": "S7WymyG/xgySCxHE/mA5tgqP4ahbm101cvCAW1waYpk=",
        "originContent": "There are 2 obvious ways in which we can reduce the number of block and shape updates.",
        "translatedContent": "Il y a 2 moyens évidents pour réduire le nombre de mises à jour de bloc et de forme."
      },
      {
        "row": 38,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 39,
        "rowsha": "6pIMYkaLneNDNPGntO3GFqk+6hKsIayUPV2M1sfluSI=",
        "originContent": "- Get rid of the 18 redundant block updates and 16 redundant shape updates, so each wire only emits 24 block updates and 6 shape updates whenever it changes its power level.",
        "translatedContent": "- Éliminer les 18 mises à jour de bloc redondantes et les 16 mises à jour de forme redondantes, de sorte que chaque fil n’émette que 24 mises à jour de bloc et 6 mises à jour de forme chaque fois qu’il change de niveau de puissance."
      },
      {
        "row": 40,
        "rowsha": "YFtipfPqvRJfOXys9ICbAz4KmzamXvjbXve67HqLbjI=",
        "originContent": "- Only emit block updates and shape updates once a wire reaches its final power level, rather than at each intermediary stage.",
        "translatedContent": "- N’émettre les mises à jour de bloc et de forme qu’une fois qu’un fil atteint son niveau de puissance final, plutôt qu’à chaque étape intermédiaire."
      }
    ],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "\nFor an individual wire, these two optimizations are the best you can do, but for an entire grid, you can do better!\n\nSince we calculate the power of the entire network, sending block and shape updates to the wires in it is redundant. Removing those updates can reduce the number of block and shape updates by up to 20%.\n\n(3)\nTo make the order of block updates to neighbors of a network deterministic, the first thing we must do is to replace the location- dependent order in which a wire updates its neighbors. Instead, we base it on the direction of power flow. This part of the algorithm was heavily inspired by theosib's 'RedstoneWireTurbo', which you can read more about in theosib's comment on Mojira [here](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777) or by checking out its implementation in carpet mod [here](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java).\n\nThe idea is to determine the direction of power flow through a wire based on the power it receives from neighboring wires. For example, if the only power a wire receives is from a neighboring wire to its west, it can be said that the direction of power flow through the wire is east.\n\nWe make the order of block updates to neighbors of a wire depend on what is determined to be the direction of power flow. This not only removes locationality entirely, it even removes directionality in a large number of cases. Unlike in 'RedstoneWireTurbo', however, I have decided to keep a directional element in ambiguous cases, rather than to introduce randomness, though this is trivial to change.\n\nWhile this change fixes the block update order of individual wires, we must still address the overall block update order of a network. This turns out to be a simple fix, because of a change we made earlier: we search through the network for wires that receive power from outside it, and spread the power from there. If we make each wire transmit its power to neighboring wires in an order dependent on the direction of power flow, we end up with a non-locational and largely non-directional wire update order.\n",
    "ContentSha": "tYEeDKb2mWRVtHdg/T/JyblT8/BcI2LcUmJma/nhKDI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "Pour un fil individuel, ces deux optimisations sont les meilleures que vous puissiez faire, mais pour une grille entière, vous pouvez faire mieux !\n\nPuisque nous calculons la puissance de tout le réseau, envoyer des mises à jour de blocs et de formes aux fils qu’il contient est redondant. Supprimer ces mises à jour peut réduire le nombre de mises à jour de blocs et de formes jusqu’à 20 %.\n\n(3)\nPour rendre l’ordre des mises à jour des blocs aux voisins d’un réseau déterministe, la première chose à faire est de remplacer l’ordre dépendant de la localisation dans lequel un fil met à jour ses voisins. À la place, nous le basons sur la direction du flux de puissance. Cette partie de l’algorithme a été fortement inspirée par le ‘RedstoneWireTurbo’ de theosib, dont vous pouvez en apprendre plus dans le commentaire de theosib sur Mojira [ici](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777) ou en consultant son implémentation dans le mod carpet [ici](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java).\n\nL’idée est de déterminer la direction du flux de puissance à travers un fil en fonction de la puissance qu’il reçoit des fils voisins. Par exemple, si la seule puissance reçue par un fil provient d’un fil voisin à l’ouest, on peut dire que la direction du flux de puissance à travers le fil est vers l’est.\n\nNous faisons en sorte que l’ordre des mises à jour des blocs aux voisins d’un fil dépende de ce qui est déterminé comme la direction du flux de puissance. Cela supprime non seulement complètement la localisation, mais enlève même la directionnalité dans un grand nombre de cas. Contrairement à ‘RedstoneWireTurbo’, cependant, j’ai décidé de garder un élément directionnel dans les cas ambigus, plutôt que d’introduire de l’aléa, bien que cela soit trivial à changer.\n\nBien que ce changement corrige l’ordre des mises à jour des blocs des fils individuels, nous devons encore traiter l’ordre global des mises à jour des blocs d’un réseau. Cela s’avère être une correction simple, grâce à un changement que nous avons fait plus tôt : nous recherchons dans le réseau les fils qui reçoivent de la puissance de l’extérieur, et diffusons la puissance à partir de là. Si nous faisons en sorte que chaque fil transmette sa puissance aux fils voisins dans un ordre dépendant de la direction du flux de puissance, nous obtenons un ordre de mise à jour des fils non localisé et en grande partie non directionnel.\n\n",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "Pour un fil individuel, ces deux optimisations sont les meilleures que vous puissiez faire, mais pour une grille entière, vous pouvez faire mieux !"
      },
      {
        "row": 2,
        "rowsha": "3UlRkk41Y6iAeNLsnhK2YFC7vfw9BcF18CzjbMKM3Us=",
        "originContent": "For an individual wire, these two optimizations are the best you can do, but for an entire grid, you can do better!",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "Puisque nous calculons la puissance de tout le réseau, envoyer des mises à jour de blocs et de formes aux fils qu’il contient est redondant. Supprimer ces mises à jour peut réduire le nombre de mises à jour de blocs et de formes jusqu’à 20 %."
      },
      {
        "row": 4,
        "rowsha": "Y9t50H//pABe7I7Hwtu+ywXr6ibre8GoQCabGWpOPNk=",
        "originContent": "Since we calculate the power of the entire network, sending block and shape updates to the wires in it is redundant. Removing those updates can reduce the number of block and shape updates by up to 20%.",
        "translatedContent": ""
      },
      {
        "row": 5,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "(3)"
      },
      {
        "row": 6,
        "rowsha": "RveJ0e/u+tCAhGkXpqSnYdDhgEuwpPJ/pGNKiH7CYmU=",
        "originContent": "(3)",
        "translatedContent": "Pour rendre l’ordre des mises à jour des blocs aux voisins d’un réseau déterministe, la première chose à faire est de remplacer l’ordre dépendant de la localisation dans lequel un fil met à jour ses voisins. À la place, nous le basons sur la direction du flux de puissance. Cette partie de l’algorithme a été fortement inspirée par le ‘RedstoneWireTurbo’ de theosib, dont vous pouvez en apprendre plus dans le commentaire de theosib sur Mojira [ici](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777) ou en consultant son implémentation dans le mod carpet [ici](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java)."
      },
      {
        "row": 7,
        "rowsha": "IVIvp4jDaRM8bw+xrWW7WlmkfA6WbV96u0wF5gHLesg=",
        "originContent": "To make the order of block updates to neighbors of a network deterministic, the first thing we must do is to replace the location- dependent order in which a wire updates its neighbors. Instead, we base it on the direction of power flow. This part of the algorithm was heavily inspired by theosib's 'RedstoneWireTurbo', which you can read more about in theosib's comment on Mojira [here](https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777) or by checking out its implementation in carpet mod [here](https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java).",
        "translatedContent": ""
      },
      {
        "row": 8,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "L’idée est de déterminer la direction du flux de puissance à travers un fil en fonction de la puissance qu’il reçoit des fils voisins. Par exemple, si la seule puissance reçue par un fil provient d’un fil voisin à l’ouest, on peut dire que la direction du flux de puissance à travers le fil est vers l’est."
      },
      {
        "row": 9,
        "rowsha": "F7Jhig5j9BWwDRZDIy8B1KPEgc0E4ae/rJ0KthB6FWE=",
        "originContent": "The idea is to determine the direction of power flow through a wire based on the power it receives from neighboring wires. For example, if the only power a wire receives is from a neighboring wire to its west, it can be said that the direction of power flow through the wire is east.",
        "translatedContent": ""
      },
      {
        "row": 10,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "Nous faisons en sorte que l’ordre des mises à jour des blocs aux voisins d’un fil dépende de ce qui est déterminé comme la direction du flux de puissance. Cela supprime non seulement complètement la localisation, mais enlève même la directionnalité dans un grand nombre de cas. Contrairement à ‘RedstoneWireTurbo’, cependant, j’ai décidé de garder un élément directionnel dans les cas ambigus, plutôt que d’introduire de l’aléa, bien que cela soit trivial à changer."
      },
      {
        "row": 11,
        "rowsha": "JRXbA2L65493xA07tBEkMQLNl2ScLj6AZYyDqCBd+PM=",
        "originContent": "We make the order of block updates to neighbors of a wire depend on what is determined to be the direction of power flow. This not only removes locationality entirely, it even removes directionality in a large number of cases. Unlike in 'RedstoneWireTurbo', however, I have decided to keep a directional element in ambiguous cases, rather than to introduce randomness, though this is trivial to change.",
        "translatedContent": ""
      },
      {
        "row": 12,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "Bien que ce changement corrige l’ordre des mises à jour des blocs des fils individuels, nous devons encore traiter l’ordre global des mises à jour des blocs d’un réseau. Cela s’avère être une correction simple, grâce à un changement que nous avons fait plus tôt : nous recherchons dans le réseau les fils qui reçoivent de la puissance de l’extérieur, et diffusons la puissance à partir de là. Si nous faisons en sorte que chaque fil transmette sa puissance aux fils voisins dans un ordre dépendant de la direction du flux de puissance, nous obtenons un ordre de mise à jour des fils non localisé et en grande partie non directionnel."
      },
      {
        "row": 13,
        "rowsha": "YEg729gXcHmwNHkIARSjGF4q/eWP1X+6KdNzN2e/iF8=",
        "originContent": "While this change fixes the block update order of individual wires, we must still address the overall block update order of a network. This turns out to be a simple fix, because of a change we made earlier: we search through the network for wires that receive power from outside it, and spread the power from there. If we make each wire transmit its power to neighboring wires in an order dependent on the direction of power flow, we end up with a non-locational and largely non-directional wire update order.",
        "translatedContent": ""
      },
      {
        "row": 14,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      }
    ],
    "IsCodeBlock": false
  }
]