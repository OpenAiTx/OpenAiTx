{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nSie können mein [Paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) lesen und wie folgt zitieren: \n> WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zürich. https://doi.org/10.5281/zenodo.15384882\n\nDa GitHub möglicherweise chinesische IP-Adressen blockiert, musste ich dieses Repository [hierhin](https://codeberg.org/ufo5260987423/scheme-langserver) und [hierhin](https://gitee.com/ufo5260987423/scheme-langserver) kopieren. Ich werde alle Repositories weiterhin aktualisieren, aber ich kann es nicht garantieren. Ich arbeite jetzt auch mit [XmacsLabs](https://github.com/XmacsLabs) zusammen, Sie können auch einen Fork [hier](https://github.com/XmacsLabs/scheme-langserver) finden.\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Jetzt kann VSCode scheme-langserver verwenden!** Bitte beachten Sie [HIER](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>HINWEIS: Es gibt viele, viele Bugs im scheme-langserver. Ich bin dabei, sie zu beheben und bitte die Community um Hilfe. Bitte haben Sie Geduld.\n\n>HINWEIS: Die automatisch generierten Typinformationen finden Sie [hier](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Sie werden derzeit hauptsächlich für die Weiterentwicklung (vielleicht inkl. AKKU) und zum Debuggen verwendet.\n\nDas Implementieren von Funktionen wie Autovervollständigung, Gehe-zu-Definition oder Dokumentation beim Hover ist ein erheblicher Aufwand beim Programmieren. Im Vergleich zu anderen Sprachen wie Java, Python, JavaScript und C werden Implementierungen des Language Server Protocols für Lisp-Sprachen jedoch quasi im Vakuum entwickelt. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) und [swish-lint](https://github.com/becls/swish-lint) basieren alle auf `repl` (Read-Eval-Print Loop) oder einem Keyword-Tokenizer statt echter Programmierung. Zum Beispiel: Wenn ein Programmierer an einem noch unfertigen Projekt arbeitet, in dem der Code nicht vollständig lauffähig ist, würden [Geiser](https://gitlab.com/emacs-geiser) oder andere nur Top-Level-Bindungsbezeichner auflisten, die durch die Prozedur `environment-symbols` (für [Chez](https://cisco.github.io/ChezScheme/)) bereitgestellt werden, oder sie vervollständigen Symbole anstelle von Bezeichnern. Das heißt, für lokale Bindungen und unfertige Codes, obwohl die Unterstützung beim Programmieren eigentlich am wichtigsten wäre, helfen [Geiser](https://gitlab.com/emacs-geiser) und ähnliche Tools nicht bei der Erkennung des gültigen Gültigkeitsbereichs eines Bezeichners. Ähnliche Probleme treten bei Gehe-zu-Definition und vielen anderen Funktionen auf.\n\nEin Hauptgrund ist, dass für Scheme und andere Lisp-Dialekte die umfangreichen Datensätze und flexiblen Kontrollstrukturen die Programmanalyse zu einer großen Herausforderung machen. Insbesondere das Makro: Es scheint, als wäre Scheme hauptsächlich für Genies und Meta-/Makroprogrammierung gedacht. Aber ich sage nein. Scheme kann viele interessante Dinge ermöglichen, wenn eine bessere Programmierumgebung bereitgestellt wird. Und jetzt können Sie [**HIER STARTEN**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nDieses Paket ist eine Implementierung des Language Server Protocol, die das Programmieren mit Scheme unterstützt. Es bietet Vervollständigung, Definition und Typinferenz. Diese Funktionen basieren auf statischer Codeanalyse mit dem [r6rs Standard](http://www.r6rs.org/) und einigen offensichtlichen Regeln für unfertige Codes. Dieses Paket selbst und zugehörige Bibliotheken sind veröffentlicht oder werden veröffentlicht mit [Akku](https://akkuscm.org/), einem Paketmanager für Scheme. \n\nDieses Paket wurde auch mit [Chez Scheme](https://cisco.github.io/ChezScheme/) in den Versionen 9.4 und 9.5 getestet. Ein detaillierter Test für Version 10.0.0 wird nach dem Upgrade meines Laptop-Betriebssystems auf eine neuere Version durchgeführt.\n\nIch mache diese Open-Source-Arbeit nur in meiner Freizeit und kann viele großartige Ideen zur Community beitragen, wie z. B. die Einbettung einer Data-Flow-Analyse in scheme-langserver oder vieles mehr. Und ich bitte kontinuierlich um mehr Spenden oder Förderung. Sie können über [diese Patreon-Seite](https://www.patreon.com/PoorProgrammer/membership) oder [爱发电](https://afdian.com/a/ufo5260987423) spenden.\n\n\n## Kompilierung, Installation & Konfiguration finden Sie [HIER](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Aktueller Status\nIch werde weiterhin Bugs beheben, den Code profilieren und Informationen für mein großes Buch über selbstgemachte Typinferenzsysteme sammeln. Das wird etwa 1 Jahr dauern. Weitere Entwicklungen beinhalten ein [VScode](https://code.visualstudio.com/) Plugin und Data-Flow-Analyse. Tatsächlich ist diese Open-Source-Arbeit derzeit ein Nebenjob für mich, und ich kann keinen Zeitplan garantieren.\n\n## Release \n1.2.9 Jetzt: Viel Spaß mit der Typinferenz!\n\nFrühere Releases finden Sie in [dieser Datei](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Funktionen\n1. Top-Level- und lokale Bezeichner-Vervollständigung.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Gehe-zu-Definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Kompatibel mit Paketmanager: Akku.\n4. Synchronisierung von Dateiänderungen und entsprechende Indexanpassung.\n5. Hover.\n6. Referenzen und Dokumenthervorhebung (dokumentenbezogene Referenzen).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Dokumentsymbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Erkennung von *-Syntax (define-syntax, let-syntax, etc.) für lokale Bezeichnerbindungen. \n9. Plattformübergreifendes paralleles Indexieren.\n10. Eigener Quellcode-Annotator zur Kompatibilität mit .sps-Dateien.\n11. Peephole-Optimierung für API-Anfragen mit aussetzbaren Aufgaben.\n12. Typinferenz mit einem selbst entwickelten DSL-Interpreter (darauf bin ich sehr stolz!). Sie ist nun auch in die Autovervollständigung integriert. Wie in der folgenden Abbildung zu sehen ist, stehen die \"length-b\" und \"length-a\" mit \"integer?\" Typ vor den anderen empfohlenen Optionen, da sie zum geforderten Parametertyp von \"<=\" passen. \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nEin Test kann dies belegen, einfach `scheme --script tests/protocol/apis/test-completion.sps` ausführen und die Logdatei `scheme-langserver.log` enthält dann Ergebnisse wie:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstrakter Interpreter zum Erkennen von Bezeichnern zwischen verschiedenen Dateiendungen wie scm, ss, sps, sls und sld.\n\n### TODOs\n14. Umbenennung. \n15. Vollständige Kompatibilität mit dem [r6rs Standard](http://www.r6rs.org/).\n16. Schrittweiser Makro-Expander: Eigentlich habe ich einen implementiert und wollte ihn als Schlüsselschritt zur Erkennung von Bezeichnerbindungen in selbst definierten Makros nutzen. Jetzt merke ich, dass diese Erkennung viel schwieriger ist als gedacht, und ich weiß nicht, wo der Expander nützlich sein könnte.\n17. Code-Auswertung.\n18. Code-Diagnose.\n19. Hinzufügen von semantischer Unterstützung für andere Sprachen. Könnten Java, C, Python und viele andere Sprachen mit einem AST-Transformer unterstützt werden?\n20. Extrahieren von Ausdrücken/Statements in eine Prozedur.\n\n## TODO:Beitragen\n\n## Debug\n\n### Wie debuggt man\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Ausgabelog\nNach den Hinweisen im Abschnitt [Building](#building), [Installation für Lunar Vim](#installation-for-lunarvim) und [Installation für VScode](#todo-installation-for-vscode), falls jemand entwickeln und etwas loggen möchte, ist es praktisch, `path-to-log-file` hinzuzufügen und die Datei `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` wie folgt umzuschreiben:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, eine Implementierung des Language Server Protocol für Scheme\n]]   ,\n  },",
  "status": "ok"
}