{
  "id": 1,
  "origin": "\n<div align=\"right\">\n  <details>\n    <summary >üåê Language</summary>\n    <div>\n      <div align=\"right\">\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=en\">English</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-CN\">ÁÆÄ‰Ωì‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-TW\">ÁπÅÈ´î‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ja\">Êó•Êú¨Ë™û</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ko\">ÌïúÍµ≠Ïñ¥</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=hi\">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=th\">‡πÑ‡∏ó‡∏¢</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fr\">Fran√ßais</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=de\">Deutsch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=es\">Espa√±ol</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=it\">Itapano</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ru\">–†—É—Å—Å–∫–∏–π</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pt\">Portugu√™s</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=nl\">Nederlands</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pl\">Polski</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ar\">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fa\">ŸÅÿßÿ±ÿ≥€å</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=tr\">T√ºrk√ße</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=vi\">Ti·∫øng Vi·ªát</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=id\">Bahasa Indonesia</a></p>\n      </div>\n    </div>\n  </details>\n</div>\n\n![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [Áà±ÂèëÁîµ](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.",
  "origin_sha": "EUEvRAM1Xn8cCqrPvuBQ0V6xXYO3O33rxE42JkAjX+s=",
  "translate": "<div align=\"right\">\n  <details>\n    <summary >üåê Sprache</summary>\n    <div>\n      <div align=\"right\">\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=en\">Englisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-CN\">ÁÆÄ‰Ωì‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-TW\">ÁπÅÈ´î‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ja\">Êó•Êú¨Ë™û</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ko\">ÌïúÍµ≠Ïñ¥</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=hi\">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=th\">‡πÑ‡∏ó‡∏¢</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fr\">Franz√∂sisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=de\">Deutsch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=es\">Spanisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=it\">Itapano</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ru\">Russisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pt\">Portugiesisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=nl\">Niederl√§ndisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pl\">Polnisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ar\">Arabisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fa\">Persisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=tr\">T√ºrkisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=vi\">Vietnamesisch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=id\">Bahasa Indonesia</a></p>\n      </div>\n    </div>\n  </details>\n</div>\n\n![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nSie k√∂nnen meine [Abhandlung](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) lesen und wie folgt zitieren: \n> WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Z√ºrich. https://doi.org/10.5281/zenodo.15384882\n\nDa GitHub m√∂glicherweise chinesische IP-Adressen blockiert, musste ich dieses Repository auf [hier](https://codeberg.org/ufo5260987423/scheme-langserver) und [hier](https://gitee.com/ufo5260987423/scheme-langserver) kopieren. Ich werde alle Repositories weiterhin aktualisieren, aber ich kann es nicht garantieren. Ich arbeite jetzt auch mit [XmacsLabs](https://github.com/XmacsLabs) zusammen, Sie finden einen Fork auch [hier](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Jetzt kann VSCode scheme-langserver verwenden!** Bitte siehe [HIER](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>HINWEIS: Es gibt viele, viele Bugs im scheme-langserver. Ich bin gerade dabei, sie zu beheben und bitte die Community um Unterst√ºtzung. Bitte haben Sie Geduld.\n\n>HINWEIS: Die automatisch generierten Typinformationen finden Sie [hier](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Sie werden derzeit haupts√§chlich f√ºr die n√§chste Entwicklungsstufe (vielleicht inklusive AKKU) und zum Debuggen verwendet.\n\nDie Implementierung von Unterst√ºtzungen wie Autovervollst√§ndigung, Gehe zu Definition oder Dokumentation beim √úberfahren ist ein erheblicher Aufwand beim Programmieren. Im Vergleich zu anderen Sprachen wie Java, Python, JavaScript und C werden jedoch Implementierungen des Language Server Protocols f√ºr Lisp-Sprachen quasi im Vakuum entwickelt. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) und [swish-lint](https://github.com/becls/swish-lint) basieren alle auf `repl` (Read-Eval-Print Loop) oder Schl√ºsselwort-Tokenizern anstelle von Programmanalyse. Wenn beispielsweise ein Programmierer an einem unfertigen Projekt arbeitet, bei dem der Code noch nicht voll lauff√§hig ist, w√ºrden [Geiser](https://gitlab.com/emacs-geiser) oder andere nur Top-Level-Bindungsbezeichner auflisten, die von der Prozedur `environment-symbols` (f√ºr [Chez](https://cisco.github.io/ChezScheme/)) bereitgestellt werden, oder sie vervollst√§ndigen Symbole statt Bezeichner. Das bedeutet, dass f√ºr lokale Bindungen und unfertigen Code, obwohl programmatische Unterst√ºtzung eigentlich am wichtigsten w√§re, [Geiser](https://gitlab.com/emacs-geiser) und Co. keinerlei Hilfe beim Erkennen des g√ºltigen G√ºltigkeitsbereichs eines Bezeichners bieten. √Ñhnliche Probleme treten bei \"Gehe zu Definition\" und vielen anderen Funktionen auf.\n\nEin Hauptgrund daf√ºr ist, dass Scheme und andere Lisp-Dialekte aufgrund ihrer reichen Datens√§tze und flexiblen Kontrollstrukturen gro√üe Herausforderungen f√ºr die Programmanalyse darstellen. Besonders Makros ‚Äì es scheint, als sei Scheme haupts√§chlich f√ºr Genies und Meta/Makro-Programmierung gedacht. Aber ich sage nein. Scheme kann viele interessante Dinge erm√∂glichen, wenn eine bessere Programmierumgebung bereitgestellt wird. Und jetzt k√∂nnen Sie [**HIER STARTEN**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nDieses Paket ist eine Implementation des Language Server Protocols zur Unterst√ºtzung der Scheme-Programmierung. Es bietet Vervollst√§ndigung, Definition und Typinferenz. Diese Funktionalit√§ten basieren auf statischer Codeanalyse nach dem [r6rs-Standard](http://www.r6rs.org/) und einigen offensichtlichen Regeln f√ºr unfertigen Code. Dieses Paket selbst und die zugeh√∂rigen Bibliotheken werden mit [Akku](https://akkuscm.org/) ver√∂ffentlicht oder sind zur Ver√∂ffentlichung vorgesehen. Akku ist ein Paketmanager f√ºr Scheme.\n\nDieses Paket wurde auch mit [Chez Scheme](https://cisco.github.io/ChezScheme/) Versionen 9.4 und 9.5 getestet. Ein detaillierter Test mit Version 10.0.0 folgt nach einem Upgrade meines Laptops auf eine neuere OS-Version.\n\nIch mache diese Open-Source-Arbeit nur in meiner Freizeit und kann viele brillante Ideen in die Community einbringen, wie die Integration von Data-Flow-Analyse in scheme-langserver oder viele andere Dinge. Und ich bitte weiterhin um mehr Spenden oder F√∂rderung. Sie k√∂nnen √ºber [diese Patreon-Seite](https://www.patreon.com/PoorProgrammer/membership) oder [Áà±ÂèëÁîµ](https://afdian.com/a/ufo5260987423) spenden.\n\n\n## Kompilierung, Installation & Konfiguration sind [HIER](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Aktueller Status\nIch werde weiterhin Fehler beheben, den Code profilieren und Informationen f√ºr mein gro√ües Buch √ºber selbstgemachte Typinferenzsysteme sammeln. Das wird etwa 1 Jahr dauern. Weitere Entwicklungen umfassen ein [VScode](https://code.visualstudio.com/) Plugin und Data-Flow-Analyse. Tats√§chlich ist dieses Open-Source-Projekt f√ºr mich jetzt eine Teilzeitbesch√§ftigung, und ich kann keinen Zeitplan garantieren.\n\n## Release \n1.2.9 Jetzt: Viel Spa√ü mit der Typinferenz!\n\nFr√ºhere Releases siehe [diese Datei](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Funktionen\n1. Vervollst√§ndigung von Top-Level- und lokalen Bezeichnerbindungen.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Gehe zu Definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Kompatibel mit Paketmanager: Akku.\n4. Datei√§nderungen und entsprechende Index√§nderungen werden synchronisiert.\n5. Hover.\n6. Referenzen und Dokument-Hervorhebung (dokumentbasierte Referenzen).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Dokumentensymbole.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Erkennung von *-Syntax (define-syntax, let-syntax, usw.)-basierten lokalen Bezeichnerbindungen.\n9. Plattform√ºbergreifendes paralleles Indexieren.\n10. Selbstentwickelter Quellcode-Annotator zur Kompatibilit√§t mit .sps-Dateien.\n11. Peephole-Optimierung f√ºr API-Anfragen mit aussetzbarer Aufgabe.\n12. Typinferenz mit selbstgebautem DSL-Interpreter (darauf bin ich sehr stolz!). Und jetzt ist sie in die Autovervollst√§ndigung eingebettet. Wie die folgende Abbildung zeigt, stehen die \"length-b\" und \"length-a\" mit Typ \"integer?\" an der Spitze der empfohlenen Optionen, weil sie zum vom \"<=\"-Operator geforderten Parametertyp passen.\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nEin Test kann dieses Ergebnis belegen, f√ºhren Sie einfach `scheme --script tests/protocol/apis/test-completion.sps` aus und die Logdatei `scheme-langserver.log` enth√§lt Ergebnisse wie dieses:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstrakter Interpreter zur Bezeichnererkennung zwischen verschiedenen Dateiendungen wie scm, ss, sps, sls und sld.\n\n### TODOs\n14. Umbenennen.\n15. Volle Kompatibilit√§t mit dem [r6rs-Standard](http://www.r6rs.org/).\n16. Schrittweiser Makro-Expander: Nun, ich habe tats√§chlich einen implementiert und wollte ihn als Schl√ºssel zum Erkennen von Bezeichnerbindungen in selbstdefinierten Makros verwenden. Jetzt merke ich, dass diese Erkennung viel schwieriger ist als gedacht, und ich wei√ü nicht, wo der Expander tats√§chlich zum Einsatz kommen kann.\n17. Code-Auswertung.",
  "status": "ok"
}