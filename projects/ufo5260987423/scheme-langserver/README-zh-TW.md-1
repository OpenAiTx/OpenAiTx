{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\n你可以閱讀我的[論文](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf)，引用方式如下：\n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\n由於 GitHub 可能會封鎖中國的 IP 位址，我必須將此倉庫複製到[這裡](https://codeberg.org/ufo5260987423/scheme-langserver)以及[這裡](https://gitee.com/ufo5260987423/scheme-langserver)。我會持續更新所有倉庫，但無法保證。現在我也與 [XmacsLabs](https://github.com/XmacsLabs) 合作，你也可以在[這裡](https://github.com/XmacsLabs/scheme-langserver)找到分支。\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**現在，VSCode 已經可以使用 scheme-langserver！** 請參考[這裡](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)。\n\n>注意：scheme-langserver 中有許多 bug。我正在修復並呼籲社群協助。請耐心等候。\n\n>注意：你可以在[這裡](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result)找到自動生成的型別資訊。這目前主要用於下一階段的開發（可能包含 AKKU）和除錯。\n\n實現自動補全、跳轉定義或懸停顯示文件等支持功能，對程式設計來說是一項重大工程。然而，與 java、python、javascript 和 c 等其他語言相比，lisp 語言的語言伺服器協定實現幾乎都是在真空中完成的。[Geiser](https://gitlab.com/emacs-geiser)、[racket langserver](https://github.com/jeapostrophe/racket-langserver) 和 [swish-lint](https://github.com/becls/swish-lint) 等，他們的工作都基於 `repl`（Read-Eval-Print Loop）或關鍵字分詞器，而不是實際程式分析。例如，如果程式設計師正在編寫一個尚未完成的專案，代碼尚未完全可執行，[Geiser](https://gitlab.com/emacs-geiser) 或其他工具只能補全由 `environment-symbols` 程序（針對 [Chez](https://cisco.github.io/ChezScheme/)）列出的頂層綁定識別符，或僅補全符號而非識別符。這意味著對於區域綁定和未完成的代碼，雖然對程式分析的努力應該是最重要的，[Geiser](https://gitlab.com/emacs-geiser) 及其同類工具對於識別識別符的有效作用域毫無幫助。類似情況也發生於跳轉定義及其他多種功能。\n\n主要原因在於，對於 scheme 及其他 lisp 方言，它們大量的資料集和靈活的控制結構使得程式分析成為一大挑戰。尤其是巨集，scheme 似乎主要用於天才和元/巨集編程。但我認為並非如此。如果有更好的程式設計環境，Scheme 可以做出許多有趣的事情。你現在可以[**從這裡開始**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)。\n\n這個套件是一個語言伺服器協定實現，協助 Scheme 程式設計。它提供補全、定義和型別推斷等功能。這些功能是基於靜態程式碼分析，依據 [r6rs 標準](http://www.r6rs.org/) 及一些針對未完成代碼的明確規則建立的。此套件及其相關庫已經或即將以 [Akku](https://akkuscm.org/) 發布，Akku 是 Scheme 的套件管理器。\n\n本套件也已經在 [Chez Scheme](https://cisco.github.io/ChezScheme/) 9.4 與 9.5 版本測試過。針對 10.0.0 版的詳細測試會在我升級筆電作業系統後進行。\n\n我只是在閒暇時間做這個開源專案，也能為社群貢獻很多精彩的想法，例如將資料流分析嵌入 scheme-langserver 或其他事情。我持續尋求更多捐贈或資助。你可以透過[這個 patreon 頁面](https://www.patreon.com/PoorProgrammer/membership)或[愛發電](https://afdian.com/a/ufo5260987423)捐款支持。\n\n## 編譯、安裝與設定請見[這裡](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## 近期狀態\n我會持續修復 bug、分析程式、並為我的自製型別推斷系統巨著收集資料。這可能需要我約一年的時間。後續開發包括 [VScode](https://code.visualstudio.com/) 外掛與資料流分析。但實際上，我目前將這個開源專案當作兼職工作，無法保證時程。\n\n## 版本發佈\n1.2.9 現在，享受型別推斷的樂趣吧！\n\n先前的版本請參考[此檔案](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md)。\n\n### 功能特色\n1. 支援頂層與區域識別符綁定補全。\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. 跳轉定義。\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. 相容套件管理器：Akku。\n4. 檔案變更同步及對應索引更新。\n5. 懸停提示。\n6. 參考搜尋與文件高亮（文件範圍內的參考）。\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. 文件符號。\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. 捕捉 *-syntax（define-syntax、let-syntax 等）型區域識別符綁定。\n9. 跨平台平行索引。\n10. 自製原始碼註釋器，相容於 .sps 檔案。\n11. API 請求的 peephole 最佳化與可掛起任務。\n12. 內建自製 DSL 直譯器的型別推斷（我非常自豪！）。且現已整合進自動補全功能。如下圖所示，\"length-b\" 和 \"length-a\" 具有 \"integer?\" 型別，會優先推薦，因為它們能匹配 \"<=\" 所需的參數型別。\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\n測試可以證明此結果，只需執行 `scheme --script tests/protocol/apis/test-completion.sps`，日誌檔 `scheme-langserver.log` 會包含如下結果：\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. 跨檔案副檔名（如 scm、ss、sps、sls、sld）識別符捕捉的抽象直譯器。\n\n### 待辦事項\n14. 重新命名功能。\n15. 完全相容於 [r6rs 標準](http://www.r6rs.org/)。\n16. 步進式巨集展開器：其實我已經實作一個了，並想要讓它成為自定義巨集內識別符綁定的重要步驟。但我發現這遠比我想像的困難，而這個展開器我也不確定能否發揮作用。\n17. 程式碼執行。\n18. 程式碼診斷。\n19. 增加跨語言語意支援。嗯，java、c、python 及其他語言是否可透過 AST 轉換器支援？\n20. 將表達式/語句抽取為子程序。\n\n## 待辦：貢獻指引\n\n## 除錯\n\n### 如何除錯\nhttps://www.scheme.com/debug/debug.html#g1\n\n### 輸出日誌\n依照[編譯](#building)、[Lunar Vim 安裝](#installation-for-lunarvim)及[VScode 安裝](#todo-installation-for-vscode)的說明，如果有人想開發或記錄日誌，只需增加 `path-to-log-file` 並重寫 `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua`，如下所示：\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "status": "ok"
}