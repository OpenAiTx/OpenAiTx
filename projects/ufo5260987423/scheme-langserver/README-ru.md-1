{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nВы можете прочитать мою [статью](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) и цитировать следующим образом: \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nПоскольку GitHub может блокировать китайские IP-адреса, мне пришлось скопировать этот репозиторий [сюда](https://codeberg.org/ufo5260987423/scheme-langserver) и [сюда](https://gitee.com/ufo5260987423/scheme-langserver). Я буду продолжать обновлять все репозитории, но не могу гарантировать. Сейчас я также сотрудничаю с [XmacsLabs](https://github.com/XmacsLabs), вы также можете найти форк [здесь](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Теперь VSCode может использовать scheme-langserver!** Пожалуйста, смотрите [ЗДЕСЬ](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>ПРИМЕЧАНИЕ: В scheme-langserver много багов. Я сейчас их исправляю и прошу помощи у сообщества. Пожалуйста, наберитесь терпения.\n\n>ПРИМЕЧАНИЕ: вы можете найти автоматически сгенерированную информацию о типах [здесь](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Сейчас она в основном используется для дальнейшей разработки (возможно, включая AKKU) и отладки.\n\nРеализация поддержки таких функций, как автодополнение, переход к определению или документация при наведении, требует значительных усилий при программировании. Однако, по сравнению с такими языками, как java, python, javascript и c, реализации протокола language server для языков семейства lisp создаются практически в вакууме. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) и [swish-lint](https://github.com/becls/swish-lint) и др. работают на основе `repl` (Read-Eval-Print Loop) или токенизации по ключевым словам, а не полноценного программного анализа. Например, если программист работает над незавершённым проектом, где код не полностью исполним, [Geiser](https://gitlab.com/emacs-geiser) или любой другой инструмент завершит только идентификаторы верхнего уровня, перечисленные через процедуру `environment-symbols` (для [Chez](https://cisco.github.io/ChezScheme/)), или завершит символы вместо идентификаторов. Это означает, что для локальных привязок и незавершённого кода, несмотря на важность программного анализа, [Geiser](https://gitlab.com/emacs-geiser) и его аналоги никак не помогают распознать область видимости идентификатора. Похожие проблемы встречаются при переходе к определению и многих других функциях.\n\nОсновная причина в том, что для scheme и других диалектов lisp их обилие структур данных и гибкие управляющие конструкции делают анализ программ очень сложным. Особенно макросы — кажется, что scheme в основном предназначен для гениального и мета/макро программирования. Но я считаю, что это не так. Scheme может быть использован для множества интересных задач, если предоставить хорошую среду разработки. И теперь вы можете [**НАЧАТЬ ЗДЕСЬ**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nЭтот пакет — реализация протокола language server, помогающая при программировании на scheme. Он предоставляет автодополнение, переход к определению и вывод типов. Эти функции основаны на статическом анализе кода с учетом [стандарта r6rs](http://www.r6rs.org/) и некоторых очевидных правил для незавершённого кода. Сам пакет и связанные с ним библиотеки опубликованы или будут опубликованы через [Akku](https://akkuscm.org/), который является менеджером пакетов для Scheme.\n\nЭтот пакет также был протестирован с [Chez Scheme](https://cisco.github.io/ChezScheme/) версий 9.4 и 9.5. Подробное тестирование на версии 10.0.0 будет проведено после обновления моей ОС ноутбука до более новой версии.\n\nЯ занимаюсь этим open source проектом только в свободное время и могу внести в сообщество множество интересных идей, например, встраивание анализа потоков данных в scheme-langserver и многое другое. Я также постоянно прошу о пожертвованиях и финансировании. Вы можете поддержать меня через [эту страницу на Patreon](https://www.patreon.com/PoorProgrammer/membership) или через [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Компиляция, установка и настройка [ЗДЕСЬ](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Текущий статус\nЯ продолжаю исправлять баги, профилировать код и собирать материал для моей большой книги о системе вывода типов. Это займёт около года. Дальнейшая разработка включает в себя плагин для [VScode](https://code.visualstudio.com/) и анализ потоков данных. Но сейчас я воспринимаю эту open source работу как подработку и не могу гарантировать сроки.\n\n## Релиз \n1.2.9 Теперь доступен вывод типов!\n\nИнформацию о предыдущих релизах смотрите в [этом файле](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Возможности\n1. Автодополнение идентификаторов верхнего уровня и локальных идентификаторов.\n![Автодополнение идентификаторов верхнего уровня и локальных идентификаторов](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Переход к определению.\n![Переход к определению с telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Совместимость с менеджером пакетов Akku.\n4. Синхронизация изменений файлов и соответствующее обновление индекса.\n5. Наведение (hover).\n6. Поиск ссылок и подсветка документа (references внутри документа).\n![Поиск ссылок с telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Символы документа.\n![Поиск символов документа с telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Обработка локальных привязок идентификаторов через *-syntax (define-syntax, let-syntax и др.).\n9. Кроссплатформенная параллельная индексация.\n10. Собственный аннотатор исходного кода для поддержки .sps файлов.\n11. Peephole-оптимизация запросов API с приостановимыми задачами.\n12. Вывод типов с помощью собственного интерпретатора DSL (я этим очень горжусь!). Теперь он встроен в автодополнение. Как видно на рисунке ниже, \"length-b\" и \"length-a\" с типом \"integer?\" находятся в начале рекомендуемых вариантов, потому что они соответствуют требуемому типу параметра для \"<=\".\n![Автодополнение с выводом типов](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nТест может подтвердить этот результат, просто выполните `scheme --script tests/protocol/apis/test-completion.sps` и лог-файл `scheme-langserver.log` будет содержать следующие строки:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Абстрактный интерпретатор для поиска идентификаторов в различных расширениях файлов: scm, ss, sps, sls и sld.\n\n### В ПЛАНАХ\n14. Переименование.\n15. Полная совместимость со [стандартом r6rs](http://www.r6rs.org/).\n16. Пошаговый макро-расширитель: на самом деле я уже реализовал один и хотел сделать его ключевым этапом для поиска привязок идентификаторов в пользовательских макросах. Сейчас я понимаю, что это сложнее, чем я думал, и не знаю, где именно этот расширитель будет работать.\n17. Выполнение кода.\n18. Диагностика кода.\n19. Добавить поддержку кросс-языковой семантики. Можно ли реализовать поддержку java, c, python и других языков с помощью AST-трансформатора?\n20. Выделение выражений/операторов в отдельную процедуру.\n\n## TODO: Вклад в проект\n\n## Отладка\n\n### Как отлаживать\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Вывод логов\nСледуя советам из разделов [Сборка](#building), [Установка для Lunar Vim](#installation-for-lunarvim) и [Установка для VScode](#todo-installation-for-vscode), если кто-то хочет заняться разработкой и логировать что-то, будет удобно добавить `path-to-log-file` и переписать файл `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` следующим образом:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "status": "ok"
}