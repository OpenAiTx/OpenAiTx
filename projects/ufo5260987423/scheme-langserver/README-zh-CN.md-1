{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\n你可以阅读我的[论文](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf)并按如下方式引用\n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\n由于 GitHub 可能会屏蔽中国大陆的 IP 地址，我不得不将此仓库复制到[这里](https://codeberg.org/ufo5260987423/scheme-langserver)和[这里](https://gitee.com/ufo5260987423/scheme-langserver)。我会持续更新所有仓库，但无法保证。同时我也与[XmacsLabs](https://github.com/XmacsLabs)合作，你也可以在[这里](https://github.com/XmacsLabs/scheme-langserver)找到一个分支。\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**现在，VSCode 可以使用 scheme-langserver 了！** 请参见[此处](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)。\n\n>注意：scheme-langserver 还有很多很多 bug。我正在修复中，并寻求社区的帮助。请耐心等待。\n\n>注意：你可以在[这里](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result)找到自动生成的类型信息。它目前主要用于下一阶段开发（也许包括 AKKU）和调试。\n\n实现诸如自动补全、跳转定义或悬停文档等支持功能，对于编程来说是一项重大工作。然而，与 java、python、javascript 和 c 等其他语言相比，针对 lisp 语言的语言服务器协议实现几乎处于真空状态。[Geiser](https://gitlab.com/emacs-geiser)、[racket langserver](https://github.com/jeapostrophe/racket-langserver) 以及 [swish-lint](https://github.com/becls/swish-lint) 等等，它们的实现都基于 `repl`（读-求值-输出循环）或关键字分词器，而不是编程。例如，如果程序员正在一个未完成的项目中编写代码，代码尚未完全可执行，[Geiser](https://gitlab.com/emacs-geiser) 或其他工具只能补全由 `environment-symbols` 过程（对于 [Chez](https://cisco.github.io/ChezScheme/)）列出的顶层绑定标识符，或者补全符号而不是标识符。这意味着对于局部绑定和未完成的代码，尽管编程本应是最重要的，[Geiser](https://gitlab.com/emacs-geiser) 及其同类工具在识别标识符的有效作用域方面毫无帮助。类似的情况也出现在跳转定义和许多其他功能上。\n\n主要原因是，对于 scheme 和其他 lisp 方言来说，其丰富的数据集和灵活的控制结构使得程序分析面临巨大挑战。尤其是宏，好像 scheme 主要是为天才和元/宏编程而用。但我认为不是这样。如果有更好的编程环境，Scheme 也可以实现许多有趣的功能。现在你可以[**从这里开始**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)。\n\n本包是一个帮助 scheme 编程的语言服务器协议实现。它提供补全、定义和类型推断功能。这些功能基于[r6rs 标准](http://www.r6rs.org/)和一些针对未完成代码的显式规则进行静态代码分析建立。此包及相关库已经或将要通过 [Akku](https://akkuscm.org/) 发布，Akku 是 Scheme 的包管理器。\n\n本包也已在 [Chez Scheme](https://cisco.github.io/ChezScheme/) 9.4 和 9.5 版本中测试过。将在我的笔记本操作系统升级后，对 10.0.0 版本做详细测试。\n\n我只是业余时间做这个开源项目，我能为社区贡献许多精彩的想法，比如将数据流分析嵌入 scheme-langserver 或其它很多内容。同时我也在不断寻求更多的捐助或资助。你可以通过[这个 patreon 页面](https://www.patreon.com/PoorProgrammer/membership)或[爱发电](https://afdian.com/a/ufo5260987423)进行捐赠。\n\n## 编译、安装与配置请见[这里](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## 最近状态\n我会持续修复 bug，对代码进行性能分析，并为我的自制类型推断系统巨著收集资料。这将耗时约一年。后续开发包括 [VScode](https://code.visualstudio.com/) 插件和数据流分析。但实际上，我现在将这个开源工作当作兼职，无法保证进度。\n\n## 发行说明\n1.2.9 现在，体验类型推断功能！\n\n以往的发布信息请参见[此文件](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md)。\n\n### 功能特性\n1. 顶层和局部标识符绑定补全。\n![顶层和局部标识符绑定](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. 跳转定义。\n![使用 telescope.nvim 跳转定义](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. 兼容包管理器：Akku。\n4. 文件变动同步与相应索引变更。\n5. 悬停功能。\n6. 引用和文档高亮（文档范围内的引用）。\n![使用 telescope.nvim 查找引用](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. 文档符号。\n![使用 telescope.nvim 查找文档符号](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. 捕获 *-syntax（define-syntax, let-syntax 等）形式的局部标识符绑定。\n9. 跨平台并行索引。\n10. 自制源码注释器以兼容 .sps 文件。\n11. API 请求的窥孔优化和可挂起任务。\n12. 类型推断，基于自制 DSL 解释器（我为此非常自豪！）。现在类型推断已经集成进自动补全。如下图所示，类型为 \"integer?\" 的 \"length-b\" 和 \"length-a\" 会优先出现在推荐选项中，因为它们能匹配 \"<=\" 所需的参数类型。\n![带类型推断的自动补全](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\n一个测试可以证明该结果，只需运行 `scheme --script tests/protocol/apis/test-completion.sps`，日志文件 `scheme-langserver.log` 会包含如下内容：\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. 跨 scm、ss、sps、sls、sld 文件扩展名的标识符捕获抽象解释器。\n\n### 待办事项\n14. 重命名功能。\n15. 完全兼容 [r6rs 标准](http://www.r6rs.org/)。\n16. 步进式宏展开器：实际上，我已经实现了一个，我想用它作为捕获自定义宏标识符绑定的关键步骤。但现在我发现这种捕获比我想象的难得多，而且这个展开器我也不知道它能用在哪里。\n17. 代码求值。\n18. 代码诊断。\n19. 增加跨语言语义支持。嗯，java、c、python 及许多其他语言是否可以通过 AST 转换器支持？\n20. 抽取表达式/语句为过程。\n\n## TODO: 贡献指南\n\n## 调试\n\n### 如何调试\nhttps://www.scheme.com/debug/debug.html#g1\n\n### 输出日志\n按照 [编译](#building)、[Lunar Vim 安装](#installation-for-lunarvim) 和 [VScode 安装](#todo-installation-for-vscode) 的提示，如果有人想开发和记录日志，可以添加 `path-to-log-file` 并重写文件 `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` 如下：\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "status": "ok"
}