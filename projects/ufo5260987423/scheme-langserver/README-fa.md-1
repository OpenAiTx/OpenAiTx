{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nشما می‌توانید [مقاله من](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) را مطالعه کنید و به این صورت به آن ارجاع دهید:\n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nبه دلیل اینکه گیت‌هاب ممکن است دسترسی آی‌پی‌های چینی را مسدود کند، مجبور شدم این مخزن را به [اینجا](https://codeberg.org/ufo5260987423/scheme-langserver) و [اینجا](https://gitee.com/ufo5260987423/scheme-langserver) کپی کنم. من به‌طور مستمر همه مخازن را به‌روزرسانی خواهم کرد اما نمی‌توانم تضمین کنم. اکنون همچنین با [XmacsLabs](https://github.com/XmacsLabs) همکاری می‌کنم و می‌توانید فورک را نیز [اینجا](https://github.com/XmacsLabs/scheme-langserver) پیدا کنید.\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**اکنون، VSCode می‌تواند از scheme-langserver استفاده کند!** لطفاً به [اینجا مراجعه کنید](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>توجه: باگ‌های بسیار زیادی در scheme-langserver وجود دارد. من در حال رفع آن‌ها هستم و از جامعه درخواست کمک دارم. لطفاً صبور باشید.\n\n>توجه: می‌توانید اطلاعات نوع (type) تولید شده به صورت خودکار را [اینجا](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result) پیدا کنید. فعلاً این اطلاعات بیشتر برای توسعه مرحله بعدی (شاید شامل AKKU) و اشکال‌زدایی استفاده می‌شود.\n\nپیاده‌سازی قابلیت‌هایی مانند تکمیل خودکار، رفتن به تعریف، یا نمایش مستندات هنگام قرار گرفتن موس روی یک عنصر، تلاشی چشمگیر برای برنامه‌نویسی محسوب می‌شود. اما در مقایسه با زبان‌هایی مانند جاوا، پایتون، جاوااسکریپت و سی، پیاده‌سازی پروتکل سرور زبان برای زبان‌های لیسپ تقریباً در خلأ صورت گرفته است. [Geiser](https://gitlab.com/emacs-geiser)، [racket langserver](https://github.com/jeapostrophe/racket-langserver) و [swish-lint](https://github.com/becls/swish-lint) و غیره، همگی بر اساس `repl` (حلقه خواندن-ارزیابی-نمایش) یا توکنایزر کلیدواژه به جای برنامه‌نویسی واقعی ساخته شده‌اند. برای مثال، اگر برنامه‌نویسی روی پروژه‌ای ناتمام کد می‌نوشت که کدهایش هنوز کاملاً قابل اجرا نبود، [Geiser](https://gitlab.com/emacs-geiser) یا سایر ابزارها فقط شناسه‌های اتصال سطح بالا را که توسط رویه `environment-symbols` (برای [Chez](https://cisco.github.io/ChezScheme/)) فهرست شده‌اند، تکمیل می‌کردند یا تنها نمادها را به جای شناسه‌ها کامل می‌کردند. این بدان معناست که برای اتصال‌های محلی و کدهای ناتمام، با وجود اینکه تلاش برای برنامه‌نویسی باید اهمیت بالایی داشته باشد، [Geiser](https://gitlab.com/emacs-geiser) و همتایانش هیچ کمکی به شناسایی حوزه معتبر شناسه‌ها نمی‌کنند. موارد مشابهی با رفتن به تعریف و بسیاری قابلیت‌های دیگر رخ می‌دهد.\n\nیکی از دلایل اصلی این است که برای اسکیم و دیگر گویش‌های لیسپ، مجموعه داده‌های فراوان و ساختارهای کنترل انعطاف‌پذیر، تحلیل برنامه را به یک چالش بزرگ تبدیل می‌کند. به ویژه ماکروها، به نظر می‌رسد که اسکیم عمدتاً برای برنامه‌نویسی نابغه و متا/ماکرو استفاده می‌شود. اما من این را قبول ندارم. اسکیم می‌تواند کارهای جالب زیادی انجام دهد اگر محیط برنامه‌نویسی بهتری فراهم شود. و اکنون شما می‌توانید [**از اینجا شروع کنید**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nاین پکیج، پیاده‌سازی پروتکل سرور زبان برای کمک به برنامه‌نویسی اسکیم است. این ابزار قابلیت‌هایی مانند تکمیل، رفتن به تعریف و استنتاج نوع را فراهم می‌کند. این قابلیت‌ها بر پایه تحلیل ایستا (استاتیک) کد با [استاندارد r6rs](http://www.r6rs.org/) و برخی قوانین واضح برای کدهای ناتمام بنا شده‌اند. خود این بسته و کتابخانه‌های مرتبط منتشر شده یا قرار است با [Akku](https://akkuscm.org/) که مدیر بسته اسکیم است، منتشر شوند.\n\nاین بسته همچنین با نسخه‌های 9.4 و 9.5 [Chez Scheme](https://cisco.github.io/ChezScheme/) تست شده است. تست دقیق روی نسخه 10.0.0 پس از ارتقاء سیستم عامل لپ‌تاپم به نسخه جدیدتر انجام خواهد شد.\n\nمن این کار اوپن سورس را فقط در اوقات فراغت انجام می‌دهم و می‌توانم ایده‌های درخشانی را به جامعه ارائه دهم، مانند تلفیق تحلیل جریان داده در scheme-langserver یا بسیاری موارد دیگر. و به طور پیوسته درخواست کمک مالی و حمایت بیشتری دارم. می‌توانید با [این صفحه پاترئون](https://www.patreon.com/PoorProgrammer/membership) یا [爱发电](https://afdian.com/a/ufo5260987423) کمک مالی کنید.\n\n\n## کامپایل، نصب و پیکربندی [اینجا](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md) قرار دارد\n\n## وضعیت اخیر\nمن به رفع باگ‌ها، پروفایل کردن کد و جمع‌آوری اطلاعات برای کتاب عظیمم درباره سیستم استنتاج نوع خانگی ادامه خواهم داد. این کار حدود یک سال زمان می‌برد. توسعه‌های بیشتر شامل یک افزونه برای [VScode](https://code.visualstudio.com/) و تحلیل جریان داده خواهد بود. اما در واقع، اکنون این کار اوپن سورس را به عنوان یک کار پاره وقت قرار داده‌ام و نمی‌توانم برنامه زمانی را تضمین کنم.\n\n## انتشار\n1.2.9 اکنون از استنتاج نوع لذت ببرید!\n\nبرای نسخه‌های قبلی لطفاً به [این فایل](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md) مراجعه کنید.\n\n### ویژگی‌ها\n1. تکمیل اتصال شناسه‌های سطح بالا و محلی.\n![تکمیل اتصال شناسه‌های سطح بالا و محلی](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. رفتن به تعریف.\n![رفتن به تعریف با telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. سازگار با مدیر بسته: Akku.\n4. همگام‌سازی تغییرات فایل و تغییر شاخص مربوطه.\n5. نمایش اطلاعات هنگام قرار گرفتن موس (Hover).\n6. مراجع و برجسته‌سازی اسناد (مراجع در محدوده سند).\n![یافتن مراجع با telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. نماد سند (Document symbol).\n![یافتن نمادهای سند با telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. گرفتن اتصال شناسه محلی مبتنی بر *-syntax (مانند define-syntax، let-syntax و غیره).\n9. ایندکس‌گذاری موازی چندسکویی (Cross-platform).\n10. حاشیه‌نویس کد منحصربه‌فرد جهت سازگاری با فایل‌های .sps.\n11. بهینه‌سازی peephole برای درخواست‌های API با وظایف قابل تعلیق.\n12. استنتاج نوع با مفسر DSL خانگی (به آن بسیار افتخار می‌کنم!). و اکنون در تکمیل خودکار نیز تعبیه شده است. همانطور که شکل زیر نشان می‌دهد، \"length-b\" و \"length-a\" که نوع \"integer?\" دارند، در ابتدای گزینه‌های پیشنهادی قرار می‌گیرند چون می‌توانند با نوع پارامتری که از \"<=\" نیاز دارد، مطابقت داشته باشند.\n![تکمیل خودکار با استنتاج نوع](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nیک تست می‌تواند این نتیجه را اثبات کند، فقط کافی است دستور `scheme --script tests/protocol/apis/test-completion.sps` را اجرا کنید و فایل لاگ `scheme-langserver.log` نتایجی مانند زیر خواهد داشت:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. مفسر انتزاعی برای گرفتن شناسه در بین پسوندهای فایل مختلف مانند scm، ss، sps، sls و sld.\n\n### کارهای در دست انجام (TODOs)\n14. تغییر نام (Renaming).\n15. سازگاری کامل با [استاندارد r6rs](http://www.r6rs.org/).\n16. گسترش‌دهنده ماکرو مرحله به مرحله: در واقع من یکی را پیاده‌سازی کرده‌ام و می‌خواستم آن را به عنوان کلیدی برای گرفتن اتصال شناسه در ماکروهای خودتعریف‌شده استفاده کنم. اکنون می‌بینم که این کار بسیار سخت‌تر از چیزی است که فکر می‌کردم و نمی‌دانم این گسترش‌دهنده کجا می‌تواند کار کند.\n17. ارزیابی کد.\n18. تشخیص کد.\n19. افزودن پشتیبانی معنایی بین‌زبانی. آیا جاوا، سی، پایتون و بسیاری زبان‌های دیگر می‌توانند با یک AST transformer پشتیبانی شوند؟\n20. استخراج عبارت‌ها/دستورات به یک رویه.\n\n## کارهای در دست انجام: مشارکت (Contributing)\n\n## اشکال‌زدایی (Debug)\n\n### نحوه اشکال‌زدایی\nhttps://www.scheme.com/debug/debug.html#g1\n\n### خروجی لاگ\nبا دنبال کردن نکات [ساخت](#building)، [نصب برای Lunar Vim](#installation-for-lunarvim) و [نصب برای VScode](#todo-installation-for-vscode)، اگر کسی بخواهد کمی توسعه دهد و چیزی لاگ کند، راحت است که `path-to-log-file` را اضافه کند و فایل `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` را به صورت زیر بازنویسی کند:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "status": "ok"
}