{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nAnda dapat membaca [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) saya dan mengutipnya seperti ini \n> WANG, Z. (2025, 12 Mei). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nKarena GitHub mungkin memblokir alamat IP Tiongkok, saya harus menyalin repositori ini ke [sini](https://codeberg.org/ufo5260987423/scheme-langserver) dan [sini](https://gitee.com/ufo5260987423/scheme-langserver). Saya akan terus memperbarui semua repositori tetapi saya tidak bisa menjamin. Saya sekarang juga bekerja sama dengan [XmacsLabs](https://github.com/XmacsLabs), Anda juga dapat menemukan fork [di sini](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Sekarang, VSCode dapat menggunakan scheme-langserver!** Silakan lihat [DI SINI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>CATATAN: Ada banyak sekali bug di scheme-langserver. Saya sedang memperbaiki dan meminta bantuan dari komunitas. Mohon bersabar.\n\n>CATATAN: Anda dapat menemukan informasi tipe yang dihasilkan otomatis [di sini](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Sekarang ini terutama digunakan untuk pengembangan tahap selanjutnya (mungkin termasuk AKKU) dan debugging.\n\nMengimplementasikan dukungan seperti autocomplete, goto definition, atau dokumentasi saat hover adalah upaya besar dalam pemrograman. Namun, jika dibandingkan dengan bahasa lain seperti java, python, javascript, dan c, implementasi protokol server bahasa untuk bahasa lisp hanya dibuat di ruang hampa. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) dan [swish-lint](https://github.com/becls/swish-lint) dll., semua pekerjaan mereka didasarkan pada `repl` (Read-Eval-Print Loop) atau tokenizer kata kunci alih-alih pemrograman. Misalnya, jika seorang programmer sedang mengerjakan proyek yang belum selesai, di mana kode-kodenya belum sepenuhnya dapat dijalankan, [Geiser](https://gitlab.com/emacs-geiser) atau lainnya hanya akan melengkapi pengenal binding tingkat atas yang terdaftar oleh prosedur `environment-symbols` (untuk [Chez](https://cisco.github.io/ChezScheme/)), atau melengkapi simbol alih-alih pengenal. Artinya, untuk binding lokal dan kode yang belum selesai, meskipun usaha pemrograman seharusnya menjadi hal terpenting, [Geiser](https://gitlab.com/emacs-geiser) dan rekan-rekannya tidak membantu mengenali scope valid dari identifier. Kasus serupa juga terjadi pada goto definition dan banyak fungsi lainnya.\n\nPenyebab utamanya adalah, untuk scheme dan dialek lisp lainnya, set data yang melimpah dan struktur kontrol yang fleksibel membuat analisis program menjadi tantangan besar. Terutama pada macro, tampaknya scheme terutama digunakan untuk pemrograman jenius dan meta/macro. Tapi saya katakan tidak. Scheme dapat membuat banyak hal menarik jika lingkungan pemrograman yang lebih baik disediakan. Dan sekarang Anda dapat [**MULAI DI SINI**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nPaket ini adalah implementasi protokol server bahasa yang membantu pemrograman scheme. Paket ini menyediakan fitur completion, definition, dan type inference. Fitur-fitur ini didasarkan pada analisis kode statis dengan [standar r6rs](http://www.r6rs.org/) dan beberapa aturan jelas untuk kode yang belum selesai. Paket ini sendiri dan pustaka terkait telah atau akan dipublikasikan dengan [Akku](https://akkuscm.org/), yang merupakan package manager untuk Scheme.\n\nPaket ini juga telah diuji dengan [Chez Scheme](https://cisco.github.io/ChezScheme/) versi 9.4 dan 9.5. Pengujian lebih detail pada versi 10.0.0 akan dilakukan setelah saya memperbarui OS laptop ke versi yang lebih baru.\n\nSaya melakukan pekerjaan open source ini hanya di waktu luang dan saya dapat memberikan banyak ide cemerlang ke komunitas seperti embedding data flow analysis ke dalam scheme-langserver atau banyak hal lain. Dan saya terus meminta donasi atau pendanaan yang lebih banyak. Anda dapat berdonasi melalui [halaman patreon ini](https://www.patreon.com/PoorProgrammer/membership) atau [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Kompilasi, Instalasi & Konfigurasi ada [DI SINI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Status Terkini\nSaya akan terus memperbaiki bug, profiling kode, dan mengumpulkan informasi untuk buku besar saya tentang homemade type inference system. Ini akan memakan waktu sekitar 1 tahun. Pengembangan selanjutnya termasuk plugin [VScode](https://code.visualstudio.com/) dan data flow analysis. Tapi sebenarnya, sekarang saya menjadikan pekerjaan open source ini sebagai pekerjaan paruh waktu, dan saya tidak bisa menjamin jadwal.\n\n## Rilis\n1.2.9 Sekarang, nikmati type inference!\n\nRilis sebelumnya silakan lihat [file ini](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Fitur\n1. Penyelesaian binding pengenal tingkat atas dan lokal.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Kompatibel dengan package manager: Akku.\n4. Sinkronisasi perubahan file dan perubahan indeks terkait.\n5. Hover.\n6. Referensi dan highlight dokumen (referensi dalam lingkup dokumen).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Simbol dokumen.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Menangkap binding pengenal lokal berbasis *-syntax (define-syntax, let-syntax, dll.).\n9. Pengindeksan paralel lintas platform.\n10. Annotator kode sumber buatan sendiri agar kompatibel dengan file .sps.\n11. Optimasi peephole untuk permintaan API dengan tugas yang dapat ditangguhkan.\n12. Type inference dengan interpreter DSL buatan sendiri (Saya sangat bangga dengan ini!). Dan sekarang sudah tertanam dalam fitur auto-completion. Seperti yang ditunjukkan pada gambar berikut, \"length-b\" dan \"length-a\" yang memiliki tipe \"integer?\" berada di depan opsi yang direkomendasikan karena dapat memenuhi tipe parameter yang dibutuhkan dari \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nSebuah pengujian dapat membuktikan hasil ini, cukup jalankan `scheme --script tests/protocol/apis/test-completion.sps` dan file log `scheme-langserver.log` akan berisi hasil seperti ini:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Interpreter abstrak untuk menangkap pengenal di berbagai ekstensi file seperti scm, ss, sps, sls, dan sld.\n\n### TODOs\n14. Renaming.\n15. Sepenuhnya kompatibel dengan [standar r6rs](http://www.r6rs.org/).\n16. Step-by-step macro expander: sebenarnya saya sudah mengimplementasikan satu dan ingin menjadikannya langkah utama untuk menangkap binding identifier dalam macro buatan sendiri. Sekarang, saya menemukan bahwa penangkapan ini jauh lebih sulit dari yang saya kira, dan expander-nya saya tidak tahu akan bekerja di mana.\n17. Code eval.\n18. Code diagnostic.\n19. Menambahkan dukungan semantik lintas bahasa. Apakah java, c, python dan banyak bahasa lain bisa didukung dengan transformer AST?\n20. Mengekstrak ekspresi/statemen menjadi sebuah prosedur.\n\n## TODO:Kontribusi\n\n## Debug\n\n### Cara Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nMengikuti tips dari [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) dan [Installation for VScode](#todo-installation-for-vscode), jika ada yang ingin melakukan pengembangan dan mencatat sesuatu, akan lebih mudah dengan menambahkan `path-to-log-file` dan menulis ulang file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` seperti berikut:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, sebuah implementasi protokol server bahasa untuk scheme\n]]   ,\n  },",
  "status": "ok"
}