{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\n제 [논문](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf)을 읽으실 수 있으며, 아래와 같이 인용하실 수 있습니다.  \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nGitHub에서 중국 IP 주소를 차단할 수 있기 때문에, 이 저장소를 [여기](https://codeberg.org/ufo5260987423/scheme-langserver)와 [여기](https://gitee.com/ufo5260987423/scheme-langserver)로 복사하였습니다. 모든 저장소를 계속 업데이트할 예정이지만, 보장할 수는 없습니다. 현재 [XmacsLabs](https://github.com/XmacsLabs)와도 협업 중이며, 포크를 [여기](https://github.com/XmacsLabs/scheme-langserver)에서도 찾으실 수 있습니다.\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**이제 VSCode에서 scheme-langserver를 사용할 수 있습니다!** 자세한 내용은 [여기](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)를 참고하세요.\n\n>참고: scheme-langserver에는 많은 버그가 있습니다. 현재 수정 중이며 커뮤니티의 도움을 요청하고 있습니다. 조금만 더 기다려주세요.\n\n>참고: 자동 생성된 타입 정보는 [여기](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result)에서 확인하실 수 있습니다. 현재는 주로 다음 단계 개발(AKKU 포함 가능성 있음) 및 디버깅에 사용됩니다.\n\n자동 완성, 정의로 이동, 또는 문서 hover와 같은 지원을 구현하는 것은 프로그래밍에서 상당한 노력이 필요합니다. 그러나 java, python, javascript, c와 같은 다른 언어와 비교하면, lisp 언어용 언어 서버 프로토콜 구현은 거의 진공 상태에서 만들어졌습니다. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver), [swish-lint](https://github.com/becls/swish-lint) 등은 모두 프로그래밍이 아닌 `repl`(Read-Eval-Print Loop)이나 키워드 토크나이저에 기반을 두고 있습니다. 예를 들어, 프로그래머가 아직 완성되지 않은 프로젝트에서 코딩할 경우, 코드가 완전히 실행 가능하지 않다면, [Geiser](https://gitlab.com/emacs-geiser)나 기타 도구들은 `environment-symbols` 프로시저(예: [Chez](https://cisco.github.io/ChezScheme/))로 나열된 최상위 바인딩 식별자만 완성하거나, 심볼만 완성할 뿐 식별자는 완성하지 않습니다. 즉, 로컬 바인딩이나 완성되지 않은 코드에 대해서는 프로그래밍 지원이 매우 중요함에도 불구하고, [Geiser](https://gitlab.com/emacs-geiser)와 유사 도구들은 식별자의 유효 범위 인식에 전혀 도움이 되지 않습니다. 정의로 이동 및 기타 여러 기능에서도 유사한 사례가 발생합니다.\n\n주요 원인 중 하나는, scheme 및 기타 lisp 계열 언어의 방대한 데이터 세트와 유연한 제어 구조가 프로그램 분석에 큰 도전 과제를 제공하기 때문입니다. 특히 매크로의 경우, scheme은 천재적이고 메타/매크로 프로그래밍에 주로 사용되는 것처럼 보이지만, 저는 그렇게 생각하지 않습니다. 더 나은 프로그래밍 환경이 제공된다면 scheme으로도 많은 흥미로운 것을 만들 수 있습니다. 이제 여러분도 [**여기서 시작**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)하실 수 있습니다.\n\n이 패키지는 scheme 프로그래밍을 돕는 언어 서버 프로토콜 구현입니다. 완성, 정의, 타입 추론 기능을 제공합니다. 이러한 기능들은 [r6rs 표준](http://www.r6rs.org/)과 일부 명확한 미완성 코드 규칙에 기반한 정적 코드 분석에 의해 구축되었습니다. 이 패키지 자체와 관련 라이브러리는 Scheme용 패키지 매니저인 [Akku](https://akkuscm.org/)를 통해 배포되었거나 배포될 예정입니다.\n\n이 패키지는 [Chez Scheme](https://cisco.github.io/ChezScheme/) 9.4 및 9.5 버전에서 테스트되었습니다. 랩탑 OS를 새 버전으로 업그레이드 한 후 10.0.0 버전에 대한 상세 테스트도 진행할 예정입니다.\n\n이 오픈소스 작업은 여가 시간에 진행하고 있으며, scheme-langserver에 데이터 흐름 분석 내장 등 커뮤니티에 많은 훌륭한 아이디어를 기여할 수 있습니다. 더 많은 후원과 펀딩을 계속 요청하고 있습니다. [이 patreon 페이지](https://www.patreon.com/PoorProgrammer/membership)나 [爱发电](https://afdian.com/a/ufo5260987423)에서 후원하실 수 있습니다.\n\n\n## 컴파일, 설치 및 설정은 [여기](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)에서 확인하세요.\n\n## 최근 현황\n버그 수정, 코드 프로파일링, 직접 만든 타입 추론 시스템에 관한 대형 책 집필을 위한 정보 수집을 계속할 예정입니다. 약 1년 정도 소요될 것으로 예상합니다. 추가 개발로는 [VScode](https://code.visualstudio.com/) 플러그인 및 데이터 흐름 분석이 포함됩니다. 하지만 현재 이 오픈소스 작업은 파트타임으로 진행 중이므로 일정은 보장할 수 없습니다.\n\n## 릴리즈 \n1.2.9 이제, 타입 추론을 즐기세요!\n\n이전 릴리즈는 [이 파일](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md)을 참고하세요.\n\n### 기능\n1. 최상위 및 로컬 식별자 바인딩 자동 완성.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. 정의로 이동.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. 패키지 매니저 Akku와 호환.\n4. 파일 변경 동기화 및 해당 인덱스 변경.\n5. Hover 기능.\n6. 참조 및 문서 강조 표시(문서 범위 참조).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. 문서 심볼.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. *-syntax(define-syntax, let-syntax 등) 기반 로컬 식별자 바인딩 포착.\n9. 크로스플랫폼 병렬 인덱싱.\n10. .sps 파일과 호환되는 자체 제작 소스 코드 주석 처리기.\n11. 중단 가능한 작업이 포함된 API 요청을 위한 피프홀 최적화.\n12. 자체 제작 DSL 인터프리터를 이용한 타입 추론(정말 자랑스럽게 생각합니다!). 이제 자동 완성에도 내장되어 있습니다. 아래 그림과 같이, \"<=\"에서 요구되는 파라미터 타입과 일치하는 \"integer?\" 타입의 \"length-b\"와 \"length-a\"가 추천 옵션의 앞에 나옵니다.\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\n이 결과는 실제 테스트로 증명할 수 있습니다. `scheme --script tests/protocol/apis/test-completion.sps`를 실행하면 로그 파일 `scheme-langserver.log`에 다음과 같은 결과가 포함됩니다:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. scm, ss, sps, sls, sld 등 다양한 파일 확장자 간 식별자 포착을 위한 추상 인터프리터.\n\n### TODOs\n14. 리네이밍(Renaming).\n15. [r6rs 표준](http://www.r6rs.org/)과 완전 호환.\n16. 단계별 매크로 확장기: 실제로 하나를 구현했으며, 사용자 정의 매크로에서 식별자 바인딩 포착의 핵심 단계로 만들고자 했습니다. 하지만 이 포착은 생각보다 훨씬 어렵고, 확장기가 어디서 동작할지 모르겠습니다.\n17. 코드 평가(Code eval).\n18. 코드 진단(Code diagnostic).\n19. 교차 언어 의미 지원 추가. Java, C, Python 등 다른 언어들도 AST 변환기로 지원 가능할까요?\n20. 식(expression)/문(statement)을 프로시저로 추출.\n\n## TODO:기여 \n\n## 디버그\n\n### 디버그 방법\nhttps://www.scheme.com/debug/debug.html#g1\n\n### 로그 출력\n[빌드](#building), [Lunar Vim 설치](#installation-for-lunarvim), [VScode 설치](#todo-installation-for-vscode) 안내를 참고하여, 개발 및 로그 기록을 원하는 경우, `path-to-log-file`을 추가하고 `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` 파일을 다음과 같이 수정하면 편리합니다:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "status": "ok"
}