{
  "id": 1,
  "origin": "\n<div align=\"right\">\n  <details>\n    <summary >ğŸŒ Language</summary>\n    <div>\n      <div align=\"right\">\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=en\">English</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-CN\">ç®€ä½“ä¸­æ–‡</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-TW\">ç¹é«”ä¸­æ–‡</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ja\">æ—¥æœ¬èª</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ko\">í•œêµ­ì–´</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=hi\">à¤¹à¤¿à¤¨à¥à¤¦à¥€</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=th\">à¹„à¸—à¸¢</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fr\">FranÃ§ais</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=de\">Deutsch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=es\">EspaÃ±ol</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=it\">Itapano</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ru\">Ğ ÑƒÑÑĞºĞ¸Ğ¹</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pt\">PortuguÃªs</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=nl\">Nederlands</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pl\">Polski</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ar\">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fa\">ÙØ§Ø±Ø³ÛŒ</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=tr\">TÃ¼rkÃ§e</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=vi\">Tiáº¿ng Viá»‡t</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=id\">Bahasa Indonesia</a></p>\n      </div>\n    </div>\n  </details>\n</div>\n\n![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [çˆ±å‘ç”µ](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.",
  "origin_sha": "EUEvRAM1Xn8cCqrPvuBQ0V6xXYO3O33rxE42JkAjX+s=",
  "translate": "<div align=\"right\">\n  <details>\n    <summary >ğŸŒ JÄ™zyk</summary>\n    <div>\n      <div align=\"right\">\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=en\">English</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-CN\">ç®€ä½“ä¸­æ–‡</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-TW\">ç¹é«”ä¸­æ–‡</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ja\">æ—¥æœ¬èª</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ko\">í•œêµ­ì–´</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=hi\">à¤¹à¤¿à¤¨à¥à¤¦à¥€</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=th\">à¹„à¸—à¸¢</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fr\">FranÃ§ais</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=de\">Deutsch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=es\">EspaÃ±ol</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=it\">Itapano</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ru\">Ğ ÑƒÑÑĞºĞ¸Ğ¹</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pt\">PortuguÃªs</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=nl\">Nederlands</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pl\">Polski</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ar\">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fa\">ÙØ§Ø±Ø³ÛŒ</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=tr\">TÃ¼rkÃ§e</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=vi\">Tiáº¿ng Viá»‡t</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=id\">Bahasa Indonesia</a></p>\n      </div>\n    </div>\n  </details>\n</div>\n\n![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nMoÅ¼esz przeczytaÄ‡ mojÄ… [pracÄ™](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) i cytowaÄ‡ jÄ… tak:\n> WANG, Z. (2025, 12 maja). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nPoniewaÅ¼ GitHub moÅ¼e blokowaÄ‡ adresy IP z Chin, musiaÅ‚em skopiowaÄ‡ to repozytorium [tutaj](https://codeberg.org/ufo5260987423/scheme-langserver) oraz [tutaj](https://gitee.com/ufo5260987423/scheme-langserver). BÄ™dÄ™ stale aktualizowaÅ‚ wszystkie repozytoria, ale nie mogÄ™ tego zagwarantowaÄ‡. WspÃ³Å‚pracujÄ™ takÅ¼e z [XmacsLabs](https://github.com/XmacsLabs), znajdziesz fork [tutaj](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Teraz VSCode moÅ¼e korzystaÄ‡ ze scheme-langserver!** Zajrzyj [TUTAJ](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>UWAGA: Scheme-langserver zawiera wiele, wiele bÅ‚Ä™dÃ³w. PracujÄ™ nad ich usuwaniem i apelujÄ™ o pomoc spoÅ‚ecznoÅ›ci. ProszÄ™ o cierpliwoÅ›Ä‡.\n\n>UWAGA: automatycznie wygenerowane informacje o typach znajdziesz [tutaj](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Obecnie wykorzystywane sÄ… gÅ‚Ã³wnie do dalszego rozwoju (moÅ¼e takÅ¼e dla AKKU) oraz debugowania.\n\nImplementacja wsparcia takich funkcji jak autouzupeÅ‚nianie, przejÅ›cie do definicji czy dokumentacja po najechaniu jest duÅ¼ym wyzwaniem programistycznym. Jednak w porÃ³wnaniu do innych jÄ™zykÃ³w jak java, python, javascript czy c, implementacje protokoÅ‚u language server dla jÄ™zykÃ³w lispowych powstajÄ… niejako w prÃ³Å¼ni. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) oraz [swish-lint](https://github.com/becls/swish-lint) i inne â€“ wszystkie opierajÄ… siÄ™ na `repl` (Read-Eval-Print Loop) lub tokenizatorze sÅ‚Ã³w kluczowych, a nie na analizie programistycznej. PrzykÅ‚adowo, jeÅ›li programista pracuje nad niedokoÅ„czonym projektem, w ktÃ³rym kod nie jest w peÅ‚ni wykonywalny, [Geiser](https://gitlab.com/emacs-geiser) lub inne narzÄ™dzia bÄ™dÄ… uzupeÅ‚niaÅ‚y jedynie identyfikatory powiÄ…zane na najwyÅ¼szym poziomie, wylistowane przez procedurÄ™ `environment-symbols` (dla [Chez](https://cisco.github.io/ChezScheme/)), lub uzupeÅ‚niaÅ‚y symbole zamiast identyfikatorÃ³w. Oznacza to, Å¼e dla lokalnych powiÄ…zaÅ„ i nieukoÅ„czonego kodu, mimo Å¼e analiza programistyczna jest tu najwaÅ¼niejsza, [Geiser](https://gitlab.com/emacs-geiser) i podobne narzÄ™dzia nie rozpoznajÄ… poprawnego zakresu identyfikatorÃ³w. Podobne przypadki wystÄ™pujÄ… przy przejÅ›ciu do definicji i wielu innych funkcjach.\n\nPodstawowÄ… przyczynÄ… jest to, Å¼e dla Scheme i innych dialektÃ³w Lispa ich bogate zbiory danych i elastyczne struktury sterujÄ…ce stanowiÄ… duÅ¼e wyzwanie dla analizy programÃ³w. SzczegÃ³lnie makra â€“ wydaje siÄ™, Å¼e Scheme jest przeznaczony gÅ‚Ã³wnie dla geniuszy i do programowania meta/makro. Ale mÃ³wiÄ™: nie. Scheme pozwala na wiele ciekawych rzeczy, jeÅ›li zapewni siÄ™ lepsze Å›rodowisko programistyczne. I teraz moÅ¼esz [**ZACZÄ„Ä† TUTAJ**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nTen pakiet to implementacja protokoÅ‚u language server wspierajÄ…ca programowanie w Scheme. Zapewnia uzupeÅ‚nianie kodu, przechodzenie do definicji oraz wnioskowanie typÃ³w. FunkcjonalnoÅ›ci te opierajÄ… siÄ™ na statycznej analizie kodu wedÅ‚ug [standardu r6rs](http://www.r6rs.org/) oraz oczywistych reguÅ‚ach dla nieukoÅ„czonego kodu. Sam pakiet i powiÄ…zane biblioteki sÄ… publikowane lub bÄ™dÄ… publikowane przez [Akku](https://akkuscm.org/), czyli menedÅ¼era pakietÃ³w dla Scheme.\n\nPakiet byÅ‚ rÃ³wnieÅ¼ testowany z [Chez Scheme](https://cisco.github.io/ChezScheme/) w wersjach 9.4 i 9.5. SzczegÃ³Å‚owe testy dla wersji 10.0.0 zostanÄ… przeprowadzone po aktualizacji mojego systemu operacyjnego.\n\nPracujÄ™ nad tym projektem open source w wolnym czasie i mogÄ™ wnieÅ›Ä‡ do spoÅ‚ecznoÅ›ci wiele ciekawych pomysÅ‚Ã³w, takich jak integracja analizy przepÅ‚ywu danych z scheme-langserver czy wiele innych rzeczy. CaÅ‚y czas proszÄ™ o wsparcie finansowe lub darowizny. MoÅ¼esz przekazaÄ‡ darowiznÄ™ poprzez [stronÄ™ patreona](https://www.patreon.com/PoorProgrammer/membership) lub [çˆ±å‘ç”µ](https://afdian.com/a/ufo5260987423).\n\n\n## Kompilacja, Instalacja i Konfiguracja znajdujÄ… siÄ™ [TUTAJ](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Ostatni Status\nBÄ™dÄ™ dalej naprawiaÄ‡ bÅ‚Ä™dy, profilowaÄ‡ kod i zbieraÄ‡ materiaÅ‚y do mojej ogromnej ksiÄ…Å¼ki o wÅ‚asnorÄ™cznym systemie wnioskowania typÃ³w. Zajmie mi to okoÅ‚o roku. Dalszy rozwÃ³j obejmuje plugin do [VScode](https://code.visualstudio.com/) oraz analizÄ™ przepÅ‚ywu danych. Ale tak naprawdÄ™, traktujÄ™ teraz to open source jako pracÄ™ dorywczÄ… i nie mogÄ™ zagwarantowaÄ‡ harmonogramu.\n\n## Wydania\n1.2.9 Teraz, korzystaj z wnioskowania typÃ³w!\n\nPoprzednie wydania znajdziesz w [tym pliku](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Funkcje\n1. UzupeÅ‚nianie powiÄ…zaÅ„ identyfikatorÃ³w na najwyÅ¼szym i lokalnym poziomie.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. PrzejÅ›cie do definicji.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. KompatybilnoÅ›Ä‡ z menedÅ¼erem pakietÃ³w: Akku.\n4. Synchronizacja zmian w plikach i odpowiednia aktualizacja indeksÃ³w.\n5. PodglÄ…d (hover).\n6. Wyszukiwanie referencji i podÅ›wietlanie dokumentu (referencje w zakresie dokumentu).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Symbole dokumentu.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Wykrywanie powiÄ…zaÅ„ lokalnych identyfikatorÃ³w opartych na *-syntax (define-syntax, let-syntax, itd.).\n9. Wieloplatformowe, rÃ³wnolegÅ‚e indeksowanie.\n10. Autorski adnotator kodu ÅºrÃ³dÅ‚owego kompatybilny z plikami .sps.\n11. Optymalizacja peephole dla Å¼Ä…daÅ„ API z zadaniami wstrzymywanymi.\n12. Wnioskowanie typÃ³w z uÅ¼yciem wÅ‚asnego interpretera DSL (jestem z tego bardzo dumny!). Teraz zostaÅ‚o ono wbudowane w autouzupeÅ‚nianie. Jak pokazuje poniÅ¼sza ilustracja, \"length-b\" i \"length-a\" majÄ…ce typ \"integer?\" sÄ… na poczÄ…tku rekomendowanych opcji, poniewaÅ¼ pasujÄ… do wymaganego typu parametru dla \"<=\".\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nTest moÅ¼e to potwierdziÄ‡, wystarczy uruchomiÄ‡ `scheme --script tests/protocol/apis/test-completion.sps` a plik logÃ³w `scheme-langserver.log` zawiera takie wyniki:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstrakcyjny interpreter do wykrywania identyfikatorÃ³w miÄ™dzy rÃ³Å¼nymi rozszerzeniami plikÃ³w, takimi jak scm, ss, sps, sls i sld.\n\n### TODO\n14. Zmiana nazw (renaming).\n15. PeÅ‚na zgodnoÅ›Ä‡ ze [standardem r6rs](http://www.r6rs.org/).\n16. Krokowy ekspander makr: wÅ‚aÅ›ciwie juÅ¼ taki zaimplementowaÅ‚em i chciaÅ‚em, Å¼eby byÅ‚ kluczowym krokiem wykrywania powiÄ…zaÅ„ identyfikatorÃ³w w makrach zdefiniowanych przez uÅ¼ytkownika. Teraz widzÄ™, Å¼e to wykrywanie jest duÅ¼o trudniejsze niÅ¼ myÅ›laÅ‚em, a ekspander nie wiem, gdzie dokÅ‚adnie siÄ™ sprawdzi.\n17. Ewaluacja kodu.",
  "status": "ok"
}