{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\n[Makale](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf)'mi okuyabilir ve şu şekilde atıf yapabilirsiniz:\n> WANG, Z. (2025, 12 Mayıs). Scheme-langserver: Scheme Kod Düzenlemeyi Birinci Sınıf Bir Kaygı Olarak Ele Almak. 18. Avrupa Lisp Sempozyumu (ELS`25), Zürih. https://doi.org/10.5281/zenodo.15384882\n\nGitHub'un Çin IP adreslerini engelleyebileceği nedeniyle bu deposunu [buraya](https://codeberg.org/ufo5260987423/scheme-langserver) ve [buraya](https://gitee.com/ufo5260987423/scheme-langserver) kopyalamak zorunda kaldım. Tüm depoları sürekli güncellemeye çalışacağım fakat garanti veremem. Şu anda [XmacsLabs](https://github.com/XmacsLabs) ile de işbirliği yapıyorum, ayrıca bir çatalı [burada](https://github.com/XmacsLabs/scheme-langserver) bulabilirsiniz.\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Artık VSCode, scheme-langserver kullanabiliyor!** Lütfen [BURADAN](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md) bakınız.\n\n>NOT: scheme-langserver'da çok fazla hata var. Şu anda düzeltmeler yapıyor ve topluluktan yardım istiyorum. Lütfen sabırlı olun.\n\n>NOT: Otomatik oluşturulan tip bilgisini [buradan](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result) bulabilirsiniz. Şu anda esas olarak sonraki aşama geliştirme (belki AKKU dahil) ve hata ayıklama için kullanılıyor.\n\nTamamlama, tanıma git veya üzerine gelindiğinde dokümantasyon gibi destekler sağlamak programlama için büyük bir çabadır. Ancak, java, python, javascript ve c gibi diğer dillere kıyasla, lisp dilleri için dil sunucusu protokolü uygulamaları adeta bir vakumda yapılmıştır. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) ve [swish-lint](https://github.com/becls/swish-lint) gibi projelerin tamamı `repl` (Read-Eval-Print Loop) veya anahtar kelime belirteçleyiciye dayalıdır, programlamaya değil. Örneğin, bir programcı tamamlanmamış bir projede kod yazıyorsa ve kodlar tam olarak çalıştırılamıyorsa, [Geiser](https://gitlab.com/emacs-geiser) veya diğerleri yalnızca `environment-symbols` prosedürüyle ([Chez](https://cisco.github.io/ChezScheme/) için) listelenen üst düzey bağlayıcı tanımlayıcıları veya simgeleri tamamlayacaktır, tanımlayıcıları değil. Bu, yerel bağlayıcılar ve tamamlanmamış kodlar için, aslında programlama için çaba harcamak en önemli şey olmasına rağmen, [Geiser](https://gitlab.com/emacs-geiser) ve benzerlerinin tanımlayıcının geçerli kapsamını tanıma konusunda hiçbir işe yaramadığı anlamına gelir. Tanıma git ve birçok başka işlevde de benzer durumlar yaşanır.\n\nBunun başlıca nedeni, scheme ve diğer lisp lehçelerinde bol veri kümeleri ve esnek kontrol yapılarının program analizini büyük bir zorluk haline getirmesidir. Özellikle makro, scheme sanki esas olarak dahi ve meta/makro programlama için kullanılıyormuş gibi görünür. Ama ben hayır diyorum. Daha iyi bir programlama ortamı sağlanırsa Scheme ile çok ilginç şeyler yapılabilir. Ve şimdi [**BURADAN BAŞLAYABİLİRSİNİZ**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nBu paket, scheme programlamaya yardımcı olan bir dil sunucusu protokolü uygulamasıdır. Tamamlama, tanımlama ve tip çıkarımı sağlar. Bu işlevler, [r6rs standardı](http://www.r6rs.org/) ve tamamlanmamış kodlar için bazı belirgin kurallarla statik kod analizi üzerine kuruludur. Bu paket ve ilgili kütüphaneler [Akku](https://akkuscm.org/) ile yayınlanmış veya yayınlanacaktır; Akku, Scheme için bir paket yöneticisidir.\n\nBu paket ayrıca [Chez Scheme](https://cisco.github.io/ChezScheme/) 9.4 ve 9.5 sürümleriyle test edilmiştir. Dizüstü bilgisayarımın işletim sistemini daha yeni bir sürüme yükselttikten sonra 10.0.0 sürümü için ayrıntılı bir test yapılacaktır.\n\nBu açık kaynak çalışmasını sadece boş zamanlarımda yapıyorum ve topluluğa scheme-langserver'a veri akışı analizi gömme veya başka birçok konuda harika fikirler kazandırabilirim. Ve sürekli olarak daha fazla bağış veya fon istiyorum. [Bu patreon sayfası](https://www.patreon.com/PoorProgrammer/membership) veya [爱发电](https://afdian.com/a/ufo5260987423) ile bağış yapabilirsiniz.\n\n\n## Derleme, Kurulum & Yapılandırma [BURADA](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Güncel Durum\nHataları düzeltmeye, kodu profillemeye ve kendi tip çıkarım sistemimle ilgili dev kitabım için bilgi toplamaya devam edeceğim. Bu bana yaklaşık 1 yıl sürecek. İleriye dönük geliştirmeler arasında bir [VScode](https://code.visualstudio.com/) eklentisi ve veri akışı analizi var. Ama aslında, şu anda bu açık kaynak işini yarı zamanlı bir iş olarak yapıyorum ve bir takvim garantisi veremem.\n\n## Sürüm\n1.2.9 Artık tip çıkarımının tadını çıkarın!\n\nÖnceki sürümler için lütfen [bu dosyaya](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md) bakınız.\n\n### Özellikler\n1. Üst düzey ve yerel tanımlayıcı bağlama tamamlama.\n![Üst düzey ve yerel tanımlayıcı bağlama](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Üst düzey ve yerel tanımlayıcı bağlama\")\n2. Tanıma git (goto definition).\n![Telescope.nvim ile tanıma git](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Telescope.nvim ile tanıma git\")\n3. Paket yöneticisi ile uyumlu: Akku.\n4. Dosya değişiklikleri senkronizasyonu ve ilgili indeks değişimi.\n5. Üzerine gelme (hover).\n6. Referanslar ve belge vurgulama (belge kapsamlı referanslar).\n![Telescope.nvim ile referans bul](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Telescope.nvim ile referans bul\")\n7. Belge simgesi.\n![Telescope.nvim ile belge simgelerini bul](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"Telescope.nvim ile belge simgelerini bul\")\n8. *-syntax (define-syntax, let-syntax, vb.) tabanlı yerel tanımlayıcı bağlama yakalama.\n9. Çoklu platformda paralel indeksleme.\n10. .sps dosyalarıyla uyumlu kendi kaynak kodu açıklayıcısı.\n11. API istekleri için askıya alınabilir görev ile peephole optimizasyonu.\n12. Ev yapımı DSL yorumlayıcısı ile tip çıkarımı (bununla çok gurur duyuyorum!). Ve artık otomatik tamamlamaya entegre edildi. Aşağıdaki şekilde görüldüğü gibi, \"integer?\" tipine sahip \"length-b\" ve \"length-a\", \"<=\" tarafından istenen parametre tipiyle eşleşebildikleri için önerilen seçeneklerin önünde yer alıyor.\n![Tip çıkarımıyla otomatik tamamlama](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Tip çıkarımıyla otomatik tamamlama\")\nBunu kanıtlamak için bir test yapılabilir, sadece `scheme --script tests/protocol/apis/test-completion.sps` komutunu çalıştırın ve `scheme-langserver.log` günlük dosyası aşağıdaki gibi sonuçlar içerecektir:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. scm, ss, sps, sls ve sld gibi farklı dosya uzantıları arasında tanımlayıcı yakalama için soyut yorumlayıcı.\n\n### YAPILACAKLAR\n14. Yeniden adlandırma.\n15. [r6rs standardı](http://www.r6rs.org/) ile tam uyumluluk.\n16. Adım adım makro genişletici: Aslında bir tane uyguladım ve bunu kendi tanımladığım makrolarda tanımlayıcı bağlama yakalamada anahtar bir adım yapmak istedim. Şimdi, bu yakalamanın düşündüğümden çok daha zor olduğunu görüyorum ve genişleticinin nerede işe yarayacağını bilmiyorum.\n17. Kod değerlendirme.\n18. Kod teşhisi.\n19. Çapraz dil semantik desteği ekleme. Peki, java, c, python ve diğer birçok dil bir AST dönüştürücü ile desteklenebilir mi?\n20. İfade/durumları bir prosedüre dönüştürme.\n\n## YAPILACAKLAR: Katkı Sağlama\n\n## Hata Ayıklama\n\n### Nasıl Hata Ayıklanır\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Çıktı Günlüğü\n[Derleme](#building), [Lunar Vim için Kurulum](#installation-for-lunarvim) ve [VScode için Kurulum](#todo-installation-for-vscode) bölümlerindeki ipuçlarını izleyerek, geliştirme yapmak ve bir şeyleri günlüğe kaydetmek isteyenler için, `path-to-log-file` eklemek ve `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` dosyasını aşağıdaki gibi yeniden yazmak uygun olacaktır:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, scheme için bir dil sunucusu protokolü uygulaması\n]]   ,\n  },",
  "status": "ok"
}