{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nPuedes leer mi [artículo](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) y citarlo así:\n> WANG, Z. (2025, 12 de mayo). Scheme-langserver: Tratar la edición de código Scheme como una preocupación de primera clase. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDebido a que GitHub puede bloquear direcciones IP chinas, he tenido que copiar este repositorio a [aquí](https://codeberg.org/ufo5260987423/scheme-langserver) y [aquí](https://gitee.com/ufo5260987423/scheme-langserver). Continuaré actualizando todos los repositorios, pero no puedo garantizarlo. Ahora también colaboro con [XmacsLabs](https://github.com/XmacsLabs), puedes encontrar un fork [aquí](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**¡Ahora, VSCode puede usar scheme-langserver!** Por favor, consulta [AQUÍ](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTA: Hay muchísimos bugs en scheme-langserver. Estoy corrigiendo y pidiendo ayuda a la comunidad. Por favor, ten paciencia.\n\n>NOTA: puedes encontrar la información de tipos generada automáticamente [aquí](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Ahora se usa principalmente para el desarrollo de la siguiente etapa (quizás incluya AKKU) y para depuración.\n\nImplementar soporte como autocompletado, ir a la definición o documentación al pasar el cursor es un esfuerzo importante en programación. Sin embargo, comparado con otros lenguajes como java, python, javascript y c, la implementación de language server protocol para lenguajes lisp se ha hecho en un vacío. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) y [swish-lint](https://github.com/becls/swish-lint), etc., sus trabajos se basan en `repl` (Read-Eval-Print Loop) o en un tokenizador de palabras clave en vez de programación real. Por ejemplo, si un programador está codificando en un proyecto inacabado, en el cual los códigos no son completamente ejecutables, [Geiser](https://gitlab.com/emacs-geiser) o cualquier otro solo completará identificadores de binding de nivel superior listados por el procedimiento `environment-symbols` (para [Chez](https://cisco.github.io/ChezScheme/)), o completará símbolos en vez de identificadores. Esto significa que para bindings locales y códigos no terminados, aunque se supone que el esfuerzo en programación es de suma importancia, [Geiser](https://gitlab.com/emacs-geiser) y sus equivalentes no ayudan en nada para reconocer el alcance válido de los identificadores. Casos similares ocurren con la función de ir a la definición y muchas otras funcionalidades.\n\nUna causa principal es que, para scheme y otros dialectos lisp, sus abundantes conjuntos de datos y estructuras de control flexibles hacen que el análisis de programas sea un gran desafío. Especialmente los macros, parece que scheme se utiliza principalmente para programación de genios y meta/macro programación. Pero yo digo que no. Scheme puede hacer muchas cosas interesantes si se proporciona un mejor entorno de programación. Y ahora puedes [**EMPEZAR AQUÍ**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nEste paquete es una implementación del language server protocol que ayuda a programar en scheme. Proporciona autocompletado, definición e inferencia de tipos. Estas funcionalidades se establecen sobre análisis estático de código con el [estándar r6rs](http://www.r6rs.org/) y algunas reglas obvias para códigos inacabados. Este paquete y las bibliotecas relacionadas se publican o se publicarán con [Akku](https://akkuscm.org/), que es un gestor de paquetes para Scheme.\n\nEste paquete también ha sido probado con [Chez Scheme](https://cisco.github.io/ChezScheme/) versiones 9.4 y 9.5. Una prueba detallada en la versión 10.0.0 se realizará después de actualizar el sistema operativo de mi portátil a una versión más reciente.\n\nHago este trabajo de código abierto solo en mi tiempo libre y puedo contribuir muchas ideas brillantes a la comunidad como incrustar análisis de flujo de datos en scheme-langserver o muchas otras cosas. Y continúo pidiendo muchas más donaciones o financiación. Puedes donar con [esta página de patreon](https://www.patreon.com/PoorProgrammer/membership) o con [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilación, Instalación y Configuración está [AQUÍ](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Estado Reciente\nSeguiré corrigiendo errores, perfilando el código y recolectando información para mi gran libro sobre sistemas de inferencia de tipos caseros. Esto me llevará alrededor de 1 año. Los desarrollos futuros incluyen un plugin para [VScode](https://code.visualstudio.com/) y análisis de flujo de datos. Pero en realidad, ahora estoy considerando este trabajo de código abierto como un trabajo de medio tiempo y no puedo garantizar un cronograma.\n\n## Lanzamiento \n1.2.9 ¡Ahora disfruta de la inferencia de tipos!\n\nPara lanzamientos anteriores por favor revisa [este archivo](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Características\n1. Autocompletado de bindings de identificadores tanto a nivel superior como local.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Ir a la definición.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible con el gestor de paquetes: Akku.\n4. Sincronización de cambios en archivos y cambios correspondientes en el índice.\n5. Hover (información al pasar el cursor).\n6. Referencias y resaltado de documentos (referencias en el ámbito del documento).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Símbolo de documento.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Captura de bindings locales basados en *-syntax (define-syntax, let-syntax, etc.).\n9. Indexación paralela multiplataforma.\n10. Anotador de código fuente propio para ser compatible con archivos .sps.\n11. Optimización \"peephole\" para solicitudes de API con tareas suspendibles.\n12. Inferencia de tipos con un intérprete DSL casero (¡estoy muy orgulloso de esto!). Y ahora se ha incrustado en el autocompletado. Como indica la siguiente figura, las opciones \"length-b\" y \"length-a\" con tipo \"integer?\" están al frente de las opciones recomendadas porque pueden coincidir con el tipo de parámetro requerido por \"<=\".\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nUna prueba puede demostrar este resultado, solo ejecuta `scheme --script tests/protocol/apis/test-completion.sps` y el archivo de registro `scheme-langserver.log` contendrá resultados como este:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Intérprete abstracto para la captura de identificadores entre diferentes extensiones de archivos como scm, ss, sps, sls y sld.\n\n### POR HACER\n14. Renombrado.\n15. Compatibilidad total con el [estándar r6rs](http://www.r6rs.org/).\n16. Expansor de macros paso a paso: bueno, en realidad ya he implementado uno y quería que fuera un paso clave para capturar bindings de identificadores en macros autodefinidos. Ahora, encuentro que esta captura es mucho más difícil de lo que pensaba, y el expansor no sé dónde podría funcionar.\n17. Evaluación de código.\n18. Diagnóstico de código.\n19. Añadir soporte semántico entre lenguajes. Bueno, ¿podrían soportarse java, c, python y muchos otros lenguajes con un transformador AST?\n20. Extraer expresiones/sentencias en un procedimiento.\n\n## POR HACER: Contribuciones \n\n## Depuración\n\n### Cómo depurar\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Salida de registro\nSiguiendo los consejos de [Compilación](#building), [Instalación para Lunar Vim](#installation-for-lunarvim) y [Instalación para VScode](#todo-installation-for-vscode), si alguien quiere hacer algo de desarrollo y registrar información, será conveniente añadir `path-to-log-file` y reescribir el archivo `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` de la siguiente manera:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, una implementación de language server protocol para scheme\n]]   ,\n  },",
  "status": "ok"
}