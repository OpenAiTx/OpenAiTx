{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nU kunt mijn [artikel](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) lezen en als volgt citeren \n> WANG, Z. (2025, 12 mei). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nOmdat GitHub mogelijk Chinese IP-adressen blokkeert, moest ik deze repository kopiëren naar [hier](https://codeberg.org/ufo5260987423/scheme-langserver) en [hier](https://gitee.com/ufo5260987423/scheme-langserver). Ik zal alle repositories blijven updaten, maar ik kan het niet garanderen. Ik werk nu ook samen met [XmacsLabs](https://github.com/XmacsLabs), je kunt ook een fork vinden [hier](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Nu kan VSCode scheme-langserver gebruiken!** Zie [HIER](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOOT: Er zitten veel, heel veel bugs in scheme-langserver. Ik ben ze aan het oplossen en vraag hulp aan de community. Wees geduldig.\n\n>NOOT: de automatisch gegenereerde type-informatie vind je [hier](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Het wordt nu vooral gebruikt voor verdere ontwikkeling (misschien inclusief AKKU) en debugging.\n\nHet implementeren van ondersteuning zoals autocompletion, ga naar definitie of documentatie bij hover is een aanzienlijke inspanning voor programmeren. Maar vergeleken met andere talen zoals java, python, javascript en c, zijn implementaties van het language server protocol voor lisp-talen gewoon in een vacuüm gemaakt. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) en [swish-lint](https://github.com/becls/swish-lint) enz., hun werk is allemaal gebaseerd op `repl` (Read-Eval-Print Loop) of keyword tokenizer in plaats van programmeren. Bijvoorbeeld, als een programmeur aan een onafgemaakt project werkt waarin de code niet volledig uitvoerbaar is, zullen [Geiser](https://gitlab.com/emacs-geiser) of anderen alleen top-level binding identifiers aanvullen die door de `environment-symbols` procedure (voor [Chez](https://cisco.github.io/ChezScheme/)) worden weergegeven, of symbolen aanvullen in plaats van identifiers. Dit betekent dat voor lokale bindings en onafgemaakte code, hoewel programmeren juist daar belangrijk voor zou moeten zijn, [Geiser](https://gitlab.com/emacs-geiser) en soortgenoten niet helpen bij het herkennen van de geldige scope van een identifier. Vergelijkbare gevallen komen voor met \"ga naar definitie\" en veel andere functionaliteiten.\n\nEen primaire oorzaak is dat voor scheme en andere lisp-dialecten hun overvloedige datastructuren en flexibele controle-structuren programma-analyse tot een grote uitdaging maken. Vooral de macro: het lijkt erop dat scheme vooral gebruikt wordt voor geniale en meta/macro-programmering. Maar ik zeg van niet. Scheme kan veel interessante dingen doen als er een betere programmeeromgeving wordt geboden. En nu kun je [**HIER STARTEN**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nDit pakket is een implementatie van het language server protocol dat scheme-programmeren ondersteunt. Het biedt autocompletion, definitie en type inferentie. Deze functionaliteiten zijn gebaseerd op statische code-analyse met de [r6rs-standaard](http://www.r6rs.org/) en enkele duidelijke regels voor onafgemaakte code. Dit pakket zelf en verwante libraries worden gepubliceerd of zullen worden gepubliceerd met [Akku](https://akkuscm.org/), een package manager voor Scheme.\n\nDit pakket is ook getest met [Chez Scheme](https://cisco.github.io/ChezScheme/) versies 9.4 en 9.5. Een gedetailleerde test op versie 10.0.0 zal worden uitgevoerd nadat ik mijn laptop-OS heb geüpdatet naar een nieuwere versie.\n\nIk doe dit open-source werk alleen in mijn vrije tijd en ik kan veel geweldige ideeën bijdragen aan de community, zoals het integreren van data flow-analyse in scheme-langserver of veel andere dingen. En ik ben voortdurend op zoek naar meer donaties of financiering. Je kunt doneren via [deze patreonpagina](https://www.patreon.com/PoorProgrammer/membership) of via [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilatie, Installatie & Configuratie is [HIER](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recente Status\nIk blijf bugs oplossen, de code profileren en informatie verzamelen voor mijn enorme boek over zelfgemaakt type-inferentiesysteem. Dit zal me ongeveer 1 jaar kosten. Verdere ontwikkelingen zijn onder meer een [VScode](https://visualstudio.com/) plugin en data flow-analyse. Maar eigenlijk zie ik dit open-source werk nu als een parttime baan, en ik kan geen planning garanderen.\n\n## Release \n1.2.9 Nu, geniet van type inference!\n\nVoor eerdere releases zie [dit bestand](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Functionaliteiten\n1. Aanvullen van top-level en lokale identifier bindings.\n![Top-level en lokale identifier bindings](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level en lokale identifier bindings\")\n2. Ga naar definitie.\n![Ga naar definitie met telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Ga naar definitie met telescope.nvim\")\n3. Compatibel met package manager: Akku.\n4. Synchroniseren van bestandswijzigingen en bijbehorende indexwijzigingen.\n5. Hover.\n6. Referenties en document highlight (document-gescoepte referenties).\n![Vind referenties met telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Vind referenties met telescope.nvim\")\n7. Documentsymbool.\n![Vind documentsymbolen met telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"vind documentsymbolen met telescope.nvim\")\n8. Vangen van *-syntax (define-syntax, let-syntax, enz.) gebaseerde lokale identifier binding.\n9. Cross-platform parallel indexeren.\n10. Zelfgemaakte broncode-annotator om compatibel te zijn met .sps-bestanden.\n11. Peephole-optimalisatie voor API-aanvragen met onderbreekbare taken.\n12. Type-inferentie met een zelfgemaakte DSL-interpreter (ik ben er erg trots op!). En nu is het geïntegreerd in de autocompletion. Zoals in de volgende afbeelding te zien is, staan \"length-b\" en \"length-a\" met het type \"integer?\" vooraan tussen de aanbevolen opties omdat ze overeenkomen met het parameter type dat \"<=\" vereist.\n![Autocompletion met type-inferentie](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion met type-inferentie\")\nEen test kan dit resultaat bewijzen, voer gewoon `scheme --script tests/protocol/apis/test-completion.sps` uit en het logbestand `scheme-langserver.log` zal resultaten bevatten zoals:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstracte interpreter voor identifier catching over verschillende bestandsextensies zoals scm, ss, sps, sls en sld.\n\n### TODO's\n14. Hernoemen.\n15. Volledig compatibel met de [r6rs-standaard](http://www.r6rs.org/).\n16. Stap-voor-stap macro-expander: ik heb er eigenlijk al een geïmplementeerd en ik wilde het een belangrijke stap maken bij het vangen van identifier bindings in zelfgedefinieerde macro's. Nu merk ik dat dit vangen veel moeilijker is dan ik dacht, en ik weet niet waar de expander zou kunnen werken.\n17. Code-evaluatie.\n18. Code-diagnose.\n19. Cross-language semantische ondersteuning toevoegen. Kunnen java, c, python en vele andere talen worden ondersteund met een AST-transformer?\n20. Expressie/statement extraheren naar een procedure.\n\n## TODO:Bijdragen\n\n## Debuggen\n\n### Hoe te debuggen\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nVolg de tips uit [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) en [Installation for VScode](#todo-installation-for-vscode). Als iemand wil ontwikkelen en iets wil loggen, is het handig om `path-to-log-file` toe te voegen en het bestand `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` als volgt te herschrijven:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, een language server protocol implementatie voor scheme\n]]   ,\n  },",
  "status": "ok"
}