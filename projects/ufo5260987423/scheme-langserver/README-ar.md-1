{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![اطرح سؤالاً على DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nيمكنك قراءة [ورقتي البحثية](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) والاستشهاد بها كالتالي:\n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nنظرًا لأن GitHub قد يحجب عناوين IP الصينية، اضطررت لنسخ هذا المستودع إلى [هنا](https://codeberg.org/ufo5260987423/scheme-langserver) و[هنا](https://gitee.com/ufo5260987423/scheme-langserver). سأستمر في تحديث جميع المستودعات ولكن لا أستطيع ضمان ذلك. أنا أتعاون الآن أيضًا مع [XmacsLabs](https://github.com/XmacsLabs)، ويمكنك أيضًا العثور على نسخة متفرعة [هنا](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**الآن، يمكن لـ VSCode استخدام scheme-langserver!** يرجى الرجوع إلى [هنا](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>ملاحظة: هناك العديد من الأخطاء في scheme-langserver. أنا فقط أقوم بإصلاحها وأطلب المساعدة من المجتمع. يرجى التحلي بالصبر.\n\n>ملاحظة: يمكنك العثور على معلومات النوع المولدة تلقائيًا [هنا](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). وهي تُستخدم الآن بشكل أساسي للتطوير في المرحلة القادمة (قد تشمل AKKU) ولأغراض التصحيح.\n\nإن تنفيذ دعم مثل الإكمال التلقائي، الانتقال إلى التعريف، أو عرض التوثيق عند التمرير هو جهد كبير في البرمجة. ومع ذلك، بالمقارنة مع لغات أخرى مثل java، python، javascript وc، فإن تنفيذ بروتوكول خادم اللغة للغات lisp يتم غالبًا في فراغ. [Geiser](https://gitlab.com/emacs-geiser)، [racket langserver](https://github.com/jeapostrophe/racket-langserver) و[swish-lint](https://github.com/becls/swish-lint) وغيرها، جميع أعمالهم تعتمد على `repl` (حلقة القراءة-التقييم-الطباعة) أو محلل الكلمات الرئيسية بدلاً من البرمجة. على سبيل المثال، إذا كان المبرمج يعمل على مشروع غير مكتمل، حيث الشيفرة غير قابلة للتنفيذ بالكامل، فإن [Geiser](https://gitlab.com/emacs-geiser) أو غيره لن يكمل إلا معرفات الربط في المستوى الأعلى المدرجة بواسطة إجراء `environment-symbols` (لـ [Chez](https://cisco.github.io/ChezScheme/))، أو يكمل الرموز بدلاً من المعرفات. هذا يعني بالنسبة للربط المحلي والشيفرات غير المكتملة، على الرغم من أن بذل الجهد للبرمجة يفترض أنه الأهم غالبًا، فإن [Geiser](https://gitlab.com/emacs-geiser) ونظرائه لا يساعدون في التعرف على نطاق صلاحية المعرفات. حالات مشابهة تحدث مع الانتقال إلى التعريف والعديد من الوظائف الأخرى.\n\nالسبب الرئيسي هو أن scheme وغيرها من لهجات lisp، مجموعاتها البيانية الوفيرة وهياكل التحكم المرنة تطرح تحديًا كبيرًا لتحليل البرامج. خصوصًا الماكرو، يبدو أن scheme يستخدم أساسًا للعباقرة وبرمجة الميتا/الماكرو. لكنني أقول لا. يمكن لـ Scheme تقديم العديد من الأشياء الشيقة إذا تم توفير بيئة برمجة أفضل. والآن يمكنك [**البدء من هنا**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nهذه الحزمة هي تنفيذ لبروتوكول خادم اللغة لمساعدة برمجة scheme. توفر الإكمال، التعريف، واستنتاج النوع. هذه الوظائف مبنية على تحليل الشيفرة الثابت مع [معيار r6rs](http://www.r6rs.org/) وبعض القواعد الواضحة للشيفرات غير المكتملة. هذه الحزمة نفسها والمكتبات المرتبطة بها منشورة أو سيتم نشرها مع [Akku](https://akkuscm.org/)، وهو مدير حزم لـ Scheme.\n\nتم اختبار هذه الحزمة أيضًا مع [Chez Scheme](https://cisco.github.io/ChezScheme/) بالإصدارين 9.4 و9.5. وسيتم إجراء اختبار تفصيلي على الإصدار 10.0.0 بعد ترقية نظام تشغيل اللابتوب إلى إصدار أحدث.\n\nأقوم بهذا العمل مفتوح المصدر فقط في أوقات فراغي ويمكنني أن أساهم بالعديد من الأفكار الرائعة للمجتمع مثل دمج تحليل تدفق البيانات في scheme-langserver أو أشياء أخرى كثيرة. وما زلت أطلب المزيد من التبرعات أو التمويل. يمكنك التبرع من خلال [صفحة patreon هذه](https://www.patreon.com/PoorProgrammer/membership) أو [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## الترجمة، التثبيت & الإعداد من [هنا](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## الحالة الحالية\nسأستمر في إصلاح الأخطاء، وتحليل أداء الشيفرة، وجمع المعلومات لكتابي الضخم عن نظام استنتاج النوع محلي الصنع. سيستغرق هذا حوالي سنة واحدة. التطويرات المستقبلية تشمل إضافة إضافة [VScode](https://code.visualstudio.com/) وتحليل تدفق البيانات. لكن في الواقع، أعتبر هذا العمل المفتوح المصدر وظيفة بدوام جزئي الآن، ولا أستطيع ضمان جدول زمني.\n\n## الإصدار\n1.2.9 الآن، استمتع باستنتاج النوع!\n\nللإصدارات السابقة يرجى الرجوع إلى [هذا الملف](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### الميزات\n1. إكمال ربط المعرفات في المستوى الأعلى والمحلي.\n![إكمال ربط المعرفات في المستوى الأعلى والمحلي](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. الانتقال إلى التعريف.\n![الانتقال إلى التعريف مع telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. متوافق مع مدير الحزم: Akku.\n4. مزامنة تغييرات الملفات وتغيير الفهرسة المقابلة.\n5. العرض عند التمرير (Hover).\n6. المراجع وإبراز المستند (المراجع ضمن المستند).\n![البحث عن المراجع مع telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. رمز المستند.\n![البحث عن رموز المستند مع telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. التقاط ربط المعرفات المحلية بناءً على *-syntax (define-syntax, let-syntax، إلخ).\n9. فهرسة متوازية عبر الأنظمة.\n10. مشرح شيفرة مصدرية محلي الصنع ليكون متوافقًا مع ملفات .sps.\n11. تحسين ثغرات الأداء لطلبات API مع مهمة قابلة للتعليق.\n12. استنتاج النوع مع مفسر DSL محلي الصنع (أنا فخور به جدًا!). والآن تم تضمينه في الإكمال التلقائي. كما توضح الصورة التالية، فإن \"length-b\" و \"length-a\" اللتين تحملان نوع \"integer?\" تظهران في مقدمة الخيارات الموصى بها لأنها تتوافق مع نوع المعامل المطلوب من \"<=\".\n![الإكمال التلقائي مع استنتاج النوع](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nيمكن لاختبار إثبات هذه النتيجة، فقط قم بتشغيل `scheme --script tests/protocol/apis/test-completion.sps` وسيحتوي ملف السجل `scheme-langserver.log` على نتائج مثل هذه:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. مفسر تجريدي لالتقاط المعرفات بين امتدادات الملفات المختلفة مثل scm، ss، sps، sls وsld.\n\n### المهام القادمة\n14. إعادة التسمية.\n15. التوافق الكامل مع [معيار r6rs](http://www.r6rs.org/).\n16. موسع ماكرو خطوة بخطوة: في الواقع، لقد نفذت واحدًا وأردت أن أجعله خطوة رئيسية لالتقاط ربط المعرفات في الماكروهات المعرفة ذاتيًا. الآن، أجد أن هذا الالتقاط أصعب بكثير مما كنت أعتقد، ولا أعرف أين يمكن أن يعمل الموسع.\n17. تقييم الشيفرة.\n18. تشخيص الشيفرة.\n19. إضافة دعم الدلالات عبر اللغات. حسنًا، هل يمكن دعم java، c، python والعديد من اللغات الأخرى مع محول AST؟\n20. استخراج التعبيرات/التعليمات إلى إجراء.\n\n## المهام القادمة: المساهمة\n\n## التصحيح\n\n### كيفية التصحيح\nhttps://www.scheme.com/debug/debug.html#g1\n\n### سجل الإخراج\nباتباع النصائح من [البناء](#building)، [التثبيت لـ Lunar Vim](#installation-for-lunarvim) و [التثبيت لـ VScode](#todo-installation-for-vscode)، إذا أراد أي شخص القيام ببعض التطوير وتسجيل شيء ما، سيكون من الملائم إضافة `path-to-log-file` وإعادة كتابة الملف `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` كما يلي:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`، تنفيذ لبروتوكول خادم اللغة لـ scheme\n]]   ,\n  },",
  "status": "ok"
}