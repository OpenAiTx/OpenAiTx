{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nVocê pode ler meu [artigo](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) e citar da seguinte forma \n> WANG, Z. (2025, 12 de maio). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDevido ao fato do GitHub poder bloquear endereços IP chineses, tive que copiar este repositório para [aqui](https://codeberg.org/ufo5260987423/scheme-langserver) e [aqui](https://gitee.com/ufo5260987423/scheme-langserver). Continuarei atualizando todos os repositórios, mas não posso garantir. Agora também colaboro com [XmacsLabs](https://github.com/XmacsLabs), você também pode encontrar um fork [aqui](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Agora, o VSCode pode usar o scheme-langserver!** Por favor, consulte [AQUI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTA: Existem muitos e muitos bugs no scheme-langserver. Estou corrigindo e pedindo ajuda à comunidade. Por favor, seja paciente.\n\n>NOTA: você pode encontrar as informações de tipos geradas automaticamente [aqui](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Atualmente, é utilizado principalmente para o desenvolvimento da próxima etapa (talvez incluindo AKKU) e depuração.\n\nImplementar suporte como autocompletar, ir para definição ou documentação ao passar o mouse é um esforço significativo para programação. No entanto, comparando com outras linguagens como java, python, javascript e c, a implementação do language server protocol para linguagens lisp é feita praticamente no vácuo. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) e [swish-lint](https://github.com/becls/swish-lint) etc., todos baseiam seu funcionamento em `repl` (Read-Eval-Print Loop) ou tokenização por palavras-chave ao invés de programação. Por exemplo, se um programador estiver codificando em um projeto inacabado, cujos códigos não estejam totalmente executáveis, [Geiser](https://gitlab.com/emacs-geiser) ou outros apenas completariam identificadores de binding no nível superior listados pelo procedimento `environment-symbols` (para [Chez](https://cisco.github.io/ChezScheme/)), ou completariam símbolos ao invés de identificadores. Isso significa que para bindings locais e códigos inacabados, embora o esforço de programação seja de suma importância, [Geiser](https://gitlab.com/emacs-geiser) e similares não ajudam em nada no reconhecimento do escopo válido de identificadores. Casos semelhantes ocorrem com ir para definição e muitas outras funcionalidades.\n\nUma das principais causas é que, para scheme e outros dialetos lisp, seus abundantes conjuntos de dados e estruturas de controle flexíveis tornam a análise de programas um grande desafio. Especialmente o macro: parece que scheme é usado principalmente para programação de gênios e meta/macro programação. Mas eu discordo. Scheme pode fazer muitas coisas interessantes se um ambiente de programação melhor for fornecido. E agora você pode [**COMEÇAR AQUI**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nEste pacote é uma implementação do language server protocol para ajudar na programação em scheme. Ele oferece autocompletar, definição e inferência de tipos. Essas funcionalidades são baseadas em análise estática de código com o [padrão r6rs](http://www.r6rs.org/) e algumas regras óbvias para códigos inacabados. Este pacote e bibliotecas relacionadas são publicados ou serão publicados com o [Akku](https://akkuscm.org/), que é um gerenciador de pacotes para Scheme.\n\nEste pacote também foi testado com as versões 9.4 e 9.5 do [Chez Scheme](https://cisco.github.io/ChezScheme/). Um teste detalhado na versão 10.0.0 será feito após atualizar o sistema operacional do meu laptop para uma versão mais recente.\n\nFaço este trabalho open source apenas em meu tempo livre e posso contribuir com muitas ideias brilhantes para a comunidade, como incorporar análise de fluxo de dados ao scheme-langserver ou muitas outras coisas. E estou continuamente pedindo mais doações ou financiamento. Você pode doar com [esta página do patreon](https://www.patreon.com/PoorProgrammer/membership) ou pelo [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilação, Instalação & Configuração está [AQUI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Status Atual\nVou continuar corrigindo bugs, fazendo profiling do código e coletando informações para meu grande livro sobre sistema de inferência de tipos homemade. Isso vai levar cerca de 1 ano. Desenvolvimentos futuros incluem um plugin para [VScode](https://code.visualstudio.com/) e análise de fluxo de dados. Mas, na prática, estou tratando este trabalho open source como um trabalho de meio período, e não posso garantir prazos.\n\n## Lançamento \n1.2.9 Agora, aproveite a inferência de tipos!\n\nPara lançamentos anteriores, consulte [este arquivo](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Funcionalidades\n1. Autocompletar bindings de identificadores no nível superior e local.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Ir para definição.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatível com gerenciador de pacotes: Akku.\n4. Sincronização de alterações em arquivos e mudanças correspondentes no índice.\n5. Hover.\n6. Referências e destaque de documentos (referências no escopo do documento).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Símbolo de documento.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Captura de *-syntax (define-syntax, let-syntax, etc.) para bindings locais de identificadores.\n9. Indexação paralela multiplataforma.\n10. Anotador de código fonte próprio para ser compatível com arquivos .sps.\n11. Otimização peephole para requisições de API com tarefas suspensas.\n12. Inferência de tipos com um interpretador DSL homemade (tenho muito orgulho disso!). E agora está incorporada no autocompletar. Como indicado na figura seguinte, \"length-b\" e \"length-a\" com tipo \"integer?\" aparecem no início das opções recomendadas porque podem corresponder ao tipo de parâmetro exigido por \"<=\".\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nUm teste pode provar esse resultado; basta executar `scheme --script tests/protocol/apis/test-completion.sps` e o arquivo de log `scheme-langserver.log` conterá resultados como este:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Interpretador abstrato para captura de identificadores entre diferentes extensões de arquivos como scm, ss, sps, sls e sld.\n\n### TODOs\n14. Renomeação.\n15. Totalmente compatível com o [padrão r6rs](http://www.r6rs.org/).\n16. Expansor de macros passo-a-passo: bem, na verdade implementei um e queria torná-lo um passo-chave na captura de bindings de identificadores em macros definidas pelo usuário. Agora vejo que essa captura é muito mais difícil do que imaginei, e não sei onde o expansor poderia funcionar.\n17. Avaliação de código.\n18. Diagnóstico de código.\n19. Adicionar suporte semântico entre linguagens. Bem, seria possível dar suporte a java, c, python e muitas outras linguagens com um transformador de AST?\n20. Extrair expressões/comandos em um procedimento.\n\n## TODO:Contribuindo\n\n## Debug\n\n### Como Depurar\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Log de Saída\nSeguindo as dicas de [Compilação](#building), [Instalação para Lunar Vim](#installation-for-lunarvim) e [Instalação para VScode](#todo-installation-for-vscode), se alguém quiser desenvolver e registrar logs, será conveniente adicionar `path-to-log-file` e reescrever o arquivo `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` da seguinte forma:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, uma implementação do language server protocol para scheme\n]]   ,\n  },",
  "status": "ok"
}