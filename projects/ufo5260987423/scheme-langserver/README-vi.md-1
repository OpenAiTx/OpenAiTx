{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nBạn có thể đọc [bài báo](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) của tôi và trích dẫn như sau \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDo GitHub có thể chặn các địa chỉ IP Trung Quốc, tôi phải sao chép kho lưu trữ này sang [đây](https://codeberg.org/ufo5260987423/scheme-langserver) và [đây](https://gitee.com/ufo5260987423/scheme-langserver). Tôi sẽ liên tục cập nhật tất cả các kho lưu trữ nhưng tôi không thể đảm bảo. Hiện tôi cũng đang hợp tác với [XmacsLabs](https://github.com/XmacsLabs), bạn cũng có thể tìm thấy một nhánh tại [đây](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Hiện tại, VSCode đã có thể sử dụng scheme-langserver!** Vui lòng tham khảo [TẠI ĐÂY](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n> LƯU Ý: Có rất nhiều lỗi trong scheme-langserver. Tôi đang sửa chữa và kêu gọi sự giúp đỡ từ cộng đồng. Xin hãy kiên nhẫn.\n\n> LƯU Ý: bạn có thể tìm thông tin kiểu tự động sinh tại [đây](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Hiện nó chủ yếu được sử dụng cho phát triển giai đoạn tiếp theo (có thể bao gồm cả AKKU) và gỡ lỗi.\n\nViệc triển khai các hỗ trợ như tự động hoàn thành, đi đến định nghĩa, hoặc hiển thị tài liệu khi di chuột là một nỗ lực lớn trong lập trình. Tuy nhiên, so với các ngôn ngữ khác như java, python, javascript và c, các triển khai language server protocol cho ngôn ngữ lisp chỉ mới được thực hiện trong môi trường chân không. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) và [swish-lint](https://github.com/becls/swish-lint) v.v., các công cụ này đều dựa trên `repl`(Read-Eval-Print Loop) hoặc bộ tách từ khóa thay vì lập trình thực thụ. Ví dụ, nếu một lập trình viên đang viết mã cho một dự án chưa hoàn thiện, trong đó mã chưa thể thực thi hoàn toàn, [Geiser](https://gitlab.com/emacs-geiser) hoặc bất kỳ công cụ nào khác chỉ hoàn thành các định danh được liên kết ở cấp cao nhất được liệt kê bởi thủ tục `environment-symbols` (cho [Chez](https://cisco.github.io/ChezScheme/)), hoặc hoàn thành các ký hiệu thay vì định danh. Điều này có nghĩa là đối với các liên kết cục bộ và mã chưa hoàn thiện, mặc dù nỗ lực lập trình được cho là rất quan trọng, [Geiser](https://gitlab.com/emacs-geiser) và các công cụ tương tự không giúp ích gì trong việc nhận diện phạm vi hợp lệ của định danh. Các trường hợp tương tự xảy ra với chức năng đi đến định nghĩa và nhiều chức năng khác.\n\nNguyên nhân chính là, đối với scheme và các biến thể lisp khác, tập dữ liệu phong phú và cấu trúc điều khiển linh hoạt khiến việc phân tích chương trình trở nên rất thách thức. Đặc biệt là macro, dường như scheme chủ yếu được sử dụng cho lập trình thiên tài và meta/macro. Nhưng tôi không nghĩ vậy. Scheme có thể làm được nhiều điều thú vị nếu có một môi trường lập trình tốt hơn. Và bây giờ bạn có thể [**BẮT ĐẦU Ở ĐÂY**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nGói này là một triển khai language server protocol giúp lập trình scheme. Nó cung cấp tính năng hoàn thành, xác định và suy luận kiểu. Các chức năng này được xây dựng dựa trên phân tích mã tĩnh với [tiêu chuẩn r6rs](http://www.r6rs.org/) và một số quy tắc rõ ràng cho mã chưa hoàn thiện. Gói này và các thư viện liên quan được phát hành hoặc sẽ được phát hành với [Akku](https://akkuscm.org/), là trình quản lý gói cho Scheme.\n\nGói này cũng đã được kiểm thử với [Chez Scheme](https://cisco.github.io/ChezScheme/) phiên bản 9.4 và 9.5. Kiểm thử chi tiết trên phiên bản 10.0.0 sẽ được thực hiện sau khi tôi nâng cấp hệ điều hành laptop lên phiên bản mới hơn.\n\nTôi làm công việc mã nguồn mở này chỉ trong thời gian rảnh và tôi có thể đóng góp nhiều ý tưởng tuyệt vời cho cộng đồng như tích hợp phân tích luồng dữ liệu vào scheme-langserver hoặc nhiều thứ khác. Và tôi liên tục kêu gọi nhiều hơn sự quyên góp hoặc tài trợ. Bạn có thể quyên góp qua [trang patreon này](https://www.patreon.com/PoorProgrammer/membership) hoặc [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Biên dịch, Cài đặt & Cấu hình ở [ĐÂY](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Trạng Thái Gần Đây\nTôi sẽ tiếp tục sửa lỗi, tối ưu mã, và thu thập thông tin cho cuốn sách lớn về hệ thống suy luận kiểu tự chế của mình. Việc này sẽ mất khoảng 1 năm. Các phát triển tiếp theo bao gồm một plugin [VScode](https://code.visualstudio.com/) và phân tích luồng dữ liệu. Nhưng thực tế, hiện tôi đang xem công việc mã nguồn mở này như một công việc bán thời gian, và tôi không thể đảm bảo lịch trình.\n\n## Phát Hành\n1.2.9 Hiện tại, hãy tận hưởng tính năng suy luận kiểu!\n\nCác bản phát hành trước vui lòng tham khảo [tệp này](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Tính Năng\n1. Hoàn thành liên kết định danh ở cấp cao nhất và cục bộ.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Đi đến định nghĩa.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Tương thích với trình quản lý gói: Akku.\n4. Đồng bộ hóa thay đổi tệp và thay đổi chỉ mục tương ứng.\n5. Hover.\n6. Tham chiếu và làm nổi bật tài liệu (tham chiếu trong phạm vi tài liệu).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Ký hiệu tài liệu.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Bắt các liên kết định danh cục bộ dựa trên *-syntax (define-syntax, let-syntax, v.v.).\n9. Lập chỉ mục song song đa nền tảng.\n10. Chú thích mã nguồn tự chế để tương thích với tệp .sps.\n11. Tối ưu hóa peephole cho các yêu cầu API với tác vụ có thể tạm dừng.\n12. Suy luận kiểu với trình thông dịch DSL tự chế (tôi rất tự hào về nó!). Và hiện đã được tích hợp vào tính năng tự động hoàn thành. Như hình dưới đây, \"length-b\" và \"length-a\" có kiểu \"integer?\" được ưu tiên trong các lựa chọn đề xuất vì chúng có thể khớp với kiểu tham số yêu cầu từ \"<=\".\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nMột kiểm thử có thể chứng minh kết quả này, chỉ cần chạy `scheme --script tests/protocol/apis/test-completion.sps` và tệp nhật ký `scheme-langserver.log` sẽ chứa các kết quả như sau:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Trình thông dịch trừu tượng để bắt định danh giữa các phần mở rộng tệp khác nhau như scm, ss, sps, sls và sld.\n\n### CẦN LÀM\n14. Đổi tên. \n15. Hoàn toàn tương thích với [tiêu chuẩn r6rs](http://www.r6rs.org/).\n16. Trình mở rộng macro từng bước: thực ra tôi đã triển khai một cái và tôi muốn biến nó thành một bước chủ chốt để bắt liên kết định danh trong macro tự định nghĩa. Bây giờ, tôi nhận ra việc này khó hơn tôi nghĩ, và tôi cũng không biết trình mở rộng này có thể làm việc ở đâu.\n17. Đánh giá mã.\n18. Chẩn đoán mã.\n19. Thêm hỗ trợ ngữ nghĩa liên ngôn ngữ. Liệu java, c, python và nhiều ngôn ngữ khác có thể được hỗ trợ với bộ chuyển đổi AST không?\n20. Trích xuất biểu thức/câu lệnh thành một thủ tục.\n\n## CẦN LÀM: Đóng Góp \n\n## Gỡ Lỗi\n\n### Cách Gỡ Lỗi\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Xuất Nhật Ký\nLàm theo các hướng dẫn từ [Xây dựng](#building), [Cài đặt cho Lunar Vim](#installation-for-lunarvim) và [Cài đặt cho VScode](#todo-installation-for-vscode), nếu ai đó muốn phát triển và ghi nhật ký, sẽ thuận tiện hơn khi thêm `path-to-log-file` và chỉnh lại tệp `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` như sau:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, một triển khai language server protocol cho scheme\n]]   ,\n  },",
  "status": "ok"
}