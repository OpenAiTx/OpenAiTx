{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\n私の[論文](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf)を読むことができ、以下のように引用できます。\n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nGitHubが中国のIPアドレスをブロックする可能性があるため、このリポジトリを[こちら](https://codeberg.org/ufo5260987423/scheme-langserver)および[こちら](https://gitee.com/ufo5260987423/scheme-langserver)にコピーしました。すべてのリポジトリを継続的に更新しますが、保証はできません。また、[XmacsLabs](https://github.com/XmacsLabs)とも協力しており、[こちら](https://github.com/XmacsLabs/scheme-langserver)にもフォークがあります。\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**現在、VSCodeでscheme-langserverが利用可能です！** 詳細は[こちら](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)を参照してください。\n\n>注意: scheme-langserverには多くのバグがあります。現在修正中で、コミュニティからの協力も求めています。ご理解ください。\n\n>注意: 自動生成された型情報は[こちら](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result)から確認できます。これは主に次の開発ステージ（おそらくAKKUを含む）やデバッグに使われています。\n\nオートコンプリート、定義へ移動、ホバー時のドキュメント表示などのサポートを実装するのは、プログラミングにおいて大きな労力です。しかし、Java、Python、JavaScript、Cなど他の言語と比較すると、Lisp系言語のLanguage Server Protocol実装は真空状態で作られています。[Geiser](https://gitlab.com/emacs-geiser)、[racket langserver](https://github.com/jeapostrophe/racket-langserver)、[swish-lint](https://github.com/becls/swish-lint)などは、`repl`(Read-Eval-Print Loop)やキーワードトークナイザーに依存しており、プログラミング的な実装ではありません。例えば、プログラマーが未完成のプロジェクトでコードを書いている場合、そのコードが完全に実行可能でなくても、[Geiser](https://gitlab.com/emacs-geiser)等は`environment-symbols`手続き（[Chez](https://cisco.github.io/ChezScheme/)の場合）でリストされたトップレベルのバインディング識別子のみを補完したり、識別子でなくシンボルの補完しかできません。つまり、ローカルバインディングや未完成のコードについて、プログラミング上最も重要とされる支援は[Geiser](https://gitlab.com/emacs-geiser)や類似ツールでは識別子の有効スコープ認識の支援ができません。定義へのジャンプやその他多くの機能でも同様の問題が発生します。\n\n主な原因は、Schemeや他のLisp方言では多様なデータセットや柔軟な制御構造があり、プログラム解析の大きな課題となっていることです。特にマクロについては、Schemeは天才やメタ／マクロプログラミング向けの言語だと思われがちですが、私はそうは思いません。より良いプログラミング環境があればSchemeで多くの面白いことができます。そして、今すぐ[**こちらから始められます**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)。\n\nこのパッケージはSchemeプログラミングを支援するLanguage Server Protocol実装です。補完、定義、型推論を提供します。これらの機能は[r6rs標準](http://www.r6rs.org/)および未完成コード向けの明確なルールに基づいた静的コード解析で実現されています。このパッケージおよび関連ライブラリは[Akku](https://akkuscm.org/)（Scheme用パッケージマネージャ）で公開または公開予定です。\n\nこのパッケージは[Chez Scheme](https://cisco.github.io/ChezScheme/)バージョン9.4および9.5でテストされています。バージョン10.0.0については、私のノートPCのOSを新しいバージョンにアップグレードした後に詳細なテストを行います。\n\nこのオープンソース活動は私の余暇時間で行っており、データフロー解析の組み込みなど多くの素晴らしいアイデアをコミュニティに貢献できます。また、より多くの寄付や支援を継続してお願いしています。[Patreonページ](https://www.patreon.com/PoorProgrammer/membership)や[愛発電](https://afdian.com/a/ufo5260987423)からご支援いただけます。\n\n\n## コンパイル・インストール・設定は[こちら](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## 最近の状況\nバグ修正、コードプロファイリング、自作型推論システムに関する巨大な書籍のための情報収集を続けています。これには約1年かかる予定です。今後の開発計画には[VScode](https://code.visualstudio.com/)プラグインやデータフロー解析も含まれます。しかし、現在はこのオープンソース活動をパートタイムとしており、スケジュールの保証はできません。\n\n## リリース\n1.2.9 現在、型推論をお楽しみください！\n\n過去のリリースについては[こちらのファイル](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md)を参照してください。\n\n### 機能一覧\n1. トップレベルおよびローカル識別子バインディングの補完。\n![トップレベルおよびローカル識別子バインディング](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. 定義へのジャンプ。\n![telescope.nvimによる定義へのジャンプ](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. パッケージマネージャAkkuとの互換性。\n4. ファイル変更の同期と対応するインデックスの変更。\n5. ホバー。\n6. 参照とドキュメントハイライト（ドキュメントスコープの参照）。\n![telescope.nvimによる参照検索](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. ドキュメントシンボル。\n![telescope.nvimによるドキュメントシンボル検索](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. *-syntax(define-syntax, let-syntax等)ベースのローカル識別子バインディングの捕捉。\n9. クロスプラットフォーム並列インデックス化。\n10. .spsファイル互換の自作ソースコードアノテーター。\n11. サスペンド可能タスクによるAPIリクエストのピープホール最適化。\n12. 自作DSLインタプリタによる型推論（これは非常に誇りに思っています！）。現在、オートコンプリートにも組み込まれています。下図のように、「length-b」と「length-a」が「integer?」型であり、「<=」が要求するパラメータ型と一致するため、推奨オプションの先頭に表示されています。\n![型推論付きオートコンプリート](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nこの結果を証明するテストは、`scheme --script tests/protocol/apis/test-completion.sps`を実行し、ログファイル`scheme-langserver.log`に次のような結果が含まれていることを確認してください。\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. scm、ss、sps、sls、sldなど異なるファイル拡張子間での識別子捕捉のための抽象インタプリタ。\n\n### 今後の課題\n14. リネーム機能。\n15. [r6rs標準](http://www.r6rs.org/)への完全対応。\n16. ステップバイステップマクロ展開器：実は一つ実装しましたが、自作マクロ内の識別子バインディング捕捉の要となるステップにしたかったのですが、想像以上に難しく、どこで使えば良いのかも分からなくなりました。\n17. コード実行。\n18. コード診断。\n19. クロス言語セマンティックサポートの追加。Java、C、Pythonなど多くの言語もASTトランスフォーマでサポートできるでしょうか？\n20. 式／文を手続きに抽出。\n\n## TODO: コントリビューション \n\n## デバッグ\n\n### デバッグ方法\nhttps://www.scheme.com/debug/debug.html#g1\n\n### 出力ログ\n[ビルド](#building)、[Lunar Vim用インストール](#installation-for-lunarvim)、[VScode用インストール](#todo-installation-for-vscode)の各説明に従い、開発やログ取得をしたい場合は、`path-to-log-file`を追加し、ファイル`~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua`を以下のように書き換えると便利です。\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "status": "ok"
}