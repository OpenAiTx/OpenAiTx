{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nPuoi leggere il mio [articolo](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) e citarlo così:\n> WANG, Z. (2025, 12 maggio). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurigo. https://doi.org/10.5281/zenodo.15384882\n\nPoiché GitHub potrebbe bloccare gli indirizzi IP cinesi, ho dovuto copiare questo repository [qui](https://codeberg.org/ufo5260987423/scheme-langserver) e [qui](https://gitee.com/ufo5260987423/scheme-langserver). Continuerò ad aggiornare tutti i repository ma non posso garantirlo. Ora collaboro anche con [XmacsLabs](https://github.com/XmacsLabs), puoi trovare un fork anche [qui](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Ora, VSCode può usare scheme-langserver!** Fai riferimento [QUI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTA: Ci sono molti, molti bug in scheme-langserver. Li sto correggendo e sto chiedendo aiuto alla comunità. Per favore, sii paziente.\n\n>NOTA: puoi trovare le informazioni sui tipi generate automaticamente [qui](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Attualmente sono utilizzate principalmente per lo sviluppo della prossima fase (forse incluso AKKU) e per il debugging.\n\nImplementare il supporto come completamento automatico, vai alla definizione o documentazione al passaggio del mouse è un impegno significativo per la programmazione. Tuttavia, rispetto ad altri linguaggi come java, python, javascript e c, le implementazioni del language server protocol per i linguaggi lisp sono state sviluppate in un vuoto. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) e [swish-lint](https://github.com/becls/swish-lint) ecc., i loro lavori si basano tutti su `repl` (Read-Eval-Print Loop) o tokenizzatori di parole chiave invece che sulla programmazione. Ad esempio, se un programmatore stesse lavorando su un progetto non completato, in cui i codici non sono completamente eseguibili, [Geiser](https://gitlab.com/emacs-geiser) o altri completerebbero solo gli identificatori di binding di livello superiore elencati dalla procedura `environment-symbols` (per [Chez](https://cisco.github.io/ChezScheme/)), o completerebbero simboli invece di identificatori. Il che significa che per i binding locali e i codici incompleti, anche se lo sforzo per la programmazione dovrebbe essere considerato di primaria importanza, [Geiser](https://gitlab.com/emacs-geiser) e i suoi omologhi non aiutano a riconoscere lo scope valido di un identificatore. Casi simili si verificano con il vai alla definizione e molte altre funzionalità.\n\nUna delle cause principali è che, per scheme e altri dialetti lisp, l'abbondanza di set di dati e le strutture di controllo flessibili rendono l'analisi del programma una grande sfida. Soprattutto la macro, sembra che scheme sia utilizzato principalmente per la programmazione geniale e meta/macro. Ma io dico di no. Scheme può fare molte cose interessanti se viene fornito un ambiente di programmazione migliore. E ora puoi [**INIZIARE QUI**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nQuesto pacchetto è un'implementazione del language server protocol che aiuta la programmazione in scheme. Fornisce completamento, definizione e inferenza dei tipi. Queste funzionalità sono basate sull'analisi statica del codice con [standard r6rs](http://www.r6rs.org/) e alcune regole ovvie per i codici incompleti. Questo pacchetto e le librerie correlate sono pubblicate o saranno pubblicate con [Akku](https://akkuscm.org/), che è un gestore di pacchetti per Scheme.\n\nQuesto pacchetto è stato anche testato con [Chez Scheme](https://cisco.github.io/ChezScheme/) versione 9.4 e 9.5. Un test dettagliato sulla versione 10.0.0 sarà eseguito dopo l'aggiornamento del mio sistema operativo a una versione più recente.\n\nFaccio questo lavoro open source solo nel mio tempo libero e posso contribuire con molte idee brillanti alla comunità, come integrare l'analisi del flusso di dati in scheme-langserver o molte altre cose. E sto continuamente chiedendo più donazioni o finanziamenti. Puoi donare tramite [questa pagina Patreon](https://www.patreon.com/PoorProgrammer/membership) o [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilazione, Installazione & Configurazione sono [QUI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Stato Recente\nContinuerò a correggere bug, profilare il codice e raccogliere informazioni per il mio grande libro sui sistemi di inferenza dei tipi fatti in casa. Questo mi porterà circa 1 anno. Sviluppi futuri includono un plugin per [VScode](https://code.visualstudio.com/) e analisi del flusso di dati. Ma in realtà, ora considero questo lavoro open source come un lavoro part-time, e non posso garantire una tabella di marcia.\n\n## Release \n1.2.9 Ora, goditi l'inferenza dei tipi!\n\nPer le release precedenti fai riferimento a [questo file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Funzionalità\n1. Completamento dei binding di identificatori di livello superiore e locale.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Vai alla definizione.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatibile con il gestore di pacchetti: Akku.\n4. Sincronizzazione delle modifiche ai file e cambiamento degli indici corrispondenti.\n5. Hover.\n6. Riferimenti e evidenziazione dei documenti (riferimenti a livello di documento).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Simbolo del documento.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Cattura del binding locale degli identificatori basati su *-syntax (define-syntax, let-syntax, ecc.).\n9. Indicizzazione parallela cross-platform.\n10. Annotatore del codice sorgente fatto in casa per compatibilità con file .sps.\n11. Ottimizzazione peephole per richieste API con task sospendibile.\n12. Inferenza dei tipi con un interprete DSL fatto in casa (ne sono molto orgoglioso!). Ed ora è stato integrato nel completamento automatico. Come indicato nella figura seguente, \"length-b\" e \"length-a\" di tipo \"integer?\" sono in cima alle opzioni raccomandate perché possono soddisfare il tipo di parametro richiesto da \"<=\".\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nUn test può dimostrare questo risultato, basta eseguire `scheme --script tests/protocol/apis/test-completion.sps` e il file di log `scheme-langserver.log` conterrà risultati come questo:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Interprete astratto per la cattura degli identificatori tra diverse estensioni di file come scm, ss, sps, sls e sld.\n\n### TODOs\n14. Rinominare.\n15. Compatibilità completa con [standard r6rs](http://www.r6rs.org/).\n16. Espansore macro step-by-step: in realtà ne ho già implementato uno e volevo renderlo uno step chiave per catturare il binding degli identificatori nelle macro definite dall'utente. Ora, trovo che questa cattura sia molto più difficile di quanto pensassi, e l'espansore non so dove potrebbe funzionare.\n17. Eval del codice.\n18. Diagnostica del codice.\n19. Aggiungere supporto semantico cross-language. Beh, potrebbero essere supportati java, c, python e molti altri linguaggi con un trasformatore AST?\n20. Estrarre espressioni/istruzioni in una procedura.\n\n## TODO:Contribuire \n\n## Debug\n\n### Come fare debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nSeguendo i suggerimenti da [Compilazione](#building), [Installazione per Lunar Vim](#installation-for-lunarvim) e [Installazione per VScode](#todo-installation-for-vscode), se qualcuno vuole fare del development e loggare qualcosa, sarà conveniente aggiungere `path-to-log-file` e riscrivere il file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` come segue:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, un'implementazione del language server protocol per scheme\n]]   ,\n  },",
  "status": "ok"
}