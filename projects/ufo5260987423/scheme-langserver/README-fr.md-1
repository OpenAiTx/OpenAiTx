{
  "id": 1,
  "origin": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.\n18. Code diagnostic.\n19. Add cross-language semantic supporting. Well, would java, c, python and many other languages can be supported with an AST transformer?\n20. Extract expression/statements into a procedure.\n\n## TODO:Contributing \n\n## Debug\n\n### How to Debug\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Output Log\nFollowing tips from [Building](#building), [Installation for Lunar Vim](#installation-for-lunarvim) and [Installation for VScode](#todo-installation-for-vscode), if anyone wants to do some developing and log something, it will be convenient to add `path-to-log-file` and re-write file `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` as follows:\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, a language server protocol implementation for scheme\n]]   ,\n  },",
  "origin_sha": "ByAuc8ttFDx8I3FA7LrI5TbHTWYZzzYJh6NmdcHCDso=",
  "translate": "![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nVous pouvez lire mon [article](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) et le citer comme ceci \n> WANG, Z. (2025, 12 mai). Scheme-langserver : Considérer l’édition de code Scheme comme une préoccupation de première classe. 18ème Symposium Européen Lisp (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nEn raison du fait que GitHub peut bloquer les adresses IP chinoises, j’ai dû copier ce dépôt [ici](https://codeberg.org/ufo5260987423/scheme-langserver) et [ici](https://gitee.com/ufo5260987423/scheme-langserver). Je continuerai à mettre à jour tous les dépôts, mais je ne peux pas le garantir. Je collabore également maintenant avec [XmacsLabs](https://github.com/XmacsLabs), vous pouvez aussi trouver un fork [ici](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Désormais, VSCode peut utiliser scheme-langserver !** Veuillez vous référer [ICI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>REMARQUE : Il y a encore de très nombreux bugs dans scheme-langserver. Je suis en train de les corriger et je sollicite l’aide de la communauté. Merci de votre patience.\n\n>REMARQUE : vous pouvez trouver les informations de type générées automatiquement [ici](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). Ceci est principalement utilisé pour le développement des prochaines étapes (peut-être incluant AKKU) et le débogage.\n\nImplémenter des fonctionnalités comme l’autocomplétion, le \"goto definition\" ou la documentation au survol représente un effort considérable pour la programmation. Cependant, comparé à d’autres langages comme Java, Python, JavaScript et C, les implémentations du protocole du serveur de langage pour les langages Lisp sont réalisées dans le vide. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) et [swish-lint](https://github.com/becls/swish-lint), etc., leurs travaux sont tous basés sur le `repl` (Read-Eval-Print Loop) ou sur un tokeniseur de mots-clés au lieu d’une véritable programmation. Par exemple, si un programmeur travaille sur un projet non abouti, dans lequel le code n’est pas entièrement exécutable, [Geiser](https://gitlab.com/emacs-geiser) ou d’autres ne complèteront que les identifiants de liaison de niveau supérieur listés par la procédure `environment-symbols` (pour [Chez](https://cisco.github.io/ChezScheme/)), ou complèteront les symboles au lieu des identifiants. Cela signifie que pour les liaisons locales et les codes non aboutis, même si l’effort de programmation est supposé être primordial, [Geiser](https://gitlab.com/emacs-geiser) et ses homologues n’aident en rien à reconnaître la portée valide des identifiants. Des cas similaires se présentent pour le \"goto definition\" et de nombreuses autres fonctionnalités.\n\nUne cause principale est que, pour Scheme et d’autres dialectes Lisp, leur abondance de structures de données et la flexibilité de leurs structures de contrôle rendent l’analyse de programme très complexe. En particulier les macros : on dirait que Scheme est principalement utilisé pour la programmation géniale et méta/macro. Mais je ne suis pas d’accord. Scheme peut permettre beaucoup de choses intéressantes si un meilleur environnement de programmation est fourni. Et maintenant, vous pouvez [**COMMENCER ICI**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nCe paquet est une implémentation du protocole du serveur de langage pour aider à la programmation Scheme. Il fournit la complétion, la définition et l’inférence de type. Ces fonctionnalités reposent sur une analyse statique du code conforme à la [norme r6rs](http://www.r6rs.org/) et à certaines règles évidentes pour les codes non aboutis. Ce paquet et les bibliothèques associées sont publiés ou vont l’être avec [Akku](https://akkuscm.org/), qui est un gestionnaire de paquets pour Scheme.\n\nCe paquet a également été testé avec [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 et 9.5. Un test détaillé sur la version 10.0.0 sera effectué après la mise à jour de mon système d’exploitation.\n\nJe réalise ce travail open source uniquement sur mon temps libre et je peux apporter de nombreuses idées brillantes à la communauté, comme l’intégration de l’analyse de flux de données à scheme-langserver ou bien d’autres choses. Et je sollicite continuellement plus de dons ou de financements. Vous pouvez faire un don via [cette page Patreon](https://www.patreon.com/PoorProgrammer/membership) ou [爱发电](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation, Installation & Configuration c’est [ICI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## État récent\nJe vais continuer à corriger les bugs, profiler le code et collecter des informations pour mon ouvrage de référence sur les systèmes d’inférence de types faits maison. Cela me prendra environ 1 an. Les développements futurs incluent un plugin [VScode](https://code.visualstudio.com/) et l’analyse de flux de données. Mais en réalité, je considère maintenant ce travail open source comme un emploi à temps partiel, et je ne peux pas garantir un calendrier fixe.\n\n## Release \n1.2.9 Maintenant, profitez de l’inférence de type !\n\nPour les versions précédentes, veuillez vous référer à [ce fichier](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Fonctionnalités\n1. Complétion des identifiants de liaison de niveau supérieur et locaux.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible avec le gestionnaire de paquets : Akku.\n4. Synchronisation des modifications de fichiers et mise à jour de l’index correspondant.\n5. Hover.\n6. Références et surlignage des documents (références au sein du document).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Symboles de document.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Capture des liaisons locales basées sur *-syntax (define-syntax, let-syntax, etc.). \n9. Indexation parallèle multiplateforme.\n10. Annotateur de code source maison compatible avec les fichiers .sps.\n11. Optimisation peephole pour les requêtes API avec tâche suspendable.\n12. Inférence de type avec un interpréteur DSL fait maison (j’en suis très fier !). Et maintenant, elle est intégrée à l’autocomplétion. Comme le montre la figure suivante, \"length-b\" et \"length-a\", ayant le type \"integer?\", sont placés en tête des options recommandées car elles correspondent au type de paramètre attendu par \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nUn test peut prouver ce résultat, il suffit d’exécuter `scheme --script tests/protocol/apis/test-completion.sps` et le fichier log `scheme-langserver.log` contiendra des résultats comme ceci :\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Interpréteur abstrait pour la capture d’identifiants entre différentes extensions de fichiers comme scm, ss, sps, sls et sld.\n\n### TODOs\n14. Renommage. \n15. Compatibilité totale avec la [norme r6rs](http://www.r6rs.org/).\n16. Expandeur de macros étape par étape : en fait, j’en ai déjà implémenté un et je voulais en faire une étape clé pour capturer la liaison d’identifiant dans les macros auto-définies. Maintenant, je trouve que cette capture est bien plus difficile que je ne le pensais, et je ne sais pas où mon expandeur pourrait servir.\n17. Évaluation de code.\n18. Diagnostic de code.\n19. Ajouter la prise en charge de la sémantique inter-langages. Eh bien, serait-il possible de supporter Java, C, Python et beaucoup d’autres langages avec un transformateur AST ?\n20. Extraire des expressions/instructions dans une procédure.\n\n## TODO : Contribution \n\n## Débogage\n\n### Comment Déboguer\nhttps://www.scheme.com/debug/debug.html#g1\n\n### Journal de sortie (Output Log)\nEn suivant les conseils de [Compilation](#building), [Installation pour Lunar Vim](#installation-for-lunarvim) et [Installation pour VScode](#todo-installation-for-vscode), si quelqu’un souhaite développer et enregistrer des logs, il sera pratique d’ajouter `path-to-log-file` et de réécrire le fichier `~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua` comme suit :\n```lua\nlocal util = require 'lspconfig.util'\nlocal bin_name = '{path-to-run}'\nlocal cmd = { bin_name ,\"path-to-log-file\"}\n\nreturn {\n  default_config = {\n    cmd = cmd,\n    filetypes = { 'scheme' },\n    root_dir = util.find_git_ancestor,\n    single_file_support = true,\n  },\n  docs = {\n    description = [[\nhttps://github.com/ufo5260987423/scheme-langserver\n`scheme-langserver`, une implémentation du protocole serveur de langage pour scheme\n]]   ,\n  },",
  "status": "ok"
}