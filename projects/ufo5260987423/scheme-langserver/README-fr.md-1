{
  "id": 1,
  "origin": "\n<div align=\"right\">\n  <details>\n    <summary >üåê Language</summary>\n    <div>\n      <div align=\"right\">\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=en\">English</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-CN\">ÁÆÄ‰Ωì‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-TW\">ÁπÅÈ´î‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ja\">Êó•Êú¨Ë™û</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ko\">ÌïúÍµ≠Ïñ¥</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=hi\">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=th\">‡πÑ‡∏ó‡∏¢</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fr\">Fran√ßais</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=de\">Deutsch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=es\">Espa√±ol</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=it\">Itapano</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ru\">–†—É—Å—Å–∫–∏–π</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pt\">Portugu√™s</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=nl\">Nederlands</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pl\">Polski</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ar\">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fa\">ŸÅÿßÿ±ÿ≥€å</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=tr\">T√ºrk√ße</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=vi\">Ti·∫øng Vi·ªát</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=id\">Bahasa Indonesia</a></p>\n      </div>\n    </div>\n  </details>\n</div>\n\n![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nYou may read my [paper](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) and cite like this \n> WANG, Z. (2025, May 12). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nDue to GitHub may block Chinese IP addresses, I have to copy this repository to [here](https://codeberg.org/ufo5260987423/scheme-langserver) and [here](https://gitee.com/ufo5260987423/scheme-langserver). I will continually update all repositories but I can't guarrentee. I now also collaborate with [XmacsLabs](https://github.com/XmacsLabs), you may also find a fork [here](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**Now, VSCode can use scheme-langserver!** Please refere [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>NOTE: There're many many bugs in scheme-langserver. I'm just fixing and appealing help from the community. Please be patient.\n\n>NOTE: you can find the auto generated type information [here](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). It's now mainly used for next-stage-development (maybe include AKKU) and debugging.\n\nImplementing support like autocomplete, goto definition, or documentation on hover is a significant effort for programming. However, comparing to other language like java, python, javascript and c, language server protocol implementation for lisp language are just made in a vacuum. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) and [swish-lint](https://github.com/becls/swish-lint) etc., their works are all based on `repl`(Read-Eval-Print Loop) or keyword tokenizer instead of programming. For example, if a programmer was coding on an unaccomplished project, in which the codes were not fully executable, [Geiser](https://gitlab.com/emacs-geiser) or any others would only complete top-level binding identifiers listed by `environment-symbols` procedure (for [Chez](https://cisco.github.io/ChezScheme/)), or complete symbols instead of identifiers. Which means for local bindings and unaccomplished codes, though making effort for programming is supposed of the importance mostly, [Geiser](https://gitlab.com/emacs-geiser) and its counterparts help nothing on recognizing identifier's valid scope. Familiar cases occur with goto definition and many other functionalities.\n\nA primary cause is, for scheme and other lisp dialects, their abundant data sets and flexible control structures raise program analysis a big challenge. Especially the macro, it seems like that scheme is mainly used for genius and meta/macro programming. But I say no. Scheme can make many interesting things if a better programming environment is provided. And now you may [**STARTUP HERE**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nThis package is a language server protocol implementation helping scheme programming. It provides completion, definition and type inference. These functionalities are established on static code analysis with [r6rs standard](http://www.r6rs.org/) and some obvious rules for unaccomplished codes. This package itself and related libraries are published or going to be published with [Akku](https://akkuscm.org/), which is a package manager for Scheme. \n\nThis package also has been tested with [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 and 9.5. A detailed test on version 10.0.0 will be done after upgrading my laptop OS to a newer version.\n\nI do this open source work just in my spare time and I can contribute many splendid ideas to the community like embedding data flow analysis into scheme-langserver or many other things. And I'm continuously asking for much more donation or funding. You can donate with [this patreon page](https://www.patreon.com/PoorProgrammer/membership) or [Áà±ÂèëÁîµ](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation , Intallation & Configuration is [HERE](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Recent Status\nI'll keep fixing bugs, profiling the code, and collecting information for my giant book on homemade type inference system. This will take me about 1 years. Further developments including a [VScode](https://code.visualstudio.com/) plugin and data flow analysis. But actually, I'm now setting this open source work a part-time job, and I can not guarantee a schedule.\n\n## Release \n1.2.9 Now, enjoy type inference!\n\nPrevious releases please refer to [this file](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Features\n1. Top-level and local identifiers binding completion.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible with package manager: Akku.\n4. File changes synchronizing and corresponding index changing.\n5. Hover.\n6. References and document highlight (document-scoped references).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Document symbol.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Catching *-syntax(define-syntax, let-syntax, etc.) based local identifier binding. \n9. Cross-platform parallel indexing.\n10. Self-made source code annotator to be compatible with .sps files.\n11. Peephole optimization for API requests with suspendable task.\n12. Type inference with a homemade DSL interpreter(I'm very proud of it!). And now it has been embedded into the auto-completion. As the following figure indicated, the \"length-b\" and \"length-a\" having \"integer?\" type are in the front of those recommended options because they can match the parameter type requiring from \"<=\". \n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nA test in can prove this result, just run `scheme --script tests/protocol/apis/test-completion.sps` and the log file `scheme-langserver.log` would contain results like this:\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Abstract interpreter for identifier catching among different file extensions like scm, ss, sps, sls and sld.\n\n### TODOs\n14. Renaming. \n15. Fully compatible with [r6rs standard](http://www.r6rs.org/).\n16. Step-by-step macro expander: well, I actually have implemented one and I wanted to make it a key step catching identifier binding in self-defined macros. Now, I find this catching is much harder than I thought, and the expander I don't know where it could work.\n17. Code eval.",
  "origin_sha": "EUEvRAM1Xn8cCqrPvuBQ0V6xXYO3O33rxE42JkAjX+s=",
  "translate": "<div align=\"right\">\n  <details>\n    <summary >üåê Langue</summary>\n    <div>\n      <div align=\"right\">\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=en\">English</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-CN\">ÁÆÄ‰Ωì‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=zh-TW\">ÁπÅÈ´î‰∏≠Êñá</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ja\">Êó•Êú¨Ë™û</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ko\">ÌïúÍµ≠Ïñ¥</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=hi\">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=th\">‡πÑ‡∏ó‡∏¢</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fr\">Fran√ßais</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=de\">Deutsch</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=es\">Espa√±ol</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=it\">Itapano</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ru\">–†—É—Å—Å–∫–∏–π</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pt\">Portugu√™s</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=nl\">Nederlands</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=pl\">Polski</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=ar\">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=fa\">ŸÅÿßÿ±ÿ≥€å</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=tr\">T√ºrk√ße</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=vi\">Ti·∫øng Vi·ªát</a></p>\n        <p><a href=\"https://openaitx.github.io/view.html?user=ufo5260987423&project=scheme-langserver&lang=id\">Bahasa Indonesia</a></p>\n      </div>\n    </div>\n  </details>\n</div>\n\n![](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png)\n# Scheme-langserver\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ufo5260987423/scheme-langserver)\n\nVous pouvez lire mon [article](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf) et le citer ainsi :\n> WANG, Z. (2025, 12 mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882\n\nEn raison du fait que GitHub peut bloquer les adresses IP chinoises, j'ai d√ª copier ce d√©p√¥t [ici](https://codeberg.org/ufo5260987423/scheme-langserver) et [ici](https://gitee.com/ufo5260987423/scheme-langserver). Je continuerai √† mettre √† jour tous les d√©p√¥ts mais je ne peux pas garantir la synchronisation. Je collabore √©galement avec [XmacsLabs](https://github.com/XmacsLabs), vous pouvez aussi trouver un fork [ici](https://github.com/XmacsLabs/scheme-langserver).\n\n<video src=\"https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb\" controls=\"controls\" width=\"500\" height=\"300\"></video>\n\n**D√©sormais, VSCode peut utiliser scheme-langserver !** Veuillez vous r√©f√©rer [ICI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\n>REMARQUE : Il y a de tr√®s nombreux bugs dans scheme-langserver. Je suis en train de les corriger et je sollicite l'aide de la communaut√©. Merci de votre patience.\n\n>REMARQUE : vous pouvez trouver les informations de types g√©n√©r√©es automatiquement [ici](https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result). C'est actuellement utilis√© principalement pour le d√©veloppement ult√©rieur (peut-√™tre incluant AKKU) et le d√©bogage.\n\nImpl√©menter des fonctionnalit√©s telles que l‚Äôautocompl√©tion, le \"goto definition\" ou la documentation au survol repr√©sente un effort consid√©rable en programmation. Cependant, compar√© √† d'autres langages comme Java, Python, Javascript ou C, l‚Äôimpl√©mentation du protocole de serveur de langage pour les langages Lisp se fait quasiment dans le vide. [Geiser](https://gitlab.com/emacs-geiser), [racket langserver](https://github.com/jeapostrophe/racket-langserver) et [swish-lint](https://github.com/becls/swish-lint) etc., leurs travaux sont tous bas√©s sur le `repl` (Read-Eval-Print Loop) ou un tokeniseur de mots-cl√©s au lieu d'une analyse r√©elle du programme. Par exemple, si un programmeur travaille sur un projet non termin√© dont le code n'est pas pleinement ex√©cutable, [Geiser](https://gitlab.com/emacs-geiser) ou d‚Äôautres ne compl√©teront que les identifiants de liaison de niveau sup√©rieur list√©s par la proc√©dure `environment-symbols` (pour [Chez](https://cisco.github.io/ChezScheme/)), ou compl√©teront uniquement les symboles au lieu des identifiants. Ce qui signifie que pour les liaisons locales et le code non abouti, bien qu‚Äôun travail de fond sur la programmation soit cens√© √™tre primordial, [Geiser](https://gitlab.com/emacs-geiser) et ses √©quivalents n‚Äôaident pas √† reconna√Ætre la port√©e valide des identifiants. Des cas similaires apparaissent avec le \"goto definition\" et beaucoup d‚Äôautres fonctionnalit√©s.\n\nUne raison principale est que, pour Scheme et d‚Äôautres dialectes Lisp, l‚Äôabondance de jeux de donn√©es et la flexibilit√© des structures de contr√¥le rendent l‚Äôanalyse de programme tr√®s complexe. En particulier les macros, il semble que Scheme soit surtout utilis√© pour la programmation de g√©nie et la m√©ta/macro-programmation. Mais je dis non. Scheme peut permettre beaucoup de choses int√©ressantes si un meilleur environnement de programmation est fourni. Et maintenant vous pouvez [**D√âMARRER ICI**](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md).\n\nCe paquet est une impl√©mentation du protocole de serveur de langage facilitant la programmation en Scheme. Il fournit l‚Äôautocompl√©tion, la d√©finition et l‚Äôinf√©rence de types. Ces fonctionnalit√©s sont bas√©es sur une analyse statique du code conforme √† la [norme r6rs](http://www.r6rs.org/) et quelques r√®gles √©videntes pour le code inachev√©. Ce paquet et les biblioth√®ques associ√©es sont publi√©s ou vont l‚Äô√™tre via [Akku](https://akkuscm.org/), qui est un gestionnaire de paquets pour Scheme.\n\nCe paquet a aussi √©t√© test√© avec [Chez Scheme](https://cisco.github.io/ChezScheme/) versions 9.4 et 9.5. Un test d√©taill√© sur la version 10.0.0 sera effectu√© apr√®s la mise √† jour de mon syst√®me d'exploitation.\n\nJe r√©alise ce travail open source uniquement sur mon temps libre et je peux apporter beaucoup d‚Äôid√©es brillantes √† la communaut√©, comme l'int√©gration de l‚Äôanalyse de flux de donn√©es dans scheme-langserver ou bien d‚Äôautres choses. Et je demande continuellement des dons ou financements. Vous pouvez faire un don via [cette page patreon](https://www.patreon.com/PoorProgrammer/membership) ou [Áà±ÂèëÁîµ](https://afdian.com/a/ufo5260987423).\n\n\n## Compilation, Installation & Configuration [ICI](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md)\n\n## Statut actuel\nJe continuerai √† corriger les bugs, √† profiler le code et √† recueillir des informations pour mon livre g√©ant sur les syst√®mes d‚Äôinf√©rence de types faits maison. Cela me prendra environ 1 an. Les d√©veloppements futurs incluent un plugin [VScode](https://code.visualstudio.com/) et l‚Äôanalyse de flux de donn√©es. Mais en r√©alit√©, je consid√®re d√©sormais ce travail open source comme un emploi √† temps partiel, et je ne peux pas garantir un calendrier.\n\n## Release\n1.2.9 Maintenant, profitez de l‚Äôinf√©rence de types !\n\nPour les versions pr√©c√©dentes, veuillez vous r√©f√©rer √† [ce fichier](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md).\n\n### Fonctionnalit√©s\n1. Autocompl√©tion des liaisons d‚Äôidentifiants de niveau sup√©rieur et local.\n![Top-level and local identifiers binding](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png \"Top-level and local identifiers binding\")\n2. Goto definition.\n![Goto definition with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png \"Goto Definition with telescope.nvim\")\n3. Compatible avec le gestionnaire de paquets : Akku.\n4. Synchronisation des modifications de fichiers et modification de l‚Äôindex correspondant.\n5. Survol (hover).\n6. R√©f√©rences et surlignage de document (r√©f√©rences √† l‚Äô√©chelle du document).\n![Find references with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png \"Find references with telescope.nvim\")\n7. Symboles du document.\n![Find document symbols with telescope.nvim](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png \"find document symbols with telescope.nvim\")\n8. Prise en compte des liaisons locales d‚Äôidentifiants bas√©es sur *-syntax (define-syntax, let-syntax, etc.).\n9. Indexation parall√®le multiplateforme.\n10. Annotateur de code source fait maison compatible avec les fichiers .sps.\n11. Optimisation peephole pour les requ√™tes d‚ÄôAPI avec t√¢che suspendable.\n12. Inf√©rence de types avec un interpr√©teur DSL maison (j‚Äôen suis tr√®s fier !). Et maintenant, cela a √©t√© int√©gr√© √† l‚Äôautocompl√©tion. Comme indiqu√© dans la figure suivante, les ‚Äúlength-b‚Äù et ‚Äúlength-a‚Äù de type ‚Äúinteger?‚Äù sont en t√™te des options recommand√©es car elles correspondent au type de param√®tre requis par ‚Äú<=‚Äù.\n![Autocompletion with type inference](https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png \"Autocompletion with type inference\")\nUn test peut prouver ce r√©sultat, il suffit d‚Äôex√©cuter `scheme --script tests/protocol/apis/test-completion.sps` et le fichier journal `scheme-langserver.log` contiendra des r√©sultats comme celui-ci :\n```bash\nsend-message\n2023 11 21 11 26 41 967266866\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"result\":[{\"label\":\"length-a\"},{\"label\":\"length-b\"},{\"label\":\"lambda\"},{\"label\":\"latin-1-codec\"},{\"label\":\"lcm\"},{\"label\":\"least-fixnum\"},{\"label\":\"length\"},{\"label\":\"let\"},{\"label\":\"let*\"},{\"label\":\"let*-values\"},{\"label\":\"let-syntax\"},{\"label\":\"let-values\"},{\"label\":\"letrec\"},{\"label\":\"letrec*\"},{\"label\":\"letrec-syntax\"},{\"label\":\"lexical-violation?\"},{\"label\":\"list\"},{\"label\":\"list->string\"},{\"label\":\"list->vector\"},{\"label\":\"list-ref\"},{\"label\":\"list-sort\"},{\"label\":\"list-tail\"},{\"label\":\"list?\"},{\"label\":\"log\"},{\"label\":\"lookahead-char\"},{\"label\":\"lookahead-u8\"}]}\n```\n13. Interpr√©teur abstrait pour la d√©tection d‚Äôidentifiants entre diff√©rentes extensions de fichiers comme scm, ss, sps, sls et sld.\n\n### TODOs\n14. Renommage.\n15. Pleine compatibilit√© avec la [norme r6rs](http://www.r6rs.org/).\n16. Macro-expanseur pas √† pas : eh bien, j‚Äôen ai effectivement impl√©ment√© un et je voulais en faire une √©tape cl√© pour d√©tecter la liaison des identifiants dans les macros auto-d√©finies. Maintenant, je me rends compte que cette d√©tection est bien plus difficile que pr√©vu, et je ne sais pas o√π l‚Äôexpanseur pourrait r√©ellement fonctionner.\n17. √âvaluation de code.",
  "status": "ok"
}