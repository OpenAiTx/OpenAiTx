# JavaScript - Algorytmy i Struktury Danych

> üá∫üá¶ UKRAINA [JEST ATAKOWANA](https://war.ukraine.ua/) PRZEZ ARMIƒò ROSYJSKƒÑ. CYWILE SƒÑ ZABIJANI. OBSZARY MIESZKALNE SƒÑ BOMBARDOWANE.
> - Wesprzyj Ukrainƒô poprzez:
>   - [Fundacjƒô CharytatywnƒÖ Serhija Prytuli](https://prytulafoundation.org/en/)
>   - [Fundacjƒô Come Back Alive](https://savelife.in.ua/en/donate-en/)
>   - [Narodowy Bank Ukrainy](https://bank.gov.ua/en/news/all/natsionalniy-bank-vidkriv-spetsrahunok-dlya-zboru-koshtiv-na-potrebi-armiyi)
> - Wiƒôcej informacji na [war.ukraine.ua](https://war.ukraine.ua/) oraz [MFA Ukrainy](https://twitter.com/MFA_Ukraine)

<hr/>

[![CI](https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg)](https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster)
[![codecov](https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg)](https://codecov.io/gh/trekhleb/javascript-algorithms)
![repo size](https://img.shields.io/github/repo-size/trekhleb/javascript-algorithms.svg)

To repozytorium zawiera przyk≈Çady wielu
popularnych algorytm√≥w i struktur danych opartych na JavaScript.

Ka≈ºdy algorytm i struktura danych posiada osobny plik README
z odpowiednimi wyja≈õnieniami i linkami do dalszej lektury (w tym do
film√≥w na YouTube).

_Przeczytaj to w innych jƒôzykach:_
[_ÁÆÄ‰Ωì‰∏≠Êñá_](README.zh-CN.md),
[_ÁπÅÈ´î‰∏≠Êñá_](README.zh-TW.md),
[_ÌïúÍµ≠Ïñ¥_](README.ko-KR.md),
[_Êó•Êú¨Ë™û_](README.ja-JP.md),
[_Polski_](README.pl-PL.md),
[_Fran√ßais_](README.fr-FR.md),
[_Espa√±ol_](README.es-ES.md),
[_Portugu√™s_](README.pt-BR.md),
[_–†—É—Å—Å–∫–∏–π_](README.ru-RU.md),
[_T√ºrk√ße_](README.tr-TR.md),
[_Italiano_](README.it-IT.md),
[_Bahasa Indonesia_](README.id-ID.md),
[_–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞_](README.uk-UA.md),
[_Arabic_](README.ar-AR.md),
[_Ti·∫øng Vi·ªát_](README.vi-VN.md),
[_Deutsch_](README.de-DE.md),
[_Uzbek_](README.uz-UZ.md),
[_◊¢◊ë◊®◊ô◊™_](README.he-IL.md)

*‚òù Zauwa≈º, ≈ºe ten projekt jest przeznaczony wy≈ÇƒÖcznie do nauki i bada≈Ñ
i **nie** jest przeznaczony do produkcji.*

## Struktury Danych

Struktura danych to okre≈õlony spos√≥b organizowania i przechowywania danych w komputerze, tak aby mo≈ºna by≈Ço
je efektywnie pobieraƒá i modyfikowaƒá. Dok≈Çadniej, struktura danych to zbi√≥r warto≈õci danych,
relacji miƒôdzy nimi oraz funkcji lub operacji, kt√≥re mo≈ºna na tych danych wykonywaƒá.

Pamiƒôtaj, ≈ºe ka≈ºda struktura danych ma swoje kompromisy. Bardziej ni≈º na tym, jak jƒÖ zaimplementowaƒá, powiniene≈õ zwracaƒá uwagƒô, dlaczego wybierasz w≈Ça≈õnie tƒô strukturƒô danych.

`B` - PoczƒÖtkujƒÖcy, `A` - Zaawansowany

* `B` [Lista jednokierunkowa](src/data-structures/linked-list)
* `B` [Lista dwukierunkowa](src/data-structures/doubly-linked-list)
* `B` [Kolejka](src/data-structures/queue)
* `B` [Stos](src/data-structures/stack)
* `B` [Tablica mieszajƒÖca (Hash Table)](src/data-structures/hash-table)
* `B` [Kopiec (Heap)](src/data-structures/heap) - wersje max i min kopca
* `B` [Kolejka priorytetowa](src/data-structures/priority-queue)
* `A` [Trie](src/data-structures/trie)
* `A` [Drzewo](src/data-structures/tree)
  * `A` [Drzewo BST](src/data-structures/tree/binary-search-tree)
  * `A` [Drzewo AVL](src/data-structures/tree/avl-tree)
  * `A` [Drzewo czerwono-czarne](src/data-structures/tree/red-black-tree)
  * `A` [Drzewo przedzia≈Çowe (Segment Tree)](src/data-structures/tree/segment-tree) - z przyk≈Çadami zapyta≈Ñ min/max/suma w zakresie
  * `A` [Drzewo Fenwicka](src/data-structures/tree/fenwick-tree) (Binary Indexed Tree)
* `A` [Graf](src/data-structures/graph) (zar√≥wno skierowany, jak i nieskierowany)
* `A` [Zbi√≥r roz≈ÇƒÖczny (Disjoint Set)](src/data-structures/disjoint-set) - struktura zbior√≥w roz≈ÇƒÖcznych (union‚Äìfind)
* `A` [Filtr Blooma (Bloom Filter)](src/data-structures/bloom-filter)
* `A` [LRU Cache](src/data-structures/lru-cache/) - cache o strategii Least Recently Used

## Algorytmy

Algorytm to jednoznaczna specyfikacja sposobu rozwiƒÖzania okre≈õlonej klasy problem√≥w. To
zbi√≥r regu≈Ç dok≈Çadnie okre≈õlajƒÖcych sekwencjƒô operacji.

`B` - PoczƒÖtkujƒÖcy, `A` - Zaawansowany

### Algorytmy wed≈Çug tematu

* **Matematyka**
  * `B` [Operacje na bitach](src/algorithms/math/bits) - ustawianie/pobieranie/aktualizacja/czyszczenie bit√≥w, mno≈ºenie/dzielenie przez dwa, negacja itd.
  * `B` [Liczby zmiennoprzecinkowe binarne](src/algorithms/math/binary-floating-point) - binarna reprezentacja liczb zmiennoprzecinkowych.
  * `B` [Silnia](src/algorithms/math/factorial)
  * `B` [Liczby Fibonacciego](src/algorithms/math/fibonacci) - wersje klasyczne i zamkniƒôte
  * `B` [Czynniki pierwsze](src/algorithms/math/prime-factors) - znajdowanie i liczenie czynnik√≥w pierwszych (twierdzenie Hardy'ego-Ramanujana)
  * `B` [Test pierwszo≈õci](src/algorithms/math/primality-test) (metoda dzielenia pr√≥bnego)
  * `B` [Algorytm Euklidesa](src/algorithms/math/euclidean-algorithm) - najwiƒôkszy wsp√≥lny dzielnik (GCD)
  * `B` [Najmniejsza wsp√≥lna wielokrotno≈õƒá](src/algorithms/math/least-common-multiple) (LCM)
  * `B` [Sito Eratostenesa](src/algorithms/math/sieve-of-eratosthenes) - znajdowanie wszystkich liczb pierwszych do okre≈õlonej granicy
  * `B` [Czy potƒôga dw√≥jki](src/algorithms/math/is-power-of-two) - sprawdzenie czy liczba jest potƒôgƒÖ dw√≥jki (naiwne i bitowe algorytmy)
  * `B` [Tr√≥jkƒÖt Pascala](src/algorithms/math/pascal-triangle)
  * `B` [Liczby zespolone](src/algorithms/math/complex-number) - liczby zespolone i podstawowe operacje
  * `B` [Radiany i stopnie](src/algorithms/math/radian) - konwersja radian√≥w na stopnie i odwrotnie
  * `B` [Szybkie potƒôgowanie](src/algorithms/math/fast-powering)
  * `B` [Metoda Hornera](src/algorithms/math/horner-method) - obliczanie warto≈õci wielomianu
  * `B` [Macierze](src/algorithms/math/matrix) - macierze i operacje na nich (mno≈ºenie, transpozycja itd.)
  * `B` [Odleg≈Ço≈õƒá Euklidesowa](src/algorithms/math/euclidean-distance) - odleg≈Ço≈õƒá miƒôdzy punktami/wektorami/macierzami
  * `A` [Rozk≈Çad liczby na sumy](src/algorithms/math/integer-partition)
  * `A` [Pierwiastek kwadratowy](src/algorithms/math/square-root) - metoda Newtona
  * `A` [Algorytm Liu Hui do przybli≈ºania liczby œÄ](src/algorithms/math/liu-hui) - przybli≈ºenia œÄ na podstawie N-wielokƒÖt√≥w
  * `A` [Dyskretny transformata Fouriera](src/algorithms/math/fourier-transform) - rozk≈Çad sygna≈Çu na czƒôstotliwo≈õci
* **Zbiory**
  * `B` [Iloczyn kartezja≈Ñski](src/algorithms/sets/cartesian-product) - iloczyn wielu zbior√≥w
  * `B` [Tasowanie Fishera‚ÄìYatesa](src/algorithms/sets/fisher-yates) - losowa permutacja sko≈Ñczonej sekwencji
  * `A` [Zbi√≥r potƒôgowy](src/algorithms/sets/power-set) - wszystkie podzbiory zbioru (bitowe, rekurencyjne, kaskadowe)
  * `A` [Permutacje](src/algorithms/sets/permutations) (z powt√≥rzeniami i bez)
  * `A` [Kombinacje](src/algorithms/sets/combinations) (z powt√≥rzeniami i bez)
  * `A` [Najd≈Çu≈ºszy wsp√≥lny podciƒÖg](src/algorithms/sets/longest-common-subsequence) (LCS)
  * `A` [Najd≈Çu≈ºszy rosnƒÖcy podciƒÖg](src/algorithms/sets/longest-increasing-subsequence)
  * `A` [Najkr√≥tsza wsp√≥lna nadsekwencja](src/algorithms/sets/shortest-common-supersequence) (SCS)
  * `A` [Problem plecakowy](src/algorithms/sets/knapsack-problem) - wersje "0/1" i "bez ogranicze≈Ñ"
  * `A` [Maksymalny podciƒÖg sumy](src/algorithms/sets/maximum-subarray) - wersje "brute force" i "dynamiczne programowanie" (Kadane)
  * `A` [Suma kombinacji](src/algorithms/sets/combination-sum) - znajdowanie wszystkich kombinacji dajƒÖcych okre≈õlonƒÖ sumƒô
* **CiƒÖgi znak√≥w**
  * `B` [Odleg≈Ço≈õƒá Hamminga](src/algorithms/string/hamming-distance) - liczba pozycji, na kt√≥rych znaki siƒô r√≥≈ºniƒÖ
  * `B` [Palindrom](src/algorithms/string/palindrome) - sprawdzenie czy ciƒÖg jest taki sam od ko≈Ñca
  * `A` [Odleg≈Ço≈õƒá Levenshteina](src/algorithms/string/levenshtein-distance) - minimalna odleg≈Ço≈õƒá edycyjna miƒôdzy dwoma sekwencjami
  * `A` [Algorytm Knutha‚ÄìMorrisa‚ÄìPratta](src/algorithms/string/knuth-morris-pratt) (KMP) - wyszukiwanie podciƒÖgu (dopasowywanie wzorca)
  * `A` [Algorytm Z](src/algorithms/string/z-algorithm) - wyszukiwanie podciƒÖgu (dopasowywanie wzorca)
  * `A` [Algorytm Rabina-Karpa](src/algorithms/string/rabin-karp) - wyszukiwanie podciƒÖgu
  * `A` [Najd≈Çu≈ºszy wsp√≥lny podciƒÖg znak√≥w](src/algorithms/string/longest-common-substring)
  * `A` [Dopasowanie wyra≈ºenia regularnego](src/algorithms/string/regular-expression-matching)
* **Wyszukiwanie**
  * `B` [Wyszukiwanie liniowe](src/algorithms/search/linear-search)
  * `B` [Wyszukiwanie skokowe](src/algorithms/search/jump-search) (blokowe) - w posortowanej tablicy
  * `B` [Wyszukiwanie binarne](src/algorithms/search/binary-search) - w posortowanej tablicy
  * `B` [Wyszukiwanie interpolacyjne](src/algorithms/search/interpolation-search) - w r√≥wnomiernie roz≈Ço≈ºonej tablicy posortowanej
* **Sortowanie**
  * `B` [Sortowanie bƒÖbelkowe](src/algorithms/sorting/bubble-sort)
  * `B` [Sortowanie przez wyb√≥r](src/algorithms/sorting/selection-sort)
  * `B` [Sortowanie przez wstawianie](src/algorithms/sorting/insertion-sort)
  * `B` [Sortowanie przez kopcowanie](src/algorithms/sorting/heap-sort)
  * `B` [Sortowanie przez scalanie](src/algorithms/sorting/merge-sort)
  * `B` [Quicksort](src/algorithms/sorting/quick-sort) - implementacje in-place i nie-in-place
  * `B` [Shellsort](src/algorithms/sorting/shell-sort)
  * `B` [Sortowanie przez zliczanie](src/algorithms/sorting/counting-sort)
  * `B` [Sortowanie pozycyjne (Radix Sort)](src/algorithms/sorting/radix-sort)
  * `B` [Sortowanie kube≈Çkowe (Bucket Sort)](src/algorithms/sorting/bucket-sort)
* **Listy**
  * `B` [Przechodzenie w prz√≥d](src/algorithms/linked-list/traversal)
  * `B` [Przechodzenie wstecz](src/algorithms/linked-list/reverse-traversal)
* **Drzewa**
  * `B` [Przeszukiwanie wg≈ÇƒÖb (DFS)](src/algorithms/tree/depth-first-search)
  * `B` [Przeszukiwanie wszerz (BFS)](src/algorithms/tree/breadth-first-search)
* **Grafy**
  * `B` [Przeszukiwanie wg≈ÇƒÖb (DFS)](src/algorithms/graph/depth-first-search)
  * `B` [Przeszukiwanie wszerz (BFS)](src/algorithms/graph/breadth-first-search)
  * `B` [Algorytm Kruskala](src/algorithms/graph/kruskal) - znajdowanie minimalnego drzewa rozpinajƒÖcego (MST) dla wa≈ºonego grafu nieskierowanego
  * `A` [Algorytm Dijkstry](src/algorithms/graph/dijkstra) - najkr√≥tsze ≈õcie≈ºki do wszystkich wierzcho≈Çk√≥w grafu
  * `A` [Algorytm Bellmana-Forda](src/algorithms/graph/bellman-ford) - najkr√≥tsze ≈õcie≈ºki do wszystkich wierzcho≈Çk√≥w grafu
  * `A` [Algorytm Floyda-Warshalla](src/algorithms/graph/floyd-warshall) - najkr√≥tsze ≈õcie≈ºki miƒôdzy wszystkimi parami wierzcho≈Çk√≥w
  * `A` [Wykrywanie cykli](src/algorithms/graph/detect-cycle) - dla graf√≥w skierowanych i nieskierowanych (wersje DFS i zbior√≥w roz≈ÇƒÖcznych)
  * `A` [Algorytm Prima](src/algorithms/graph/prim) - znajdowanie minimalnego drzewa rozpinajƒÖcego (MST) dla wa≈ºonego grafu nieskierowanego
  * `A` [Sortowanie topologiczne](src/algorithms/graph/topological-sorting) - metoda DFS
  * `A` [Punkty artykulacji](src/algorithms/graph/articulation-points) - algorytm Tarjana (na bazie DFS)
  * `A` [Mosty](src/algorithms/graph/bridges) - algorytm na bazie DFS
  * `A` [≈öcie≈ºka Eulera i cykl Eulera](src/algorithms/graph/eulerian-path) - algorytm Fleury'ego - ka≈ºda krawƒôd≈∫ odwiedzona dok≈Çadnie raz
  * `A` [Cykl Hamiltona](src/algorithms/graph/hamiltonian-cycle) - ka≈ºdy wierzcho≈Çek odwiedzony dok≈Çadnie raz
  * `A` [Silnie sp√≥jne sk≈Çadowe](src/algorithms/graph/strongly-connected-components) - algorytm Kosaraju
  * `A` [Problem komiwoja≈ºera](src/algorithms/graph/travelling-salesman) - najkr√≥tsza mo≈ºliwa trasa odwiedzajƒÖca ka≈ºde miasto i wracajƒÖca do punktu poczƒÖtkowego
* **Kryptografia**
  * `B` [Hash wielomianowy](src/algorithms/cryptography/polynomial-hash) - haszowanie "rolling hash" na bazie wielomianu
  * `B` [Szyfr p≈Çotkowy (Rail Fence Cipher)](src/algorithms/cryptography/rail-fence-cipher) - szyfr przestawieniowy
  * `B` [Szyfr Cezara](src/algorithms/cryptography/caesar-cipher) - prosty szyfr podstawieniowy
  * `B` [Szyfr Hilla](src/algorithms/cryptography/hill-cipher) - szyfr podstawieniowy oparty na algebrze liniowej
* **Uczenie maszynowe**
  * `B` [NanoNeuron](https://github.com/trekhleb/nano-neuron) - 7 prostych funkcji JS ilustrujƒÖcych naukƒô maszynowƒÖ (propagacja w prz√≥d/wstecz)
  * `B` [k-NN](src/algorithms/ml/knn) - algorytm klasyfikacji najbli≈ºszych sƒÖsiad√≥w
  * `B` [k-Means](src/algorithms/ml/k-means) - algorytm klastrowania k-≈õrednich
* **Przetwarzanie obraz√≥w**
  * `B` [Seam Carving](src/algorithms/image-processing/seam-carving) - algorytm zmiany rozmiaru obrazu z zachowaniem tre≈õci
* **Statystyka**
  * `B` [Losowanie wa≈ºone](src/algorithms/statistics/weighted-random) - wyb√≥r losowego elementu z listy na podstawie wag
* **Algorytmy ewolucyjne**
  * `A` [Algorytm genetyczny](https://github.com/trekhleb/self-parking-car-evolution) - przyk≈Çad zastosowania algorytmu genetycznego do trenowania samoparkujƒÖcych siƒô samochod√≥w
* **Nieprzypisane**
  * `B` [Wie≈ºe Hanoi](src/algorithms/uncategorized/hanoi-tower)
  * `B` [Obr√≥t kwadratowej macierzy](src/algorithms/uncategorized/square-matrix-rotation) - algorytm in-place
  * `B` [Gra skok√≥w](src/algorithms/uncategorized/jump-game) - przyk≈Çady z u≈ºyciem rekurencji, programowania dynamicznego (top-down, bottom-up) i zach≈Çannego
  * `B` [Unikalne ≈õcie≈ºki](src/algorithms/uncategorized/unique-paths) - przyk≈Çady z u≈ºyciem rekurencji, programowania dynamicznego i tr√≥jkƒÖta Pascala
  * `B` [Tarasy deszczowe](src/algorithms/uncategorized/rain-terraces) - problem magazynowania wody (wersje DP i brute force)
  * `B` [Rekurencyjne schody](src/algorithms/uncategorized/recursive-staircase) - liczba sposob√≥w wej≈õcia na szczyt (4 rozwiƒÖzania)
  * `B` [Najlepszy czas na kupno/sprzeda≈º akcji](src/algorithms/uncategorized/best-time-to-buy-sell-stocks) - przyk≈Çady podzia≈Çu i podboju oraz jednokrotnego przej≈õcia
  * `B` [Poprawno≈õƒá nawias√≥w](src/algorithms/stack/valid-parentheses) - sprawdzenie czy ciƒÖg zawiera poprawne nawiasy (stos)
  * `A` [Problem N-hetman√≥w](src/algorithms/uncategorized/n-queens)
  * `A` [Trasa skoczka szachowego](src/algorithms/uncategorized/knight-tour)

### Algorytmy wed≈Çug paradygmatu

Paradygmat algorytmiczny to og√≥lna metoda lub podej≈õcie le≈ºƒÖce u podstaw projektowania danej klasy
algorytm√≥w. Jest to abstrakcja wy≈ºszego poziomu ni≈º pojƒôcie algorytmu, podobnie jak
algorytm jest abstrakcjƒÖ wy≈ºszƒÖ ni≈º program komputerowy.

* **Brute Force** ‚Äì sprawdza wszystkie mo≈ºliwo≈õci i wybiera najlepsze rozwiƒÖzanie
  * `B` [Wyszukiwanie liniowe](src/algorithms/search/linear-search)
  * `B` [Tarasy deszczowe](src/algorithms/uncategorized/rain-terraces) - problem magazynowania wody
  * `B` [Rekurencyjne schody](src/algorithms/uncategorized/recursive-staircase) - liczba sposob√≥w wej≈õcia na szczyt
  * `A` [Maksymalny podciƒÖg sumy](src/algorithms/sets/maximum-subarray)
  * `A` [Problem komiwoja≈ºera](src/algorithms/graph/travelling-salesman) - najkr√≥tsza mo≈ºliwa trasa odwiedzajƒÖca ka≈ºde miasto i wracajƒÖca do punktu poczƒÖtkowego
  * `A` [Dyskretny transformata Fouriera](src/algorithms/math/fourier-transform) - rozk≈Çad sygna≈Çu na czƒôstotliwo≈õci
* **Zach≈Çanne** ‚Äì wybiera najlepszƒÖ opcjƒô w danej chwili, nie patrzƒÖc na przysz≈Ço≈õƒá
  * `B` [Gra skok√≥w](src/algorithms/uncategorized/jump-game)
  * `A` [Problem plecakowy bez ogranicze≈Ñ](src/algorithms/sets/knapsack-problem)
  * `A` [Algorytm Dijkstry](src/algorithms/graph/dijkstra) - najkr√≥tsza ≈õcie≈ºka do wszystkich wierzcho≈Çk√≥w grafu
  * `A` [Algorytm Prima](src/algorithms/graph/prim) - minimalne drzewo rozpinajƒÖce (MST)
  * `A` [Algorytm Kruskala](src/algorithms/graph/kruskal) - minimalne drzewo rozpinajƒÖce (MST)
* **Podzia≈Ç i podb√≥j** ‚Äì dzieli problem na mniejsze czƒô≈õci, a nastƒôpnie rozwiƒÖzuje je
  * `B` [Wyszukiwanie binarne](src/algorithms/search/binary-search)
  * `B` [Wie≈ºe Hanoi](src/algorithms/uncategorized/hanoi-tower)
  * `B` [Tr√≥jkƒÖt Pascala](src/algorithms/math/pascal-triangle)
  * `B` [Algorytm Euklidesa](src/algorithms/math/euclidean-algorithm) - najwiƒôkszy wsp√≥lny dzielnik (GCD)
  * `B` [Sortowanie przez scalanie](src/algorithms/sorting/merge-sort)
  * `B` [Quicksort](src/algorithms/sorting/quick-sort)
  * `B` [Przeszukiwanie drzewa DFS](src/algorithms/tree/depth-first-search)
  * `B` [Przeszukiwanie grafu DFS](src/algorithms/graph/depth-first-search)
  * `B` [Macierze](src/algorithms/math/matrix) - generowanie i przechodzenie macierzy o r√≥≈ºnych kszta≈Çtach
  * `B` [Gra skok√≥w](src/algorithms/uncategorized/jump-game)
  * `B` [Szybkie potƒôgowanie](src/algorithms/math/fast-powering)
  * `B` [Najlepszy czas na kupno/sprzeda≈º akcji](src/algorithms/uncategorized/best-time-to-buy-sell-stocks) - podzia≈Ç i podb√≥j oraz przyk≈Çady jednokrotnego przej≈õcia
  * `A` [Permutacje](src/algorithms/sets/permutations) (z powt√≥rzeniami i bez)
  * `A` [Kombinacje](src/algorithms/sets/combinations) (z powt√≥rzeniami i bez)
  * `A` [Maksymalny podciƒÖg sumy](src/algorithms/sets/maximum-subarray)
* **Programowanie dynamiczne** ‚Äì buduje rozwiƒÖzanie na podstawie wcze≈õniej znalezionych podrozwiƒÖza≈Ñ
  * `B` [Liczby Fibonacciego](src/algorithms/math/fibonacci)
  * `B` [Gra skok√≥w](src/algorithms/uncategorized/jump-game)
  * `B` [Unikalne ≈õcie≈ºki](src/algorithms/uncategorized/unique-paths)
  * `B` [Tarasy deszczowe](src/algorithms/uncategorized/rain-terraces) - problem magazynowania wody
  * `B` [Rekurencyjne schody](src/algorithms/uncategorized/recursive-staircase) - liczba sposob√≥w wej≈õcia na szczyt
  * `B` [Seam Carving](src/algorithms/image-processing/seam-carving) - zmiana rozmiaru obrazu z zachowaniem tre≈õci
  * `A` [Odleg≈Ço≈õƒá Levenshteina](src/algorithms/string/levenshtein-distance) - minimalna odleg≈Ço≈õƒá edycyjna
  * `A` [Najd≈Çu≈ºszy wsp√≥lny podciƒÖg](src/algorithms/sets/longest-common-subsequence) (LCS)
  * `A` [Najd≈Çu≈ºszy wsp√≥lny podciƒÖg znak√≥w](src/algorithms/string/longest-common-substring)
  * `A` [Najd≈Çu≈ºszy rosnƒÖcy podciƒÖg](src/algorithms/sets/longest-increasing-subsequence)
  * `A` [Najkr√≥tsza wsp√≥lna nadsekwencja](src/algorithms/sets/shortest-common-supersequence)
  * `A` [Problem plecakowy 0/1](src/algorithms/sets/knapsack-problem)
  * `A` [Rozk≈Çad liczby na sumy](src/algorithms/math/integer-partition)
  * `A` [Maksymalny podciƒÖg sumy](src/algorithms/sets/maximum-subarray)
  * `A` [Algorytm Bellmana-Forda](src/algorithms/graph/bellman-ford) - najkr√≥tsza ≈õcie≈ºka do wszystkich wierzcho≈Çk√≥w grafu
  * `A` [Algorytm Floyda-Warshalla](src/algorithms/graph/floyd-warshall) - najkr√≥tsze ≈õcie≈ºki miƒôdzy wszystkimi parami wierzcho≈Çk√≥w
  * `A` [Dopasowanie wyra≈ºenia regularnego](src/algorithms/string/regular-expression-matching)
* **Backtracking** ‚Äì podobnie jak brute force, generuje wszystkie mo≈ºliwe rozwiƒÖzania, ale za ka≈ºdym razem, gdy generuje kolejne rozwiƒÖzanie, sprawdza
czy spe≈Çnia wszystkie warunki i tylko wtedy kontynuuje generowanie dalszych rozwiƒÖza≈Ñ. W przeciwnym razie cofa siƒô i wybiera innƒÖ ≈õcie≈ºkƒô. Zazwyczaj u≈ºywane jest przechodzenie DFS po przestrzeni stan√≥w.
  * `B` [Gra skok√≥w](src/algorithms/uncategorized/jump-game)
  * `B` [Unikalne ≈õcie≈ºki](src/algorithms/uncategorized/unique-paths)
  * `B` [Zbi√≥r potƒôgowy](src/algorithms/sets/power-set) - wszystkie podzbiory zbioru
  * `A` [Cykl Hamiltona](src/algorithms/graph/hamiltonian-cycle) - ka≈ºdy wierzcho≈Çek odwiedzony dok≈Çadnie raz
  * `A` [Problem N-hetman√≥w](src/algorithms/uncategorized/n-queens)
  * `A` [Trasa skoczka szachowego](src/algorithms/uncategorized/knight-tour)
  * `A` [Suma kombinacji](src/algorithms/sets/combination-sum) - wszystkie kombinacje dajƒÖce okre≈õlonƒÖ sumƒô
* **Branch & Bound** ‚Äì zapamiƒôtuje najta≈Ñsze rozwiƒÖzanie znalezione na danym etapie przeszukiwania backtrackingowego
i wykorzystuje koszt najlepszego znalezionego rozwiƒÖzania jako dolne ograniczenie, by odrzucaƒá czƒô≈õciowe rozwiƒÖzania o wiƒôkszych kosztach. Zazwyczaj u≈ºywana jest kombinacja BFS i DFS po drzewie przestrzeni stan√≥w.

## Jak u≈ºywaƒá tego repozytorium

**Zainstaluj wszystkie zale≈ºno≈õci**

```
npm install
```

**Uruchom ESLint**

Mo≈ºesz uruchomiƒá ten program, aby sprawdziƒá jako≈õƒá kodu.

```
npm run lint
```

**Uruchom wszystkie testy**

```
npm test
```

**Uruchom testy wed≈Çug nazwy**

```
npm test -- 'LinkedList'
```

**RozwiƒÖzywanie problem√≥w**

Je≈õli lintowanie lub testowanie siƒô nie powiod≈Ço, spr√≥buj usunƒÖƒá folder `node_modules` i ponownie zainstalowaƒá pakiety npm:

```
rm -rf ./node_modules
npm i
```

Upewnij siƒô tak≈ºe, ≈ºe u≈ºywasz w≈Ça≈õciwej wersji Node (`>=16`). Je≈õli u≈ºywasz [nvm](https://github.com/nvm-sh/nvm) do zarzƒÖdzania wersjƒÖ Node, mo≈ºesz uruchomiƒá `nvm use` z katalogu g≈Ç√≥wnego projektu, a odpowiednia wersja zostanie wybrana.

**Playground**

Mo≈ºesz pobawiƒá siƒô strukturami danych i algorytmami w pliku `./src/playground/playground.js` oraz napisaƒá
do niego testy w `./src/playground/__test__/playground.test.js`.

Nastƒôpnie po prostu uruchom poni≈ºszƒÖ komendƒô, aby sprawdziƒá, czy Tw√≥j kod dzia≈Ça zgodnie z oczekiwaniami:

```
npm test -- 'playground'
```

## Przydatne informacje

### ≈πr√≥d≈Ça

- [‚ñ∂ Struktury danych i algorytmy na YouTube](https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)
- [‚úçüèª Szkice struktur danych](https://okso.app/showcase/data-structures)

### Notacja Big O

*Notacja Big O* s≈Çu≈ºy do klasyfikowania algorytm√≥w wed≈Çug tego, jak ro≈õnie ich czas dzia≈Çania lub wymagania pamiƒôciowe wraz ze wzrostem rozmiaru danych wej≈õciowych.
Na poni≈ºszym wykresie przedstawiono najczƒô≈õciej spotykane rzƒôdy wzrostu algorytm√≥w w notacji Big O.

![Big O graphs](./assets/big-o-graph.png)

≈πr√≥d≈Ço: [Big O Cheat Sheet](http://bigocheatsheet.com/).

Poni≈ºej znajduje siƒô lista najczƒô≈õciej u≈ºywanych notacji Big O i ich por√≥wnanie wydajno≈õciowe dla r√≥≈ºnych rozmiar√≥w danych wej≈õciowych.

| Notacja Big O   | Typ         | Obliczenia dla 10 element√≥w | Obliczenia dla 100 element√≥w | Obliczenia dla 1000 element√≥w   |
| --------------- | ----------- | --------------------------- | ---------------------------- | ------------------------------- |
| **O(1)**        | Sta≈Ça       | 1                           | 1                            | 1                               |
| **O(log N)**    | Logarytmiczny| 3                           | 6                            | 9                               |
| **O(N)**        | Liniowy     | 10                          | 100                          | 1000                            |
| **O(N log N)**  | N log(n)    | 30                          | 600                          | 9000                            |
| **O(N^2)**      | Kwadratowy  | 100                         | 10000                        | 1000000                         |
| **O(2^N)**      | Wyk≈Çadniczy | 1024                        | 1.26e+29                     | 1.07e+301                       |
| **O(N!)**       | Silniowy    | 3628800                     | 9.3e+157                     | 4.02e+2567                      |

### Z≈Ço≈ºono≈õƒá operacji na strukturach danych

| Struktura danych         | Odczyt    | Wyszukiwanie | Wstawianie | Usuwanie   | Uwagi  |
| ------------------------ | :-------: | :----------: | :--------: | :--------: | :----- |
| **Tablica**              | 1         | n            | n          | n          |        |
| **Stos**                 | n         | n            | 1          | 1          |        |
| **Kolejka**              | n         | n            | 1          | 1          |        |
| **Lista jednokierunkowa**| n         | n            | 1          | n          |        |
| **Tablica mieszajƒÖca**   | -         | n            | n          | n          | Przy idealnej funkcji hashujƒÖcej O(1) |
| **Drzewo BST**           | n         | n            | n          | n          | Przy zbalansowanym drzewie O(log(n)) |
| **Drzewo B**             | log(n)    | log(n)       | log(n)     | log(n)     |        |
| **Drzewo czerwono-czarne**| log(n)   | log(n)       | log(n)     | log(n)     |        |
| **Drzewo AVL**           | log(n)    | log(n)       | log(n)     | log(n)     |        |
| **Filtr Blooma**         | -         | 1            | 1          | -          | Mo≈ºliwe fa≈Çszywe trafienia przy wyszukiwaniu |

### Z≈Ço≈ºono≈õƒá algorytm√≥w sortowania tablic

| Nazwa                 | Najlepszy        | ≈öredni               | Najgorszy             | Pamiƒôƒá    | Stabilny   | Uwagi     |
| --------------------- | :--------------: | :------------------: | :-------------------: | :-------: | :--------: | :-------- |
| **Sortowanie bƒÖbelkowe** | n             | n<sup>2</sup>        | n<sup>2</sup>         | 1         | Tak        |           |
| **Sortowanie przez wstawianie** | n      | n<sup>2</sup>        | n<sup>2</sup>         | 1         | Tak        |           |
| **Sortowanie przez wyb√≥r** | n<sup>2</sup> | n<sup>2</sup>       | n<sup>2</sup>         | 1         | Nie        |           |
| **Sortowanie przez kopcowanie** | n&nbsp;log(n) | n&nbsp;log(n) | n&nbsp;log(n)         | 1         | Nie        |           |
| **Sortowanie przez scalanie** | n&nbsp;log(n) | n&nbsp;log(n) | n&nbsp;log(n)         | n         | Tak        |           |
| **Quicksort**         | n&nbsp;log(n)    | n&nbsp;log(n)        | n<sup>2</sup>         | log(n)    | Nie        | Zwykle in-place z O(log(n)) miejsca na stosie |
| **Shellsort**         | n&nbsp;log(n)    | zale≈ºy od sekwencji odstƒôp√≥w | n&nbsp;(log(n))<sup>2</sup> | 1         | Nie        |           |
| **Sortowanie przez zliczanie** | n + r  | n + r                | n + r                 | n + r     | Tak        | r - najwiƒôksza liczba w tablicy |
| **Sortowanie pozycyjne (Radix sort)** | n * k | n * k         | n * k                 | n + k     | Tak        | k - d≈Çugo≈õƒá najd≈Çu≈ºszego klucza |

## WspierajƒÖcy projekt

> Mo≈ºesz wesprzeƒá ten projekt ‚ù§Ô∏èÔ∏è przez [GitHub](https://github.com/sponsors/trekhleb) lub ‚ù§Ô∏èÔ∏è przez [Patreon](https://www.patreon.com/trekhleb).

[Osoby wspierajƒÖce ten projekt](https://github.com/trekhleb/javascript-algorithms/blob/master/BACKERS.md) `‚àë = 1`

## Autor

[@trekhleb](https://trekhleb.dev)

Kilka innych [projekt√≥w](https://trekhleb.dev/projects/) i [artyku≈Ç√≥w](https://trekhleb.dev/blog/) o JavaScript i algorytmach na [trekhleb.dev](https://trekhleb.dev)

---

[Powered By OpenAiTx](https://github.com/OpenAiTx/OpenAiTx)

---