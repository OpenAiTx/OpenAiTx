[
  {
    "Id": 1,
    "Content": "# RISC-V Vector benchmark\n\nA collection of RISC-V Vector (RVV) benchmarks to help developers write portably performant RVV code.\n\nBenchmark results can be found at: https://camel-cdr.github.io/rvv-bench-results\n\n## Benchmarks ([./bench/](./bench/))\n\nContains a bunch of benchmark of different implementations of certain algorithms.\n\n## Instruction cycle count ([./instructions/](./instructions/))\n\nMeasures the cycle count of RVV instructions by unrolling and looping over the given instruction repeatedly.\n\n## Getting started\n\nStart by configuring [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk), such that `make` works and optionally [./run.sh](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./run.sh), which allows you to compile and run using `make run`.\n\nThe default configuration should work with all recent clang builds and doesn't require a full cross compilation toolchain, because it builds in freestanding mode.\nThis means it will only work on linux, or linux syscall compatible OS.\n\nOn recent linux versions, the performance counters aren't exposed by default, you may have to execute `echo 2 >/proc/sys/kernel/perf_user_access` and append `-DUSE_PERF_EVENT` to the `CFLAGS=...` line in [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk) (if that doesn't work, try `-DUSE_PERF_EVENT_SLOW` instead).\n\nYou can configure [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk) to build a hosted build or configure it with your custom toolchain, add the `-DCUSTOM_HOST` define, and implement the unimplemented functions under `#ifdef CUSTOM_HOST` in [./nolibc.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./nolibc.h).\n\nXTheadVector isn't supported anymore.\n\n### Running benchmarks ([./bench/](./bench/))\n\nTo run the benchmarks, first look through ([./bench/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./bench/config.h)) and adjust it to your processor (e.g. set `HAS_E64`). If it takes too long to execute, try lowering `MAX_MEM`, which is used to scale the benchmark, and play around with the other constants until it executes in a reasonable amount of time and gives a relatively smooth graph.\n\nNow you can just run the benchmarks using `make run` in the ([./bench/](./bench/)) directory, or `make` to just build the executables.\n\n### Measuring cycle count ([./instructions/](./instructions/))\n\nTo run the cycle count measurement, first configure [instructions/rvv/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/instructions/rvv/config.h) to your processor.\n\nNow you can run the measurement using `make run` in the ([./instructions/rvv/](./instructions/rvv/)) directory, or `make` to just build the executables.\n\nFor XTheadVector use the ([./instructions/xtheadvector/](./instructions/xtheadvector/)) directory instead. (this isn't maintained anymore)",
    "ContentSha": "Nn3cvjgTp7tMYRR85kLRjeFSVm+jUplVlEuOiOBmEV8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# RISC-V 벡터 벤치마크\n\n개발자가 이식 가능하고 성능이 뛰어난 RVV 코드를 작성할 수 있도록 돕는 RISC-V 벡터(RVV) 벤치마크 모음입니다.\n\n벤치마크 결과는 다음에서 확인할 수 있습니다: https://camel-cdr.github.io/rvv-bench-results\n\n## 벤치마크 ([./bench/](./bench/))\n\n특정 알고리즘의 다양한 구현에 대한 여러 벤치마크를 포함합니다.\n\n## 명령어 사이클 수 ([./instructions/](./instructions/))\n\n주어진 명령어를 반복해서 풀고 루프를 돌며 RVV 명령어의 사이클 수를 측정합니다.\n\n## 시작하기\n\n먼저 [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk)를 구성하여 `make`가 작동하도록 하고 선택적으로 [./run.sh](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./run.sh)를 구성하면 `make run`으로 컴파일 및 실행할 수 있습니다.\n\n기본 구성은 최신 clang 빌드 모두에서 작동하며, 완전한 크로스 컴파일 툴체인이 필요 없는데, freestanding 모드로 빌드하기 때문입니다.\n즉, Linux 또는 Linux 시스템 콜 호환 OS에서만 작동합니다.\n\n최신 Linux 버전에서는 성능 카운터가 기본적으로 노출되지 않으므로, `echo 2 >/proc/sys/kernel/perf_user_access`를 실행해야 할 수 있으며, [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk)의 `CFLAGS=...` 줄에 `-DUSE_PERF_EVENT`를 추가해야 합니다 (만약 작동하지 않으면 `-DUSE_PERF_EVENT_SLOW`를 대신 시도하세요).\n\n[./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk)를 호스티드 빌드로 설정하거나 사용자 맞춤 툴체인으로 구성할 수 있으며, `-DCUSTOM_HOST` 정의를 추가하고, [./nolibc.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./nolibc.h)의 `#ifdef CUSTOM_HOST` 아래 미구현 함수를 구현하면 됩니다.\n\nXTheadVector는 더 이상 지원되지 않습니다.\n\n### 벤치마크 실행 ([./bench/](./bench/))\n\n벤치마크를 실행하려면 먼저 ([./bench/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./bench/config.h))를 열어 프로세서에 맞게 조정하세요(예: `HAS_E64` 설정). 실행 시간이 너무 길면 벤치마크 스케일 조정에 사용되는 `MAX_MEM` 값을 낮추고, 다른 상수들도 조절하여 적당한 시간 내에 실행되고 상대적으로 부드러운 그래프가 나오도록 하세요.\n\n이제 ([./bench/](./bench/)) 디렉터리에서 `make run`으로 벤치마크를 실행하거나, 실행 파일만 빌드하려면 `make`를 실행하면 됩니다.\n\n### 사이클 수 측정 ([./instructions/](./instructions/))\n\n사이클 수 측정을 실행하려면 먼저 [instructions/rvv/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/instructions/rvv/config.h)를 프로세서에 맞게 구성하세요.\n\n그 다음 ([./instructions/rvv/](./instructions/rvv/)) 디렉터리에서 `make run`으로 측정을 실행하거나, 실행 파일만 빌드하려면 `make`를 실행하면 됩니다.\n\nXTheadVector의 경우 ([./instructions/xtheadvector/](./instructions/xtheadvector/)) 디렉터리를 대신 사용하세요. (더 이상 유지 관리되지 않습니다)",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "ORHkZy1aZEOTqS4/AqneAQ8W2kXn7ZXQinKydUXb/Yw=",
        "originContent": "# RISC-V Vector benchmark",
        "translatedContent": "# RISC-V 벡터 벤치마크"
      },
      {
        "row": 2,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "FSmW3ivRY3MYq56AmMpjtwQdkSsBIjG1lqQmf9TmcUE=",
        "originContent": "A collection of RISC-V Vector (RVV) benchmarks to help developers write portably performant RVV code.",
        "translatedContent": "개발자가 이식 가능하고 성능이 뛰어난 RVV 코드를 작성할 수 있도록 돕는 RISC-V 벡터(RVV) 벤치마크 모음입니다."
      },
      {
        "row": 4,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 5,
        "rowsha": "0vhtGt+ZlgXOgITSo1iF9LMqLelNoJY5HzfAdM6RRK4=",
        "originContent": "Benchmark results can be found at: https://camel-cdr.github.io/rvv-bench-results",
        "translatedContent": "벤치마크 결과는 다음에서 확인할 수 있습니다: https://camel-cdr.github.io/rvv-bench-results"
      },
      {
        "row": 6,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 7,
        "rowsha": "atAsnd+Imf0Koh1YsWCDB/sFMv4GpkEVu02FPmK1uUo=",
        "originContent": "## Benchmarks ([./bench/](./bench/))",
        "translatedContent": "## 벤치마크 ([./bench/](./bench/))"
      },
      {
        "row": 8,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 9,
        "rowsha": "PK4CnG++cvbZvYpzuLgBC3ZxlkREiGexDmwmjfeSTpk=",
        "originContent": "Contains a bunch of benchmark of different implementations of certain algorithms.",
        "translatedContent": "특정 알고리즘의 다양한 구현에 대한 여러 벤치마크를 포함합니다."
      },
      {
        "row": 10,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 11,
        "rowsha": "3YmBfYhdK+HTo06a7dQjEUfuVFNie/N7lyWzciDDsQc=",
        "originContent": "## Instruction cycle count ([./instructions/](./instructions/))",
        "translatedContent": "## 명령어 사이클 수 ([./instructions/](./instructions/))"
      },
      {
        "row": 12,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 13,
        "rowsha": "AMmALKgqh75UryFWjmXdWs+tY4aYNF5eSdQj3c7aihU=",
        "originContent": "Measures the cycle count of RVV instructions by unrolling and looping over the given instruction repeatedly.",
        "translatedContent": "주어진 명령어를 반복해서 풀고 루프를 돌며 RVV 명령어의 사이클 수를 측정합니다."
      },
      {
        "row": 14,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 15,
        "rowsha": "eetlngBf9IRRYZknBdo+Zo5q71Wk5hbFmnHDAzfrtps=",
        "originContent": "## Getting started",
        "translatedContent": "## 시작하기"
      },
      {
        "row": 16,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 17,
        "rowsha": "RATqtRwnHlBfbneNgql/2Fludl4qUf7zGgLPqvLpT+k=",
        "originContent": "Start by configuring [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk), such that `make` works and optionally [./run.sh](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./run.sh), which allows you to compile and run using `make run`.",
        "translatedContent": "먼저 [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk)를 구성하여 `make`가 작동하도록 하고 선택적으로 [./run.sh](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./run.sh)를 구성하면 `make run`으로 컴파일 및 실행할 수 있습니다."
      },
      {
        "row": 18,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 19,
        "rowsha": "MhZZ7phZTBX2DGWuxewP3StXIx2hJgYfylpZkhLVVL0=",
        "originContent": "The default configuration should work with all recent clang builds and doesn't require a full cross compilation toolchain, because it builds in freestanding mode.",
        "translatedContent": "기본 구성은 최신 clang 빌드 모두에서 작동하며, 완전한 크로스 컴파일 툴체인이 필요 없는데, freestanding 모드로 빌드하기 때문입니다."
      },
      {
        "row": 20,
        "rowsha": "FJ+maq7xiFb21vAVXU0ficI4xVZC/fXbijKeMvZ/7zg=",
        "originContent": "This means it will only work on linux, or linux syscall compatible OS.",
        "translatedContent": "즉, Linux 또는 Linux 시스템 콜 호환 OS에서만 작동합니다."
      },
      {
        "row": 21,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 22,
        "rowsha": "OuTaq2UdZvS6857Cil8hZ+glV8F4w7yOnWmUYSZaRqw=",
        "originContent": "On recent linux versions, the performance counters aren't exposed by default, you may have to execute `echo 2 >/proc/sys/kernel/perf_user_access` and append `-DUSE_PERF_EVENT` to the `CFLAGS=...` line in [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk) (if that doesn't work, try `-DUSE_PERF_EVENT_SLOW` instead).",
        "translatedContent": "최신 Linux 버전에서는 성능 카운터가 기본적으로 노출되지 않으므로, `echo 2 >/proc/sys/kernel/perf_user_access`를 실행해야 할 수 있으며, [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk)의 `CFLAGS=...` 줄에 `-DUSE_PERF_EVENT`를 추가해야 합니다 (만약 작동하지 않으면 `-DUSE_PERF_EVENT_SLOW`를 대신 시도하세요)."
      },
      {
        "row": 23,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 24,
        "rowsha": "wUQRkKYbx9qCypZK4u3lwuJyLpsdvBV9bdz/QgdHrmM=",
        "originContent": "You can configure [./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk) to build a hosted build or configure it with your custom toolchain, add the `-DCUSTOM_HOST` define, and implement the unimplemented functions under `#ifdef CUSTOM_HOST` in [./nolibc.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./nolibc.h).",
        "translatedContent": "[./config.mk](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./config.mk)를 호스티드 빌드로 설정하거나 사용자 맞춤 툴체인으로 구성할 수 있으며, `-DCUSTOM_HOST` 정의를 추가하고, [./nolibc.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./nolibc.h)의 `#ifdef CUSTOM_HOST` 아래 미구현 함수를 구현하면 됩니다."
      },
      {
        "row": 25,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 26,
        "rowsha": "QRFDvlLEfnqVJ7RdOPfbJ9BdOg2Q3B8Y00dVWWStkx4=",
        "originContent": "XTheadVector isn't supported anymore.",
        "translatedContent": "XTheadVector는 더 이상 지원되지 않습니다."
      },
      {
        "row": 27,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 28,
        "rowsha": "pq/plj5gqTE4Q0XCTVhuV7298OqC731xEj7r6fR+2AA=",
        "originContent": "### Running benchmarks ([./bench/](./bench/))",
        "translatedContent": "### 벤치마크 실행 ([./bench/](./bench/))"
      },
      {
        "row": 29,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 30,
        "rowsha": "1k6Axz94UWWc0Bsegctd7ts37gcdhTKiyvQz8YS8+cM=",
        "originContent": "To run the benchmarks, first look through ([./bench/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./bench/config.h)) and adjust it to your processor (e.g. set `HAS_E64`). If it takes too long to execute, try lowering `MAX_MEM`, which is used to scale the benchmark, and play around with the other constants until it executes in a reasonable amount of time and gives a relatively smooth graph.",
        "translatedContent": "벤치마크를 실행하려면 먼저 ([./bench/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/./bench/config.h))를 열어 프로세서에 맞게 조정하세요(예: `HAS_E64` 설정). 실행 시간이 너무 길면 벤치마크 스케일 조정에 사용되는 `MAX_MEM` 값을 낮추고, 다른 상수들도 조절하여 적당한 시간 내에 실행되고 상대적으로 부드러운 그래프가 나오도록 하세요."
      },
      {
        "row": 31,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 32,
        "rowsha": "uOlVPPF/VE+7OKIaFzxzy/DF4alRHNigKLxiGwlBJEo=",
        "originContent": "Now you can just run the benchmarks using `make run` in the ([./bench/](./bench/)) directory, or `make` to just build the executables.",
        "translatedContent": "이제 ([./bench/](./bench/)) 디렉터리에서 `make run`으로 벤치마크를 실행하거나, 실행 파일만 빌드하려면 `make`를 실행하면 됩니다."
      },
      {
        "row": 33,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 34,
        "rowsha": "3P6meKSCPE5J4W3ClsBBwKPoV14SH3bmeDNEJJs3d+k=",
        "originContent": "### Measuring cycle count ([./instructions/](./instructions/))",
        "translatedContent": "### 사이클 수 측정 ([./instructions/](./instructions/))"
      },
      {
        "row": 35,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 36,
        "rowsha": "okN6ed2j+2Y8j5TB2iibQQOnTeJelgsF3a7jGOVVEhQ=",
        "originContent": "To run the cycle count measurement, first configure [instructions/rvv/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/instructions/rvv/config.h) to your processor.",
        "translatedContent": "사이클 수 측정을 실행하려면 먼저 [instructions/rvv/config.h](https://raw.githubusercontent.com/camel-cdr/rvv-bench/main/instructions/rvv/config.h)를 프로세서에 맞게 구성하세요."
      },
      {
        "row": 37,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 38,
        "rowsha": "MHva9rFWPs7Y64Pjrls/VBT5wsSQwOmCqcUucjCGWBQ=",
        "originContent": "Now you can run the measurement using `make run` in the ([./instructions/rvv/](./instructions/rvv/)) directory, or `make` to just build the executables.",
        "translatedContent": "그 다음 ([./instructions/rvv/](./instructions/rvv/)) 디렉터리에서 `make run`으로 측정을 실행하거나, 실행 파일만 빌드하려면 `make`를 실행하면 됩니다."
      },
      {
        "row": 39,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 40,
        "rowsha": "dq8cZCLUwsRTjkkYqYw2+RWdxFEo11yoUoZqau9HvyA=",
        "originContent": "For XTheadVector use the ([./instructions/xtheadvector/](./instructions/xtheadvector/)) directory instead. (this isn't maintained anymore)",
        "translatedContent": "XTheadVector의 경우 ([./instructions/xtheadvector/](./instructions/xtheadvector/)) 디렉터리를 대신 사용하세요. (더 이상 유지 관리되지 않습니다)"
      }
    ],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "\n## Contributing\n\nHere are some suggestions of things that still need to be done.\n\n* contribute a measurement of a new CPU to: https://github.com/camel-cdr/rvv-bench-results \\\n  You can just create an issue with a single json file, which contains all concatenated [./bench/](./bench/) results. (after proper setup, `make run > out.json` should do the trick). \\\n* implement non memory bound benchmarks\n* implement more benchmarks\n* better cycle count measurements: throughput vs latency (also: can we figure out the execution port configuration?)\n* cycle count for load/stores\n* cycle count for vsetvl\n\n## License\n\nThis repository is licensed under the MIT [LICENSE](LICENSE).\n\n",
    "ContentSha": "O6MHXXQB5RqhuHrx9R6kVjC2WwrnmUl6du+t6zCtow4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "## Contributing\n\n다음은 아직 완료해야 할 작업들에 대한 제안입니다.\n\n* 새로운 CPU 측정을 다음에 기여하세요: https://github.com/camel-cdr/rvv-bench-results \\\n  단일 json 파일을 포함하는 이슈를 생성하면 됩니다. 이 파일은 모든 결합된 [./bench/](./bench/) 결과를 포함합니다. (적절한 설정 후, `make run > out.json` 명령어가 효과적입니다). \\\n* 메모리 바운드가 아닌 벤치마크 구현\n* 더 많은 벤치마크 구현\n* 더 나은 사이클 수 측정: 처리량 대 대기 시간 (또한: 실행 포트 구성을 파악할 수 있을까요?)\n* 로드/스토어에 대한 사이클 수\n* vsetvl에 대한 사이클 수\n\n## License\n\n이 저장소는 MIT [LICENSE](LICENSE) 하에 라이선스가 부여됩니다.\n\n\n",
    "Status": "ok",
    "RowTranslations": [
      {
        "row": 1,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "## Contributing"
      },
      {
        "row": 2,
        "rowsha": "R5ZPLZ4vkE9tjX5qe8QB7AkTfWZsuNTGFLFKMp2KUzM=",
        "originContent": "## Contributing",
        "translatedContent": ""
      },
      {
        "row": 3,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "다음은 아직 완료해야 할 작업들에 대한 제안입니다."
      },
      {
        "row": 4,
        "rowsha": "qY/ETJS2ixFUyg30/IJDyi8g8WvYoZDhUk09CR/No3k=",
        "originContent": "Here are some suggestions of things that still need to be done.",
        "translatedContent": ""
      },
      {
        "row": 5,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "* 새로운 CPU 측정을 다음에 기여하세요: https://github.com/camel-cdr/rvv-bench-results \\"
      },
      {
        "row": 6,
        "rowsha": "xE/r3EAKCIliSuFWjm0sUAfnXhhwCRu2HsbJqS9RdCE=",
        "originContent": "* contribute a measurement of a new CPU to: https://github.com/camel-cdr/rvv-bench-results \\",
        "translatedContent": "  단일 json 파일을 포함하는 이슈를 생성하면 됩니다. 이 파일은 모든 결합된 [./bench/](./bench/) 결과를 포함합니다. (적절한 설정 후, `make run > out.json` 명령어가 효과적입니다). \\"
      },
      {
        "row": 7,
        "rowsha": "xoSG9N0qa4hiqyPdJJeyJoXd7g/sqJVYxTo6tUZsFtE=",
        "originContent": "  You can just create an issue with a single json file, which contains all concatenated [./bench/](./bench/) results. (after proper setup, `make run > out.json` should do the trick). \\",
        "translatedContent": "* 메모리 바운드가 아닌 벤치마크 구현"
      },
      {
        "row": 8,
        "rowsha": "yT6iwcWiQsSpos2Q+/4m6nTcwthVciNSQmozzlk4aI4=",
        "originContent": "* implement non memory bound benchmarks",
        "translatedContent": "* 더 많은 벤치마크 구현"
      },
      {
        "row": 9,
        "rowsha": "QFwgp1N3p+8fohBHFjhKAlSBOJ8GOH88jodQwVpUHsk=",
        "originContent": "* implement more benchmarks",
        "translatedContent": "* 더 나은 사이클 수 측정: 처리량 대 대기 시간 (또한: 실행 포트 구성을 파악할 수 있을까요?)"
      },
      {
        "row": 10,
        "rowsha": "MlzK0xJ4PogmG/VcU7h8DKcqEXnZ8UKzoXGs3FAytxM=",
        "originContent": "* better cycle count measurements: throughput vs latency (also: can we figure out the execution port configuration?)",
        "translatedContent": "* 로드/스토어에 대한 사이클 수"
      },
      {
        "row": 11,
        "rowsha": "6KnPE9TQgqJNz+Ieg6+CBYw3XipmrFINEpvAEoulWuk=",
        "originContent": "* cycle count for load/stores",
        "translatedContent": "* vsetvl에 대한 사이클 수"
      },
      {
        "row": 12,
        "rowsha": "9Iv85q1v+dIdR5osJ30VNVRHh8a/ZgUlbQ1t1WbvSU4=",
        "originContent": "* cycle count for vsetvl",
        "translatedContent": ""
      },
      {
        "row": 13,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "## License"
      },
      {
        "row": 14,
        "rowsha": "bFSaVtsB4CHySNjaeCiaMZfT24b+DTbTM4HQ38cR6Lw=",
        "originContent": "## License",
        "translatedContent": ""
      },
      {
        "row": 15,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": "이 저장소는 MIT [LICENSE](LICENSE) 하에 라이선스가 부여됩니다."
      },
      {
        "row": 16,
        "rowsha": "ICc4Vy1/+XdoO5LcZNVtAYO6qdFgMziQHTgyb6OU4IE=",
        "originContent": "This repository is licensed under the MIT [LICENSE](LICENSE).",
        "translatedContent": ""
      },
      {
        "row": 17,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      },
      {
        "row": 18,
        "rowsha": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
        "originContent": "",
        "translatedContent": ""
      }
    ],
    "IsCodeBlock": false
  }
]