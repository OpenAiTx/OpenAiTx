[
  {
    "Id": 1,
    "Content": "# PacketSniffer - 实时网络抓包与协议解析工具\n\n一个基于 C# 开发的实时网络抓包工具，支持自动协议识别、解析和业务逻辑分发。\n\n## 功能特性\n\n- 🔍 **实时抓包**：使用 SharpPcap 进行网络数据包捕获\n- 🔄 **自动协议识别**：支持 JSON、HTTP、二进制协议自动识别\n- 📊 **智能解析**：自动提取协议字段和内容\n- 🎯 **业务分发**：支持自定义业务逻辑处理\n- 🛡️ **扩展性强**：易于添加新的协议解析器\n\n## 项目结构\n",
    "ContentSha": "GZhXeRaWotgL2QjihgdpXBHvnJ/sAGyIyhkw0fOd1pM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "# PacketSniffer - 실시간 네트워크 패킷 캡처 및 프로토콜 분석 도구\n\nC# 기반으로 개발된 실시간 네트워크 패킷 캡처 도구로, 자동 프로토콜 인식, 분석 및 비즈니스 로직 분배를 지원합니다.\n\n## 기능 특징\n\n- 🔍 **실시간 패킷 캡처**：SharpPcap을 사용하여 네트워크 데이터 패킷을 캡처\n- 🔄 **자동 프로토콜 인식**：JSON, HTTP, 이진 프로토콜 자동 인식 지원\n- 📊 **스마트 분석**：프로토콜 필드 및 내용 자동 추출\n- 🎯 **비즈니스 분배**：사용자 정의 비즈니스 로직 처리 지원\n- 🛡️ **높은 확장성**：새로운 프로토콜 분석기 추가 용이\n\n## 프로젝트 구조\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 2,
    "Content": "```\nPacketSniffer/\n├── PacketSniffer.csproj      # 项目配置文件\n├── Program.cs                 # 程序入口\n├── Core/\n│   ├── Sniffer.cs            # 抓包核心模块\n│   └── PacketRouter.cs       # 数据包路由分发器\n├── Parsers/\n│   ├── IParser.cs            # 解析器接口\n│   ├── JsonParser.cs         # JSON 协议解析器\n│   ├── HttpParser.cs         # HTTP 协议解析器\n│   └── BinaryParser.cs       # 二进制协议解析器（兜底）\n└── Models/\n    └── ParsedResult.cs       # 解析结果数据模型\n```",
    "ContentSha": "JIt5vuG43YSBpH6jp7kzGbBKBF8RP95V0EAxKezALhI=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```\nPacketSniffer/\n├── PacketSniffer.csproj      # 项目配置文件\n├── Program.cs                 # 程序入口\n├── Core/\n│   ├── Sniffer.cs            # 抓包核心模块\n│   └── PacketRouter.cs       # 数据包路由分发器\n├── Parsers/\n│   ├── IParser.cs            # 解析器接口\n│   ├── JsonParser.cs         # JSON 协议解析器\n│   ├── HttpParser.cs         # HTTP 协议解析器\n│   └── BinaryParser.cs       # 二进制协议解析器（兜底）\n└── Models/\n    └── ParsedResult.cs       # 解析结果数据模型\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 3,
    "Content": "\n## 环境要求\n\n- .NET 6.0 或更高版本\n- Windows 操作系统（需要管理员权限运行）\n- 已安装的网络适配器\n\n## 安装步骤\n\n### 1. 克隆或下载项目\n",
    "ContentSha": "a7BvBnad3lWftPhKsUVTvN1cCo1vqhGeotdZs1FTOZ0=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "## 환경 요구 사항\n\n- .NET 6.0 이상 버전\n- Windows 운영 체제(관리자 권한으로 실행 필요)\n- 설치된 네트워크 어댑터\n\n## 설치 단계\n\n### 1. 프로젝트 클론 또는 다운로드\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 4,
    "Content": "```bash\ncd \"D:\\C# Project\\zhuabao\"\n```",
    "ContentSha": "iGPuA/6Spg9ZEDz2TfRtQfiT8YWr+wwOTRh9reHcdAw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```bash\ncd \"D:\\C# Project\\zhuabao\"\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 5,
    "Content": "\n### 2. 恢复 NuGet 依赖\n",
    "ContentSha": "wogAZxSMPuF3CMf+SkajjyZOuu5BK3dC5wcp4eN/1x4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### 2. NuGet 종속성 복원\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 6,
    "Content": "```bash\ndotnet restore\n```",
    "ContentSha": "+Oy6whqeumY9C3bBuQJB+9sKwk7SGKnhLLK9WFhJSbs=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```bash\ndotnet restore\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 7,
    "Content": "\n### 3. 构建项目\n",
    "ContentSha": "QMrlKc9SaL1odE0jdmYwc9IO13NKRwuh0+JTtGaPtW4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### 3. 프로젝트 빌드\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 8,
    "Content": "```bash\ndotnet build\n```",
    "ContentSha": "/qh4FT/+fK65m7vGe0WB8ZDdAkgFps1KnyvBeQiBhRA=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```bash\ndotnet build\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 9,
    "Content": "\n## 使用方法\n\n### 基本运行\n\n**重要：必须以管理员权限运行！**\n",
    "ContentSha": "Hc56q2TtMj4rEoLXBoTyVrAFez9oTtprkRALvXFM7q4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "## 사용 방법\n\n### 기본 실행\n\n**중요: 반드시 관리자 권한으로 실행해야 합니다!**\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 10,
    "Content": "```bash\n# 默认模式：只打印 HTTP Request 的时间 + 方法 + 路径\ndotnet run\n\n# 完整模式：打印完整数据包信息（包含 IP/MAC/端口/Body 等）\ndotnet run -- --full\n\n# 先构建后运行\ndotnet build\ndotnet bin/Debug/net6.0/PacketSniffer.exe\n```",
    "ContentSha": "n1GCxX7RGtAk5c+qtrTsQSNQ9AmkwudFgTty/HtfrZM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```bash\n# 默认模式：只打印 HTTP Request 的时间 + 方法 + 路径\ndotnet run\n\n# 完整模式：打印完整数据包信息（包含 IP/MAC/端口/Body 等）\ndotnet run -- --full\n\n# 先构建后运行\ndotnet build\ndotnet bin/Debug/net6.0/PacketSniffer.exe\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 11,
    "Content": "\n### 配置文件 `config.json`\n\n所有需要手动调整的内容都集中在根目录的 `config.json`，程序运行时会从 **exe 所在目录** 读取该文件。\n\n示例：\n",
    "ContentSha": "LQ+/kb4tfnMeJroUHUZnDtRtbIVkTW87i3+Wp354204=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### 配置文件 `config.json`\n\n所有需要手动调整的内容都集中在根目录的 `config.json`，程序运行时会从 **exe 所在目录** 读取该文件。\n\n示例：\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 12,
    "Content": "```json\n{\n  \"DeviceKeyword\": \"loopback\",\n  \"Ports\": [5005],\n  \"FilterSourcePort\": true,\n  \"FilterDestinationPort\": true,\n  \"HttpPathFilters\": [\n    \"/api/\"\n  ]\n}\n```",
    "ContentSha": "gj3SRLSUHjwJeAg7m/ObjJSgFl79brekSS7H5hVMe+I=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```json\n{\n  \"DeviceKeyword\": \"loopback\",\n  \"Ports\": [5005],\n  \"FilterSourcePort\": true,\n  \"FilterDestinationPort\": true,\n  \"HttpPathFilters\": [\n    \"/api/\"\n  ]\n}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 13,
    "Content": "\n- **DeviceKeyword**：网卡筛选关键字（匹配 Name/Description）。  \n  例如 `\"Intel\"`、`\"Realtek\"`、`\"Npcap Loopback\"`、`\"loopback\"`。为空或省略时，将自动选择物理网卡优先，其次 Npcap Loopback。\n- **Ports**：监听的端口列表（源端口或目标端口任一匹配即可）。为空或省略时，监听所有端口。\n- **FilterSourcePort / FilterDestinationPort**：是否按源端口 / 目标端口进行过滤。\n- **HttpPathFilters**：HTTP 请求路径过滤关键字，仅对 **HTTP Request** 生效。  \n  例如 `[\"/api/\"]` 表示只打印路径中包含 `/api/` 的 HTTP 请求。\n\n### 运行流程\n\n1. 启动时读取 `config.json`，确定：网卡关键字、监听端口、HTTP 路径过滤规则。\n2. 根据 `DeviceKeyword` 从网卡列表中模糊匹配，优先选择配置指定的网卡；若未配置则自动选择物理网卡优先，其次 Npcap Loopback。  \n   此时控制台会列出所有网卡并标注 `[PHYSICAL]` / `[VIRTUAL]` / `[LOOPBACK]`。\n3. 开启混杂模式（Promiscuous Mode）进行抓包。\n4. 实时捕获 TCP/UDP 包的 payload，并根据端口配置 (`Ports` + FilterSource/FilterDestination) 做过滤。\n5. 自动识别协议类型（JsonParser → HttpParser → BinaryParser）。\n6. 默认模式下：只处理 HTTP Request，解析请求行并打印 `时间 + 方法 + 路径 + 端口`，可选按路径关键字过滤。\n7. 完整模式（`--full`）下：对每个包构建 `PacketInfo`，打印完整的包结构、头部信息和 Payload 摘要。\n\n### 停止程序\n\n按 `Ctrl+C` 优雅退出，程序会自动停止抓包并清理资源。\n\n## 协议解析说明\n\n### JSON 协议解析\n\n- **识别方式**：检查 payload 是否以 `{` 或 `[` 开头\n- **解析内容**：提取所有一级字段的键值对\n- **输出格式**：`Protocol=json, Fields={key1=value1, key2=value2, ...}`\n\n### HTTP 协议解析\n\n- **识别方式**：检查是否以 HTTP 方法（GET/POST等）或 `HTTP/1.x` 开头\n- **解析内容**：\n  - 解析 HTTP Headers（所有 header 字段）\n  - 解析 Request Line 或 Status Line\n  - 如果 Body 是 JSON 格式，自动解析 JSON 字段\n- **输出格式**：`Protocol=http, Fields={request_line=..., header_Content-Type=..., ...}`\n",
    "ContentSha": "moJnXu/W8fiiHGWbC6h3xqQSMuh4zL3p1W/UBmRdyu4=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "- **DeviceKeyword**：네트워크 카드 필터 키워드(Name/Description 일치).  \n  예: `\"Intel\"`, `\"Realtek\"`, `\"Npcap Loopback\"`, `\"loopback\"`. 비어 있거나 생략 시 물리 네트워크 카드를 우선 선택하며, 다음으로 Npcap Loopback을 선택합니다.\n- **Ports**：감시할 포트 목록(출발지 포트 또는 목적지 포트 중 하나만 일치해도 됨). 비어 있거나 생략 시 모든 포트를 감시합니다.\n- **FilterSourcePort / FilterDestinationPort**：출발지 포트 / 목적지 포트로 필터링 여부.\n- **HttpPathFilters**：HTTP 요청 경로 필터 키워드, **HTTP Request**에만 적용.  \n  예: `[\"/api/\"]` 는 경로에 `/api/` 가 포함된 HTTP 요청만 출력합니다.\n\n### 실행 흐름\n\n1. 시작 시 `config.json`을 읽어 네트워크 카드 키워드, 감시 포트, HTTP 경로 필터 규칙을 결정합니다.\n2. `DeviceKeyword`에 따라 네트워크 카드 목록에서 모호하게 매칭하여, 설정된 카드 우선 선택; 설정 없으면 물리 네트워크 카드 우선, 다음 Npcap Loopback 선택.  \n   이때 콘솔에 모든 네트워크 카드를 표시하며 `[PHYSICAL]` / `[VIRTUAL]` / `[LOOPBACK]` 태그를 붙입니다.\n3. 프로미스큐어스 모드(Promiscuous Mode)를 켜서 패킷을 캡처합니다.\n4. 실시간으로 TCP/UDP 페이로드를 캡처하며 포트 설정(`Ports` + FilterSource/FilterDestination)에 따라 필터링합니다.\n5. 프로토콜 유형 자동 인식(JsonParser → HttpParser → BinaryParser).\n6. 기본 모드: HTTP Request만 처리하며 요청 라인을 분석해 `시간 + 메서드 + 경로 + 포트`를 출력, 경로 키워드 필터링 선택 가능.\n7. 전체 모드(`--full`)에서는 각 패킷에 대해 `PacketInfo`를 구성, 패킷 전체 구조, 헤더 정보, 페이로드 요약을 출력.\n\n### 프로그램 종료\n\n`Ctrl+C`를 눌러 우아하게 종료, 프로그램은 자동으로 패킷 캡처를 중지하고 자원을 정리합니다.\n\n## 프로토콜 분석 설명\n\n### JSON 프로토콜 분석\n\n- **인식 방법**：페이로드가 `{` 또는 `[` 로 시작하는지 검사\n- **분석 내용**：모든 1차 필드의 키-값 쌍 추출\n- **출력 형식**：`Protocol=json, Fields={key1=value1, key2=value2, ...}`\n\n### HTTP 프로토콜 분석\n\n- **인식 방법**：HTTP 메서드(GET/POST 등) 또는 `HTTP/1.x` 로 시작하는지 검사\n- **분석 내용**：\n  - HTTP 헤더(모든 헤더 필드) 분석\n  - 요청 라인(Request Line) 또는 상태 라인(Status Line) 분석\n  - 바디가 JSON 형식이면 JSON 필드 자동 분석\n- **출력 형식**：`Protocol=http, Fields={request_line=..., header_Content-Type=..., ...}`\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 14,
    "Content": "### 二进制协议解析\n\n- **识别方式**：作为兜底解析器，所有无法识别的协议都会使用此解析器\n- **解析内容**：将 payload 转换为十六进制字符串\n- **输出格式**：`Protocol=binary, Fields={hex=AA BB CC DD ...}`\n- **扩展提示**：可在 `BinaryParser.cs` 中添加自定义协议解析逻辑\n\n## 业务逻辑处理\n\n当前版本默认只做“捕获 + 解析 + 打印”，便于你观察实际流量：\n\n- 默认模式下：只打印 HTTP Request 的时间、方法、路径和端口信息。\n- 完整模式下：打印完整 `PacketInfo`，包括链路层/IP 层/传输层信息及 Payload 概要。\n- 业务处理入口 `HandleBusinessLogic(ParsedResult result)` 仍然保留，方便你后续按解析结果做自定义处理。\n\n## 自定义扩展\n\n### 添加新的协议解析器\n\n1. 实现 `IParser` 接口：\n",
    "ContentSha": "iXwPJZN2OhoK3Ixbq5QfVA18Ab6U5X/x5BnxedVU0/8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "### 이진 프로토콜 분석\n\n- **인식 방식**：대체 분석기로서, 인식할 수 없는 모든 프로토콜에 대해 이 분석기를 사용\n- **분석 내용**：payload를 16진수 문자열로 변환\n- **출력 형식**：`Protocol=binary, Fields={hex=AA BB CC DD ...}`\n- **확장 팁**：`BinaryParser.cs`에 사용자 정의 프로토콜 분석 로직 추가 가능\n\n## 비즈니스 로직 처리\n\n현재 버전은 기본적으로 \"캡처 + 분석 + 출력\"만 수행하여 실제 트래픽 관찰에 용이:\n\n- 기본 모드：HTTP 요청의 시간, 메서드, 경로 및 포트 정보만 출력.\n- 전체 모드：체인 계층/IP 계층/전송 계층 정보 및 Payload 개요를 포함한 전체 `PacketInfo` 출력.\n- 비즈니스 처리 진입점 `HandleBusinessLogic(ParsedResult result)`는 여전히 남아 있어, 분석 결과에 따른 사용자 정의 처리를 편리하게 수행 가능.\n\n## 사용자 정의 확장\n\n### 새로운 프로토콜 분석기 추가\n\n1. `IParser` 인터페이스 구현：\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 15,
    "Content": "```csharp\npublic class CustomParser : IParser\n{\n    public bool CanParse(byte[] payload)\n    {\n        // 判断逻辑\n        return false;\n    }\n\n    public ParsedResult Parse(byte[] payload)\n    {\n        // 解析逻辑\n        return new ParsedResult { ... };\n    }\n}\n```",
    "ContentSha": "JijA5yH2KqtfK5MLMrmj2mIEd6FLUDmdQQV70f+dm5A=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```csharp\npublic class CustomParser : IParser\n{\n    public bool CanParse(byte[] payload)\n    {\n        // 判断逻辑\n        return false;\n    }\n\n    public ParsedResult Parse(byte[] payload)\n    {\n        // 解析逻辑\n        return new ParsedResult { ... };\n    }\n}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 16,
    "Content": "\n2. 在 `Program.cs` 中注册：\n",
    "ContentSha": "5ULV455HJ1YbqrOv5wZ7RbAtsrRd5Dfh+ghl6Rp/uws=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n2. `Program.cs`에서 등록:\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 17,
    "Content": "```csharp\nrouter.RegisterParser(new CustomParser());\n```",
    "ContentSha": "wFX8h0yNAMvpVabAuAVj27jrxQYQKJEHoLUORBxw43s=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```csharp\nrouter.RegisterParser(new CustomParser());\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 18,
    "Content": "\n### 扩展业务逻辑\n\n在 `PacketRouter.cs` 的 `HandleBusinessLogic()` 方法中添加自定义逻辑：\n",
    "ContentSha": "MoDCsOzoUBbTGz4Oh3fDZIPQ2SM1i8KlRSIaBZGq9xE=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### 확장 비즈니스 로직\n\n`PacketRouter.cs`의 `HandleBusinessLogic()` 메서드에 사용자 정의 로직 추가:\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 19,
    "Content": "```csharp\nprivate void HandleBusinessLogic(ParsedResult result)\n{\n    // 添加你的业务逻辑\n    if (result.Fields.ContainsKey(\"yourKey\"))\n    {\n        // 处理逻辑\n    }\n}\n```",
    "ContentSha": "sYW0j0E177DdT/boNGR8Wr9MmKDd+v+2A4zbcfm2BYg=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```csharp\nprivate void HandleBusinessLogic(ParsedResult result)\n{\n    // 添加你的业务逻辑\n    if (result.Fields.ContainsKey(\"yourKey\"))\n    {\n        // 处理逻辑\n    }\n}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 20,
    "Content": "\n## 输出示例\n\n### 默认模式：只打印 HTTP 请求路径\n\n使用如下配置（`config.json`）示例：\n",
    "ContentSha": "kjUNFS+ihDTNaXlo54HmrQixS0o2I5i25Kk1M+YY5tE=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n## 출력 예제\n\n### 기본 모드: HTTP 요청 경로만 출력\n\n다음 구성(`config.json`) 예시를 사용합니다:\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 21,
    "Content": "```json\n{\n  \"DeviceKeyword\": \"loopback\",\n  \"Ports\": [5005],\n  \"FilterSourcePort\": true,\n  \"FilterDestinationPort\": true,\n  \"HttpPathFilters\": [\n    \"/api/\"\n  ]\n}\n```",
    "ContentSha": "gj3SRLSUHjwJeAg7m/ObjJSgFl79brekSS7H5hVMe+I=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```json\n{\n  \"DeviceKeyword\": \"loopback\",\n  \"Ports\": [5005],\n  \"FilterSourcePort\": true,\n  \"FilterDestinationPort\": true,\n  \"HttpPathFilters\": [\n    \"/api/\"\n  ]\n}\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 22,
    "Content": "\n运行输出示例：\n",
    "ContentSha": "ttyJSMwcYnWfMOCQskiBdeWaSDHMlW4ODPAu2SWbWlk=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n실행 출력 예시:\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 23,
    "Content": "```text\n=== Packet Sniffer - Protocol Parse Mode ===\n已加载配置文件: C:\\...\\bin\\Debug\\net6.0\\config.json\n端口过滤: 已启用，监听端口: 5005\n过滤模式: 源端口=True, 目标端口=True\n网卡关键字: \"loopback\"（将优先匹配 Name/Description）\nHTTP 路径过滤已启用，关键字列表：\n  - /api/\n\nUsing device (from config/auto): Npcap Loopback Adapter\nPacket capture started. Press Ctrl+C to stop.\n\n======================================================================================================================\n[2025-12-01 16:30:12.345] GET /api/user/123  (src:52345 -> dst:5005)\n======================================================================================================================\n[2025-12-01 16:30:13.001] POST /api/order/create  (src:52346 -> dst:5005)\n```",
    "ContentSha": "ehlAaoqDEz/SP6PkMReJ+EutZcS8mYsEhrYyQi54zCw=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```text\n=== Packet Sniffer - Protocol Parse Mode ===\n已加载配置文件: C:\\...\\bin\\Debug\\net6.0\\config.json\n端口过滤: 已启用，监听端口: 5005\n过滤模式: 源端口=True, 目标端口=True\n网卡关键字: \"loopback\"（将优先匹配 Name/Description）\nHTTP 路径过滤已启用，关键字列表：\n  - /api/\n\nUsing device (from config/auto): Npcap Loopback Adapter\nPacket capture started. Press Ctrl+C to stop.\n\n======================================================================================================================\n[2025-12-01 16:30:12.345] GET /api/user/123  (src:52345 -> dst:5005)\n======================================================================================================================\n[2025-12-01 16:30:13.001] POST /api/order/create  (src:52346 -> dst:5005)\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 24,
    "Content": "\n### 完整模式：打印完整包信息\n",
    "ContentSha": "BOgPxRr70W4E7hJlS4BbEYiXANvv87M9onax+kT8GBQ=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "\n### 전체 모드: 전체 패키지 정보 출력\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 25,
    "Content": "```bash\ndotnet run -- --full\n```",
    "ContentSha": "iPAGoY1IEehPB9ljqrm7K9htGPUJXVm7YYUqrS0z/dM=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```bash\ndotnet run -- --full\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 26,
    "Content": "\n输出示例（截断）：\n",
    "ContentSha": "FTXFTujTuqP6UvSqfn8T5If20THk0hKRxjq2DfFaS6c=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "출력 예시(절단):\n\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 27,
    "Content": "```text\n================================================================================\n数据包捕获时间: 2025-12-01 16:31:00.123\n--------------------------------------------------------------------------------\n数据包长度: 1500 字节\n链路层类型: Ethernet\n源 MAC 地址: AA:BB:CC:DD:EE:FF\n目标 MAC 地址: 11:22:33:44:55:66\n\n网络层协议: IPv4Packet\nIP 版本: IPv4\n源 IP 地址: 192.168.1.100\n目标 IP 地址: 192.168.1.1\nTTL: 64\n\n传输层协议: TCP\n源端口: 52345\n目标端口: 5005\nTCP 标志: Syn, Ack\n\nPayload 长度: 256 字节\nPayload (十六进制):\n0000: 47 45 54 20 2F 61 70 69 2F 75 73 65 72 2F 31 32 | GET /api/user/12\n...\n================================================================================\n```",
    "ContentSha": "uI25QoRyiUFWIJHoUMhtxqaeoAkBHdkPX4kkKZaquLc=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "```text\n================================================================================\n数据包捕获时间: 2025-12-01 16:31:00.123\n--------------------------------------------------------------------------------\n数据包长度: 1500 字节\n链路层类型: Ethernet\n源 MAC 地址: AA:BB:CC:DD:EE:FF\n目标 MAC 地址: 11:22:33:44:55:66\n\n网络层协议: IPv4Packet\nIP 版本: IPv4\n源 IP 地址: 192.168.1.100\n目标 IP 地址: 192.168.1.1\nTTL: 64\n\n传输层协议: TCP\n源端口: 52345\n目标端口: 5005\nTCP 标志: Syn, Ack\n\nPayload 长度: 256 字节\nPayload (十六进制):\n0000: 47 45 54 20 2F 61 70 69 2F 75 73 65 72 2F 31 32 | GET /api/user/12\n...\n================================================================================\n```",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": true
  },
  {
    "Id": 28,
    "Content": "\n## 注意事项\n\n1. **管理员权限**：抓包功能需要管理员权限，否则无法打开网络适配器\n2. **防火墙**：某些防火墙可能会阻止抓包操作\n3. **性能影响**：大量网络流量可能会影响程序性能，建议使用端口过滤减少处理量\n4. **隐私安全**：请确保在合法合规的环境中使用，不要抓取他人隐私数据\n5. **端口过滤**：使用端口过滤可以显著减少处理的数据包数量，提高性能\n\n## 故障排除\n\n### 问题1：找不到网络设备\n\n**错误信息**：`No network devices found`\n\n**解决方案**：\n- 确保已安装网络适配器驱动\n- 检查是否有可用的网络连接\n- 尝试以管理员权限运行\n\n### 问题2：无法打开设备\n\n**错误信息**：`Failed to open device`\n\n**解决方案**：\n- 确保以管理员权限运行\n- 检查是否有其他程序占用网络适配器\n- 尝试重启程序\n\n### 问题3：解析失败\n\n**现象**：某些数据包无法解析\n\n**说明**：这是正常现象，无法识别的协议会使用 BinaryParser 输出十六进制格式\n\n## 技术栈\n\n- **.NET 6.0** - 开发框架\n- **SharpPcap 6.2.5** - 网络抓包库\n- **PacketDotNet 1.4.7** - 数据包解析库",
    "ContentSha": "O51vD6tG6vjx8xmeQW5pxGURF2SMCo7Ut44OxMgd8a8=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "## 주의사항\n\n1. **관리자 권한**: 패킷 캡처 기능은 관리자 권한이 필요하며, 그렇지 않으면 네트워크 어댑터를 열 수 없습니다.\n2. **방화벽**: 일부 방화벽은 패킷 캡처 작업을 차단할 수 있습니다.\n3. **성능 영향**: 대량의 네트워크 트래픽은 프로그램 성능에 영향을 줄 수 있으므로, 처리량을 줄이기 위해 포트 필터링 사용을 권장합니다.\n4. **개인정보 보호**: 합법적이고 규정을 준수하는 환경에서 사용하며 타인의 개인정보를 캡처하지 마십시오.\n5. **포트 필터링**: 포트 필터링을 사용하면 처리해야 할 패킷 수를 크게 줄여 성능을 향상시킬 수 있습니다.\n\n## 문제 해결\n\n### 문제1: 네트워크 장치를 찾을 수 없음\n\n**오류 메시지**: `No network devices found`\n\n**해결 방법**:\n- 네트워크 어댑터 드라이버가 설치되어 있는지 확인\n- 사용 가능한 네트워크 연결이 있는지 확인\n- 관리자 권한으로 실행 시도\n\n### 문제2: 장치를 열 수 없음\n\n**오류 메시지**: `Failed to open device`\n\n**해결 방법**:\n- 관리자 권한으로 실행하는지 확인\n- 다른 프로그램이 네트워크 어댑터를 사용 중인지 확인\n- 프로그램 재시작 시도\n\n### 문제3: 파싱 실패\n\n**현상**: 일부 패킷이 파싱되지 않음\n\n**설명**: 이는 정상적인 현상이며, 인식할 수 없는 프로토콜은 BinaryParser를 사용해 16진수 형식으로 출력됩니다.\n\n## 기술 스택\n\n- **.NET 6.0** - 개발 프레임워크\n- **SharpPcap 6.2.5** - 네트워크 패킷 캡처 라이브러리\n- **PacketDotNet 1.4.7** - 패킷 파싱 라이브러리\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  },
  {
    "Id": 29,
    "Content": "- **Newtonsoft.Json 13.0.3** - JSON 解析库\n\n## 许可证\n\n本项目仅供学习和研究使用。\n\n## 更新日志\n\n### v1.0.0 (2024)\n- ✅ 实现实时网络抓包功能\n- ✅ 支持 JSON/HTTP/二进制协议自动识别\n- ✅ 实现业务逻辑分发机制\n- ✅ 支持优雅退出（Ctrl+C）\n\n## 联系方式\n\n如有问题或建议，请提交 Issue 或 Pull Request。\n\n---\n\n**⚠️ 免责声明**：本工具仅供学习和合法用途使用，使用者需自行承担使用本工具所产生的法律责任。\n\n\n## Stargazers over time\n[![Stargazers over time](https://starchart.cc/Preserved-name/PacketSniffer.svg?variant=adaptive)](https://starchart.cc/Preserved-name/PacketSniffer)\n",
    "ContentSha": "wJGM+pFhlbZjwS3sAAbfUGeraf7t5sLkx07t1K/LPoQ=",
    "SectionType": "",
    "StartLine": 0,
    "EndLine": 0,
    "Translation": "- **Newtonsoft.Json 13.0.3** - JSON 파싱 라이브러리\n\n## 라이선스\n\n본 프로젝트는 학습 및 연구용으로만 사용 가능합니다.\n\n## 변경 로그\n\n### v1.0.0 (2024)\n- ✅ 실시간 네트워크 패킷 캡처 기능 구현\n- ✅ JSON/HTTP/바이너리 프로토콜 자동 인식 지원\n- ✅ 비즈니스 로직 분배 메커니즘 구현\n- ✅ 우아한 종료 지원 (Ctrl+C)\n\n## 연락처\n\n문의 사항이나 제안이 있으면 Issue 또는 Pull Request를 제출해 주세요.\n\n---\n\n**⚠️ 면책 조항**: 본 도구는 학습 및 합법적인 용도로만 사용해야 하며, 사용자는 본 도구 사용으로 인한 법적 책임을 스스로 감수해야 합니다.\n\n\n## 시간에 따른 스타 수\n[![시간에 따른 스타 수](https://starchart.cc/Preserved-name/PacketSniffer.svg?variant=adaptive)](https://starchart.cc/Preserved-name/PacketSniffer)\n",
    "Status": "ok",
    "RowTranslations": [],
    "IsCodeBlock": false
  }
]