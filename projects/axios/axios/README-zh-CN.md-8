{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// 创建实例时设置配置默认值\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// 在实例创建后修改默认值\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### 配置优先级顺序\n\n配置将按照优先级顺序进行合并。顺序为：[lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49) 中库的默认值，然后是实例的 `defaults` 属性，最后是请求的 `config` 参数。后者会覆盖前者。以下是示例。\n\n```js\n// 使用库提供的配置默认值创建实例\n// 此时超时配置值为 `0`，这是库的默认值\nconst instance = axios.create();\n\n// 覆盖库的超时默认值\n// 现在所有使用此实例的请求将在超时前等待 2.5 秒\ninstance.defaults.timeout = 2500;\n\n// 为该请求覆盖超时时间，因为已知该请求需要较长时间\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## 拦截器\n\n你可以在 `then` 或 `catch` 处理请求或响应之前拦截它们。\n\n```js\n\nconst instance = axios.create();\n\n// 添加请求拦截器\ninstance.interceptors.request.use(function (config) {\n    // 在请求发送之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  });\n\n// 添加响应拦截器\ninstance.interceptors.response.use(function (response) {\n    // 任何 2xx 范围内的状态码都会触发该函数\n    // 对响应数据做些什么\n    return response;\n  }, function (error) {\n    // 任何超出 2xx 范围的状态码都会触发该函数\n    // 对响应错误做些什么\n    return Promise.reject(error);\n  });\n```\n\n如果你需要在之后移除拦截器，也可以做到。\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\n你也可以清除所有请求或响应的拦截器。\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // 移除请求拦截器\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // 移除响应拦截器\n```\n\n你可以为 axios 的自定义实例添加拦截器。\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\n当你添加请求拦截器时，默认情况下它们被视为异步。这可能会在主线程被阻塞时导致 axios 请求执行延迟（拦截器底层会创建一个 promise，你的请求会被放到调用栈底部）。如果你的请求拦截器是同步的，你可以在选项对象中添加一个标志，告知 axios 以同步方式运行代码，从而避免请求执行的延迟。\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\n如果你想根据运行时检查执行特定拦截器，可以在选项对象中添加 `runWhen` 函数。**只有当** `runWhen` 返回 `false` 时，请求拦截器才不会被执行。该函数会接收 config 对象（你也可以绑定自己的参数）。当你有一个仅在特定时间需要运行的异步请求拦截器时，这非常有用。\n```",
  "status": "ok"
}