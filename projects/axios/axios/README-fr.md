<h3 align="center"> 🥇 Sponsors Or Gold <br> </h3> <table align="center" width="100%"><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="38px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/stytch_white.png"> <img width="200px" height="38px" src="https://axios-http.com/assets/sponsors/stytch.png" alt="Stytch"/> </picture> </a> <p align="center" title="API-first authentication, authorization, and fraud prevention">Authentification, autorisation et prévention de la fraude orientées API</p> <p align="center"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http"><b>Site web</b></a> | <a href="https://stytch.com/docs?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;docs-link&amp;utm_campaign&#x3D;axios-http"><b>Documentation</b></a> | <a href="https://github.com/stytchauth/stytch-node?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;node-sdk&amp;utm_campaign&#x3D;axios-http"><b>Node.js</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="133px" height="43px" src="https://axios-http.com/assets/sponsors/principal.svg" alt="Principal Financial Group"/> </a> <p align="center" title="We’re bound by one common purpose: to give you the financial tools, resources and information you need to live your best life.">Nous sommes unis par un objectif commun : vous fournir les outils financiers, ressources et informations nécessaires pour vivre votre meilleure vie.</p> <p align="center"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.principal.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="85px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buy-instagram-followers-twicsy.png" alt="Buy Instagram Followers Twicsy"/> </a> <p align="center" title="Buy real Instagram followers from Twicsy starting at only $2.97. Twicsy has been voted the best site to buy followers from the likes of US Magazine.">Achetez de vrais abonnés Instagram sur Twicsy à partir de seulement 2,97 $. Twicsy a été élu meilleur site pour acheter des abonnés selon US Magazine.</p> <p align="center"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>twicsy.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="52px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/descope_white.png"> <img width="200px" height="52px" src="https://axios-http.com/assets/sponsors/descope.png" alt="Descope"/> </picture> </a> <p align="center" title="Hi, we&#x27;re Descope! We are building something in the authentication space for app developers and can’t wait to place it in your hands.">Bonjour, nous sommes Descope ! Nous développons une solution d’authentification pour les développeurs d’applications et avons hâte de la mettre entre vos mains.</p> <p align="center"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>Site web</b></a> | <a href="https://docs.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>Docs</b></a> | <a href="https://www.descope.com/community?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>Communauté</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="62px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buzzoid-buy-instagram-followers.png" alt="Buzzoid - Buy Instagram Followers"/> </a> <p align="center" title="At Buzzoid, you can buy Instagram followers quickly, safely, and easily with just a few clicks. Rated world&#x27;s #1 IG service since 2012.">Chez Buzzoid, vous pouvez acheter des abonnés Instagram rapidement, en toute sécurité et facilement en quelques clics. Classé service IG n°1 mondial depuis 2012.</p> <p align="center"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>buzzoid.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/famety-buy-instagram-followers.png" alt="Famety - Buy Instagram Followers"/> </a> <p align="center" title="At Famety, you can grow your social media following quickly, safely, and easily with just a few clicks. Rated the world’s #1 social media service since 2013.">Chez Famety, développez votre audience sur les réseaux sociaux rapidement, en toute sécurité et facilement en quelques clics. Classé service social n°1 mondial depuis 2013.</p> <p align="center"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.famety.net</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/instagram-likes.png" alt="Poprey - Buy Instagram Likes"/> </a> <p align="center" title="Buy Instagram Likes">Achetez des mentions J’aime Instagram</p> <p align="center"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>poprey.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/youtube-subscribers-ssmarket.png" alt="Buy Youtube Subscribers"/> </a> <p align="center" title="SS Market offers professional social media services that rapidly increase your YouTube subscriber count, elevating your channel to a powerful position.">SS Market propose des services professionnels pour les réseaux sociaux permettant d’augmenter rapidement votre nombre d’abonnés YouTube et d’élever votre chaîne à un niveau supérieur.</p> <p align="center"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>ssmarket.net</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="200px" height="56px" src="https://axios-http.com/assets/sponsors/opencollective/smmpanelserver123.png" alt="smmpanelserver"/> </a> <p align="center" title="smmpanelserver - Best and Cheapest Smm Panel">smmpanelserver - Meilleur et moins cher panneau SMM</p> <p align="center"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>smmpanelserver.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 Devenez sponsor</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 Devenez sponsor</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 Devenez sponsor</a>
</td></tr></table>

<!--<div>marker</div>-->
<br><br>
<div align="center">
   <a href="https://axios-http.com"><img src="https://axios-http.com/assets/logo.svg" /></a><br>
</div>

<p align="center">Client HTTP basé sur les Promesses pour le navigateur et node.js</p>

<p align="center">
    <a href="https://axios-http.com/"><b>Site web</b></a> •
    <a href="https://axios-http.com/docs/intro"><b>Documentation</b></a>
</p>

<div align="center">

[![npm version](https://img.shields.io/npm/v/axios.svg?style=flat-square)](https://www.npmjs.org/package/axios)
[![CDNJS](https://img.shields.io/cdnjs/v/axios.svg?style=flat-square)](https://cdnjs.com/libraries/axios)
[![Build status](https://img.shields.io/github/actions/workflow/status/axios/axios/ci.yml?branch=v1.x&label=CI&logo=github&style=flat-square)](https://github.com/axios/axios/actions/workflows/ci.yml)
[![Gitpod Ready-to-Code](https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod&style=flat-square)](https://gitpod.io/#https://github.com/axios/axios)
[![code coverage](https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square)](https://coveralls.io/r/mzabriskie/axios)
[![install size](https://img.shields.io/badge/dynamic/json?url=https://packagephobia.com/v2/api.json?p=axios&query=$.install.pretty&label=install%20size&style=flat-square)](https://packagephobia.now.sh/result?p=axios)
[![npm bundle size](https://img.shields.io/bundlephobia/minzip/axios?style=flat-square)](https://bundlephobia.com/package/axios@latest)
[![npm downloads](https://img.shields.io/npm/dm/axios.svg?style=flat-square)](https://npm-stat.com/charts.html?package=axios)
[![gitter chat](https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square)](https://gitter.im/mzabriskie/axios)
[![code helpers](https://www.codetriage.com/axios/axios/badges/users.svg)](https://www.codetriage.com/axios/axios)
[![Known Vulnerabilities](https://snyk.io/test/npm/axios/badge.svg)](https://snyk.io/test/npm/axios)




</div>

## Table des matières

  - [Fonctionnalités](#features)
  - [Compatibilité navigateur](#browser-support)
  - [Installation](#installing)
    - [Gestionnaire de paquets](#package-manager)
    - [CDN](#cdn)
  - [Exemple](#example)
  - [API Axios](#axios-api)
  - [Alias de méthodes de requête](#request-method-aliases)
  - [Concurrence 👎](#concurrency-deprecated)
  - [Créer une instance](#creating-an-instance)
  - [Méthodes d'instance](#instance-methods)
  - [Config Requête](#request-config)
  - [Schéma de réponse](#response-schema)
  - [Valeurs par défaut de configuration](#config-defaults)
    - [Valeurs globales par défaut](#global-axios-defaults)
    - [Valeurs par défaut pour une instance personnalisée](#custom-instance-defaults)
    - [Ordre de priorité de la configuration](#config-order-of-precedence)
  - [Intercepteurs](#interceptors)
    - [Intercepteurs multiples](#multiple-interceptors)
  - [Gestion des erreurs](#handling-errors)
  - [Annulation](#cancellation)
    - [AbortController](#abortcontroller)
    - [CancelToken 👎](#canceltoken-deprecated)
  - [Utiliser le format application/x-www-form-urlencoded](#using-applicationx-www-form-urlencoded-format)
    - [URLSearchParams](#urlsearchparams)
    - [Chaîne de requête](#query-string-older-browsers)
    - [🆕 Sérialisation automatique](#-automatic-serialization-to-urlsearchparams)
  - [Utiliser le format multipart/form-data](#using-multipartform-data-format)
    - [FormData](#formdata)
    - [🆕 Sérialisation automatique](#-automatic-serialization-to-formdata)
  - [Envoi de fichiers](#files-posting)
  - [Envoi de formulaire HTML](#-html-form-posting-browser)
  - [🆕 Capture de progression](#-progress-capturing)
  - [🆕 Limitation de débit](#-progress-capturing)
  - [🆕 AxiosHeaders](#-axiosheaders)
  - [🔥 Adaptateur Fetch](#-fetch-adapter)
  - [Semver](#semver)
  - [Promesses](#promises)
  - [TypeScript](#typescript)
  - [Ressources](#resources)
  - [Crédits](#credits)
  - [Licence](#license)

## Fonctionnalités

- Effectuer des [XMLHttpRequests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) depuis le navigateur
- Effectuer des requêtes [http](https://nodejs.org/api/http.html) depuis node.js
- Prise en charge de l'API [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- Intercepter les requêtes et les réponses
- Transformer les données des requêtes et des réponses
- Annuler les requêtes
- Transformations automatiques pour les données [JSON](https://www.json.org/json-en.html)
- 🆕 Sérialisation automatique des objets de données en encodages de corps `multipart/form-data` et `x-www-form-urlencoded`
- Prise en charge côté client pour la protection contre la [XSRF](https://fr.wikipedia.org/wiki/Cross-site_request_forgery)

## Prise en charge des navigateurs

![Chrome](https://raw.githubusercontent.com/alrra/browser-logos/main/src/chrome/chrome_48x48.png) | ![Firefox](https://raw.githubusercontent.com/alrra/browser-logos/main/src/firefox/firefox_48x48.png) | ![Safari](https://raw.githubusercontent.com/alrra/browser-logos/main/src/safari/safari_48x48.png) | ![Opera](https://raw.githubusercontent.com/alrra/browser-logos/main/src/opera/opera_48x48.png) | ![Edge](https://raw.githubusercontent.com/alrra/browser-logos/main/src/edge/edge_48x48.png) |
--- | --- | --- | --- | --- |
Dernière ✔ | Dernière ✔ | Dernière ✔ | Dernière ✔ | Dernière ✔ | 11 ✔ |

[![Browser Matrix](https://saucelabs.com/open_sauce/build_matrix/axios.svg)](https://saucelabs.com/u/axios)

## Installation

### Gestionnaire de paquets

Avec npm :

```bash
$ npm install axios
```

Avec bower :

```bash
$ bower install axios
```

Avec yarn :

```bash
$ yarn add axios
```

Avec pnpm :

```bash
$ pnpm add axios
```

Avec bun :

```bash
$ bun add axios
```

Une fois le paquet installé, vous pouvez importer la bibliothèque en utilisant l'approche `import` ou `require` :

```js
import axios, {isCancel, AxiosError} from 'axios';
```

Vous pouvez également utiliser l’exportation par défaut, puisque l’exportation nommée n’est qu’une réexportation de la fabrique Axios :

```js
import axios from 'axios';

console.log(axios.isCancel('something'));
````

Si vous utilisez `require` pour l'importation, **seule l’exportation par défaut est disponible** :

```js
const axios = require('axios');

console.log(axios.isCancel('something'));
```

Pour certains bundlers et certains linters ES6, il peut être nécessaire de faire ce qui suit :

```js
import { default as axios } from 'axios';
```

Dans les cas où une erreur se produit lors de l’import d’un module dans un environnement personnalisé ou hérité,
vous pouvez essayer d’importer directement le paquet du module :

```js
const axios = require('axios/dist/browser/axios.cjs'); // bundle commonJS pour navigateur (ES2017)
// const axios = require('axios/dist/node/axios.cjs'); // bundle commonJS pour node (ES2017)
```

### CDN

Avec le CDN jsDelivr (module navigateur UMD ES5) :

```html
<script src="https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js"></script>
```

Avec le CDN unpkg :

```html
<script src="https://unpkg.com/axios@1.6.7/dist/axios.min.js"></script>
```

## Exemple

> **Remarque** : Utilisation de CommonJS  
> Afin de bénéficier des typings TypeScript (pour l’intellisense / l’autocomplétion) tout en utilisant des imports CommonJS avec `require()`, utilisez l’approche suivante :
```js
import axios from 'axios';
//const axios = require('axios'); // méthode héritée

// Effectuer une requête pour un utilisateur avec un ID donné
axios.get('/user?ID=12345')
  .then(function (response) {
    // gérer le succès
    console.log(response);
  })
  .catch(function (error) {
    // gérer l'erreur
    console.log(error);
  })
  .finally(function () {
    // toujours exécuté
  });

// Optionnellement, la requête ci-dessus pourrait également être effectuée ainsi
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .finally(function () {
    // toujours exécuté
  });

// Vous souhaitez utiliser async/await ? Ajoutez le mot-clé `async` à votre fonction/méthode externe.
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
```

> **Remarque** : `async/await` fait partie d'ECMAScript 2017 et n'est pas pris en charge dans Internet
> Explorer et les anciens navigateurs, donc à utiliser avec précaution.

Effectuer une requête `POST`

```js
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

Effectuer plusieurs requêtes concurrentes

```js
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

Promise.all([getUserAccount(), getUserPermissions()])
  .then(function (results) {
    const acct = results[0];
    const perm = results[1];
  });
```

## API axios

Les requêtes peuvent être effectuées en passant la configuration appropriée à `axios`.

##### axios(config)

```js
// Envoyer une requête POST
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});
```

```js
// Requête GET pour une image distante en node.js
axios({
  method: 'get',
  url: 'https://bit.ly/2mTM3nY',
  responseType: 'stream'
})
  .then(function (response) {
    response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))
  });
```

##### axios(url[, config])

```js
// Envoyer une requête GET (méthode par défaut)
axios('/user/12345');
```

### Alias de méthode de requête

Pour plus de commodité, des alias ont été fournis pour toutes les méthodes de requête courantes.

##### axios.request(config)
##### axios.get(url[, config])
##### axios.delete(url[, config])
##### axios.head(url[, config])
##### axios.options(url[, config])
##### axios.post(url[, data[, config]])
##### axios.put(url[, data[, config]])
##### axios.patch(url[, data[, config]])

###### REMARQUE
Lorsque vous utilisez les méthodes alias, les propriétés `url`, `method` et `data` n'ont pas besoin d'être spécifiées dans la configuration.

### Concurrence (Obsolète)
Veuillez utiliser `Promise.all` pour remplacer les fonctions ci-dessous.

Fonctions utilitaires pour gérer les requêtes concurrentes.

axios.all(iterable)
axios.spread(callback)

### Création d'une instance

Vous pouvez créer une nouvelle instance d'axios avec une configuration personnalisée.

##### axios.create([config])

```js
const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});
```

### Méthodes d'instance

Les méthodes d'instance disponibles sont listées ci-dessous. La configuration spécifiée sera fusionnée avec la configuration de l'instance.

##### axios#request(config)
##### axios#get(url[, config])
##### axios#delete(url[, config])
##### axios#head(url[, config])
##### axios#options(url[, config])
##### axios#post(url[, data[, config]])
##### axios#put(url[, data[, config]])
##### axios#patch(url[, data[, config]])
##### axios#getUri([config])

## Configuration de la requête

Voici les options de configuration disponibles pour effectuer des requêtes. Seule la propriété `url` est requise. Les requêtes utiliseront par défaut la méthode `GET` si `method` n'est pas spécifié.

```js
{
  // `url` est l’URL du serveur qui sera utilisée pour la requête
  url: '/user',

  // `method` est la méthode de requête à utiliser lors de la requête
  method: 'get', // par défaut

  // `baseURL` sera préfixée à `url` à moins que `url` soit absolue et que l’option `allowAbsoluteUrls` soit définie à true.
  // Il peut être pratique de définir `baseURL` pour une instance d’axios afin de passer des URL relatives
  // aux méthodes de cette instance.
  baseURL: 'https://some-domain.com/api/',

  // `allowAbsoluteUrls` détermine si les URLs absolues remplaceront un `baseUrl` configuré ou non.
  // Lorsqu'il est défini à true (par défaut), les valeurs absolues pour `url` remplaceront `baseUrl`.
  // Lorsqu'il est défini à false, les valeurs absolues pour `url` seront toujours précédées de `baseUrl`.
  allowAbsoluteUrls: true,

  // `transformRequest` permet de modifier les données de la requête avant qu'elles ne soient envoyées au serveur
  // Ceci n’est applicable que pour les méthodes de requête 'PUT', 'POST', 'PATCH' et 'DELETE'
  // La dernière fonction du tableau doit retourner une chaîne ou une instance de Buffer, ArrayBuffer,
  // FormData ou Stream
  // Vous pouvez modifier l’objet headers.
  transformRequest: [function (data, headers) {
    // Faites ce que vous souhaitez pour transformer les données
```
```markdown
    return data;
  }],

  // `transformResponse` permet de modifier les données de la réponse avant
  // qu'elles ne soient transmises à then/catch
  transformResponse: [function (data) {
    // Faites ce que vous voulez pour transformer les données

    return data;
  }],

  // `headers` sont des en-têtes personnalisés à envoyer
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // `params` sont les paramètres d'URL à envoyer avec la requête
  // Doit être un objet simple ou un objet URLSearchParams
  params: {
    ID: 12345
  },
  
  // `paramsSerializer` est une configuration optionnelle qui permet de personnaliser la sérialisation des `params`. 
  paramsSerializer: {

    // Fonction d'encodage personnalisée qui envoie les paires clé/valeur de manière itérative.
    encode?: (param: string): string => { /* Effectuez des opérations personnalisées ici et retournez la chaîne transformée */ }, 
    
    // Fonction de sérialisation personnalisée pour l'ensemble des paramètres. Permet à l'utilisateur d'imiter le comportement antérieur à la version 1.x.
    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ), 
    
    // Configuration pour le formatage des index de tableau dans les params. 
    indexes: false // Trois options disponibles : (1) indexes: null (pas de crochets), (2) (par défaut) indexes: false (crochets vides), (3) indexes: true (crochets avec index).    
  },

  // `data` sont les données à envoyer en tant que corps de la requête
  // Applicable uniquement pour les méthodes 'PUT', 'POST', 'DELETE' et 'PATCH'
  // Lorsqu'aucun `transformRequest` n'est défini, doit être de l'un des types suivants :
  // - string, objet simple, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - Navigateur uniquement : FormData, File, Blob
  // - Node uniquement : Stream, Buffer, FormData (paquet form-data)
  data: {
    firstName: 'Fred'
  },

  // syntaxe alternative pour envoyer des données dans le corps
  // méthode post
  // seule la valeur est envoyée, pas la clé
  data: 'Country=Brasil&City=Belo Horizonte',

  // `timeout` spécifie le nombre de millisecondes avant l'expiration de la requête.
  // Si la requête prend plus longtemps que `timeout`, elle sera abandonnée.
  timeout: 1000, // la valeur par défaut est `0` (pas de délai d'expiration)

  // `withCredentials` indique si les requêtes cross-site Access-Control
  // doivent être effectuées avec des identifiants
  withCredentials: false, // valeur par défaut

  // `adapter` permet une gestion personnalisée des requêtes, ce qui facilite les tests.
  // Retourne une promesse et fournit une réponse valide (voir lib/adapters/README.md)
  adapter: function (config) {
    /* ... */
  },
  // Vous pouvez également définir le nom de l'adaptateur intégré, ou fournir un tableau avec leurs noms
  // pour choisir le premier disponible dans l'environnement
  adapter: 'xhr', // 'fetch' | 'http' | ['xhr', 'http', 'fetch']

  // `auth` indique que l'authentification HTTP Basic doit être utilisée, et fournit les identifiants.
  // Cela définira un en-tête `Authorization`, écrasant tout en-tête
  // `Authorization` personnalisé que vous avez défini via `headers`.
  // Veuillez noter que seule l'authentification HTTP Basic est configurable via ce paramètre.
  // Pour les tokens Bearer, etc., utilisez plutôt les en-têtes personnalisés `Authorization`.
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

  // `responseType` indique le type de données que le serveur renverra
  // options : 'arraybuffer', 'document', 'json', 'text', 'stream'
  //   navigateur uniquement : 'blob'
  responseType: 'json', // valeur par défaut

  // `responseEncoding` indique l'encodage à utiliser pour décoder les réponses (Node.js uniquement)
  // Remarque : Ignoré pour `responseType` de 'stream' ou les requêtes côté client
  // options : 'ascii', 'ASCII', 'ansi', 'ANSI', 'binary', 'BINARY', 'base64', 'BASE64', 'base64url',
  // 'BASE64URL', 'hex', 'HEX', 'latin1', 'LATIN1', 'ucs-2', 'UCS-2', 'ucs2', 'UCS2', 'utf-8', 'UTF-8',
  // 'utf8', 'UTF8', 'utf16le', 'UTF16LE'
  responseEncoding: 'utf8', // valeur par défaut

  // `xsrfCookieName` est le nom du cookie à utiliser comme valeur pour le token xsrf
  xsrfCookieName: 'XSRF-TOKEN', // valeur par défaut

  // `xsrfHeaderName` est le nom de l'en-tête http qui transporte la valeur du token xsrf
  xsrfHeaderName: 'X-XSRF-TOKEN', // valeur par défaut
    
  // `undefined` (par défaut) - définit l'en-tête XSRF uniquement pour les requêtes de même origine
  withXSRFToken: boolean | undefined | ((config: InternalAxiosRequestConfig) => boolean | undefined),

  // `onUploadProgress` permet la gestion des événements de progression pour les téléchargements
  // navigateur & node.js
  onUploadProgress: function ({loaded, total, progress, bytes, estimated, rate, upload = true}) {
```
```markdown
    // Faites ce que vous voulez avec l'événement de progression Axios
  },

  // `onDownloadProgress` permet la gestion des événements de progression pour les téléchargements
  // navigateur & node.js
  onDownloadProgress: function ({loaded, total, progress, bytes, estimated, rate, download = true}) {
    // Faites ce que vous voulez avec l'événement de progression Axios
  },

  // `maxContentLength` définit la taille maximale du contenu de la réponse http en octets autorisée dans node.js
  maxContentLength: 2000,

  // `maxBodyLength` (option uniquement pour Node) définit la taille maximale du contenu de la requête http en octets autorisée
  maxBodyLength: 2000,

  // `validateStatus` définit s'il faut résoudre ou rejeter la promesse pour un
  // code de statut de réponse HTTP donné. Si `validateStatus` retourne `true` (ou est défini sur `null`
  // ou `undefined`), la promesse sera résolue ; sinon, la promesse sera
  // rejetée.
  validateStatus: function (status) {
    return status >= 200 && status < 300; // valeur par défaut
  },

  // `maxRedirects` définit le nombre maximum de redirections à suivre dans node.js.
  // Si défini à 0, aucune redirection ne sera suivie.
  maxRedirects: 21, // valeur par défaut

  // `beforeRedirect` définit une fonction qui sera appelée avant la redirection.
  // Utilisez ceci pour ajuster les options de la requête lors d'une redirection,
  // pour inspecter les derniers en-têtes de réponse,
  // ou pour annuler la requête en lançant une erreur
  // Si maxRedirects est défini à 0, `beforeRedirect` n'est pas utilisé.
  beforeRedirect: (options, { headers }) => {
    if (options.hostname === "example.com") {
      options.auth = "user:password";
    }
  },

  // `socketPath` définit un socket UNIX à utiliser dans node.js.
  // par ex. '/var/run/docker.sock' pour envoyer des requêtes au démon docker.
  // Seul `socketPath` ou `proxy` peut être spécifié.
  // Si les deux sont spécifiés, `socketPath` est utilisé.
  socketPath: null, // valeur par défaut
  
  // `transport` détermine la méthode de transport qui sera utilisée pour effectuer la requête.
  // Si défini, il sera utilisé. Sinon, si `maxRedirects` est 0,
  // la bibliothèque `http` ou `https` par défaut sera utilisée, selon le protocole spécifié dans `protocol`.
  // Sinon, la bibliothèque `httpFollow` ou `httpsFollow` sera utilisée, encore une fois selon le protocole,
  // qui peut gérer les redirections.
  transport: undefined, // valeur par défaut

  // `httpAgent` et `httpsAgent` définissent un agent personnalisé à utiliser lors des requêtes http
  // et https, respectivement, dans node.js. Cela permet d'ajouter des options comme
  // `keepAlive` qui ne sont pas activées par défaut avant Node.js v19.0.0. Après Node.js
  // v19.0.0, il n'est plus nécessaire de personnaliser l'agent pour activer `keepAlive` car
  // `http.globalAgent` a `keepAlive` activé par défaut.
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),

  // `proxy` définit le nom d'hôte, le port et le protocole du serveur proxy.
  // Vous pouvez également définir votre proxy en utilisant les variables d'environnement conventionnelles `http_proxy` et
  // `https_proxy`. Si vous utilisez des variables d'environnement
  // pour votre configuration proxy, vous pouvez également définir une variable d'environnement `no_proxy`
  // comme une liste de domaines séparés par des virgules qui ne doivent pas être proxyfiés.
  // Utilisez `false` pour désactiver les proxys, en ignorant les variables d'environnement.
  // `auth` indique que l'authentification HTTP Basic doit être utilisée pour se connecter au proxy, et
  // fournit les identifiants.
  // Cela définira un en-tête `Proxy-Authorization`, écrasant tous les
  // en-têtes personnalisés `Proxy-Authorization` que vous avez définis via `headers`.
  // Si le serveur proxy utilise HTTPS, vous devez alors définir le protocole sur `https`.
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    // hostname: '127.0.0.1' // Prend le dessus sur 'host' si les deux sont définis
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  // `cancelToken` spécifie un jeton d'annulation qui peut être utilisé pour annuler la requête
  // (voir la section Annulation ci-dessous pour plus de détails)
  cancelToken: new CancelToken(function (cancel) {
  }),

  // une autre manière d'annuler les requêtes Axios en utilisant AbortController
  signal: new AbortController().signal,

  // `decompress` indique si le corps de la réponse doit être décompressé
  // automatiquement. Si défini à `true`, supprimera également l'en-tête 'content-encoding'
  // des objets réponses de toutes les réponses décompressées
  // - Uniquement Node (XHR ne peut pas désactiver la décompression)
  decompress: true, // valeur par défaut

  // `insecureHTTPParser` booléen.
  // Indique s'il faut utiliser un parseur HTTP non sécurisé qui accepte des en-têtes HTTP invalides.
  // Cela peut permettre l'interopérabilité avec des implémentations HTTP non conformes.
  // L'utilisation du parseur non sécurisé doit être évitée.
  // voir les options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback
```
```js
  // voir aussi https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none
  insecureHTTPParser: undefined, // valeur par défaut

  // options transitoires pour la rétrocompatibilité qui pourraient être supprimées dans les futures versions
  transitional: {
    // mode silencieux d’analyse JSON
    // `true`  - ignorer les erreurs d’analyse JSON et définir response.data à null si l’analyse échoue (ancien comportement)
    // `false` - lancer une erreur SyntaxError si l’analyse JSON échoue (Remarque : responseType doit être défini sur 'json')
    silentJSONParsing: true, // valeur par défaut pour la version actuelle d’Axios

    // tenter d’analyser la chaîne de réponse comme JSON même si `responseType` n’est pas 'json'
    forcedJSONParsing: true,

    // lancer une erreur ETIMEDOUT au lieu de l’erreur générique ECONNABORTED lors des expirations de requête
    clarifyTimeoutError: false,
  },

  env: {
    // La classe FormData à utiliser pour sérialiser automatiquement la charge utile dans un objet FormData
    FormData: window?.FormData || global?.FormData
  },

  formSerializer: {
      visitor: (value, key, path, helpers) => {}, // fonction visiteur personnalisée pour sérialiser les valeurs du formulaire
      dots: boolean, // utiliser le format à points au lieu du format entre crochets
      metaTokens: boolean, // conserver les terminaisons spéciales comme {} dans la clé du paramètre
      indexes: boolean, // format des index de tableau : null - pas de crochets, false - crochets vides, true - crochets avec index
  },

  // adaptateur http uniquement (node.js)
  maxRate: [
    100 * 1024, // limite d’upload de 100KB/s,
    100 * 1024  // limite de download de 100KB/s
  ]
}
```

## Schéma de la réponse

La réponse à une requête contient les informations suivantes.

```js
{
  // `data` est la réponse fournie par le serveur
  data: {},

  // `status` est le code de statut HTTP de la réponse serveur
  status: 200,

  // `statusText` est le message de statut HTTP de la réponse serveur
  statusText: 'OK',

  // `headers` sont les en-têtes HTTP avec lesquels le serveur a répondu
  // Tous les noms d’en-tête sont en minuscules et accessibles via la notation entre crochets.
  // Exemple : `response.headers['content-type']`
  headers: {},

  // `config` est la configuration transmise à `axios` pour la requête
  config: {},

  // `request` est la requête qui a généré cette réponse
  // Il s’agit de la dernière instance ClientRequest dans node.js (en cas de redirections)
  // et d’une instance XMLHttpRequest dans le navigateur
  request: {}
}
```

Lors de l’utilisation de `then`, vous recevrez la réponse comme suit :

```js
axios.get('/user/12345')
  .then(function (response) {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });
```

Lors de l’utilisation de `catch`, ou en passant un [callback de rejet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) en second paramètre de `then`, la réponse sera disponible via l’objet `error` comme expliqué dans la section [Gestion des erreurs](#handling-errors).

## Valeurs par défaut de la configuration

Vous pouvez spécifier des valeurs par défaut de configuration qui seront appliquées à chaque requête.

### Valeurs par défaut globales d’axios

```js
axios.defaults.baseURL = 'https://api.example.com';

// Important : Si axios est utilisé avec plusieurs domaines, le AUTH_TOKEN sera envoyé à tous.
// Voir ci-dessous pour un exemple utilisant les valeurs par défaut d’une instance personnalisée.
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;

axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
```

### Valeurs par défaut d’une instance personnalisée
```
```js
// Définir les valeurs par défaut de la configuration lors de la création de l'instance
const instance = axios.create({
  baseURL: 'https://api.example.com'
});

// Modifier les valeurs par défaut après la création de l'instance
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;
```

### Ordre de priorité de la configuration

La configuration sera fusionnée selon un ordre de priorité. L'ordre est : les valeurs par défaut de la bibliothèque trouvées dans [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), puis la propriété `defaults` de l'instance, et enfin l'argument `config` pour la requête. Ce dernier prendra le dessus sur le précédent. Voici un exemple.

```js
// Créer une instance en utilisant les valeurs de configuration par défaut fournies par la bibliothèque
// À ce stade, la valeur de configuration timeout est `0`, comme c'est le cas par défaut pour la bibliothèque
const instance = axios.create();

// Remplacer la valeur par défaut du timeout pour la bibliothèque
// Désormais, toutes les requêtes utilisant cette instance attendront 2,5 secondes avant d'expirer
instance.defaults.timeout = 2500;

// Remplacer le timeout pour cette requête car elle est connue pour être longue
instance.get('/longRequest', {
  timeout: 5000
});
```

## Intercepteurs

Vous pouvez intercepter les requêtes ou les réponses avant qu'elles ne soient traitées par `then` ou `catch`.

```js

const instance = axios.create();

// Ajouter un intercepteur de requête
instance.interceptors.request.use(function (config) {
    // Faire quelque chose avant l'envoi de la requête
    return config;
  }, function (error) {
    // Faire quelque chose en cas d'erreur de requête
    return Promise.reject(error);
  });

// Ajouter un intercepteur de réponse
instance.interceptors.response.use(function (response) {
    // Tout code de statut compris dans la plage 2xx déclenche cette fonction
    // Faire quelque chose avec les données de la réponse
    return response;
  }, function (error) {
    // Tout code de statut en dehors de la plage 2xx déclenche cette fonction
    // Faire quelque chose en cas d'erreur de réponse
    return Promise.reject(error);
  });
```

Si vous avez besoin de supprimer un intercepteur plus tard, vous pouvez le faire.

```js
const instance = axios.create();
const myInterceptor = instance.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

Vous pouvez également supprimer tous les intercepteurs pour les requêtes ou les réponses.
```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
instance.interceptors.request.clear(); // Supprime les intercepteurs des requêtes
instance.interceptors.response.use(function () {/*...*/});
instance.interceptors.response.clear(); // Supprime les intercepteurs des réponses
```

Vous pouvez ajouter des intercepteurs à une instance personnalisée d'axios.

```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
```

Lorsque vous ajoutez des intercepteurs de requête, ils sont supposés être asynchrones par défaut. Cela peut entraîner un délai
dans l'exécution de votre requête axios lorsque le thread principal est bloqué (une promesse est créée en interne pour
l'intercepteur et votre requête est placée en bas de la pile d'appels). Si vos intercepteurs de requêtes sont synchrones, vous pouvez ajouter un indicateur
dans l'objet d'options qui indiquera à axios d'exécuter le code de façon synchrone et d'éviter tout délai dans l'exécution de la requête.

```js
axios.interceptors.request.use(function (config) {
  config.headers.test = 'Je suis uniquement un en-tête !';
  return config;
}, null, { synchronous: true });
```

Si vous souhaitez exécuter un intercepteur particulier en fonction d'un contrôle à l'exécution,
vous pouvez ajouter une fonction `runWhen` à l'objet d'options. L'intercepteur de requête ne sera **pas exécuté si et seulement si** le retour
de `runWhen` est `false`. La fonction sera appelée avec l'objet config
(n'oubliez pas que vous pouvez aussi lui lier vos propres arguments). Cela peut être utile lorsqu'un intercepteur de requête asynchrone
ne doit s'exécuter qu'à certains moments.
```
```js
function onGetCall(config) {
  return config.method === 'get';
}
axios.interceptors.request.use(function (config) {
  config.headers.test = 'special get headers';
  return config;
}, null, { runWhen: onGetCall });
```

> **Remarque :** le paramètre options (contenant les propriétés `synchronous` et `runWhen`) n'est actuellement pris en charge que pour les intercepteurs de requête.

### Intercepteurs Multiples

Si vous ajoutez plusieurs intercepteurs de réponse
et lorsque la réponse est remplie
- alors chaque intercepteur est exécuté
- puis ils sont exécutés dans l'ordre dans lequel ils ont été ajoutés
- ensuite, seul le résultat du dernier intercepteur est retourné
- chaque intercepteur reçoit le résultat de son prédécesseur
- et si l'intercepteur fulfillment lève une exception
    - alors l'intercepteur fulfillment suivant n'est pas appelé
    - alors l'intercepteur de rejet suivant est appelé
    - une fois capturé, un autre intercepteur fulfillment suivant est de nouveau appelé (comme dans une chaîne de promesses).

Lisez [les tests d'intercepteurs](https://raw.githubusercontent.com/axios/axios/v1.x/./test/specs/interceptors.spec.js) pour voir tout cela en code.

## Types d'Erreurs

Il existe différents messages d'erreurs axios qui peuvent apparaître et fournir des informations de base sur la spécificité de l'erreur et où des opportunités de débogage peuvent se présenter.

La structure générale des erreurs axios est la suivante :
| Propriété  | Définition  |
| -------- | ----------  |
| message  | Un résumé rapide du message d'erreur et du statut avec lequel il a échoué. |
| name     | Définit l'origine de l'erreur. Pour axios, ce sera toujours 'AxiosError'. |
| stack    | Fournit la trace de la pile de l'erreur. | 
| config   | Un objet de configuration axios avec des configurations d'instance spécifiques définies par l'utilisateur lors de la requête |
| code     | Représente une erreur identifiée par axios. Le tableau ci-dessous liste les définitions spécifiques pour les erreurs internes axios.  |
| status   | Code de statut de réponse HTTP. Voir [ici](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) pour la signification des codes de statut HTTP courants. 

Ci-dessous une liste des erreurs potentielles identifiées par axios :

| Code                      | Définition                                                                                                                                                                                                                                                                                                                                                                                     |
| --- | --- |
| ERR_BAD_OPTION_VALUE      | Valeur invalide fournie dans la configuration axios.                                                                                                                                                                                                                                                                                                                                           |
| ERR_BAD_OPTION            | Option invalide fournie dans la configuration axios.                                                                                                                                                                                                                                                                                                                                           |
| ERR_NOT_SUPPORT           | Fonctionnalité ou méthode non prise en charge dans l'environnement axios actuel.                                                                                                                                                                                                                                                                        |
| ERR_DEPRECATED            | Fonctionnalité ou méthode obsolète utilisée dans axios.                                                                                                                                                                                                                                                                                                 |
| ERR_INVALID_URL           | URL invalide fournie pour la requête axios.                                                                                                                                                                                                                                                                                                             |
| ECONNABORTED              | Indique généralement que la requête a expiré (sauf si `transitional.clarifyTimeoutError` est défini) ou a été interrompue par le navigateur ou son plugin.                                                                                                                                                                                             |
| ERR_CANCELED              | Fonctionnalité ou méthode explicitement annulée par l'utilisateur via un AbortSignal (ou un CancelToken).                                                                                                                                                                                                                                              |
| ETIMEDOUT                 | La requête a expiré en dépassant la limite de temps par défaut d'axios. `transitional.clarifyTimeoutError` doit être défini à `true`, sinon une erreur générique `ECONNABORTED` sera levée à la place.                                                                                                                                                 |
| ERR_NETWORK               | Problème lié au réseau. Dans le navigateur, cette erreur peut également être causée par une violation de la politique [CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/CORS) ou de [contenu mixte](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content). Le navigateur n'autorise pas le code JS à clarifier la véritable raison de l'erreur causée par des questions de sécurité, veuillez donc vérifier la console. |
| ERR_FR_TOO_MANY_REDIRECTS | La requête est redirigée trop de fois ; dépasse le nombre maximal de redirections spécifié dans la configuration axios.                                                                                                                                                                                                                                 |
| ERR_BAD_RESPONSE          | La réponse ne peut pas être correctement analysée ou est dans un format inattendu. Généralement lié à une réponse avec un code de statut `5xx`.                                                                                                                                                                                                      |
| ERR_BAD_REQUEST           | La requête a un format inattendu ou des paramètres obligatoires manquants. Généralement lié à une réponse avec un code de statut `4xx`.                                                                                                                                                                                                               |

## Gestion des Erreurs

Le comportement par défaut est de rejeter toute réponse qui retourne un code de statut hors de la plage 2xx et de la traiter comme une erreur.

```js
axios.get('/user/12345')
  .catch(function (error) {
    if (error.response) {
      // La requête a été faite et le serveur a répondu avec un code de statut
      // qui est hors de la plage 2xx
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    } else if (error.request) {
      // La requête a été faite mais aucune réponse n'a été reçue
      // `error.request` est une instance de XMLHttpRequest dans le navigateur et une instance de
      // http.ClientRequest dans node.js
      console.log(error.request);
    } else {
      // Une erreur s'est produite lors de la configuration de la requête qui a déclenché une erreur
      console.log('Erreur', error.message);
    }
    console.log(error.config);
  });
```

En utilisant l'option de configuration `validateStatus`, vous pouvez remplacer la condition par défaut (status >= 200 && status < 300) et définir le(s) code(s) HTTP qui doivent lever une erreur.

```js
axios.get('/user/12345', {
  validateStatus: function (status) {
    return status < 500; // Résoudre uniquement si le code de statut est inférieur à 500
  }
})
```

En utilisant `toJSON`, vous obtenez un objet avec plus d'informations sur l'erreur HTTP.

```js
axios.get('/user/12345')
  .catch(function (error) {
    console.log(error.toJSON());
```
```markdown
  });
```

## Annulation

### AbortController

Depuis la version `v0.22.0`, Axios prend en charge AbortController pour annuler les requêtes de la même manière que l'API fetch :

```js
const controller = new AbortController();

axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// annuler la requête
controller.abort()
```

### CancelToken `👎déprécié`

Vous pouvez également annuler une requête en utilisant un *CancelToken*.

> L’API cancel token d’axios est basée sur la proposition [cancellable promises proposal](https://github.com/tc39/proposal-cancelable-promises) qui a été retirée.

> Cette API est dépréciée depuis la version v0.22.0 et ne devrait pas être utilisée dans de nouveaux projets.

Vous pouvez créer un cancel token en utilisant la fabrique `CancelToken.source` comme indiqué ci-dessous :

```js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function (thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Requête annulée', thrown.message);
  } else {
    // gérer l’erreur
  }
});

axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})

// annuler la requête (le paramètre message est optionnel)
source.cancel('Opération annulée par l’utilisateur.');
```

Vous pouvez également créer un cancel token en passant une fonction exécutrice au constructeur `CancelToken` :

```js
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // Une fonction exécutrice reçoit une fonction d’annulation en paramètre
    cancel = c;
  })
});

// annuler la requête
cancel();
```

> **Remarque :** vous pouvez annuler plusieurs requêtes avec le même cancel token/abort controller.
> Si un jeton d’annulation est déjà annulé au moment du lancement d’une requête Axios, alors la requête est immédiatement annulée, sans aucune tentative de requête réelle.

> Durant la période de transition, vous pouvez utiliser les deux APIs d’annulation, même pour la même requête :

## Utilisation du format `application/x-www-form-urlencoded`

### URLSearchParams

Par défaut, axios sérialise les objets JavaScript en `JSON`. Pour envoyer des données dans le [format `application/x-www-form-urlencoded`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) à la place, vous pouvez utiliser l’API [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams), qui est [prise en charge](http://www.caniuse.com/#feat=urlsearchparams) par la grande majorité des navigateurs, ainsi que par [Node](https://nodejs.org/api/url.html#url_class_urlsearchparams) à partir de la version v10 (sortie en 2018).

```js
const params = new URLSearchParams({ foo: 'bar' });
params.append('extraparam', 'value');
axios.post('/foo', params);
```

### Chaîne de requête (navigateurs anciens)

Pour la compatibilité avec des navigateurs très anciens, il existe un [polyfill](https://github.com/WebReflection/url-search-params) disponible (assurez-vous de polyfiller l’environnement global).

Alternativement, vous pouvez encoder les données en utilisant la bibliothèque [`qs`](https://github.com/ljharb/qs) :

```js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
```
```
Ou d'une autre manière (ES6),

```js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
```

### Anciennes versions de Node.js

Pour les anciens moteurs Node.js, vous pouvez utiliser le module [`querystring`](https://nodejs.org/api/querystring.html) comme suit :

```js
const querystring = require('querystring');
axios.post('https://something.com/', querystring.stringify({ foo: 'bar' }));
```

Vous pouvez également utiliser la bibliothèque [`qs`](https://github.com/ljharb/qs).

> **Remarque** : La bibliothèque `qs` est préférable si vous devez sérialiser des objets imbriqués, car la méthode `querystring` a des [problèmes connus](https://github.com/nodejs/node-v0.x-archive/issues/1665) dans ce cas d'utilisation.

### 🆕 Sérialisation automatique vers URLSearchParams

Axios va automatiquement sérialiser l'objet data au format urlencoded si l'en-tête content-type est défini sur "application/x-www-form-urlencoded".

```js
const data = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
};

await axios.postForm('https://postman-echo.com/post', data,
  {headers: {'content-type': 'application/x-www-form-urlencoded'}}
);
```

Le serveur le traitera comme :

```js
  {
    x: '1',
    'arr[]': [ '1', '2', '3' ],
    'arr2[0]': '1',
    'arr2[1][0]': '2',
    'arr2[2]': '3',
    'arr3[]': [ '1', '2', '3' ],
    'users[0][name]': 'Peter',
    'users[0][surname]': 'griffin',
    'users[1][name]': 'Thomas',
    'users[1][surname]': 'Anderson'
  }
```

Si votre body-parser côté backend (comme `body-parser` de `express.js`) prend en charge le décodage des objets imbriqués, vous obtiendrez automatiquement le même objet côté serveur

```js
  var app = express();

  app.use(bodyParser.urlencoded({ extended: true })); // supporte les corps encodés

  app.post('/', function (req, res, next) {
     // renvoie le corps en JSON
     res.send(JSON.stringify(req.body));
  });

  server = app.listen(3000);
```

## Utilisation du format `multipart/form-data`

### FormData

Pour envoyer les données sous forme de `multipart/formdata`, vous devez passer une instance de formData en tant que charge utile.
Définir l'en-tête `Content-Type` n'est pas nécessaire car Axios le déduit en fonction du type de charge utile.

```js
const formData = new FormData();
formData.append('foo', 'bar');

axios.post('https://httpbin.org/post', formData);
```

Dans node.js, vous pouvez utiliser la bibliothèque [`form-data`](https://github.com/form-data/form-data) comme suit :

```js
const FormData = require('form-data');

const form = new FormData();
form.append('my_field', 'ma valeur');
form.append('my_buffer', new Buffer(10));
form.append('my_file', fs.createReadStream('/foo/bar.jpg'));
```
axios.post('https://example.com', form)
```

### 🆕 Sérialisation automatique vers FormData

À partir de la version `v0.27.0`, Axios prend en charge la sérialisation automatique des objets en un objet FormData si l’en-tête
`Content-Type` de la requête est défini sur `multipart/form-data`.

La requête suivante soumettra les données au format FormData (Navigateur & Node.js) :

```js
import axios from 'axios';

axios.post('https://httpbin.org/post', {x: 1}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));
```

Dans la version `node.js`, le polyfill ([`form-data`](https://github.com/form-data/form-data)) est utilisé par défaut.

Vous pouvez surcharger la classe FormData en définissant la variable de configuration `env.FormData`,
mais dans la plupart des cas, vous n’en aurez probablement pas besoin :

```js
const axios = require('axios');
var FormData = require('form-data');

axios.post('https://httpbin.org/post', {x: 1, buf: new Buffer(10)}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));
```

Le sérialiseur FormData d’Axios prend en charge certaines terminaisons spéciales pour effectuer les opérations suivantes :

- `{}` - sérialise la valeur avec JSON.stringify
- `[]` - déplie l’objet de type tableau en champs séparés avec la même clé

> **Remarque** : l’opération de dépliage/expansion sera utilisée par défaut sur les tableaux et objets FileList

Le sérialiseur FormData prend en charge des options supplémentaires via la propriété `config.formSerializer: object` pour gérer les cas rares :

- `visitor: Function` - fonction visiteur définie par l’utilisateur qui sera appelée de manière récursive pour sérialiser l’objet de données
en un objet `FormData` selon des règles personnalisées.

- `dots: boolean = false` - utilise la notation par points au lieu des crochets pour sérialiser les tableaux et objets ;

- `metaTokens: boolean = true` - ajoute la terminaison spéciale (par ex. `user{}: '{"name": "John"}'`) dans la clé FormData.
Le body-parser du back-end pourrait potentiellement utiliser cette méta-information pour analyser automatiquement la valeur en tant que JSON.

- `indexes: null|false|true = false` - contrôle comment les index seront ajoutés aux clés dépliées des objets de type tableau « plats ».

    - `null` - n’ajoute pas de crochets (`arr: 1`, `arr: 2`, `arr: 3`)
    - `false` (par défaut) - ajoute des crochets vides (`arr[]: 1`, `arr[]: 2`, `arr[]: 3`)
    - `true` - ajoute des crochets avec index (`arr[0]: 1`, `arr[1]: 2`, `arr[2]: 3`)

Supposons que nous ayons un objet comme celui-ci :

```js
const obj = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
  'obj2{}': [{x:1}]
};
```

Les étapes suivantes seront exécutées en interne par le sérialiseur Axios :

```js
const formData = new FormData();
formData.append('x', '1');
formData.append('arr[]', '1');
formData.append('arr[]', '2');
formData.append('arr[]', '3');
formData.append('arr2[0]', '1');
formData.append('arr2[1][0]', '2');
formData.append('arr2[2]', '3');
formData.append('users[0][name]', 'Peter');
formData.append('users[0][surname]', 'Griffin');
formData.append('users[1][name]', 'Thomas');
formData.append('users[1][surname]', 'Anderson');
formData.append('obj2{}', '[{"x":1}]');
```

Axios prend en charge les méthodes raccourcies suivantes : `postForm`, `putForm`, `patchForm`
qui sont simplement les méthodes http correspondantes avec l’en-tête `Content-Type` prédéfini à `multipart/form-data`.

## Envoi de fichiers

Vous pouvez facilement soumettre un fichier unique :

```js
await axios.postForm('https://httpbin.org/post', {
  'myVar' : 'foo',
  'file': document.querySelector('#fileInput').files[0]
});
```

ou plusieurs fichiers en tant que `multipart/form-data` :

```js
await axios.postForm('https://httpbin.org/post', {
  'files[]': document.querySelector('#fileInput').files
});
```

L'objet `FileList` peut être passé directement :

```js
await axios.postForm('https://httpbin.org/post', document.querySelector('#fileInput').files)
```

Tous les fichiers seront envoyés avec les mêmes noms de champ : `files[]`.

## 🆕 Soumission de formulaire HTML (navigateur)

Transmettez un élément de formulaire HTML comme charge utile pour le soumettre en tant que contenu `multipart/form-data`.

```js
await axios.postForm('https://httpbin.org/post', document.querySelector('#htmlForm'));
```

Les objets `FormData` et `HTMLForm` peuvent également être envoyés en tant que `JSON` en définissant explicitement l'en-tête `Content-Type` sur `application/json` :

```js
await axios.post('https://httpbin.org/post', document.querySelector('#htmlForm'), {
  headers: {
    'Content-Type': 'application/json'
  }
})
```

Par exemple, le formulaire

```html
<form id="form">
  <input type="text" name="foo" value="1">
  <input type="text" name="deep.prop" value="2">
  <input type="text" name="deep prop spaced" value="3">
  <input type="text" name="baz" value="4">
  <input type="text" name="baz" value="5">

  <select name="user.age">
    <option value="value1">Value 1</option>
    <option value="value2" selected>Value 2</option>
    <option value="value3">Value 3</option>
  </select>

  <input type="submit" value="Enregistrer">
</form>
```

sera soumis sous la forme de l'objet JSON suivant :

```js
{
  "foo": "1",
  "deep": {
    "prop": {
      "spaced": "3"
    }
  },
  "baz": [
    "4",
    "5"
  ],
  "user": {
    "age": "value2"
  }
}
````

L'envoi de `Blobs`/`Files` sous forme de JSON (`base64`) n'est actuellement pas pris en charge.

## 🆕 Capture de la progression

Axios prend en charge à la fois les environnements navigateur et node pour capturer la progression de l'envoi ou du téléchargement d'une requête.
La fréquence des événements de progression est limitée à `3` fois par seconde.

```js    
await axios.post(url, data, {
  onUploadProgress: function (axiosProgressEvent) {
    /*{
      loaded: number;
      total?: number;
      progress?: number; // dans la plage [0..1]
      bytes: number; // nombre d'octets transférés depuis le dernier déclenchement (delta)
      estimated?: number; // temps estimé en secondes
      rate?: number; // vitesse d'envoi en octets
      upload: true; // indicateur d'envoi
    }*/
  },

  onDownloadProgress: function (axiosProgressEvent) {
    /*{
      loaded: number;
      total?: number;
      progress?: number;
      bytes: number; 
      estimated?: number;
      rate?: number; // vitesse de téléchargement en octets
      download: true; // indicateur de téléchargement
    }*/
  }
});  
```

Vous pouvez également suivre la progression du téléchargement/téléversement de flux dans node.js :

```js
const {data} = await axios.post(SERVER_URL, readableStream, {
   onUploadProgress: ({progress}) => {
     console.log((progress * 100).toFixed(2));
   },
  
   headers: {
    'Content-Length': contentLength
   },

   maxRedirects: 0 // éviter de mettre en mémoire tampon l'intégralité du flux
});
````

> **Remarque :**
> Le suivi de la progression du téléversement FormData n'est actuellement pas pris en charge dans les environnements node.js.

> **⚠️ Avertissement**
> Il est recommandé de désactiver les redirections en définissant maxRedirects: 0 pour téléverser le flux dans l'environnement **node.js**,
> car le paquet follow-redirects mettra en mémoire tampon tout le flux dans la RAM sans suivre l'algorithme de "backpressure".


## 🆕 Limitation de débit

Les limites de débit de téléchargement et de téléversement ne peuvent être définies que pour l'adaptateur http (node.js) :

```js
const {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {
  onUploadProgress: ({progress, rate}) => {
    console.log(`Téléversement [${(progress*100).toFixed(2)}%] : ${(rate / 1024).toFixed(2)}KB/s`)
  },
   
  maxRate: [100 * 1024], // limite à 100KB/s
});
```

## 🆕 AxiosHeaders

Axios dispose de sa propre classe `AxiosHeaders` pour manipuler les en-têtes à l'aide d'une API de type Map qui garantit la gestion insensible à la casse.
Bien que HTTP soit insensible à la casse dans les en-têtes, Axios conservera la casse de l'en-tête d'origine pour des raisons stylistiques
et comme solution de contournement lorsque les serveurs considèrent par erreur la casse de l'en-tête.
L'ancienne méthode de manipulation directe de l'objet headers est toujours disponible, mais obsolète et non recommandée pour une utilisation future.

### Travailler avec les en-têtes

Une instance d'objet AxiosHeaders peut contenir différents types de valeurs internes qui contrôlent la logique d'attribution et de fusion.
L'objet final headers avec des valeurs de type chaîne est obtenu par Axios en appelant la méthode `toJSON`.

> Remarque : Par JSON ici, nous entendons un objet composé uniquement de valeurs de type chaîne destinées à être envoyées sur le réseau.

La valeur d’un en-tête peut être de l’un des types suivants :
- `string` - valeur de chaîne normale qui sera envoyée au serveur
- `null` - ignorer l’en-tête lors du rendu en JSON
- `false` - ignorer l’en-tête lors du rendu en JSON, indique également que la méthode `set` doit être appelée avec l’option `rewrite` définie à `true`
  pour écraser cette valeur (Axios utilise cela en interne pour permettre aux utilisateurs de ne pas installer certains en-têtes comme `User-Agent` ou `Content-Type`)
- `undefined` - valeur non définie

> Remarque : La valeur de l’en-tête est considérée comme définie si elle n’est pas égale à undefined.

L'objet headers est toujours initialisé à l'intérieur des intercepteurs et des transformateurs :

```ts
  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {
      request.headers.set('My-header', 'value');

      request.headers.set({
        "My-set-header1": "my-set-value1",
        "My-set-header2": "my-set-value2"
      });
      
      request.headers.set('User-Agent', false); // désactiver l’attribution ultérieure de l’en-tête par Axios

      request.headers.setContentType('text/plain');
    
      request.headers['My-set-header2'] = 'newValue' // accès direct obsolète
    
      return request;
    }
  );
````

Vous pouvez itérer sur une instance de `AxiosHeaders` à l’aide d’une instruction `for...of` :

````js
const headers = new AxiosHeaders({
  foo: '1',
```js
  bar: '2',
  baz: '3'
});

for(const [header, value] of headers) {
  console.log(header, value);
}

// foo 1
// bar 2
// baz 3
````

### new AxiosHeaders(headers?)

Construit une nouvelle instance de `AxiosHeaders`.

```
constructor(headers?: RawAxiosHeaders | AxiosHeaders | string);
```

Si l'objet headers est une chaîne de caractères, il sera analysé comme des en-têtes HTTP RAW.

````js
const headers = new AxiosHeaders(`
Host: www.bing.com
User-Agent: curl/7.54.0
Accept: */*`);

console.log(headers);

// Object [AxiosHeaders] {
//   host: 'www.bing.com',
//   'user-agent': 'curl/7.54.0',
//   accept: '*/*'
// }
````

### AxiosHeaders#set

```ts
set(headerName, value: Axios, rewrite?: boolean);
set(headerName, value, rewrite?: (this: AxiosHeaders, value: string, name: string, headers: RawAxiosHeaders) => boolean);
set(headers?: RawAxiosHeaders | AxiosHeaders | string, rewrite?: boolean);
```

L’argument `rewrite` contrôle le comportement d’écrasement :
- `false` - ne pas écraser si la valeur de l’en-tête est définie (n’est pas `undefined`)
- `undefined` (par défaut) - écrase l’en-tête sauf si sa valeur est définie à `false`
- `true` - écraser dans tous les cas

L’option peut également accepter une fonction définie par l’utilisateur qui détermine si la valeur doit être écrasée ou non.

Retourne `this`.

### AxiosHeaders#get(header)

```
  get(headerName: string, matcher?: true | AxiosHeaderMatcher): AxiosHeaderValue;
  get(headerName: string, parser: RegExp): RegExpExecArray | null;
````

Retourne la valeur interne de l’en-tête. Il peut prendre un argument supplémentaire pour analyser la valeur de l’en-tête avec `RegExp.exec`,
une fonction de correspondance ou un analyseur interne clé-valeur.

```ts
const headers = new AxiosHeaders({
  'Content-Type': 'multipart/form-data; boundary=Asrf456BGe4h'
});

console.log(headers.get('Content-Type')); 
// multipart/form-data; boundary=Asrf456BGe4h

console.log(headers.get('Content-Type', true)); // analyse les paires clé-valeur à partir d’une chaîne séparée avec les délimiteurs \s,;= :
// [Object: null prototype] {
//   'multipart/form-data': undefined,
//    boundary: 'Asrf456BGe4h'
// }


console.log(headers.get('Content-Type', (value, name, headers) => {
  return String(value).replace(/a/g, 'ZZZ');
}));
// multipZZZrt/form-dZZZtZZZ; boundZZZry=Asrf456BGe4h

console.log(headers.get('Content-Type', /boundary=(\w+)/)?.[0]);
// boundary=Asrf456BGe4h

```

Retourne la valeur de l’en-tête.

### AxiosHeaders#has(header, matcher?)

```
has(header: string, matcher?: AxiosHeaderMatcher): boolean;
```

Retourne `true` si l’en-tête est défini (n’a pas de valeur `undefined`).
```
### AxiosHeaders#delete(header, matcher?)

```
delete(header: string | string[], matcher?: AxiosHeaderMatcher): boolean;
```

Renvoie `true` si au moins un en-tête a été supprimé.

### AxiosHeaders#clear(matcher?)

```
clear(matcher?: AxiosHeaderMatcher): boolean;
```

Supprime tous les en-têtes.  
Contrairement au matcher de la méthode `delete`, ce matcher optionnel sera utilisé pour correspondre au nom de l'en-tête plutôt qu'à la valeur.

```ts
const headers = new AxiosHeaders({
  'foo': '1',
  'x-foo': '2',
  'x-bar': '3',
});

console.log(headers.clear(/^x-/)); // true

console.log(headers.toJSON()); // [Object: null prototype] { foo: '1' }
```

Renvoie `true` si au moins un en-tête a été supprimé.

### AxiosHeaders#normalize(format);

Si l'objet d'en-têtes a été modifié directement, il peut contenir des doublons portant le même nom mais avec des casse différentes.  
Cette méthode normalise l'objet d'en-têtes en combinant les clés dupliquées en une seule.  
Axios utilise cette méthode en interne après l'appel de chaque intercepteur.  
Définissez `format` à true pour convertir les noms des en-têtes en minuscules et mettre la première lettre en majuscule (`cOntEnt-type` => `Content-Type`)

```js
const headers = new AxiosHeaders({
  'foo': '1',
});

headers.Foo = '2';
headers.FOO = '3';

console.log(headers.toJSON()); // [Object: null prototype] { foo: '1', Foo: '2', FOO: '3' }
console.log(headers.normalize().toJSON()); // [Object: null prototype] { foo: '3' }
console.log(headers.normalize(true).toJSON()); // [Object: null prototype] { Foo: '3' }
```

Renvoie `this`.

### AxiosHeaders#concat(...targets)

```
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
```

Fusionne l'instance avec les cibles dans une nouvelle instance `AxiosHeaders`. Si la cible est une chaîne de caractères, elle sera analysée comme des en-têtes HTTP bruts.

Renvoie une nouvelle instance `AxiosHeaders`.

### AxiosHeaders#toJSON(asStrings?)

````
toJSON(asStrings?: boolean): RawAxiosHeaders;
````

Résout toutes les valeurs internes des en-têtes dans un nouvel objet à prototype nul.  
Définir `asStrings` à true permet de résoudre les tableaux sous forme de chaîne contenant tous les éléments, séparés par des virgules.

### AxiosHeaders.from(thing?)

````
from(thing?: AxiosHeaders | RawAxiosHeaders | string): AxiosHeaders;
````

Renvoie une nouvelle instance `AxiosHeaders` créée à partir des en-têtes bruts passés,  
ou retourne simplement l'objet d'en-têtes donné s'il s'agit d'une instance `AxiosHeaders`.

### AxiosHeaders.concat(...targets)

````
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
````

Renvoie une nouvelle instance `AxiosHeaders` créée en fusionnant les objets cibles.

### Raccourcis

Les raccourcis suivants sont disponibles :

- `setContentType`, `getContentType`, `hasContentType`

- `setContentLength`, `getContentLength`, `hasContentLength`

- `setAccept`, `getAccept`, `hasAccept`

- `setUserAgent`, `getUserAgent`, `hasUserAgent`
- `setContentEncoding`, `getContentEncoding`, `hasContentEncoding`

## 🔥 Adaptateur Fetch

L’adaptateur Fetch a été introduit dans la version `v1.7.0`. Par défaut, il sera utilisé si les adaptateurs `xhr` et `http` ne sont pas disponibles dans la build,
ou ne sont pas pris en charge par l’environnement.
Pour l’utiliser par défaut, il doit être sélectionné explicitement :

```js
const {data} = axios.get(url, {
  adapter: 'fetch' // par défaut ['xhr', 'http', 'fetch']
})
```

Vous pouvez créer une instance séparée pour cela :

```js
const fetchAxios = axios.create({
  adapter: 'fetch'
});

const {data} = fetchAxios.get(url);
```

L’adaptateur prend en charge les mêmes fonctionnalités que l’adaptateur `xhr`, **y compris la capture de la progression de l’envoi et du téléchargement**.
De plus, il prend en charge des types de réponse supplémentaires tels que `stream` et `formdata` (si pris en charge par l’environnement).

## Semver

Jusqu’à ce qu’axios atteigne une version `1.0`, les changements majeurs seront publiés avec une nouvelle version mineure. Par exemple, `0.5.1` et `0.5.4` auront la même API, mais `0.6.0` introduira des changements majeurs.

## Promesses

axios dépend d’une implémentation native ES6 Promise pour être [pris en charge](https://caniuse.com/promises).
Si votre environnement ne prend pas en charge les Promesses ES6, vous pouvez utiliser un [polyfill](https://github.com/jakearchibald/es6-promise).

## TypeScript

axios inclut des définitions [TypeScript](https://typescriptlang.org) et un garde de type pour les erreurs axios.

```typescript
let user: User = null;
try {
  const { data } = await axios.get('/user?ID=12345');
  user = data.userDetails;
} catch (error) {
  if (axios.isAxiosError(error)) {
    handleAxiosError(error);
  } else {
    handleUnexpectedError(error);
  }
}
```

Parce qu’axios publie à la fois avec une exportation par défaut ESM et un `module.exports` CJS, il existe quelques particularités.
Le paramètre recommandé est d’utiliser `"moduleResolution": "node16"` (ceci est impliqué par `"module": "node16"`). Notez que cela nécessite TypeScript 4.7 ou supérieur.
Si vous utilisez ESM, vos paramètres devraient être corrects.
Si vous compilez TypeScript en CJS et que vous ne pouvez pas utiliser `"moduleResolution": "node16"`, vous devez activer `esModuleInterop`.
Si vous utilisez TypeScript pour vérifier le typage du code JavaScript CJS, votre seule option est d’utiliser `"moduleResolution": "node16"`.

## Configuration en un clic en ligne

Vous pouvez utiliser Gitpod, un IDE en ligne (qui est gratuit pour l’Open Source) pour contribuer ou exécuter les exemples en ligne.

[![Ouvrir dans Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/axios/axios/blob/main/examples/server.js)


## Ressources

* [Changelog](https://github.com/axios/axios/blob/v1.x/CHANGELOG.md)
* [Ecosystème](https://github.com/axios/axios/blob/v1.x/ECOSYSTEM.md)
* [Guide de contribution](https://github.com/axios/axios/blob/v1.x/CONTRIBUTING.md)
* [Code de conduite](https://github.com/axios/axios/blob/v1.x/CODE_OF_CONDUCT.md)

## Crédits

axios est fortement inspiré par le service [$http](https://docs.angularjs.org/api/ng/service/$http) fourni dans [AngularJS](https://angularjs.org/). En fin de compte, axios est un effort pour fournir un service autonome similaire à `$http` utilisable en dehors d’AngularJS.

## Licence

[MIT](LICENSE)


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-30

---