{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Stel standaardconfiguratie in bij het aanmaken van de instantie\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Wijzig standaardinstellingen nadat de instantie is aangemaakt\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config volgorde van prioriteit\n\nConfiguratie wordt samengevoegd met een bepaalde volgorde van prioriteit. De volgorde is: bibliotheekstandaarden gevonden in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), daarna de `defaults`-eigenschap van de instantie, en tenslotte het `config`-argument van het verzoek. De laatste heeft voorrang op de vorige. Hier is een voorbeeld.\n\n```js\n// Maak een instantie aan met de standaardconfiguratie van de bibliotheek\n// Op dit punt is de timeout-configuratiewaarde `0`, zoals standaard is ingesteld in de bibliotheek\nconst instance = axios.create();\n\n// Overschrijf de standaard timeout van de bibliotheek\n// Nu wachten alle verzoeken via deze instantie 2,5 seconden voordat ze verlopen\ninstance.defaults.timeout = 2500;\n\n// Overschrijf de timeout voor dit verzoek omdat bekend is dat het lang duurt\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nJe kunt verzoeken of responses onderscheppen voordat ze worden afgehandeld door `then` of `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Voeg een request-interceptor toe\ninstance.interceptors.request.use(function (config) {\n    // Doe iets voordat het verzoek wordt verzonden\n    return config;\n  }, function (error) {\n    // Doe iets bij een fout in het verzoek\n    return Promise.reject(error);\n  });\n\n// Voeg een response-interceptor toe\ninstance.interceptors.response.use(function (response) {\n    // Elke statuscode binnen het bereik van 2xx activeert deze functie\n    // Doe iets met de response-data\n    return response;\n  }, function (error) {\n    // Elke statuscode buiten het bereik van 2xx activeert deze functie\n    // Doe iets bij een response-fout\n    return Promise.reject(error);\n  });\n```\n\nAls je later een interceptor wilt verwijderen, kan dat.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nJe kunt ook alle interceptors voor verzoeken of responses verwijderen.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Verwijdert interceptors van verzoeken\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Verwijdert interceptors van responses\n```\n\nJe kunt interceptors toevoegen aan een aangepaste instantie van axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWanneer je request-interceptors toevoegt, wordt ervan uitgegaan dat ze standaard asynchroon zijn. Dit kan een vertraging veroorzaken\nin de uitvoering van je axios-verzoek wanneer de hoofdthread wordt geblokkeerd (er wordt onder de motorkap een promise aangemaakt voor\nde interceptor en je verzoek komt onderaan de call stack terecht). Als je request-interceptors synchroon zijn, kun je een vlag\ntoevoegen aan het opties-object die axios vertelt om de code synchroon uit te voeren en zo vertragingen te voorkomen bij de uitvoering van het verzoek.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'Ik ben alleen een header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nAls je een bepaalde interceptor wilt uitvoeren op basis van een runtime-check,\nkun je een `runWhen`-functie toevoegen aan het opties-object. De request-interceptor wordt **alleen uitgevoerd als** de returnwaarde\nvan `runWhen` niet `false` is. De functie wordt aangeroepen met het config-object\n(denk eraan dat je hier ook je eigen argumenten aan kunt binden). Dit is handig als je een asynchrone request-interceptor hebt die alleen op bepaalde momenten hoeft te draaien.\n```",
  "status": "ok"
}