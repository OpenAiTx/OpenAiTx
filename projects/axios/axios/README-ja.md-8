{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// インスタンス作成時に設定のデフォルト値をセット\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// インスタンス作成後にデフォルト値を変更\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### 設定の優先順位\n\n設定は優先順位に従ってマージされます。順序は、[lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49) にあるライブラリのデフォルト値、次にインスタンスの `defaults` プロパティ、最後にリクエストの `config` 引数です。後者が前者よりも優先されます。以下は例です。\n\n```js\n// ライブラリが提供する設定のデフォルト値を使ってインスタンスを作成\n// この時点では timeout 設定値は `0`（ライブラリのデフォルト値）です\nconst instance = axios.create();\n\n// ライブラリのデフォルト timeout を上書き\n// これでこのインスタンスを使うすべてのリクエストはタイムアウトまで2.5秒待ちます\ninstance.defaults.timeout = 2500;\n\n// このリクエストは時間がかかることが分かっているので timeout を上書き\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## インターセプター\n\n`then` や `catch` で処理される前に、リクエストやレスポンスをインターセプトすることができます。\n\n```js\n\nconst instance = axios.create();\n\n// リクエストインターセプターを追加\ninstance.interceptors.request.use(function (config) {\n    // リクエスト送信前に何か処理を行う\n    return config;\n  }, function (error) {\n    // リクエストエラー時の処理\n    return Promise.reject(error);\n  });\n\n// レスポンスインターセプターを追加\ninstance.interceptors.response.use(function (response) {\n    // 2xxのステータスコードの場合、この関数が実行される\n    // レスポンスデータの処理\n    return response;\n  }, function (error) {\n    // 2xx以外のステータスコードの場合、この関数が実行される\n    // レスポンスエラー時の処理\n    return Promise.reject(error);\n  });\n```\n\n後でインターセプターを削除する必要がある場合も対応できます。\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nリクエストやレスポンスのインターセプターをすべてクリアすることもできます。\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // リクエストのインターセプターを削除\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // レスポンスのインターセプターを削除\n```\n\nカスタムインスタンスにもインターセプターを追加できます。\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nリクエストインターセプターを追加すると、デフォルトでは非同期として扱われます。これにより、メインスレッドがブロックされている場合は\naxiosリクエストの実行に遅延が発生する可能性があります（インターセプターの内部でPromiseが作成され、リクエストがコールスタックの一番下に置かれます）。\nインターセプターが同期的である場合は、オプションオブジェクトにフラグを追加することで、axiosに同期的にコードを実行させ、\nリクエスト実行の遅延を回避できます。\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\n特定のインターセプターを実行時の条件に基づいて実行したい場合は、\nオプションオブジェクトに `runWhen` 関数を追加できます。リクエストインターセプターは **戻り値が `false` の場合のみ** 実行されません。\n関数はconfigオブジェクトとともに呼び出されます（独自の引数をバインドすることも可能です）。これは\n特定のタイミングでのみ実行したい非同期リクエストインターセプターがある場合に便利です。\n```",
  "status": "ok"
}