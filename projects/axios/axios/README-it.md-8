{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Imposta i valori predefiniti di configurazione quando crei l'istanza\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Modifica i valori predefiniti dopo che l'istanza è stata creata\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Ordine di precedenza della configurazione\n\nLa configurazione verrà unita secondo un ordine di precedenza. L'ordine è: i valori predefiniti della libreria che si trovano in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), poi la proprietà `defaults` dell'istanza e infine l'argomento `config` della richiesta. Quest'ultimo avrà la precedenza sui precedenti. Ecco un esempio.\n\n```js\n// Crea un'istanza usando i valori di configurazione predefiniti forniti dalla libreria\n// A questo punto il valore di timeout di configurazione è `0`, come previsto dalla libreria\nconst instance = axios.create();\n\n// Sovrascrivi il valore predefinito di timeout della libreria\n// Ora tutte le richieste che usano questa istanza attenderanno 2,5 secondi prima di andare in timeout\ninstance.defaults.timeout = 2500;\n\n// Sovrascrivi il timeout per questa richiesta poiché si sa che impiega molto tempo\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Intercettori\n\nPuoi intercettare richieste o risposte prima che vengano gestite da `then` o `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Aggiungi un intercettore di richiesta\ninstance.interceptors.request.use(function (config) {\n    // Esegui qualcosa prima che la richiesta venga inviata\n    return config;\n  }, function (error) {\n    // Esegui qualcosa in caso di errore nella richiesta\n    return Promise.reject(error);\n  });\n\n// Aggiungi un intercettore di risposta\ninstance.interceptors.response.use(function (response) {\n    // Qualsiasi codice di stato compreso nell'intervallo 2xx fa scattare questa funzione\n    // Esegui qualcosa con i dati della risposta\n    return response;\n  }, function (error) {\n    // Qualsiasi codice di stato fuori dall'intervallo 2xx fa scattare questa funzione\n    // Esegui qualcosa in caso di errore nella risposta\n    return Promise.reject(error);\n  });\n```\n\nSe hai bisogno di rimuovere un intercettore successivamente, puoi farlo.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nPuoi anche cancellare tutti gli intercettori per richieste o risposte.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Rimuove gli intercettori dalle richieste\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Rimuove gli intercettori dalle risposte\n```\n\nPuoi aggiungere intercettori a un'istanza personalizzata di axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nQuando aggiungi intercettori di richiesta, si presume che siano asincroni per impostazione predefinita. Questo può causare un ritardo\nnell'esecuzione della tua richiesta axios quando il thread principale è bloccato (viene creato internamente una promise per\nl'intercettore e la tua richiesta viene messa in fondo allo stack delle chiamate). Se i tuoi intercettori di richiesta sono sincroni puoi aggiungere un flag\nall'oggetto delle opzioni che dirà ad axios di eseguire il codice in modo sincrono ed evitare qualsiasi ritardo nell'esecuzione della richiesta.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nSe vuoi eseguire un determinato intercettore in base a un controllo a runtime,\npuoi aggiungere una funzione `runWhen` all'oggetto delle opzioni. L'intercettore di richiesta non verrà eseguito **se e solo se** il ritorno\ndi `runWhen` è `false`. La funzione verrà chiamata con l'oggetto config\n(non dimenticare che puoi anche bindare i tuoi argomenti). Questo può essere utile quando hai un\nintercettore di richiesta asincrono che deve essere eseguito solo in determinati momenti.\n```",
  "status": "ok"
}