{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Ustaw domyślne konfiguracje podczas tworzenia instancji\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Zmień domyślne ustawienia po utworzeniu instancji\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Kolejność nadrzędności konfiguracji\n\nKonfiguracja będzie scalana według określonej kolejności nadrzędności. Kolejność to: domyślne ustawienia biblioteki znajdujące się w [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), następnie właściwość `defaults` instancji, a na końcu argument `config` przekazany do żądania. Ostatni z nich ma najwyższy priorytet. Oto przykład.\n\n```js\n// Utwórz instancję używając domyślnej konfiguracji dostarczonej przez bibliotekę\n// W tym momencie wartość timeout jest równa `0`, zgodnie z domyślną wartością w bibliotece\nconst instance = axios.create();\n\n// Nadpisz domyślny timeout dla biblioteki\n// Teraz wszystkie żądania używające tej instancji będą czekać 2,5 sekundy przed przekroczeniem limitu czasu\ninstance.defaults.timeout = 2500;\n\n// Nadpisz timeout tylko dla tego żądania, ponieważ wiadomo, że zajmie dużo czasu\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptory\n\nMożesz przechwycić żądania lub odpowiedzi zanim zostaną obsłużone przez `then` lub `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Dodaj interceptor żądania\ninstance.interceptors.request.use(function (config) {\n    // Wykonaj coś przed wysłaniem żądania\n    return config;\n  }, function (error) {\n    // Obsłuż błąd żądania\n    return Promise.reject(error);\n  });\n\n// Dodaj interceptor odpowiedzi\ninstance.interceptors.response.use(function (response) {\n    // Każdy kod statusu w zakresie 2xx powoduje wywołanie tej funkcji\n    // Wykonaj coś z danymi odpowiedzi\n    return response;\n  }, function (error) {\n    // Każdy kod statusu poza zakresem 2xx powoduje wywołanie tej funkcji\n    // Obsłuż błąd odpowiedzi\n    return Promise.reject(error);\n  });\n```\n\nJeśli później musisz usunąć interceptor, możesz to zrobić.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nMożesz również usunąć wszystkie interceptory dla żądań lub odpowiedzi.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Usuwa interceptory żądań\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Usuwa interceptory odpowiedzi\n```\n\nMożesz dodać interceptory do własnej instancji axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nGdy dodajesz interceptory żądania, domyślnie są one uznawane za asynchroniczne. Może to powodować opóźnienie\nw wykonaniu żądania axios, jeśli główny wątek jest zablokowany (pod spodem tworzona jest obietnica dla\ninterceptora, a żądanie trafia na koniec stosu wywołań). Jeśli Twoje interceptory żądania są synchroniczne, możesz dodać flagę\ndo obiektu opcji, która poinformuje axios, by kod był wykonywany synchronicznie i uniknąć opóźnień w realizacji żądania.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'Jestem tylko nagłówkiem!';\n  return config;\n}, null, { synchronous: true });\n```\n\nJeśli chcesz wykonać konkretny interceptor na podstawie sprawdzenia w czasie rzeczywistym,\nmożesz dodać funkcję `runWhen` do obiektu opcji. Interceptor żądania nie zostanie wykonany **tylko wtedy, gdy** zwrócona wartość\n`runWhen` to `false`. Funkcja zostanie wywołana z obiektem config\n(nie zapomnij, że możesz do niej podpiąć własne argumenty). Jest to przydatne, gdy masz\nasynchroniczny interceptor żądania, który powinien być wykonywany tylko w określonych przypadkach.\n```",
  "status": "ok"
}