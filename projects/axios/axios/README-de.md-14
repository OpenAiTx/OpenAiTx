{
  "id": 14,
  "origin": "      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // download speed in bytes\n      download: true; // download sign\n    }*/\n  }\n});  \n```\n\nYou can also track stream upload/download progress in node.js:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // avoid buffering the entire stream\n});\n````\n\n> **Note:**\n> Capturing FormData upload progress is not currently supported in node.js environments.\n\n> **⚠️ Warning**\n> It is recommended to disable redirects by setting maxRedirects: 0 to upload the stream in the **node.js** environment,\n> as follow-redirects package will buffer the entire stream in RAM without following the \"backpressure\" algorithm.\n\n\n## 🆕 Rate limiting\n\nDownload and upload rate limits can only be set for the http adapter (node.js):\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // 100KB/s limit\n});\n```\n\n## 🆕 AxiosHeaders\n\nAxios has its own `AxiosHeaders` class to manipulate headers using a Map-like API that guarantees caseless work.\nAlthough HTTP is case-insensitive in headers, Axios will retain the case of the original header for stylistic reasons\nand for a workaround when servers mistakenly consider the header's case.\nThe old approach of directly manipulating headers object is still available, but deprecated and not recommended for future usage.\n\n### Working with headers\n\nAn AxiosHeaders object instance can contain different types of internal values. that control setting and merging logic.\nThe final headers object with string values is obtained by Axios by calling the `toJSON` method.\n\n> Note: By JSON here we mean an object consisting only of string values intended to be sent over the network.\n\nThe header value can be one of the following types:\n- `string` - normal string value that will be sent to the server\n- `null` - skip header when rendering to JSON\n- `false` - skip header when rendering to JSON, additionally indicates that `set` method must be called with `rewrite` option set to `true`\n  to overwrite this value (Axios uses this internally to allow users to opt out of installing certain headers like `User-Agent` or `Content-Type`)\n- `undefined` - value is not set\n\n> Note: The header value is considered set if it is not equal to undefined.\n\nThe headers object is always initialized inside interceptors and transformers:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // disable subsequent setting the header by Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // direct access is deprecated\n    \n      return request;\n    }\n  );\n````\n\nYou can iterate over an `AxiosHeaders` instance using a `for...of` statement:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',",
  "origin_sha": "FK9fblZzMaAq7pcNVVG17lyaNO+0Z7qRCDVMdJcNTFs=",
  "translate": "```markdown\n      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // Download-Geschwindigkeit in Bytes\n      download: true; // Download-Kennzeichen\n    }*/\n  }\n});  \n```\n\nDu kannst den Fortschritt beim Stream-Upload/-Download auch in Node.js verfolgen:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // Verhindert das Puffern des gesamten Streams\n});\n````\n\n> **Hinweis:**\n> Das Erfassen des Upload-Fortschritts von FormData wird derzeit in Node.js-Umgebungen nicht unterstützt.\n\n> **⚠️ Warnung**\n> Es wird empfohlen, Weiterleitungen durch Setzen von maxRedirects: 0 zu deaktivieren, um den Stream in der **Node.js**-Umgebung hochzuladen,\n> da das Paket follow-redirects den gesamten Stream im RAM puffert, ohne den \"Backpressure\"-Algorithmus zu befolgen.\n\n\n## 🆕 Ratenbegrenzung\n\nDownload- und Upload-Geschwindigkeitsbegrenzungen können nur für den HTTP-Adapter (Node.js) festgelegt werden:\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // Begrenzung auf 100KB/s\n});\n```\n\n## 🆕 AxiosHeaders\n\nAxios verfügt über eine eigene `AxiosHeaders`-Klasse, um Header mit einer Map-ähnlichen API zu bearbeiten, die eine Fallunabhängigkeit garantiert.\nObwohl HTTP-Header nicht zwischen Groß- und Kleinschreibung unterscheiden, behält Axios den Fall des ursprünglichen Headers aus stilistischen Gründen\nund als Workaround, wenn Server versehentlich den Fall des Headers berücksichtigen.\nDie alte Methode, das Header-Objekt direkt zu manipulieren, ist weiterhin verfügbar, aber veraltet und für die zukünftige Nutzung nicht empfohlen.\n\n### Arbeiten mit Headern\n\nEine AxiosHeaders-Objektinstanz kann verschiedene Arten von internen Werten enthalten, die das Setzen und die Zusammenführungslogik steuern.\nDas endgültige Header-Objekt mit String-Werten wird von Axios durch Aufruf der `toJSON`-Methode erhalten.\n\n> Hinweis: Mit JSON ist hier ein Objekt gemeint, das nur aus String-Werten besteht und über das Netzwerk gesendet werden soll.\n\nDer Header-Wert kann einer der folgenden Typen sein:\n- `string` – Normaler String-Wert, der an den Server gesendet wird\n- `null` – Header wird beim Rendern nach JSON übersprungen\n- `false` – Header wird beim Rendern nach JSON übersprungen, zeigt zusätzlich an, dass die `set`-Methode mit der Option `rewrite` auf `true` aufgerufen werden muss,\n  um diesen Wert zu überschreiben (Axios nutzt dies intern, um es Nutzern zu ermöglichen, bestimmte Header wie `User-Agent` oder `Content-Type` abzuwählen)\n- `undefined` – Wert ist nicht gesetzt\n\n> Hinweis: Der Header-Wert gilt als gesetzt, wenn er ungleich undefined ist.\n\nDas Header-Objekt wird immer innerhalb von Interceptors und Transformern initialisiert:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // Nachfolgendes Setzen des Headers durch Axios deaktivieren\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // Direkter Zugriff ist veraltet\n    \n      return request;\n    }\n  );\n````\n\nDu kannst über eine Instanz von `AxiosHeaders` mit einer `for...of`-Schleife iterieren:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',\n```",
  "status": "ok"
}