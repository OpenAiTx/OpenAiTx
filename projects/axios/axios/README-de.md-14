{
  "id": 14,
  "origin": "      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // download speed in bytes\n      download: true; // download sign\n    }*/\n  }\n});  \n```\n\nYou can also track stream upload/download progress in node.js:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // avoid buffering the entire stream\n});\n````\n\n> **Note:**\n> Capturing FormData upload progress is not currently supported in node.js environments.\n\n> **âš ï¸ Warning**\n> It is recommended to disable redirects by setting maxRedirects: 0 to upload the stream in the **node.js** environment,\n> as follow-redirects package will buffer the entire stream in RAM without following the \"backpressure\" algorithm.\n\n\n## ğŸ†• Rate limiting\n\nDownload and upload rate limits can only be set for the http adapter (node.js):\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // 100KB/s limit\n});\n```\n\n## ğŸ†• AxiosHeaders\n\nAxios has its own `AxiosHeaders` class to manipulate headers using a Map-like API that guarantees caseless work.\nAlthough HTTP is case-insensitive in headers, Axios will retain the case of the original header for stylistic reasons\nand for a workaround when servers mistakenly consider the header's case.\nThe old approach of directly manipulating headers object is still available, but deprecated and not recommended for future usage.\n\n### Working with headers\n\nAn AxiosHeaders object instance can contain different types of internal values. that control setting and merging logic.\nThe final headers object with string values is obtained by Axios by calling the `toJSON` method.\n\n> Note: By JSON here we mean an object consisting only of string values intended to be sent over the network.\n\nThe header value can be one of the following types:\n- `string` - normal string value that will be sent to the server\n- `null` - skip header when rendering to JSON\n- `false` - skip header when rendering to JSON, additionally indicates that `set` method must be called with `rewrite` option set to `true`\n  to overwrite this value (Axios uses this internally to allow users to opt out of installing certain headers like `User-Agent` or `Content-Type`)\n- `undefined` - value is not set\n\n> Note: The header value is considered set if it is not equal to undefined.\n\nThe headers object is always initialized inside interceptors and transformers:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // disable subsequent setting the header by Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // direct access is deprecated\n    \n      return request;\n    }\n  );\n````\n\nYou can iterate over an `AxiosHeaders` instance using a `for...of` statement:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',",
  "origin_sha": "FK9fblZzMaAq7pcNVVG17lyaNO+0Z7qRCDVMdJcNTFs=",
  "translate": "```markdown\n      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // Download-Geschwindigkeit in Bytes\n      download: true; // Download-Kennzeichen\n    }*/\n  }\n});  \n```\n\nDu kannst den Fortschritt beim Stream-Upload/-Download auch in Node.js verfolgen:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // Verhindert das Puffern des gesamten Streams\n});\n````\n\n> **Hinweis:**\n> Das Erfassen des Upload-Fortschritts von FormData wird derzeit in Node.js-Umgebungen nicht unterstÃ¼tzt.\n\n> **âš ï¸ Warnung**\n> Es wird empfohlen, Weiterleitungen durch Setzen von maxRedirects: 0 zu deaktivieren, um den Stream in der **Node.js**-Umgebung hochzuladen,\n> da das Paket follow-redirects den gesamten Stream im RAM puffert, ohne den \"Backpressure\"-Algorithmus zu befolgen.\n\n\n## ğŸ†• Ratenbegrenzung\n\nDownload- und Upload-Geschwindigkeitsbegrenzungen kÃ¶nnen nur fÃ¼r den HTTP-Adapter (Node.js) festgelegt werden:\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // Begrenzung auf 100KB/s\n});\n```\n\n## ğŸ†• AxiosHeaders\n\nAxios verfÃ¼gt Ã¼ber eine eigene `AxiosHeaders`-Klasse, um Header mit einer Map-Ã¤hnlichen API zu bearbeiten, die eine FallunabhÃ¤ngigkeit garantiert.\nObwohl HTTP-Header nicht zwischen GroÃŸ- und Kleinschreibung unterscheiden, behÃ¤lt Axios den Fall des ursprÃ¼nglichen Headers aus stilistischen GrÃ¼nden\nund als Workaround, wenn Server versehentlich den Fall des Headers berÃ¼cksichtigen.\nDie alte Methode, das Header-Objekt direkt zu manipulieren, ist weiterhin verfÃ¼gbar, aber veraltet und fÃ¼r die zukÃ¼nftige Nutzung nicht empfohlen.\n\n### Arbeiten mit Headern\n\nEine AxiosHeaders-Objektinstanz kann verschiedene Arten von internen Werten enthalten, die das Setzen und die ZusammenfÃ¼hrungslogik steuern.\nDas endgÃ¼ltige Header-Objekt mit String-Werten wird von Axios durch Aufruf der `toJSON`-Methode erhalten.\n\n> Hinweis: Mit JSON ist hier ein Objekt gemeint, das nur aus String-Werten besteht und Ã¼ber das Netzwerk gesendet werden soll.\n\nDer Header-Wert kann einer der folgenden Typen sein:\n- `string` â€“ Normaler String-Wert, der an den Server gesendet wird\n- `null` â€“ Header wird beim Rendern nach JSON Ã¼bersprungen\n- `false` â€“ Header wird beim Rendern nach JSON Ã¼bersprungen, zeigt zusÃ¤tzlich an, dass die `set`-Methode mit der Option `rewrite` auf `true` aufgerufen werden muss,\n  um diesen Wert zu Ã¼berschreiben (Axios nutzt dies intern, um es Nutzern zu ermÃ¶glichen, bestimmte Header wie `User-Agent` oder `Content-Type` abzuwÃ¤hlen)\n- `undefined` â€“ Wert ist nicht gesetzt\n\n> Hinweis: Der Header-Wert gilt als gesetzt, wenn er ungleich undefined ist.\n\nDas Header-Objekt wird immer innerhalb von Interceptors und Transformern initialisiert:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // Nachfolgendes Setzen des Headers durch Axios deaktivieren\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // Direkter Zugriff ist veraltet\n    \n      return request;\n    }\n  );\n````\n\nDu kannst Ã¼ber eine Instanz von `AxiosHeaders` mit einer `for...of`-Schleife iterieren:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',\n```",
  "status": "ok"
}