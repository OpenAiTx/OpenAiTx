{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// تنظیم مقادیر پیش‌فرض کانفیگ هنگام ساخت نمونه\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// تغییر مقادیر پیش‌فرض پس از ایجاد نمونه\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### ترتیب اولویت کانفیگ\n\nکانفیگ با ترتیب اولویت ادغام می‌شود. ترتیب به این صورت است: مقادیر پیش‌فرض کتابخانه که در [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49) یافت می‌شود، سپس ویژگی `defaults` از نمونه، و در نهایت آرگومان `config` برای درخواست. مورد آخر نسبت به قبلی‌ها اولویت خواهد داشت. در اینجا یک مثال آورده شده است.\n\n```js\n// ایجاد یک نمونه با استفاده از مقادیر پیش‌فرض کانفیگ ارائه‌شده توسط کتابخانه\n// در این لحظه مقدار کانفیگ timeout برابر با `0` است که مقدار پیش‌فرض کتابخانه می‌باشد\nconst instance = axios.create();\n\n// بازنویسی مقدار پیش‌فرض timeout برای کتابخانه\n// اکنون همه درخواست‌هایی که از این نمونه استفاده می‌کنند، قبل از تایم‌اوت ۲.۵ ثانیه صبر خواهند کرد\ninstance.defaults.timeout = 2500;\n\n// بازنویسی مقدار تایم‌اوت برای این درخواست خاص که می‌دانیم مدت‌زمان زیادی طول می‌کشد\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## اینترسپتور‌ها (Interceptors)\n\nشما می‌توانید درخواست‌ها یا پاسخ‌ها را قبل از این که توسط `then` یا `catch` مدیریت شوند، رهگیری (intercept) کنید.\n\n```js\n\nconst instance = axios.create();\n\n// افزودن یک اینترسپتور درخواست\ninstance.interceptors.request.use(function (config) {\n    // انجام کاری قبل از ارسال درخواست\n    return config;\n  }, function (error) {\n    // انجام کاری هنگام بروز خطا در درخواست\n    return Promise.reject(error);\n  });\n\n// افزودن یک اینترسپتور پاسخ\ninstance.interceptors.response.use(function (response) {\n    // هر کد وضعیتی که در بازه 2xx باشد باعث فعال شدن این تابع می‌شود\n    // انجام کاری با داده‌های پاسخ\n    return response;\n  }, function (error) {\n    // هر کد وضعیتی که خارج از بازه 2xx باشد باعث فعال شدن این تابع می‌شود\n    // انجام کاری هنگام بروز خطا در پاسخ\n    return Promise.reject(error);\n  });\n```\n\nاگر نیاز داشتید بعداً یک اینترسپتور را حذف کنید، می‌توانید این کار را انجام دهید.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nشما همچنین می‌توانید همه اینترسپتورهای درخواست یا پاسخ را پاک کنید.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // حذف اینترسپتورهای درخواست\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // حذف اینترسپتورهای پاسخ\n```\n\nشما می‌توانید اینترسپتورها را به نمونه سفارشی axios اضافه کنید.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nوقتی که اینترسپتورهای درخواست را اضافه می‌کنید، به طور پیش‌فرض فرض می‌شود که آن‌ها ناهمزمان (asynchronous) هستند. این می‌تواند باعث تاخیر\nدر اجرای درخواست axios شما شود زمانی که رشته اصلی (main thread) مسدود شده باشد (یک پرامیس به صورت داخلی برای\nاینترسپتور ایجاد می‌شود و درخواست شما به انتهای پشته فراخوانی (call stack) می‌رود). اگر اینترسپتورهای درخواست شما همزمان (synchronous) هستند، می‌توانید یک پرچم (flag)\nبه شیء گزینه‌ها اضافه کنید تا به axios بگویید کد را به صورت همزمان اجرا کند و از هرگونه تاخیر در اجرای درخواست جلوگیری کند.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nاگر می‌خواهید یک اینترسپتور خاص را بر اساس بررسی در زمان اجرا (runtime check) اجرا کنید،\nمی‌توانید یک تابع `runWhen` به شیء گزینه‌ها اضافه کنید. اینترسپتور درخواست **در صورتی و فقط در صورتی** اجرا نمی‌شود که مقدار بازگشتی\n`runWhen` برابر با `false` باشد. این تابع با شیء کانفیگ فراخوانی می‌شود (فراموش نکنید که می‌توانید آرگومان‌های خودتان را هم به آن bind کنید). این می‌تواند زمانی مفید باشد که\nیک اینترسپتور درخواست ناهمزمان دارید که فقط در شرایط خاصی باید اجرا شود.\n```",
  "status": "ok"
}