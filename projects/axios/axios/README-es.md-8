{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Establecer valores predeterminados de configuración al crear la instancia\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Modificar los valores predeterminados después de que se haya creado la instancia\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Orden de precedencia de la configuración\n\nLa configuración se fusionará con un orden de precedencia. El orden es: los valores predeterminados de la biblioteca que se encuentran en [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), luego la propiedad `defaults` de la instancia, y finalmente el argumento `config` de la solicitud. Este último tendrá precedencia sobre el anterior. Aquí tienes un ejemplo.\n\n```js\n// Crear una instancia usando los valores predeterminados de configuración proporcionados por la biblioteca\n// En este punto, el valor de configuración timeout es `0` como es el valor predeterminado de la biblioteca\nconst instance = axios.create();\n\n// Sobrescribir el valor predeterminado de timeout de la biblioteca\n// Ahora todas las solicitudes que usen esta instancia esperarán 2.5 segundos antes de agotar el tiempo de espera\ninstance.defaults.timeout = 2500;\n\n// Sobrescribir el timeout para esta solicitud ya que se sabe que tomará mucho tiempo\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptores\n\nPuedes interceptar solicitudes o respuestas antes de que sean manejadas por `then` o `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Agregar un interceptor de solicitud\ninstance.interceptors.request.use(function (config) {\n    // Hacer algo antes de que se envíe la solicitud\n    return config;\n  }, function (error) {\n    // Hacer algo con el error de la solicitud\n    return Promise.reject(error);\n  });\n\n// Agregar un interceptor de respuesta\ninstance.interceptors.response.use(function (response) {\n    // Cualquier código de estado dentro del rango 2xx hace que esta función se dispare\n    // Hacer algo con los datos de la respuesta\n    return response;\n  }, function (error) {\n    // Cualquier código de estado fuera del rango 2xx hace que esta función se dispare\n    // Hacer algo con el error de la respuesta\n    return Promise.reject(error);\n  });\n```\n\nSi necesitas eliminar un interceptor más tarde, puedes hacerlo.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nTambién puedes eliminar todos los interceptores de solicitudes o respuestas.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Elimina los interceptores de solicitudes\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Elimina los interceptores de respuestas\n```\n\nPuedes agregar interceptores a una instancia personalizada de axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nCuando agregas interceptores de solicitud, se presume que son asíncronos por defecto. Esto puede causar un retraso\nen la ejecución de tu solicitud axios cuando el hilo principal está bloqueado (se crea una promesa internamente para\nel interceptor y tu solicitud se coloca al final de la pila de llamadas). Si tus interceptores de solicitud son síncronos, puedes agregar una bandera\nal objeto de opciones que le indicará a axios que ejecute el código de manera síncrona y evite cualquier retraso en la ejecución de la solicitud.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = '¡Solo soy un encabezado!';\n  return config;\n}, null, { synchronous: true });\n```\n\nSi quieres ejecutar un interceptor en particular basándote en una comprobación en tiempo de ejecución,\npuedes agregar una función `runWhen` al objeto de opciones. El interceptor de solicitud **no se ejecutará si y solo si** el retorno\nde `runWhen` es `false`. La función será llamada con el objeto de configuración\n(no olvides que también puedes enlazar tus propios argumentos a ella). Esto puede ser útil cuando tienes un\ninterceptor de solicitud asíncrono que solo necesita ejecutarse en ciertos momentos.\n```",
  "status": "ok"
}