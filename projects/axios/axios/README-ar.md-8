{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// تعيين الإعدادات الافتراضية عند إنشاء المثيل\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// تعديل الإعدادات الافتراضية بعد إنشاء المثيل\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### ترتيب أولوية الإعدادات\n\nسيتم دمج الإعدادات بترتيب الأولوية. الترتيب هو الإعدادات الافتراضية للمكتبة الموجودة في [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49)، ثم خاصية `defaults` الخاصة بالمثيل، وأخيراً وسيطة `config` لطلب الاستدعاء. الوسيطة الأخيرة سيكون لها الأولوية على ما قبلها. إليك مثال:\n\n```js\n// أنشئ مثيلاً باستخدام الإعدادات الافتراضية المقدمة من المكتبة\n// في هذه المرحلة تكون قيمة timeout الافتراضية هي `0` كما هو افتراضي في المكتبة\nconst instance = axios.create();\n\n// تجاوز القيمة الافتراضية للمهلة للمكتبة\n// الآن جميع الطلبات باستخدام هذا المثيل ستنتظر 2.5 ثانية قبل انتهاء المهلة\ninstance.defaults.timeout = 2500;\n\n// تجاوز المهلة لهذا الطلب لأنه معروف أنه سيستغرق وقتًا طويلاً\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## المعترضات (Interceptors)\n\nيمكنك اعتراض الطلبات أو الاستجابات قبل أن يتم التعامل معها بواسطة `then` أو `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// إضافة معترض للطلبات\ninstance.interceptors.request.use(function (config) {\n    // قم بفعل شيء قبل إرسال الطلب\n    return config;\n  }, function (error) {\n    // قم بفعل شيء عند حدوث خطأ في الطلب\n    return Promise.reject(error);\n  });\n\n// إضافة معترض للاستجابات\ninstance.interceptors.response.use(function (response) {\n    // أي كود حالة يقع ضمن نطاق 2xx سيؤدي إلى تنفيذ هذه الدالة\n    // قم بفعل شيء مع بيانات الاستجابة\n    return response;\n  }, function (error) {\n    // أي كود حالة خارج نطاق 2xx سيؤدي إلى تنفيذ هذه الدالة\n    // قم بفعل شيء مع خطأ الاستجابة\n    return Promise.reject(error);\n  });\n```\n\nإذا كنت بحاجة لإزالة معترض في وقت لاحق، يمكنك ذلك.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nيمكنك أيضًا إزالة جميع المعترضات للطلبات أو الاستجابات.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // يزيل المعترضات من الطلبات\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // يزيل المعترضات من الاستجابات\n```\n\nيمكنك إضافة معترضات إلى مثيل مخصص من axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nعند إضافة معترضات للطلبات، يُفترض أنها غير متزامنة بشكل افتراضي. هذا قد يسبب تأخيراً\nفي تنفيذ طلب axios عندما يكون الخيط الرئيسي مشغولاً (يتم إنشاء وعد تحت الغطاء للمعترض\nويتم وضع طلبك في أسفل مكدس الاستدعاء). إذا كانت معترضاتك متزامنة، يمكنك إضافة علم\nإلى كائن الخيارات ليخبر axios بتنفيذ الكود بشكل متزامن وتجنب أي تأخير في تنفيذ الطلب.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nإذا كنت تريد تنفيذ معترض معين بناءً على تحقق وقت التشغيل،\nيمكنك إضافة دالة `runWhen` إلى كائن الخيارات. لن يتم تنفيذ معترض الطلب **إذا وفقط إذا**\nكانت قيمة الإرجاع من `runWhen` هي `false`. سيتم استدعاء الدالة مع كائن\nالإعدادات (ولا تنس أنه يمكنك ربط وسائطك الخاصة بها أيضاً). هذا قد يكون مفيداً عندما يكون لديك\nمعترض طلب غير متزامن يحتاج للتنفيذ فقط في أوقات معينة.\n```",
  "status": "ok"
}