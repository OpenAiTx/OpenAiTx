{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Установить значения конфигурации по умолчанию при создании экземпляра\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Изменить значения по умолчанию после создания экземпляра\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Порядок приоритета конфигураций\n\nКонфигурация будет объединяться с учетом порядка приоритета. Сначала используются значения по умолчанию библиотеки, определённые в [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), затем свойство `defaults` экземпляра, и, наконец, аргумент `config` для запроса. Последний имеет приоритет над предыдущими. Вот пример.\n\n```js\n// Создать экземпляр, используя значения конфигурации по умолчанию, предоставленные библиотекой\n// На этом этапе значение timeout равно `0`, как и по умолчанию для библиотеки\nconst instance = axios.create();\n\n// Переопределить значение timeout по умолчанию для библиотеки\n// Теперь все запросы, использующие этот экземпляр, будут ожидать 2.5 секунды перед истечением времени ожидания\ninstance.defaults.timeout = 2500;\n\n// Переопределить timeout для этого запроса, так как известно, что он занимает много времени\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Перехватчики (Interceptors)\n\nВы можете перехватывать запросы или ответы до того, как ими займутся `then` или `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Добавить перехватчик запроса\ninstance.interceptors.request.use(function (config) {\n    // Выполнить действия перед отправкой запроса\n    return config;\n  }, function (error) {\n    // Обработка ошибки запроса\n    return Promise.reject(error);\n  });\n\n// Добавить перехватчик ответа\ninstance.interceptors.response.use(function (response) {\n    // Любой код статуса в диапазоне 2xx вызовет выполнение этой функции\n    // Обработка данных ответа\n    return response;\n  }, function (error) {\n    // Любой код статуса вне диапазона 2xx вызовет выполнение этой функции\n    // Обработка ошибки ответа\n    return Promise.reject(error);\n  });\n```\n\nЕсли вам нужно позже удалить перехватчик, вы можете это сделать.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nВы также можете удалить все перехватчики для запросов или ответов.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Удаляет перехватчики запросов\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Удаляет перехватчики ответов\n```\n\nВы можете добавить перехватчики к своему собственному экземпляру axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nКогда вы добавляете перехватчики запросов, по умолчанию считается, что они асинхронные. Это может вызвать задержку\nв выполнении вашего axios-запроса, если главный поток заблокирован (под капотом для\nперехватчика создаётся promise, и ваш запрос помещается в конец стека вызовов). Если ваши перехватчики запросов синхронные, вы можете добавить флаг\nв объект опций, который укажет axios выполнять код синхронно и избежать любых задержек при выполнении запроса.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nЕсли вы хотите выполнить определённый перехватчик на основе проверки во время выполнения,\nвы можете добавить функцию `runWhen` в объект опций. Перехватчик запроса не будет выполнен **только если** возвращаемое значение\n`runWhen` — `false`. Функция будет вызвана с объектом config\n(не забывайте, что вы также можете привязать к ней свои собственные аргументы). Это может быть полезно, если у вас есть\nасинхронный перехватчик запросов, который должен выполняться только в определённых случаях.\n```",
  "status": "ok"
}