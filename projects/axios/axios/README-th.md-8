{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// กำหนดค่าเริ่มต้นของ config เมื่อสร้าง instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// เปลี่ยนค่าเริ่มต้นหลังจากสร้าง instance แล้ว\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### ลำดับความสำคัญของ Config\n\nConfig จะถูกนำมารวมกันตามลำดับความสำคัญ ลำดับคือ ค่าเริ่มต้นของไลบรารีที่อยู่ใน [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), จากนั้นเป็น property `defaults` ของ instance และสุดท้ายคือ argument `config` สำหรับ request ค่าหลังจะมีความสำคัญเหนือกว่าค่าก่อนหน้า ตัวอย่างเช่น\n\n```js\n// สร้าง instance โดยใช้ config เริ่มต้นที่ไลบรารีกำหนดไว้\n// ณ จุดนี้ ค่า timeout ของ config คือ `0` ซึ่งเป็นค่าเริ่มต้นของไลบรารี\nconst instance = axios.create();\n\n// เปลี่ยนค่า timeout เริ่มต้นของไลบรารี\n// ตอนนี้ทุก request ที่ใช้ instance นี้จะรอ 2.5 วินาทีก่อน timeout\ninstance.defaults.timeout = 2500;\n\n// เปลี่ยนค่า timeout สำหรับ request นี้เท่านั้น เนื่องจากทราบว่าจะใช้เวลานาน\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nคุณสามารถดักจับ (intercept) request หรือ response ก่อนที่จะถูกจัดการโดย `then` หรือ `catch`\n\n```js\n\nconst instance = axios.create();\n\n// เพิ่ม request interceptor\ninstance.interceptors.request.use(function (config) {\n    // ทำบางอย่างก่อนส่ง request\n    return config;\n  }, function (error) {\n    // ทำบางอย่างเมื่อเกิดข้อผิดพลาดกับ request\n    return Promise.reject(error);\n  });\n\n// เพิ่ม response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Status code ใด ๆ ที่อยู่ในช่วง 2xx จะทำให้ฟังก์ชันนี้ทำงาน\n    // ทำบางอย่างกับข้อมูล response\n    return response;\n  }, function (error) {\n    // Status code ใด ๆ ที่อยู่นอกช่วง 2xx จะทำให้ฟังก์ชันนี้ทำงาน\n    // ทำบางอย่างกับข้อผิดพลาดของ response\n    return Promise.reject(error);\n  });\n```\n\nหากคุณต้องการลบ interceptor ในภายหลัง คุณสามารถทำได้\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nคุณยังสามารถลบ interceptor ทั้งหมดสำหรับ request หรือ response ได้เช่นกัน\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // ลบ interceptor ทั้งหมดจาก request\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // ลบ interceptor ทั้งหมดจาก response\n```\n\nคุณสามารถเพิ่ม interceptor ให้กับ instance แบบกำหนดเองของ axios ได้\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nเมื่อคุณเพิ่ม request interceptor ค่าเริ่มต้นจะถือว่าเป็นแบบ asynchronous ซึ่งอาจทำให้เกิดความล่าช้า\nในการทำงานของ axios request เมื่อ main thread ถูกบล็อก (จะมีการสร้าง promise เบื้องหลังสำหรับ interceptor และ request ของคุณจะถูกวางไว้ล่างสุดของ call stack) หาก request interceptor ของคุณเป็น synchronous คุณสามารถเพิ่ม flag\nใน options object เพื่อแจ้งให้ axios รันโค้ดแบบ synchronous และหลีกเลี่ยงความล่าช้าในการทำงานของ request\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nหากคุณต้องการให้ interceptor ตัวใดทำงานตามเงื่อนไขขณะรันไทม์\nคุณสามารถเพิ่มฟังก์ชัน `runWhen` ลงใน options object ได้ โดย request interceptor จะไม่ทำงาน **หากและเฉพาะเมื่อ** ผลลัพธ์ที่คืนค่าจาก `runWhen` เป็น `false` ฟังก์ชันนี้จะถูกเรียกพร้อมกับ object config (อย่าลืมว่าคุณสามารถ bind argument ของคุณเองเข้าไปได้เช่นกัน) สิ่งนี้จะมีประโยชน์เมื่อคุณมี request interceptor แบบ asynchronous ที่จำเป็นต้องรันเฉพาะบางช่วงเวลาเท่านั้น\n```",
  "status": "ok"
}