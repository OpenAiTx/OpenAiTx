{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// 建立實例時設定預設組態\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// 在建立實例後修改預設值\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### 組態優先順序\n\n組態會依照優先順序進行合併。順序為：在 [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49) 中定義的函式庫預設值，然後是實例的 `defaults` 屬性，最後是請求的 `config` 參數。後者會覆蓋前者。以下是一個範例。\n\n```js\n// 使用函式庫提供的預設組態建立實例\n// 此時，timeout 組態值為 `0`，這是函式庫的預設值\nconst instance = axios.create();\n\n// 覆蓋函式庫的 timeout 預設值\n// 現在所有使用此實例的請求都會等候 2.5 秒才會逾時\ninstance.defaults.timeout = 2500;\n\n// 由於這個請求預期會花較長時間，因此單獨覆蓋 timeout\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## 攔截器\n\n你可以在 `then` 或 `catch` 處理之前，攔截請求或回應。\n\n```js\n\nconst instance = axios.create();\n\n// 新增請求攔截器\ninstance.interceptors.request.use(function (config) {\n    // 在請求發送前做些處理\n    return config;\n  }, function (error) {\n    // 處理請求錯誤\n    return Promise.reject(error);\n  });\n\n// 新增回應攔截器\ninstance.interceptors.response.use(function (response) {\n    // 任何 2xx 範圍內的狀態碼都會觸發此函式\n    // 處理回應資料\n    return response;\n  }, function (error) {\n    // 任何不在 2xx 範圍內的狀態碼都會觸發此函式\n    // 處理回應錯誤\n    return Promise.reject(error);\n  });\n```\n\n如果你需要之後移除攔截器，可以這麼做。\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\n你也可以清除所有請求或回應的攔截器。\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // 移除所有請求攔截器\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // 移除所有回應攔截器\n```\n\n你可以將攔截器加到自訂的 axios 實例上。\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\n當你新增請求攔截器時，預設會被視為非同步。這可能會導致當主執行緒被阻塞時，\naxios 請求執行有延遲（攔截器底層會建立一個 promise，請求會被放到底部的呼叫堆疊）。如果你的請求攔截器是同步的，可以在選項物件中加入一個旗標，\n讓 axios 以同步方式執行程式碼，避免請求執行延遲。\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\n如果你想根據執行階段檢查來執行特定攔截器，\n可以在選項物件中加入 `runWhen` 函式。當且僅當 `runWhen` 的回傳值為 `false` 時，該請求攔截器才不會被執行。此函式會接收 config\n物件作為參數（你也可以繫結自己的參數）。這在你有非同步請求攔截器只需在特定時機執行時會很方便。\n```",
  "status": "ok"
}