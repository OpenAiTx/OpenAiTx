{
  "id": 14,
  "origin": "      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // download speed in bytes\n      download: true; // download sign\n    }*/\n  }\n});  \n```\n\nYou can also track stream upload/download progress in node.js:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // avoid buffering the entire stream\n});\n````\n\n> **Note:**\n> Capturing FormData upload progress is not currently supported in node.js environments.\n\n> **âš ï¸ Warning**\n> It is recommended to disable redirects by setting maxRedirects: 0 to upload the stream in the **node.js** environment,\n> as follow-redirects package will buffer the entire stream in RAM without following the \"backpressure\" algorithm.\n\n\n## ğŸ†• Rate limiting\n\nDownload and upload rate limits can only be set for the http adapter (node.js):\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // 100KB/s limit\n});\n```\n\n## ğŸ†• AxiosHeaders\n\nAxios has its own `AxiosHeaders` class to manipulate headers using a Map-like API that guarantees caseless work.\nAlthough HTTP is case-insensitive in headers, Axios will retain the case of the original header for stylistic reasons\nand for a workaround when servers mistakenly consider the header's case.\nThe old approach of directly manipulating headers object is still available, but deprecated and not recommended for future usage.\n\n### Working with headers\n\nAn AxiosHeaders object instance can contain different types of internal values. that control setting and merging logic.\nThe final headers object with string values is obtained by Axios by calling the `toJSON` method.\n\n> Note: By JSON here we mean an object consisting only of string values intended to be sent over the network.\n\nThe header value can be one of the following types:\n- `string` - normal string value that will be sent to the server\n- `null` - skip header when rendering to JSON\n- `false` - skip header when rendering to JSON, additionally indicates that `set` method must be called with `rewrite` option set to `true`\n  to overwrite this value (Axios uses this internally to allow users to opt out of installing certain headers like `User-Agent` or `Content-Type`)\n- `undefined` - value is not set\n\n> Note: The header value is considered set if it is not equal to undefined.\n\nThe headers object is always initialized inside interceptors and transformers:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // disable subsequent setting the header by Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // direct access is deprecated\n    \n      return request;\n    }\n  );\n````\n\nYou can iterate over an `AxiosHeaders` instance using a `for...of` statement:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',",
  "origin_sha": "FK9fblZzMaAq7pcNVVG17lyaNO+0Z7qRCDVMdJcNTFs=",
  "translate": "      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // vitesse de tÃ©lÃ©chargement en octets\n      download: true; // indicateur de tÃ©lÃ©chargement\n    }*/\n  }\n});  \n```\n\nVous pouvez Ã©galement suivre la progression du tÃ©lÃ©chargement/tÃ©lÃ©versement de flux dans node.js :\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // Ã©viter de mettre en mÃ©moire tampon l'intÃ©gralitÃ© du flux\n});\n````\n\n> **Remarque :**\n> Le suivi de la progression du tÃ©lÃ©versement FormData n'est actuellement pas pris en charge dans les environnements node.js.\n\n> **âš ï¸ Avertissement**\n> Il est recommandÃ© de dÃ©sactiver les redirections en dÃ©finissant maxRedirects: 0 pour tÃ©lÃ©verser le flux dans l'environnement **node.js**,\n> car le paquet follow-redirects mettra en mÃ©moire tampon tout le flux dans la RAM sans suivre l'algorithme de \"backpressure\".\n\n\n## ğŸ†• Limitation de dÃ©bit\n\nLes limites de dÃ©bit de tÃ©lÃ©chargement et de tÃ©lÃ©versement ne peuvent Ãªtre dÃ©finies que pour l'adaptateur http (node.js) :\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`TÃ©lÃ©versement [${(progress*100).toFixed(2)}%] : ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // limite Ã  100KB/s\n});\n```\n\n## ğŸ†• AxiosHeaders\n\nAxios dispose de sa propre classe `AxiosHeaders` pour manipuler les en-tÃªtes Ã  l'aide d'une API de type Map qui garantit la gestion insensible Ã  la casse.\nBien que HTTP soit insensible Ã  la casse dans les en-tÃªtes, Axios conservera la casse de l'en-tÃªte d'origine pour des raisons stylistiques\net comme solution de contournement lorsque les serveurs considÃ¨rent par erreur la casse de l'en-tÃªte.\nL'ancienne mÃ©thode de manipulation directe de l'objet headers est toujours disponible, mais obsolÃ¨te et non recommandÃ©e pour une utilisation future.\n\n### Travailler avec les en-tÃªtes\n\nUne instance d'objet AxiosHeaders peut contenir diffÃ©rents types de valeurs internes qui contrÃ´lent la logique d'attribution et de fusion.\nL'objet final headers avec des valeurs de type chaÃ®ne est obtenu par Axios en appelant la mÃ©thode `toJSON`.\n\n> Remarque : Par JSON ici, nous entendons un objet composÃ© uniquement de valeurs de type chaÃ®ne destinÃ©es Ã  Ãªtre envoyÃ©es sur le rÃ©seau.\n\nLa valeur dâ€™un en-tÃªte peut Ãªtre de lâ€™un des types suivants :\n- `string` - valeur de chaÃ®ne normale qui sera envoyÃ©e au serveur\n- `null` - ignorer lâ€™en-tÃªte lors du rendu en JSON\n- `false` - ignorer lâ€™en-tÃªte lors du rendu en JSON, indique Ã©galement que la mÃ©thode `set` doit Ãªtre appelÃ©e avec lâ€™option `rewrite` dÃ©finie Ã  `true`\n  pour Ã©craser cette valeur (Axios utilise cela en interne pour permettre aux utilisateurs de ne pas installer certains en-tÃªtes comme `User-Agent` ou `Content-Type`)\n- `undefined` - valeur non dÃ©finie\n\n> Remarque : La valeur de lâ€™en-tÃªte est considÃ©rÃ©e comme dÃ©finie si elle nâ€™est pas Ã©gale Ã  undefined.\n\nL'objet headers est toujours initialisÃ© Ã  l'intÃ©rieur des intercepteurs et des transformateurs :\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // dÃ©sactiver lâ€™attribution ultÃ©rieure de lâ€™en-tÃªte par Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // accÃ¨s direct obsolÃ¨te\n    \n      return request;\n    }\n  );\n````\n\nVous pouvez itÃ©rer sur une instance de `AxiosHeaders` Ã  lâ€™aide dâ€™une instruction `for...of` :\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',",
  "status": "ok"
}