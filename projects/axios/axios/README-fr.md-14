{
  "id": 14,
  "origin": "      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // download speed in bytes\n      download: true; // download sign\n    }*/\n  }\n});  \n```\n\nYou can also track stream upload/download progress in node.js:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // avoid buffering the entire stream\n});\n````\n\n> **Note:**\n> Capturing FormData upload progress is not currently supported in node.js environments.\n\n> **⚠️ Warning**\n> It is recommended to disable redirects by setting maxRedirects: 0 to upload the stream in the **node.js** environment,\n> as follow-redirects package will buffer the entire stream in RAM without following the \"backpressure\" algorithm.\n\n\n## 🆕 Rate limiting\n\nDownload and upload rate limits can only be set for the http adapter (node.js):\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // 100KB/s limit\n});\n```\n\n## 🆕 AxiosHeaders\n\nAxios has its own `AxiosHeaders` class to manipulate headers using a Map-like API that guarantees caseless work.\nAlthough HTTP is case-insensitive in headers, Axios will retain the case of the original header for stylistic reasons\nand for a workaround when servers mistakenly consider the header's case.\nThe old approach of directly manipulating headers object is still available, but deprecated and not recommended for future usage.\n\n### Working with headers\n\nAn AxiosHeaders object instance can contain different types of internal values. that control setting and merging logic.\nThe final headers object with string values is obtained by Axios by calling the `toJSON` method.\n\n> Note: By JSON here we mean an object consisting only of string values intended to be sent over the network.\n\nThe header value can be one of the following types:\n- `string` - normal string value that will be sent to the server\n- `null` - skip header when rendering to JSON\n- `false` - skip header when rendering to JSON, additionally indicates that `set` method must be called with `rewrite` option set to `true`\n  to overwrite this value (Axios uses this internally to allow users to opt out of installing certain headers like `User-Agent` or `Content-Type`)\n- `undefined` - value is not set\n\n> Note: The header value is considered set if it is not equal to undefined.\n\nThe headers object is always initialized inside interceptors and transformers:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // disable subsequent setting the header by Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // direct access is deprecated\n    \n      return request;\n    }\n  );\n````\n\nYou can iterate over an `AxiosHeaders` instance using a `for...of` statement:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',",
  "origin_sha": "FK9fblZzMaAq7pcNVVG17lyaNO+0Z7qRCDVMdJcNTFs=",
  "translate": "      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // vitesse de téléchargement en octets\n      download: true; // indicateur de téléchargement\n    }*/\n  }\n});  \n```\n\nVous pouvez également suivre la progression du téléchargement/téléversement de flux dans node.js :\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // éviter de mettre en mémoire tampon l'intégralité du flux\n});\n````\n\n> **Remarque :**\n> Le suivi de la progression du téléversement FormData n'est actuellement pas pris en charge dans les environnements node.js.\n\n> **⚠️ Avertissement**\n> Il est recommandé de désactiver les redirections en définissant maxRedirects: 0 pour téléverser le flux dans l'environnement **node.js**,\n> car le paquet follow-redirects mettra en mémoire tampon tout le flux dans la RAM sans suivre l'algorithme de \"backpressure\".\n\n\n## 🆕 Limitation de débit\n\nLes limites de débit de téléchargement et de téléversement ne peuvent être définies que pour l'adaptateur http (node.js) :\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Téléversement [${(progress*100).toFixed(2)}%] : ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // limite à 100KB/s\n});\n```\n\n## 🆕 AxiosHeaders\n\nAxios dispose de sa propre classe `AxiosHeaders` pour manipuler les en-têtes à l'aide d'une API de type Map qui garantit la gestion insensible à la casse.\nBien que HTTP soit insensible à la casse dans les en-têtes, Axios conservera la casse de l'en-tête d'origine pour des raisons stylistiques\net comme solution de contournement lorsque les serveurs considèrent par erreur la casse de l'en-tête.\nL'ancienne méthode de manipulation directe de l'objet headers est toujours disponible, mais obsolète et non recommandée pour une utilisation future.\n\n### Travailler avec les en-têtes\n\nUne instance d'objet AxiosHeaders peut contenir différents types de valeurs internes qui contrôlent la logique d'attribution et de fusion.\nL'objet final headers avec des valeurs de type chaîne est obtenu par Axios en appelant la méthode `toJSON`.\n\n> Remarque : Par JSON ici, nous entendons un objet composé uniquement de valeurs de type chaîne destinées à être envoyées sur le réseau.\n\nLa valeur d’un en-tête peut être de l’un des types suivants :\n- `string` - valeur de chaîne normale qui sera envoyée au serveur\n- `null` - ignorer l’en-tête lors du rendu en JSON\n- `false` - ignorer l’en-tête lors du rendu en JSON, indique également que la méthode `set` doit être appelée avec l’option `rewrite` définie à `true`\n  pour écraser cette valeur (Axios utilise cela en interne pour permettre aux utilisateurs de ne pas installer certains en-têtes comme `User-Agent` ou `Content-Type`)\n- `undefined` - valeur non définie\n\n> Remarque : La valeur de l’en-tête est considérée comme définie si elle n’est pas égale à undefined.\n\nL'objet headers est toujours initialisé à l'intérieur des intercepteurs et des transformateurs :\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // désactiver l’attribution ultérieure de l’en-tête par Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // accès direct obsolète\n    \n      return request;\n    }\n  );\n````\n\nVous pouvez itérer sur une instance de `AxiosHeaders` à l’aide d’une instruction `for...of` :\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',",
  "status": "ok"
}