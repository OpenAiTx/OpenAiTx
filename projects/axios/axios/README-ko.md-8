{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// 인스턴스 생성 시 기본 설정값 지정\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// 인스턴스 생성 후 기본값 변경\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### 설정값 우선순위\n\n설정값은 우선순위에 따라 병합됩니다. 우선순위는 [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49)에서 찾을 수 있는 라이브러리 기본값, 그 다음은 인스턴스의 `defaults` 속성, 마지막으로 요청에 대한 `config` 인자입니다. 후자가 전자보다 우선합니다. 다음은 예시입니다.\n\n```js\n// 라이브러리에서 제공하는 기본 설정값을 이용해 인스턴스 생성\n// 이 시점에서 timeout 값은 라이브러리의 기본값인 `0`입니다\nconst instance = axios.create();\n\n// 라이브러리의 timeout 기본값을 재정의\n// 이제 이 인스턴스를 사용하는 모든 요청은 2.5초 동안 대기 후 timeout이 발생합니다\ninstance.defaults.timeout = 2500;\n\n// 해당 요청이 오래 걸릴 것으로 예상되어 timeout을 재정의\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## 인터셉터(Interceptors)\n\n`then`이나 `catch`로 처리되기 전에 요청 또는 응답을 가로챌 수 있습니다.\n\n```js\n\nconst instance = axios.create();\n\n// 요청 인터셉터 추가\ninstance.interceptors.request.use(function (config) {\n    // 요청이 전송되기 전에 작업 수행\n    return config;\n  }, function (error) {\n    // 요청 오류가 발생했을 때 작업 수행\n    return Promise.reject(error);\n  });\n\n// 응답 인터셉터 추가\ninstance.interceptors.response.use(function (response) {\n    // 2xx 범위 내의 상태 코드는 이 함수가 실행되도록 함\n    // 응답 데이터로 작업 수행\n    return response;\n  }, function (error) {\n    // 2xx 범위 밖의 상태 코드는 이 함수가 실행되도록 함\n    // 응답 오류로 작업 수행\n    return Promise.reject(error);\n  });\n```\n\n나중에 인터셉터를 제거해야 한다면 가능합니다.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\n요청 또는 응답에 대한 모든 인터셉터를 제거할 수도 있습니다.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // 요청에서 인터셉터 제거\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // 응답에서 인터셉터 제거\n```\n\naxios의 사용자 정의 인스턴스에도 인터셉터를 추가할 수 있습니다.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\n요청 인터셉터를 추가할 때, 기본적으로 비동기로 간주됩니다. 이로 인해 메인 스레드가 막힐 때 axios 요청 실행이 지연될 수 있습니다(인터셉터 내부적으로 promise가 생성되고 요청이 콜 스택의 가장 아래로 밀림). 만약 요청 인터셉터가 동기라면 옵션 객체에 플래그를 추가해 axios가 코드를 동기로 실행하도록 하여 요청 실행의 지연을 방지할 수 있습니다.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\n실행 시점에 따라 특정 인터셉터를 실행하고 싶다면, 옵션 객체에 `runWhen` 함수를 추가할 수 있습니다. `runWhen`의 반환값이 `false`일 경우에만 요청 인터셉터가 실행되지 **않습니다**. 이 함수는 config 객체를 인자로 호출됩니다(여기에 사용자 인자를 바인딩할 수도 있습니다). 이는 특정 시점에만 실행되어야 하는 비동기 요청 인터셉터가 있을 때 유용합니다.\n```",
  "status": "ok"
}