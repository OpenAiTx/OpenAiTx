{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Définir les valeurs par défaut de la configuration lors de la création de l'instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Modifier les valeurs par défaut après la création de l'instance\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Ordre de priorité de la configuration\n\nLa configuration sera fusionnée selon un ordre de priorité. L'ordre est : les valeurs par défaut de la bibliothèque trouvées dans [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), puis la propriété `defaults` de l'instance, et enfin l'argument `config` pour la requête. Ce dernier prendra le dessus sur le précédent. Voici un exemple.\n\n```js\n// Créer une instance en utilisant les valeurs de configuration par défaut fournies par la bibliothèque\n// À ce stade, la valeur de configuration timeout est `0`, comme c'est le cas par défaut pour la bibliothèque\nconst instance = axios.create();\n\n// Remplacer la valeur par défaut du timeout pour la bibliothèque\n// Désormais, toutes les requêtes utilisant cette instance attendront 2,5 secondes avant d'expirer\ninstance.defaults.timeout = 2500;\n\n// Remplacer le timeout pour cette requête car elle est connue pour être longue\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Intercepteurs\n\nVous pouvez intercepter les requêtes ou les réponses avant qu'elles ne soient traitées par `then` ou `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Ajouter un intercepteur de requête\ninstance.interceptors.request.use(function (config) {\n    // Faire quelque chose avant l'envoi de la requête\n    return config;\n  }, function (error) {\n    // Faire quelque chose en cas d'erreur de requête\n    return Promise.reject(error);\n  });\n\n// Ajouter un intercepteur de réponse\ninstance.interceptors.response.use(function (response) {\n    // Tout code de statut compris dans la plage 2xx déclenche cette fonction\n    // Faire quelque chose avec les données de la réponse\n    return response;\n  }, function (error) {\n    // Tout code de statut en dehors de la plage 2xx déclenche cette fonction\n    // Faire quelque chose en cas d'erreur de réponse\n    return Promise.reject(error);\n  });\n```\n\nSi vous avez besoin de supprimer un intercepteur plus tard, vous pouvez le faire.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nVous pouvez également supprimer tous les intercepteurs pour les requêtes ou les réponses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Supprime les intercepteurs des requêtes\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Supprime les intercepteurs des réponses\n```\n\nVous pouvez ajouter des intercepteurs à une instance personnalisée d'axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nLorsque vous ajoutez des intercepteurs de requête, ils sont supposés être asynchrones par défaut. Cela peut entraîner un délai\ndans l'exécution de votre requête axios lorsque le thread principal est bloqué (une promesse est créée en interne pour\nl'intercepteur et votre requête est placée en bas de la pile d'appels). Si vos intercepteurs de requêtes sont synchrones, vous pouvez ajouter un indicateur\ndans l'objet d'options qui indiquera à axios d'exécuter le code de façon synchrone et d'éviter tout délai dans l'exécution de la requête.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'Je suis uniquement un en-tête !';\n  return config;\n}, null, { synchronous: true });\n```\n\nSi vous souhaitez exécuter un intercepteur particulier en fonction d'un contrôle à l'exécution,\nvous pouvez ajouter une fonction `runWhen` à l'objet d'options. L'intercepteur de requête ne sera **pas exécuté si et seulement si** le retour\nde `runWhen` est `false`. La fonction sera appelée avec l'objet config\n(n'oubliez pas que vous pouvez aussi lui lier vos propres arguments). Cela peut être utile lorsqu'un intercepteur de requête asynchrone\nne doit s'exécuter qu'à certains moments.\n```",
  "status": "ok"
}