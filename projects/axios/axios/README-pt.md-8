{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Defina os padrões de configuração ao criar a instância\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Altere os padrões após a criação da instância\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Ordem de precedência da configuração\n\nA configuração será mesclada com uma ordem de precedência. A ordem é: padrões da biblioteca encontrados em [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), depois a propriedade `defaults` da instância e, por fim, o argumento `config` da requisição. O último terá precedência sobre o anterior. Veja um exemplo.\n\n```js\n// Crie uma instância usando os padrões de configuração fornecidos pela biblioteca\n// Neste ponto, o valor de timeout na configuração é `0`, pois este é o padrão da biblioteca\nconst instance = axios.create();\n\n// Substitua o padrão de timeout da biblioteca\n// Agora todas as requisições usando esta instância esperarão 2,5 segundos antes do timeout\ninstance.defaults.timeout = 2500;\n\n// Substitua o timeout para esta requisição, pois sabe-se que ela demora\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptadores\n\nVocê pode interceptar requisições ou respostas antes que elas sejam tratadas pelo `then` ou `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Adicione um interceptador de requisição\ninstance.interceptors.request.use(function (config) {\n    // Faça algo antes da requisição ser enviada\n    return config;\n  }, function (error) {\n    // Faça algo com o erro da requisição\n    return Promise.reject(error);\n  });\n\n// Adicione um interceptador de resposta\ninstance.interceptors.response.use(function (response) {\n    // Qualquer código de status dentro do intervalo de 2xx faz esta função ser disparada\n    // Faça algo com os dados da resposta\n    return response;\n  }, function (error) {\n    // Qualquer código de status fora do intervalo de 2xx faz esta função ser disparada\n    // Faça algo com o erro da resposta\n    return Promise.reject(error);\n  });\n```\n\nSe você precisar remover um interceptador posteriormente, você pode.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nVocê também pode limpar todos os interceptadores de requisições ou respostas.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Remove os interceptadores das requisições\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Remove os interceptadores das respostas\n```\n\nVocê pode adicionar interceptadores a uma instância personalizada do axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nAo adicionar interceptadores de requisição, presume-se que eles sejam assíncronos por padrão. Isso pode causar um atraso\nna execução da sua requisição axios quando a thread principal está bloqueada (uma promise é criada internamente para\no interceptador e sua requisição é colocada no final da pilha de chamadas). Se seus interceptadores de requisição forem síncronos, você pode adicionar uma flag\nao objeto de opções que informará ao axios para executar o código de forma síncrona e evitar atrasos na execução da requisição.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nSe você quiser executar um interceptador específico com base em uma verificação em tempo de execução,\npode adicionar uma função `runWhen` ao objeto de opções. O interceptador de requisição não será executado **se, e somente se**, o retorno\nde `runWhen` for `false`. A função será chamada com o objeto config\n(não se esqueça de que você também pode vincular seus próprios argumentos a ela). Isso pode ser útil quando você tem um\ninterceptador de requisição assíncrono que só precisa ser executado em determinados momentos.\n```",
  "status": "ok"
}