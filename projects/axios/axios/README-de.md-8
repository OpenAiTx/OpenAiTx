{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Setze Standardkonfigurationen beim Erstellen der Instanz\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Ändere Standardwerte, nachdem die Instanz erstellt wurde\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Reihenfolge der Konfigurationspriorität\n\nDie Konfiguration wird mit einer Prioritätsreihenfolge zusammengeführt. Die Reihenfolge ist: Bibliotheks-Standardwerte, zu finden in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), dann die `defaults`-Eigenschaft der Instanz und schließlich das `config`-Argument für die Anfrage. Letzteres hat Vorrang vor den anderen. Hier ein Beispiel.\n\n```js\n// Erstelle eine Instanz unter Verwendung der von der Bibliothek bereitgestellten Standardkonfigurationen\n// Zu diesem Zeitpunkt ist der Timeout-Wert `0`, wie es der Standard für die Bibliothek ist\nconst instance = axios.create();\n\n// Überschreibe den Timeout-Standardwert der Bibliothek\n// Jetzt warten alle Anfragen mit dieser Instanz 2,5 Sekunden, bevor sie abbrechen\ninstance.defaults.timeout = 2500;\n\n// Überschreibe den Timeout für diese Anfrage, da bekannt ist, dass sie lange dauert\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nDu kannst Anfragen oder Antworten abfangen, bevor sie von `then` oder `catch` verarbeitet werden.\n\n```js\n\nconst instance = axios.create();\n\n// Füge einen Anfrage-Interceptor hinzu\ninstance.interceptors.request.use(function (config) {\n    // Vor dem Senden der Anfrage etwas tun\n    return config;\n  }, function (error) {\n    // Etwas mit dem Anfragefehler tun\n    return Promise.reject(error);\n  });\n\n// Füge einen Antwort-Interceptor hinzu\ninstance.interceptors.response.use(function (response) {\n    // Jeder Statuscode im Bereich von 2xx löst diese Funktion aus\n    // Etwas mit den Antwortdaten tun\n    return response;\n  }, function (error) {\n    // Jeder Statuscode außerhalb des Bereichs von 2xx löst diese Funktion aus\n    // Etwas mit dem Antwortfehler tun\n    return Promise.reject(error);\n  });\n```\n\nFalls du später einen Interceptor entfernen musst, ist das möglich.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nDu kannst auch alle Interceptors für Anfragen oder Antworten löschen.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Entfernt Interceptors von Anfragen\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Entfernt Interceptors von Antworten\n```\n\nDu kannst Interceptors auch einer benutzerdefinierten Instanz von axios hinzufügen.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWenn du Anfrage-Interceptors hinzufügst, werden sie standardmäßig als asynchron betrachtet. Dies kann eine Verzögerung\nbei der Ausführung deiner axios-Anfrage verursachen, wenn der Hauptthread blockiert ist (unter der Haube wird ein Promise für\nden Interceptor erstellt und deine Anfrage wird ans Ende des Call Stacks gesetzt). Falls deine Anfrage-Interceptors synchron sind, kannst du eine Option\nim Optionsobjekt setzen, die axios anweist, den Code synchron auszuführen, um Verzögerungen bei der Anfrageausführung zu vermeiden.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'Ich bin nur ein Header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nWenn du einen bestimmten Interceptor basierend auf einer Laufzeitprüfung ausführen möchtest,\nkannst du eine `runWhen`-Funktion zum Optionsobjekt hinzufügen. Der Anfrage-Interceptor wird **nur dann nicht ausgeführt**, wenn der Rückgabewert\nvon `runWhen` `false` ist. Die Funktion wird mit dem Config-Objekt aufgerufen\n(denk daran, dass du auch eigene Argumente binden kannst). Das ist praktisch, wenn du einen\nasynchronen Anfrage-Interceptor hast, der nur zu bestimmten Zeiten ausgeführt werden muss.\n```",
  "status": "ok"
}