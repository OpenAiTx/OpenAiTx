{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Örnek oluşturulurken yapılandırma varsayılanlarını ayarla\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Örnek oluşturulduktan sonra varsayılanları değiştir\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Yapılandırma öncelik sırası\n\nYapılandırma, bir öncelik sırasına göre birleştirilecektir. Sıra, [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49) dosyasında bulunan kütüphane varsayılanları, ardından örneğin `defaults` özelliği ve son olarak isteğin `config` argümanıdır. Sonuncusu, öncekine göre önceliklidir. İşte bir örnek.\n\n```js\n// Kütüphane tarafından sağlanan yapılandırma varsayılanlarını kullanarak bir örnek oluştur\n// Bu noktada, timeout yapılandırma değeri `0`'dır; bu, kütüphane için varsayılandır\nconst instance = axios.create();\n\n// Kütüphane için timeout varsayılanını geçersiz kıl\n// Artık bu örneği kullanan tüm istekler zaman aşımına uğramadan önce 2,5 saniye bekleyecek\ninstance.defaults.timeout = 2500;\n\n// Bu isteğin uzun süreceği bilindiği için timeout'u geçersiz kıl\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Yakalayıcılar (Interceptors)\n\nİstekleri veya yanıtları, `then` veya `catch` tarafından işlenmeden önce yakalayabilirsiniz.\n\n```js\n\nconst instance = axios.create();\n\n// Bir istek yakalayıcı ekle\ninstance.interceptors.request.use(function (config) {\n    // İstek gönderilmeden önce bir şeyler yap\n    return config;\n  }, function (error) {\n    // İstek hatası ile bir şeyler yap\n    return Promise.reject(error);\n  });\n\n// Bir yanıt yakalayıcı ekle\ninstance.interceptors.response.use(function (response) {\n    // 2xx aralığındaki herhangi bir durum kodu bu fonksiyonun tetiklenmesine neden olur\n    // Yanıt verisi ile bir şeyler yap\n    return response;\n  }, function (error) {\n    // 2xx aralığı dışında kalan herhangi bir durum kodu bu fonksiyonun tetiklenmesine neden olur\n    // Yanıt hatası ile bir şeyler yap\n    return Promise.reject(error);\n  });\n```\n\nDaha sonra bir yakalayıcıyı kaldırmanız gerekirse bunu yapabilirsiniz.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nİstekler veya yanıtlar için tüm yakalayıcıları da temizleyebilirsiniz.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // İsteklerden yakalayıcıları kaldırır\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Yanıtlardan yakalayıcıları kaldırır\n```\n\nAxios'un özel bir örneğine de yakalayıcı ekleyebilirsiniz.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nİstek yakalayıcıları eklediğinizde, bunların varsayılan olarak eşzamansız olduğu varsayılır. Bu, ana iş parçacığı bloke olduğunda axios isteğinizin yürütülmesinde gecikmeye neden olabilir\n(yakalayıcı için arka planda bir promise oluşturulur ve isteğiniz çağrı yığınının en altına yerleştirilir). Eğer istek yakalayıcılarınız eşzamanlı ise,\naxios'a kodu eşzamanlı olarak çalıştırmasını ve istek yürütmesinde herhangi bir gecikmeyi önlemesini söyleyen bir bayrak ekleyebilirsiniz.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'Sadece bir başlıktayım!';\n  return config;\n}, null, { synchronous: true });\n```\n\nBelirli bir yakalayıcıyı çalışma zamanında yapılan bir kontrole göre çalıştırmak isterseniz,\nseçenekler nesnesine bir `runWhen` fonksiyonu ekleyebilirsiniz. Yalnızca ve yalnızca `runWhen`'in dönüşü `false` ise istek yakalayıcı çalıştırılmaz.\nFonksiyon, config nesnesiyle çağrılacaktır (kendi argümanlarınızı da ona bağlayabileceğinizi unutmayın). Bu, yalnızca belirli zamanlarda çalışması gereken\neşzamansız bir istek yakalayıcınız olduğunda kullanışlı olabilir.\n```",
  "status": "ok"
}