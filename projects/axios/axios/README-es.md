<h3 align="center"> 🥇 Patrocinadores de oro <br> </h3> <table align="center" width="100%"><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="38px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/stytch_white.png"> <img width="200px" height="38px" src="https://axios-http.com/assets/sponsors/stytch.png" alt="Stytch"/> </picture> </a> <p align="center" title="API-first authentication, authorization, and fraud prevention">Autenticación, autorización y prevención de fraude API-first</p> <p align="center"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http"><b>Sitio web</b></a> | <a href="https://stytch.com/docs?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;docs-link&amp;utm_campaign&#x3D;axios-http"><b>Documentación</b></a> | <a href="https://github.com/stytchauth/stytch-node?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;node-sdk&amp;utm_campaign&#x3D;axios-http"><b>Node.js</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="133px" height="43px" src="https://axios-http.com/assets/sponsors/principal.svg" alt="Principal Financial Group"/> </a> <p align="center" title="We’re bound by one common purpose: to give you the financial tools, resources and information you need to live your best life.">Estamos unidos por un propósito común: brindarte las herramientas financieras, recursos e información que necesitas para vivir tu mejor vida.</p> <p align="center"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.principal.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="85px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buy-instagram-followers-twicsy.png" alt="Buy Instagram Followers Twicsy"/> </a> <p align="center" title="Buy real Instagram followers from Twicsy starting at only $2.97. Twicsy has been voted the best site to buy followers from the likes of US Magazine.">Compra seguidores reales de Instagram en Twicsy desde solo $2.97. Twicsy ha sido votado como el mejor sitio para comprar seguidores, según US Magazine.</p> <p align="center"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>twicsy.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="52px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/descope_white.png"> <img width="200px" height="52px" src="https://axios-http.com/assets/sponsors/descope.png" alt="Descope"/> </picture> </a> <p align="center" title="Hi, we&#x27;re Descope! We are building something in the authentication space for app developers and can’t wait to place it in your hands.">¡Hola, somos Descope! Estamos desarrollando algo en el área de autenticación para desarrolladores de aplicaciones y estamos ansiosos por ponerlo en tus manos.</p> <p align="center"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>Sitio web</b></a> | <a href="https://docs.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>Docs</b></a> | <a href="https://www.descope.com/community?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>Comunidad</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="62px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buzzoid-buy-instagram-followers.png" alt="Buzzoid - Buy Instagram Followers"/> </a> <p align="center" title="At Buzzoid, you can buy Instagram followers quickly, safely, and easily with just a few clicks. Rated world&#x27;s #1 IG service since 2012.">En Buzzoid, puedes comprar seguidores de Instagram de manera rápida, segura y sencilla con solo unos clics. Calificado como el servicio de IG n.º 1 del mundo desde 2012.</p> <p align="center"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>buzzoid.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/famety-buy-instagram-followers.png" alt="Famety - Buy Instagram Followers"/> </a> <p align="center" title="At Famety, you can grow your social media following quickly, safely, and easily with just a few clicks. Rated the world’s #1 social media service since 2013.">En Famety, puedes hacer crecer tus seguidores en redes sociales de forma rápida, segura y sencilla con solo unos clics. Calificado como el servicio de redes sociales n.º 1 del mundo desde 2013.</p> <p align="center"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.famety.net</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/instagram-likes.png" alt="Poprey - Buy Instagram Likes"/> </a> <p align="center" title="Buy Instagram Likes">Compra Me gusta en Instagram</p> <p align="center"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>poprey.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/youtube-subscribers-ssmarket.png" alt="Buy Youtube Subscribers"/> </a> <p align="center" title="SS Market offers professional social media services that rapidly increase your YouTube subscriber count, elevating your channel to a powerful position.">SS Market ofrece servicios profesionales de redes sociales que aumentan rápidamente la cantidad de suscriptores de tu canal de YouTube, llevando tu canal a una posición poderosa.</p> <p align="center"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>ssmarket.net</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="200px" height="56px" src="https://axios-http.com/assets/sponsors/opencollective/smmpanelserver123.png" alt="smmpanelserver"/> </a> <p align="center" title="smmpanelserver - Best and Cheapest Smm Panel">smmpanelserver - El mejor y más barato panel SMM</p> <p align="center"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>smmpanelserver.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 Conviértete en patrocinador</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 Conviértete en patrocinador</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 Conviértete en patrocinador</a>
</td></tr></table>

<!--<div>marker</div>-->
<br><br>
<div align="center">
   <a href="https://axios-http.com"><img src="https://axios-http.com/assets/logo.svg" /></a><br>
</div>

<p align="center">Cliente HTTP basado en Promesas para el navegador y node.js</p>

<p align="center">
    <a href="https://axios-http.com/"><b>Sitio web</b></a> •
    <a href="https://axios-http.com/docs/intro"><b>Documentación</b></a>
</p>

<div align="center">

[![npm version](https://img.shields.io/npm/v/axios.svg?style=flat-square)](https://www.npmjs.org/package/axios)
[![CDNJS](https://img.shields.io/cdnjs/v/axios.svg?style=flat-square)](https://cdnjs.com/libraries/axios)
[![Build status](https://img.shields.io/github/actions/workflow/status/axios/axios/ci.yml?branch=v1.x&label=CI&logo=github&style=flat-square)](https://github.com/axios/axios/actions/workflows/ci.yml)
[![Gitpod Ready-to-Code](https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod&style=flat-square)](https://gitpod.io/#https://github.com/axios/axios)
[![code coverage](https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square)](https://coveralls.io/r/mzabriskie/axios)
[![install size](https://img.shields.io/badge/dynamic/json?url=https://packagephobia.com/v2/api.json?p=axios&query=$.install.pretty&label=install%20size&style=flat-square)](https://packagephobia.now.sh/result?p=axios)
[![npm bundle size](https://img.shields.io/bundlephobia/minzip/axios?style=flat-square)](https://bundlephobia.com/package/axios@latest)
[![npm downloads](https://img.shields.io/npm/dm/axios.svg?style=flat-square)](https://npm-stat.com/charts.html?package=axios)
[![gitter chat](https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square)](https://gitter.im/mzabriskie/axios)
[![code helpers](https://www.codetriage.com/axios/axios/badges/users.svg)](https://www.codetriage.com/axios/axios)
[![Known Vulnerabilities](https://snyk.io/test/npm/axios/badge.svg)](https://snyk.io/test/npm/axios)




</div>

## Tabla de Contenidos

  - [Características](#features)
  - [Compatibilidad con Navegadores](#browser-support)
  - [Instalación](#installing)
    - [Gestor de paquetes](#package-manager)
    - [CDN](#cdn)
  - [Ejemplo](#example)
  - [API de Axios](#axios-api)
  - [Alias de métodos de solicitud](#request-method-aliases)
  - [Concurrencia 👎](#concurrency-deprecated)
  - [Creando una instancia](#creating-an-instance)
  - [Métodos de instancia](#instance-methods)
  - [Configuración de la solicitud](#request-config)
  - [Esquema de respuesta](#response-schema)
  - [Valores predeterminados de configuración](#config-defaults)
    - [Valores predeterminados globales de axios](#global-axios-defaults)
    - [Valores predeterminados de instancia personalizada](#custom-instance-defaults)
    - [Orden de precedencia de la configuración](#config-order-of-precedence)
  - [Interceptors](#interceptors)
    - [Múltiples interceptores](#multiple-interceptors)
  - [Manejo de errores](#handling-errors)
  - [Cancelación](#cancellation)
    - [AbortController](#abortcontroller)
    - [CancelToken 👎](#canceltoken-deprecated)
  - [Uso del formato application/x-www-form-urlencoded](#using-applicationx-www-form-urlencoded-format)
    - [URLSearchParams](#urlsearchparams)
    - [Cadena de consulta](#query-string-older-browsers)
    - [🆕 Serialización automática](#-automatic-serialization-to-urlsearchparams)
  - [Uso del formato multipart/form-data](#using-multipartform-data-format)
    - [FormData](#formdata)
    - [🆕 Serialización automática](#-automatic-serialization-to-formdata)
  - [Envío de archivos](#files-posting)
  - [Envío de formularios HTML](#-html-form-posting-browser)
  - [🆕 Captura de progreso](#-progress-capturing)
  - [🆕 Limitación de tasa](#-progress-capturing)
  - [🆕 AxiosHeaders](#-axiosheaders)
  - [🔥 Adaptador Fetch](#-fetch-adapter)
  - [Semver](#semver)
  - [Promesas](#promises)
  - [TypeScript](#typescript)
  - [Recursos](#resources)
  - [Créditos](#credits)
  - [Licencia](#license)

## Características

- Realiza [XMLHttpRequests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) desde el navegador
- Realiza solicitudes [http](https://nodejs.org/api/http.html) desde node.js
- Soporta la API de [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- Intercepta la solicitud y la respuesta
- Transforma los datos de solicitud y respuesta
- Cancela solicitudes
- Transformaciones automáticas para datos [JSON](https://www.json.org/json-en.html)
- 🆕 Serialización automática de objetos de datos a las codificaciones de cuerpo `multipart/form-data` y `x-www-form-urlencoded`
- Soporte del lado del cliente para proteger contra [XSRF](https://es.wikipedia.org/wiki/Cross-site_request_forgery)

## Compatibilidad con navegadores

![Chrome](https://raw.githubusercontent.com/alrra/browser-logos/main/src/chrome/chrome_48x48.png) | ![Firefox](https://raw.githubusercontent.com/alrra/browser-logos/main/src/firefox/firefox_48x48.png) | ![Safari](https://raw.githubusercontent.com/alrra/browser-logos/main/src/safari/safari_48x48.png) | ![Opera](https://raw.githubusercontent.com/alrra/browser-logos/main/src/opera/opera_48x48.png) | ![Edge](https://raw.githubusercontent.com/alrra/browser-logos/main/src/edge/edge_48x48.png) |
--- | --- | --- | --- | --- |
Última ✔ | Última ✔ | Última ✔ | Última ✔ | Última ✔ | 11 ✔ |

[![Browser Matrix](https://saucelabs.com/open_sauce/build_matrix/axios.svg)](https://saucelabs.com/u/axios)

## Instalación

### Gestor de paquetes

Usando npm:

```bash
$ npm install axios
```

Usando bower:

```bash
$ bower install axios
```

Usando yarn:

```bash
$ yarn add axios
```

Usando pnpm:

```bash
$ pnpm add axios
```

Usando bun:

```bash
$ bun add axios
```

Una vez instalado el paquete, puedes importar la librería usando el enfoque `import` o `require`:

```js
import axios, {isCancel, AxiosError} from 'axios';
```

También puedes usar la exportación por defecto, ya que la exportación nombrada es solo una re-exportación desde la fábrica de Axios:

```js
import axios from 'axios';

console.log(axios.isCancel('something'));
```

Si usas `require` para importar, **solo está disponible la exportación por defecto**:

```js
const axios = require('axios');

console.log(axios.isCancel('something'));
```

Para algunos empaquetadores y algunos linters ES6 puede que necesites hacer lo siguiente:

```js
import { default as axios } from 'axios';
```

Para los casos en los que algo salió mal al intentar importar un módulo en un entorno personalizado o heredado,
puedes intentar importar el paquete del módulo directamente:

```js
const axios = require('axios/dist/browser/axios.cjs'); // bundle commonJS para navegador (ES2017)
// const axios = require('axios/dist/node/axios.cjs'); // bundle commonJS para node (ES2017)
```

### CDN

Usando jsDelivr CDN (módulo UMD ES5 para navegador):

```html
<script src="https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js"></script>
```

Usando unpkg CDN:

```html
<script src="https://unpkg.com/axios@1.6.7/dist/axios.min.js"></script>
```

## Ejemplo

> **Nota**: Uso de CommonJS  
> Para obtener las tipificaciones de TypeScript (para intellisense / autocompletado) mientras usas importaciones CommonJS con `require()`, usa el siguiente enfoque:
```js
import axios from 'axios';
//const axios = require('axios'); // forma heredada

// Realizar una solicitud para un usuario con un ID dado
axios.get('/user?ID=12345')
  .then(function (response) {
    // manejar éxito
    console.log(response);
  })
  .catch(function (error) {
    // manejar error
    console.log(error);
  })
  .finally(function () {
    // siempre se ejecuta
  });

// Opcionalmente, la solicitud anterior también se puede realizar como
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .finally(function () {
    // siempre se ejecuta
  });

// ¿Quieres usar async/await? Añade la palabra clave `async` a tu función/método externo.
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
```

> **Nota**: `async/await` es parte de ECMAScript 2017 y no es compatible con Internet
> Explorer y navegadores antiguos, así que úsalo con precaución.

Realizando una solicitud `POST`

```js
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

Realizando múltiples solicitudes concurrentes

```js
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

Promise.all([getUserAccount(), getUserPermissions()])
  .then(function (results) {
    const acct = results[0];
    const perm = results[1];
  });
```

## API de axios

Las solicitudes se pueden realizar pasando la configuración relevante a `axios`.

##### axios(config)

```js
// Enviar una solicitud POST
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});
```

```js
// Solicitud GET para imagen remota en node.js
axios({
  method: 'get',
  url: 'https://bit.ly/2mTM3nY',
  responseType: 'stream'
})
  .then(function (response) {
    response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))
  });
```

##### axios(url[, config])

```js
// Enviar una solicitud GET (método predeterminado)
axios('/user/12345');
```

### Alias de métodos de solicitud

Para mayor comodidad, se han proporcionado alias para todos los métodos de solicitud comunes.

##### axios.request(config)
##### axios.get(url[, config])
##### axios.delete(url[, config])
##### axios.head(url[, config])
##### axios.options(url[, config])
##### axios.post(url[, data[, config]])
##### axios.put(url[, data[, config]])
##### axios.patch(url[, data[, config]])

###### NOTA
Al utilizar los métodos alias, no es necesario especificar las propiedades `url`, `method` y `data` en la configuración.

### Concurrencia (Obsoleto)
Por favor, use `Promise.all` para reemplazar las funciones siguientes.

Funciones auxiliares para manejar solicitudes concurrentes.

axios.all(iterable)
axios.spread(callback)

### Creando una instancia

Puede crear una nueva instancia de axios con una configuración personalizada.

##### axios.create([config])

```js
const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});
```

### Métodos de instancia

Los métodos de instancia disponibles se enumeran a continuación. La configuración especificada se fusionará con la configuración de la instancia.

##### axios#request(config)
##### axios#get(url[, config])
##### axios#delete(url[, config])
##### axios#head(url[, config])
##### axios#options(url[, config])
##### axios#post(url[, data[, config]])
##### axios#put(url[, data[, config]])
##### axios#patch(url[, data[, config]])
##### axios#getUri([config])

## Configuración de la Solicitud

Estas son las opciones de configuración disponibles para realizar solicitudes. Solo la `url` es obligatoria. Las solicitudes serán `GET` por defecto si no se especifica el `method`.

```js
{
  // `url` es la URL del servidor que se usará para la solicitud
  url: '/user',

  // `method` es el método de solicitud que se utilizará al realizar la solicitud
  method: 'get', // predeterminado

  // `baseURL` se antepondrá a `url` a menos que `url` sea absoluta y la opción `allowAbsoluteUrls` esté configurada en true.
  // Puede ser conveniente establecer `baseURL` para una instancia de axios para pasar URLs relativas
  // a los métodos de esa instancia.
  baseURL: 'https://some-domain.com/api/',

  // `allowAbsoluteUrls` determina si las URLs absolutas sobrescribirán un `baseUrl` configurado o no.
  // Cuando está en true (predeterminado), los valores absolutos para `url` sobrescribirán `baseUrl`.
  // Cuando está en false, los valores absolutos para `url` siempre serán precedidos por `baseUrl`.
  allowAbsoluteUrls: true,

  // `transformRequest` permite realizar cambios en los datos de la solicitud antes de enviarlos al servidor
  // Esto solo es aplicable para los métodos de solicitud 'PUT', 'POST', 'PATCH' y 'DELETE'
  // La última función en el array debe devolver una cadena o una instancia de Buffer, ArrayBuffer,
  // FormData o Stream
  // Puede modificar el objeto headers.
  transformRequest: [function (data, headers) {
    // Haga lo que desee para transformar los datos
```
```markdown
    return data;
  }],

  // `transformResponse` permite realizar cambios en los datos de respuesta antes
  // de que se pasen a then/catch
  transformResponse: [function (data) {
    // Haz lo que quieras para transformar los datos

    return data;
  }],

  // `headers` son encabezados personalizados que se enviarán
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // `params` son los parámetros de URL que se enviarán con la solicitud
  // Debe ser un objeto simple o un objeto URLSearchParams
  params: {
    ID: 12345
  },
  
  // `paramsSerializer` es una configuración opcional que permite personalizar la serialización de `params`. 
  paramsSerializer: {

    // Función codificadora personalizada que envía los pares clave/valor de forma iterativa.
    encode?: (param: string): string => { /* Realiza operaciones personalizadas aquí y retorna la cadena transformada */ }, 
    
    // Función de serialización personalizada para todo el parámetro. Permite al usuario imitar el comportamiento previo a la versión 1.x.
    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ), 
    
    // Configuración para el formato de los índices de los arreglos en los params. 
    indexes: false // Tres opciones disponibles: (1) indexes: null (no pone corchetes), (2) (predeterminado) indexes: false (corchetes vacíos), (3) indexes: true (corchetes con índices).    
  },

  // `data` son los datos que se enviarán como cuerpo de la solicitud
  // Solo aplicable para los métodos de solicitud 'PUT', 'POST', 'DELETE' y 'PATCH'
  // Cuando no se define `transformRequest`, debe ser de uno de los siguientes tipos:
  // - string, objeto simple, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - Solo navegador: FormData, File, Blob
  // - Solo Node: Stream, Buffer, FormData (paquete form-data)
  data: {
    firstName: 'Fred'
  },

  // sintaxis alternativa para enviar datos en el cuerpo
  // método post
  // solo se envía el valor, no la clave
  data: 'Country=Brasil&City=Belo Horizonte',

  // `timeout` especifica el número de milisegundos antes de que la solicitud agote el tiempo de espera.
  // Si la solicitud tarda más que `timeout`, la solicitud será abortada.
  timeout: 1000, // el valor predeterminado es `0` (sin límite de tiempo)

  // `withCredentials` indica si las solicitudes cross-site Access-Control
  // deben realizarse usando credenciales
  withCredentials: false, // predeterminado

  // `adapter` permite el manejo personalizado de las solicitudes, lo que facilita las pruebas.
  // Retorna una promesa y proporciona una respuesta válida (ver lib/adapters/README.md)
  adapter: function (config) {
    /* ... */
  },
  // Además, puedes establecer el nombre del adaptador incorporado, o proporcionar un arreglo con sus nombres
  // para elegir el primero disponible en el entorno
  adapter: 'xhr', // 'fetch' | 'http' | ['xhr', 'http', 'fetch']

  // `auth` indica que se debe usar autenticación básica HTTP y proporciona credenciales.
  // Esto establecerá un encabezado `Authorization`, sobrescribiendo cualquier encabezado
  // `Authorization` personalizado que hayas establecido usando `headers`.
  // Ten en cuenta que solo la autenticación básica HTTP es configurable a través de este parámetro.
  // Para tokens Bearer y similares, utiliza encabezados personalizados `Authorization` en su lugar.
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

  // `responseType` indica el tipo de datos que responderá el servidor
  // las opciones son: 'arraybuffer', 'document', 'json', 'text', 'stream'
  //   solo navegador: 'blob'
  responseType: 'json', // predeterminado

  // `responseEncoding` indica la codificación a usar para decodificar respuestas (solo Node.js)
  // Nota: Se ignora para `responseType` de 'stream' o solicitudes del lado del cliente
  // las opciones son: 'ascii', 'ASCII', 'ansi', 'ANSI', 'binary', 'BINARY', 'base64', 'BASE64', 'base64url',
  // 'BASE64URL', 'hex', 'HEX', 'latin1', 'LATIN1', 'ucs-2', 'UCS-2', 'ucs2', 'UCS2', 'utf-8', 'UTF-8',
  // 'utf8', 'UTF8', 'utf16le', 'UTF16LE'
  responseEncoding: 'utf8', // predeterminado

  // `xsrfCookieName` es el nombre de la cookie que se usará como valor para el token xsrf
  xsrfCookieName: 'XSRF-TOKEN', // predeterminado

  // `xsrfHeaderName` es el nombre del encabezado http que transporta el valor del token xsrf
  xsrfHeaderName: 'X-XSRF-TOKEN', // predeterminado
    
  // `undefined` (predeterminado) - establece el encabezado XSRF solo para solicitudes del mismo origen
  withXSRFToken: boolean | undefined | ((config: InternalAxiosRequestConfig) => boolean | undefined),

  // `onUploadProgress` permite manejar eventos de progreso para cargas
  // navegador y node.js
  onUploadProgress: function ({loaded, total, progress, bytes, estimated, rate, upload = true}) {
```
```markdown
    // Haz lo que quieras con el evento de progreso de Axios
  },

  // `onDownloadProgress` permite manejar eventos de progreso para descargas
  // navegador y node.js
  onDownloadProgress: function ({loaded, total, progress, bytes, estimated, rate, download = true}) {
    // Haz lo que quieras con el evento de progreso de Axios
  },

  // `maxContentLength` define el tamaño máximo permitido del contenido de la respuesta http en bytes en node.js
  maxContentLength: 2000,

  // `maxBodyLength` (opción solo para Node) define el tamaño máximo permitido del contenido de la solicitud http en bytes
  maxBodyLength: 2000,

  // `validateStatus` define si se debe resolver o rechazar la promesa para un
  // código de estado HTTP dado. Si `validateStatus` retorna `true` (o se establece en `null`
  // o `undefined`), la promesa se resolverá; de lo contrario, la promesa será
  // rechazada.
  validateStatus: function (status) {
    return status >= 200 && status < 300; // valor por defecto
  },

  // `maxRedirects` define el número máximo de redirecciones a seguir en node.js.
  // Si se establece en 0, no se seguirán redirecciones.
  maxRedirects: 21, // valor por defecto

  // `beforeRedirect` define una función que se llamará antes de la redirección.
  // Usa esto para ajustar las opciones de la solicitud al redirigir,
  // para inspeccionar las cabeceras de la respuesta más reciente,
  // o para cancelar la solicitud lanzando un error.
  // Si maxRedirects se establece en 0, `beforeRedirect` no se utiliza.
  beforeRedirect: (options, { headers }) => {
    if (options.hostname === "example.com") {
      options.auth = "user:password";
    }
  },

  // `socketPath` define un Socket UNIX que se usará en node.js.
  // p. ej., '/var/run/docker.sock' para enviar solicitudes al daemon de docker.
  // Solo se puede especificar `socketPath` o `proxy`.
  // Si ambos se especifican, se usa `socketPath`.
  socketPath: null, // valor por defecto
  
  // `transport` determina el método de transporte que se usará para realizar la solicitud.
  // Si se define, se usará. De lo contrario, si `maxRedirects` es 0,
  // se usará la biblioteca predeterminada `http` o `https`, dependiendo del protocolo especificado en `protocol`.
  // De lo contrario, se usará la biblioteca `httpFollow` o `httpsFollow`, nuevamente dependiendo del protocolo,
  // que puede manejar redirecciones.
  transport: undefined, // valor por defecto

  // `httpAgent` y `httpsAgent` definen un agente personalizado que se usará al realizar solicitudes http
  // y https, respectivamente, en node.js. Esto permite agregar opciones como
  // `keepAlive` que no están habilitadas por defecto antes de Node.js v19.0.0. Después de Node.js
  // v19.0.0, ya no es necesario personalizar el agente para habilitar `keepAlive` porque
  // `http.globalAgent` tiene `keepAlive` habilitado por defecto.
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),

  // `proxy` define el nombre de host, el puerto y el protocolo del servidor proxy.
  // También puedes definir tu proxy usando las variables de entorno convencionales `http_proxy` y
  // `https_proxy`. Si usas variables de entorno
  // para la configuración del proxy, también puedes definir una variable de entorno `no_proxy`
  // como una lista de dominios separados por comas que no deben ser proxificados.
  // Usa `false` para desactivar los proxies, ignorando las variables de entorno.
  // `auth` indica que se debe usar autenticación HTTP Basic para conectarse al proxy y
  // proporciona credenciales.
  // Esto establecerá una cabecera `Proxy-Authorization`, sobrescribiendo cualquier
  // cabecera personalizada `Proxy-Authorization` que hayas definido usando `headers`.
  // Si el servidor proxy utiliza HTTPS, entonces debes establecer el protocolo a `https`.
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    // hostname: '127.0.0.1' // Tiene prioridad sobre 'host' si ambos se definen
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  // `cancelToken` especifica un token de cancelación que se puede usar para cancelar la solicitud
  // (ver la sección de Cancelación más abajo para más detalles)
  cancelToken: new CancelToken(function (cancel) {
  }),

  // una forma alternativa de cancelar solicitudes Axios usando AbortController
  signal: new AbortController().signal,

  // `decompress` indica si el cuerpo de la respuesta debe ser descomprimido
  // automáticamente. Si se establece en `true` también eliminará la cabecera 'content-encoding'
  // de los objetos de respuesta de todas las respuestas descomprimidas
  // - Solo para Node (XHR no puede desactivar la descompresión)
  decompress: true, // valor por defecto

  // `insecureHTTPParser` booleano.
  // Indica si se debe usar un analizador HTTP inseguro que acepte cabeceras HTTP inválidas.
  // Esto puede permitir la interoperabilidad con implementaciones HTTP no conformes.
  // El uso del analizador inseguro debe evitarse.
  // ver opciones https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback
```
```js
  // ver también https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none
  insecureHTTPParser: undefined, // valor por defecto

  // opciones transicionales para compatibilidad hacia atrás que pueden ser eliminadas en versiones futuras
  transitional: {
    // modo silencioso de análisis JSON
    // `true`  - ignora los errores de análisis JSON y establece response.data en null si el análisis falla (comportamiento anterior)
    // `false` - lanza SyntaxError si el análisis JSON falla (Nota: responseType debe ser 'json')
    silentJSONParsing: true, // valor por defecto para la versión actual de Axios

    // intenta analizar la cadena de respuesta como JSON incluso si `responseType` no es 'json'
    forcedJSONParsing: true,

    // lanza un error ETIMEDOUT en lugar de ECONNABORTED genérico en caso de tiempo de espera de la solicitud
    clarifyTimeoutError: false,
  },

  env: {
    // La clase FormData que se utilizará para serializar automáticamente el payload en un objeto FormData
    FormData: window?.FormData || global?.FormData
  },

  formSerializer: {
      visitor: (value, key, path, helpers) => {}, // función visitor personalizada para serializar valores de formulario
      dots: boolean, // usar puntos en vez del formato de corchetes
      metaTokens: boolean, // mantener terminaciones especiales como {} en la clave del parámetro
      indexes: boolean, // formato de índices de arrays: null - sin corchetes, false - corchetes vacíos, true - corchetes con índices
  },

  // solo para adaptador http (node.js)
  maxRate: [
    100 * 1024, // límite de subida de 100KB/s,
    100 * 1024  // límite de descarga de 100KB/s
  ]
}
```

## Esquema de la Respuesta

La respuesta de una solicitud contiene la siguiente información.

```js
{
  // `data` es la respuesta proporcionada por el servidor
  data: {},

  // `status` es el código de estado HTTP de la respuesta del servidor
  status: 200,

  // `statusText` es el mensaje de estado HTTP de la respuesta del servidor
  statusText: 'OK',

  // `headers` son los encabezados HTTP con los que respondió el servidor
  // Todos los nombres de encabezado están en minúsculas y se pueden acceder usando la notación de corchetes.
  // Ejemplo: `response.headers['content-type']`
  headers: {},

  // `config` es la configuración que se proporcionó a `axios` para la solicitud
  config: {},

  // `request` es la solicitud que generó esta respuesta
  // Es la última instancia de ClientRequest en node.js (en redirecciones)
  // y una instancia de XMLHttpRequest en el navegador
  request: {}
}
```

Al usar `then`, recibirás la respuesta de la siguiente manera:

```js
axios.get('/user/12345')
  .then(function (response) {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });
```

Al usar `catch`, o pasando un [callback de rechazo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) como segundo parámetro de `then`, la respuesta estará disponible a través del objeto `error` como se explica en la sección [Manejo de Errores](#handling-errors).

## Valores por Defecto de Configuración

Puedes especificar valores por defecto de configuración que se aplicarán a cada solicitud.

### Valores por defecto globales de axios

```js
axios.defaults.baseURL = 'https://api.example.com';

// Importante: Si axios se usa con múltiples dominios, el AUTH_TOKEN será enviado a todos ellos.
// Ver más abajo un ejemplo usando valores por defecto de instancia personalizada.
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;

axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
```

### Valores por defecto de instancia personalizada
```
```js
// Establecer valores predeterminados de configuración al crear la instancia
const instance = axios.create({
  baseURL: 'https://api.example.com'
});

// Modificar los valores predeterminados después de que se haya creado la instancia
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;
```

### Orden de precedencia de la configuración

La configuración se fusionará con un orden de precedencia. El orden es: los valores predeterminados de la biblioteca que se encuentran en [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), luego la propiedad `defaults` de la instancia, y finalmente el argumento `config` de la solicitud. Este último tendrá precedencia sobre el anterior. Aquí tienes un ejemplo.

```js
// Crear una instancia usando los valores predeterminados de configuración proporcionados por la biblioteca
// En este punto, el valor de configuración timeout es `0` como es el valor predeterminado de la biblioteca
const instance = axios.create();

// Sobrescribir el valor predeterminado de timeout de la biblioteca
// Ahora todas las solicitudes que usen esta instancia esperarán 2.5 segundos antes de agotar el tiempo de espera
instance.defaults.timeout = 2500;

// Sobrescribir el timeout para esta solicitud ya que se sabe que tomará mucho tiempo
instance.get('/longRequest', {
  timeout: 5000
});
```

## Interceptores

Puedes interceptar solicitudes o respuestas antes de que sean manejadas por `then` o `catch`.

```js

const instance = axios.create();

// Agregar un interceptor de solicitud
instance.interceptors.request.use(function (config) {
    // Hacer algo antes de que se envíe la solicitud
    return config;
  }, function (error) {
    // Hacer algo con el error de la solicitud
    return Promise.reject(error);
  });

// Agregar un interceptor de respuesta
instance.interceptors.response.use(function (response) {
    // Cualquier código de estado dentro del rango 2xx hace que esta función se dispare
    // Hacer algo con los datos de la respuesta
    return response;
  }, function (error) {
    // Cualquier código de estado fuera del rango 2xx hace que esta función se dispare
    // Hacer algo con el error de la respuesta
    return Promise.reject(error);
  });
```

Si necesitas eliminar un interceptor más tarde, puedes hacerlo.

```js
const instance = axios.create();
const myInterceptor = instance.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

También puedes eliminar todos los interceptores de solicitudes o respuestas.
```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
instance.interceptors.request.clear(); // Elimina los interceptores de solicitudes
instance.interceptors.response.use(function () {/*...*/});
instance.interceptors.response.clear(); // Elimina los interceptores de respuestas
```

Puedes agregar interceptores a una instancia personalizada de axios.

```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
```

Cuando agregas interceptores de solicitud, se presume que son asíncronos por defecto. Esto puede causar un retraso
en la ejecución de tu solicitud axios cuando el hilo principal está bloqueado (se crea una promesa internamente para
el interceptor y tu solicitud se coloca al final de la pila de llamadas). Si tus interceptores de solicitud son síncronos, puedes agregar una bandera
al objeto de opciones que le indicará a axios que ejecute el código de manera síncrona y evite cualquier retraso en la ejecución de la solicitud.

```js
axios.interceptors.request.use(function (config) {
  config.headers.test = '¡Solo soy un encabezado!';
  return config;
}, null, { synchronous: true });
```

Si quieres ejecutar un interceptor en particular basándote en una comprobación en tiempo de ejecución,
puedes agregar una función `runWhen` al objeto de opciones. El interceptor de solicitud **no se ejecutará si y solo si** el retorno
de `runWhen` es `false`. La función será llamada con el objeto de configuración
(no olvides que también puedes enlazar tus propios argumentos a ella). Esto puede ser útil cuando tienes un
interceptor de solicitud asíncrono que solo necesita ejecutarse en ciertos momentos.
```
```js
function onGetCall(config) {
  return config.method === 'get';
}
axios.interceptors.request.use(function (config) {
  config.headers.test = 'special get headers';
  return config;
}, null, { runWhen: onGetCall });
```

> **Nota:** El parámetro options (que contiene las propiedades `synchronous` y `runWhen`) solo es compatible actualmente con los interceptores de solicitud.

### Interceptores Múltiples

Dado que agregas múltiples interceptores de respuesta
y cuando la respuesta se cumple
- entonces se ejecuta cada interceptor
- entonces se ejecutan en el orden en que fueron añadidos
- entonces solo se retorna el resultado del último interceptor
- entonces cada interceptor recibe el resultado de su predecesor
- y cuando el interceptor de cumplimiento arroja una excepción
    - entonces el siguiente interceptor de cumplimiento no es llamado
    - entonces el siguiente interceptor de rechazo es llamado
    - una vez capturada, otro siguiente interceptor de cumplimiento es llamado nuevamente (igual que en una cadena de promesas).

Lee [las pruebas de interceptores](https://raw.githubusercontent.com/axios/axios/v1.x/./test/specs/interceptors.spec.js) para ver todo esto en código.

## Tipos de Error

Existen muchos mensajes de error diferentes de axios que pueden aparecer y proporcionar información básica sobre los detalles del error y dónde pueden estar las oportunidades para depurar.

La estructura general de los errores de axios es la siguiente:
| Propiedad  | Definición  |
| -------- | ----------  |
| message  | Un resumen rápido del mensaje de error y el estado con el que falló. |
| name     | Esto define de dónde se originó el error. Para axios, siempre será un 'AxiosError'. |
| stack    | Proporciona el stack trace del error. | 
| config   | Un objeto de configuración de axios con configuraciones específicas definidas por el usuario desde el momento en que se realizó la solicitud |
| code     | Representa un error identificado por axios. La siguiente tabla enumera definiciones específicas para errores internos de axios.  |
| status   | Código de estado HTTP de la respuesta. Consulta [aquí](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) para conocer los significados comunes de los códigos de estado HTTP. 

A continuación se muestra una lista de posibles errores identificados por axios:

| Código                      | Definición                                                                                                                                                                                                                                                                                                                                                                                     |
| --- | --- |
| ERR_BAD_OPTION_VALUE      | Valor inválido proporcionado en la configuración de axios.                                                                                                                                                                                                                                                                                                                                                 |
| ERR_BAD_OPTION            | Opción inválida proporcionada en la configuración de axios.                                                                                                                                                                                                                                                                                                                                                |
| ERR_NOT_SUPPORT           | Característica o método no soportado en el entorno actual de axios.                                                                                                                                                                                                                                                                                                                              |
| ERR_DEPRECATED            | Característica o método en desuso utilizado en axios.                                                                                                                                                                                                                                                                                                                                                    |
| ERR_INVALID_URL           | URL inválida proporcionada para la solicitud de axios.                                                                                                                                                                                                                                                                                                                                                        |
| ECONNABORTED              | Normalmente indica que la solicitud se ha agotado el tiempo de espera (a menos que `transitional.clarifyTimeoutError` esté establecido) o ha sido abortada por el navegador o su complemento.                                                                                                                                                                                                                                            |
| ERR_CANCELED              | La característica o método es cancelado explícitamente por el usuario usando un AbortSignal (o un CancelToken).                                                                                                                                                                                                                                                                                                  |
| ETIMEDOUT                 | La solicitud agotó el tiempo de espera por exceder el límite de tiempo predeterminado de axios. `transitional.clarifyTimeoutError` debe estar configurado en `true`, de lo contrario se lanzará un error genérico `ECONNABORTED`.                                                                                                                                                                                                         |
| ERR_NETWORK               | Problema relacionado con la red. En el navegador, este error también puede ser causado por una violación de la política de [CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/CORS) o de [Contenido Mixto](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content). El navegador no permite que el código JS aclare la verdadera razón del error causado por problemas de seguridad, así que por favor revisa la consola. |
| ERR_FR_TOO_MANY_REDIRECTS | La solicitud es redirigida demasiadas veces; excede el máximo de redirecciones especificado en la configuración de axios.                                                                                                                                                                                                                                                                                                  |
| ERR_BAD_RESPONSE          | La respuesta no puede ser analizada correctamente o está en un formato inesperado. Usualmente relacionado con una respuesta con código de estado `5xx`.                                                                                                                                                                                                                                                                          |
| ERR_BAD_REQUEST           | La solicitud tiene un formato inesperado o le faltan parámetros requeridos. Usualmente relacionado con una respuesta con código de estado `4xx`.                                                                                                                                                                                                                                                                    |

## Manejo de Errores

el comportamiento predeterminado es rechazar cada respuesta que retorna con un código de estado que sale del rango de 2xx y tratarlo como un error.

```js
axios.get('/user/12345')
  .catch(function (error) {
    if (error.response) {
      // La solicitud fue realizada y el servidor respondió con un código de estado
      // que está fuera del rango de 2xx
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    } else if (error.request) {
      // La solicitud fue realizada pero no se recibió respuesta
      // `error.request` es una instancia de XMLHttpRequest en el navegador y una instancia de
      // http.ClientRequest en node.js
      console.log(error.request);
    } else {
      // Ocurrió algo al configurar la solicitud que disparó un Error
      console.log('Error', error.message);
    }
    console.log(error.config);
  });
```

Usando la opción de configuración `validateStatus`, puedes sobrescribir la condición predeterminada (status >= 200 && status < 300) y definir código(s) HTTP que deberían lanzar un error.

```js
axios.get('/user/12345', {
  validateStatus: function (status) {
    return status < 500; // Solo resuelve si el código de estado es menor a 500
  }
})
```

Usando `toJSON` obtienes un objeto con más información sobre el error HTTP.

```js
axios.get('/user/12345')
  .catch(function (error) {
    console.log(error.toJSON());
```
```markdown
  });
```

## Cancelación

### AbortController

A partir de la versión `v0.22.0` Axios soporta AbortController para cancelar solicitudes al estilo de la API fetch:

```js
const controller = new AbortController();

axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// cancelar la solicitud
controller.abort()
```

### CancelToken `👎deprecated`

También puedes cancelar una solicitud usando un *CancelToken*.

> La API de cancelación de axios está basada en la propuesta retirada de [promesas cancelables](https://github.com/tc39/proposal-cancelable-promises).

> Esta API está obsoleta desde la v0.22.0 y no debería usarse en nuevos proyectos

Puedes crear un token de cancelación usando la función de fábrica `CancelToken.source` como se muestra a continuación:

```js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function (thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Solicitud cancelada', thrown.message);
  } else {
    // manejar error
  }
});

axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})

// cancelar la solicitud (el parámetro message es opcional)
source.cancel('Operación cancelada por el usuario.');
```

También puedes crear un token de cancelación pasando una función ejecutora al constructor de `CancelToken`:

```js
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // Una función ejecutora recibe una función de cancelación como parámetro
    cancel = c;
  })
});

// cancelar la solicitud
cancel();
```

> **Nota:** puedes cancelar varias solicitudes con el mismo token de cancelación/controlador de aborto.
> Si un token de cancelación ya está cancelado en el momento de iniciar una solicitud Axios, entonces la solicitud se cancela inmediatamente, sin intentar realizar la solicitud real.

> Durante el período de transición, puedes utilizar ambas APIs de cancelación, incluso para la misma solicitud:

## Usando el formato `application/x-www-form-urlencoded`

### URLSearchParams

Por defecto, axios serializa objetos JavaScript a `JSON`. Para enviar datos en el [formato `application/x-www-form-urlencoded`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) en su lugar, puedes usar la API [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams), que es [compatible](http://www.caniuse.com/#feat=urlsearchparams) con la gran mayoría de navegadores, y [Node](https://nodejs.org/api/url.html#url_class_urlsearchparams) desde la versión 10 (lanzada en 2018).

```js
const params = new URLSearchParams({ foo: 'bar' });
params.append('extraparam', 'value');
axios.post('/foo', params);
```

### Query string (Navegadores antiguos)

Para compatibilidad con navegadores muy antiguos, hay disponible un [polyfill](https://github.com/WebReflection/url-search-params) (asegúrate de incluir el polyfill en el entorno global).

Alternativamente, puedes codificar los datos usando la librería [`qs`](https://github.com/ljharb/qs):

```js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
```
```
O de otra manera (ES6),

```js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
```

### Versiones antiguas de Node.js

Para motores antiguos de Node.js, puedes usar el módulo [`querystring`](https://nodejs.org/api/querystring.html) de la siguiente manera:

```js
const querystring = require('querystring');
axios.post('https://something.com/', querystring.stringify({ foo: 'bar' }));
```

También puedes usar la librería [`qs`](https://github.com/ljharb/qs).

> **Nota**: La librería `qs` es preferible si necesitas convertir objetos anidados a string, ya que el método `querystring` tiene [problemas conocidos](https://github.com/nodejs/node-v0.x-archive/issues/1665) con ese caso de uso.

### 🆕 Serialización automática a URLSearchParams

Axios serializará automáticamente el objeto de datos al formato urlencoded si el encabezado content-type está establecido en "application/x-www-form-urlencoded".

```js
const data = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
};

await axios.postForm('https://postman-echo.com/post', data,
  {headers: {'content-type': 'application/x-www-form-urlencoded'}}
);
```

El servidor lo manejará así:

```js
  {
    x: '1',
    'arr[]': [ '1', '2', '3' ],
    'arr2[0]': '1',
    'arr2[1][0]': '2',
    'arr2[2]': '3',
    'arr3[]': [ '1', '2', '3' ],
    'users[0][name]': 'Peter',
    'users[0][surname]': 'griffin',
    'users[1][name]': 'Thomas',
    'users[1][surname]': 'Anderson'
  }
```

Si tu body-parser del backend (como `body-parser` de `express.js`) soporta la decodificación de objetos anidados, obtendrás el mismo objeto automáticamente en el lado del servidor

```js
  var app = express();

  app.use(bodyParser.urlencoded({ extended: true })); // soporta cuerpos codificados

  app.post('/', function (req, res, next) {
     // devuelve el body como JSON
     res.send(JSON.stringify(req.body));
  });

  server = app.listen(3000);
```

## Uso del formato `multipart/form-data`

### FormData

Para enviar los datos como un `multipart/formdata` necesitas pasar una instancia de formData como payload.
No es necesario establecer el encabezado `Content-Type`, ya que Axios lo deduce según el tipo de payload.

```js
const formData = new FormData();
formData.append('foo', 'bar');

axios.post('https://httpbin.org/post', formData);
```

En node.js, puedes usar la librería [`form-data`](https://github.com/form-data/form-data) de la siguiente manera:

```js
const FormData = require('form-data');

const form = new FormData();
form.append('my_field', 'my value');
form.append('my_buffer', new Buffer(10));
form.append('my_file', fs.createReadStream('/foo/bar.jpg'));
```
axios.post('https://example.com', form)
```

### 🆕 Serialización automática a FormData

A partir de la versión `v0.27.0`, Axios admite la serialización automática de objetos a un objeto FormData si la cabecera `Content-Type`
de la solicitud está configurada como `multipart/form-data`.

La siguiente solicitud enviará los datos en formato FormData (Navegador y Node.js):

```js
import axios from 'axios';

axios.post('https://httpbin.org/post', {x: 1}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));
```

En la versión para `node.js`, se utiliza por defecto el polyfill ([`form-data`](https://github.com/form-data/form-data)).

Puedes sobrecargar la clase FormData configurando la variable `env.FormData` en la configuración,
pero probablemente no lo necesitarás en la mayoría de los casos:

```js
const axios = require('axios');
var FormData = require('form-data');

axios.post('https://httpbin.org/post', {x: 1, buf: new Buffer(10)}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));
```

El serializador de FormData de Axios admite algunos sufijos especiales para realizar las siguientes operaciones:

- `{}` - serializa el valor usando JSON.stringify
- `[]` - desenvuelve el objeto tipo array como campos separados con la misma clave

> **Nota**: la operación de desenvuelto/expansión se usará por defecto en arrays y objetos FileList

El serializador de FormData admite opciones adicionales mediante la propiedad `config.formSerializer: object` para manejar casos poco comunes:

- `visitor: Function` - función visitor definida por el usuario que se llamará recursivamente para serializar el objeto de datos
a un objeto `FormData` siguiendo reglas personalizadas.

- `dots: boolean = false` - utiliza notación de puntos en lugar de corchetes para serializar arrays y objetos;

- `metaTokens: boolean = true` - añade el sufijo especial (por ejemplo `user{}: '{"name": "John"}'`) en la clave de FormData.
El body-parser del back-end podría usar potencialmente esta metainformación para analizar automáticamente el valor como JSON.

- `indexes: null|false|true = false` - controla cómo se añadirán los índices a las claves desenvoltas de objetos tipo array `flat`.

    - `null` - no añade corchetes (`arr: 1`, `arr: 2`, `arr: 3`)
    - `false` (por defecto) - añade corchetes vacíos (`arr[]: 1`, `arr[]: 2`, `arr[]: 3`)
    - `true` - añade corchetes con índices  (`arr[0]: 1`, `arr[1]: 2`, `arr[2]: 3`)

Supongamos que tenemos un objeto como el siguiente:

```js
const obj = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
  'obj2{}': [{x:1}]
};
```

Los siguientes pasos serán ejecutados internamente por el serializador de Axios:

```js
const formData = new FormData();
formData.append('x', '1');
formData.append('arr[]', '1');
formData.append('arr[]', '2');
formData.append('arr[]', '3');
formData.append('arr2[0]', '1');
formData.append('arr2[1][0]', '2');
formData.append('arr2[2]', '3');
formData.append('users[0][name]', 'Peter');
formData.append('users[0][surname]', 'Griffin');
formData.append('users[1][name]', 'Thomas');
formData.append('users[1][surname]', 'Anderson');
formData.append('obj2{}', '[{"x":1}]');
```

Axios admite los siguientes métodos abreviados: `postForm`, `putForm`, `patchForm`
que son simplemente los métodos http correspondientes con la cabecera `Content-Type` preestablecida en `multipart/form-data`.

## Envío de archivos

Puedes enviar fácilmente un solo archivo:

```js
await axios.postForm('https://httpbin.org/post', {
  'myVar' : 'foo',
  'file': document.querySelector('#fileInput').files[0]
});
```

o múltiples archivos como `multipart/form-data`:

```js
await axios.postForm('https://httpbin.org/post', {
  'files[]': document.querySelector('#fileInput').files
});
```

El objeto `FileList` se puede pasar directamente:

```js
await axios.postForm('https://httpbin.org/post', document.querySelector('#fileInput').files)
```

Todos los archivos se enviarán con los mismos nombres de campo: `files[]`.

## 🆕 Envío de formularios HTML (navegador)

Pasa un elemento de formulario HTML como carga útil para enviarlo como contenido `multipart/form-data`.

```js
await axios.postForm('https://httpbin.org/post', document.querySelector('#htmlForm'));
```

Los objetos `FormData` y `HTMLForm` también pueden enviarse como `JSON` configurando explícitamente la cabecera `Content-Type` a `application/json`:

```js
await axios.post('https://httpbin.org/post', document.querySelector('#htmlForm'), {
  headers: {
    'Content-Type': 'application/json'
  }
})
```

Por ejemplo, el formulario

```html
<form id="form">
  <input type="text" name="foo" value="1">
  <input type="text" name="deep.prop" value="2">
  <input type="text" name="deep prop spaced" value="3">
  <input type="text" name="baz" value="4">
  <input type="text" name="baz" value="5">

  <select name="user.age">
    <option value="value1">Value 1</option>
    <option value="value2" selected>Value 2</option>
    <option value="value3">Value 3</option>
  </select>

  <input type="submit" value="Guardar">
</form>
```

se enviará como el siguiente objeto JSON:

```js
{
  "foo": "1",
  "deep": {
    "prop": {
      "spaced": "3"
    }
  },
  "baz": [
    "4",
    "5"
  ],
  "user": {
    "age": "value2"
  }
}
````

No se admite actualmente el envío de `Blobs`/`Files` como JSON (`base64`).

## 🆕 Captura de progreso

Axios admite tanto entornos de navegador como de Node para capturar el progreso de carga/descarga de solicitudes.
La frecuencia de los eventos de progreso se limita forzosamente a `3` veces por segundo.

```js    
await axios.post(url, data, {
  onUploadProgress: function (axiosProgressEvent) {
    /*{
      loaded: number;
      total?: number;
      progress?: number; // en el rango [0..1]
      bytes: number; // cuántos bytes se han transferido desde el último disparo (delta)
      estimated?: number; // tiempo estimado en segundos
      rate?: number; // velocidad de subida en bytes
      upload: true; // indicador de subida
    }*/
  },

  onDownloadProgress: function (axiosProgressEvent) {
    /*{
```js
      loaded: number;
      total?: number;
      progress?: number;
      bytes: number; 
      estimated?: number;
      rate?: number; // velocidad de descarga en bytes
      download: true; // indicador de descarga
    }*/
  }
});  
```

También puedes rastrear el progreso de carga/descarga de streams en node.js:

```js
const {data} = await axios.post(SERVER_URL, readableStream, {
   onUploadProgress: ({progress}) => {
     console.log((progress * 100).toFixed(2));
   },
  
   headers: {
    'Content-Length': contentLength
   },

   maxRedirects: 0 // evita almacenar en búfer todo el stream
});
````

> **Nota:**
> Actualmente no se admite capturar el progreso de carga de FormData en entornos node.js.

> **⚠️ Advertencia**
> Se recomienda deshabilitar las redirecciones configurando maxRedirects: 0 para cargar el stream en el entorno **node.js**,
> ya que el paquete follow-redirects almacenará en búfer todo el stream en RAM sin seguir el algoritmo de "backpressure".


## 🆕 Limitación de velocidad

Los límites de velocidad de descarga y carga solo se pueden establecer para el adaptador http (node.js):

```js
const {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {
  onUploadProgress: ({progress, rate}) => {
    console.log(`Subida [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)
  },
   
  maxRate: [100 * 1024], // límite de 100KB/s
});
```

## 🆕 AxiosHeaders

Axios tiene su propia clase `AxiosHeaders` para manipular encabezados usando una API similar a Map que garantiza el trabajo sin distinción de mayúsculas y minúsculas.
Aunque HTTP no distingue entre mayúsculas y minúsculas en los encabezados, Axios conservará la mayúscula original del encabezado por razones de estilo
y como solución alternativa cuando los servidores consideran erróneamente la mayúscula del encabezado.
El método antiguo de manipular directamente el objeto headers sigue estando disponible, pero está obsoleto y no se recomienda para uso futuro.

### Trabajando con encabezados

Una instancia del objeto AxiosHeaders puede contener diferentes tipos de valores internos que controlan la lógica de establecimiento y fusión.
El objeto final de encabezados con valores de tipo string se obtiene en Axios llamando al método `toJSON`.

> Nota: Por JSON aquí nos referimos a un objeto que consiste solo en valores de tipo string destinados a ser enviados por la red.

El valor del encabezado puede ser uno de los siguientes tipos:
- `string` - valor de tipo cadena normal que se enviará al servidor
- `null` - omite el encabezado al convertir a JSON
- `false` - omite el encabezado al convertir a JSON, además indica que el método `set` debe llamarse con la opción `rewrite` establecida en `true`
  para sobrescribir este valor (Axios utiliza esto internamente para permitir a los usuarios optar por no instalar ciertos encabezados como `User-Agent` o `Content-Type`)
- `undefined` - el valor no está establecido

> Nota: Se considera que el valor del encabezado está establecido si no es igual a undefined.

El objeto headers siempre se inicializa dentro de interceptores y transformadores:

```ts
  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {
      request.headers.set('My-header', 'value');

      request.headers.set({
        "My-set-header1": "my-set-value1",
        "My-set-header2": "my-set-value2"
      });
      
      request.headers.set('User-Agent', false); // deshabilita el establecimiento posterior del encabezado por Axios

      request.headers.setContentType('text/plain');
    
      request.headers['My-set-header2'] = 'newValue' // el acceso directo está obsoleto
    
      return request;
    }
  );
````

Puedes iterar sobre una instancia de `AxiosHeaders` usando una instrucción `for...of`:

````js
const headers = new AxiosHeaders({
  foo: '1',
```
```js
  bar: '2',
  baz: '3'
});

for(const [header, value] of headers) {
  console.log(header, value);
}

// foo 1
// bar 2
// baz 3
````

### new AxiosHeaders(headers?)

Construye una nueva instancia de `AxiosHeaders`.

```
constructor(headers?: RawAxiosHeaders | AxiosHeaders | string);
```

Si el objeto headers es una cadena, se analizará como cabeceras HTTP RAW.

````js
const headers = new AxiosHeaders(`
Host: www.bing.com
User-Agent: curl/7.54.0
Accept: */*`);

console.log(headers);

// Object [AxiosHeaders] {
//   host: 'www.bing.com',
//   'user-agent': 'curl/7.54.0',
//   accept: '*/*'
// }
````

### AxiosHeaders#set

```ts
set(headerName, value: Axios, rewrite?: boolean);
set(headerName, value, rewrite?: (this: AxiosHeaders, value: string, name: string, headers: RawAxiosHeaders) => boolean);
set(headers?: RawAxiosHeaders | AxiosHeaders | string, rewrite?: boolean);
```

El argumento `rewrite` controla el comportamiento de sobrescritura:
- `false` - no sobrescribe si el valor de la cabecera está establecido (no es `undefined`)
- `undefined` (por defecto) - sobrescribe la cabecera a menos que su valor esté establecido en `false`
- `true` - sobrescribe de todos modos

La opción también puede aceptar una función definida por el usuario que determina si el valor debe sobrescribirse o no.

Devuelve `this`.

### AxiosHeaders#get(header)

```
  get(headerName: string, matcher?: true | AxiosHeaderMatcher): AxiosHeaderValue;
  get(headerName: string, parser: RegExp): RegExpExecArray | null;
````

Devuelve el valor interno de la cabecera. Puede tomar un argumento adicional para analizar el valor de la cabecera con `RegExp.exec`,
una función matcher o el analizador interno de pares clave-valor.

```ts
const headers = new AxiosHeaders({
  'Content-Type': 'multipart/form-data; boundary=Asrf456BGe4h'
});

console.log(headers.get('Content-Type')); 
// multipart/form-data; boundary=Asrf456BGe4h

console.log(headers.get('Content-Type', true)); // analiza pares clave-valor de una cadena separada por los delimitadores \s,;= :
// [Object: null prototype] {
//   'multipart/form-data': undefined,
//    boundary: 'Asrf456BGe4h'
// }


console.log(headers.get('Content-Type', (value, name, headers) => {
  return String(value).replace(/a/g, 'ZZZ');
}));
// multipZZZrt/form-dZZZtZZZ; boundZZZry=Asrf456BGe4h

console.log(headers.get('Content-Type', /boundary=(\w+)/)?.[0]);
// boundary=Asrf456BGe4h

```

Devuelve el valor de la cabecera.

### AxiosHeaders#has(header, matcher?)

```
has(header: string, matcher?: AxiosHeaderMatcher): boolean;
```

Devuelve `true` si la cabecera está establecida (no tiene valor `undefined`).
```
### AxiosHeaders#delete(header, matcher?)

```
delete(header: string | string[], matcher?: AxiosHeaderMatcher): boolean;
```

Devuelve `true` si al menos un encabezado ha sido eliminado.

### AxiosHeaders#clear(matcher?)

```
clear(matcher?: AxiosHeaderMatcher): boolean;
```

Elimina todos los encabezados.  
A diferencia del matcher del método `delete`, este matcher opcional se usará para coincidir con el nombre del encabezado en lugar del valor.

```ts
const headers = new AxiosHeaders({
  'foo': '1',
  'x-foo': '2',
  'x-bar': '3',
});

console.log(headers.clear(/^x-/)); // true

console.log(headers.toJSON()); // [Object: null prototype] { foo: '1' }
```

Devuelve `true` si al menos un encabezado ha sido eliminado.

### AxiosHeaders#normalize(format);

Si el objeto de encabezados fue modificado directamente, puede tener duplicados con el mismo nombre pero en diferentes mayúsculas/minúsculas.  
Este método normaliza el objeto de encabezados combinando claves duplicadas en una sola.  
Axios utiliza este método internamente después de llamar a cada interceptor.  
Establezca `format` en true para convertir el nombre de los encabezados a minúsculas y capitalizar las letras iniciales (`cOntEnt-type` => `Content-Type`)

```js
const headers = new AxiosHeaders({
  'foo': '1',
});

headers.Foo = '2';
headers.FOO = '3';

console.log(headers.toJSON()); // [Object: null prototype] { foo: '1', Foo: '2', FOO: '3' }
console.log(headers.normalize().toJSON()); // [Object: null prototype] { foo: '3' }
console.log(headers.normalize(true).toJSON()); // [Object: null prototype] { Foo: '3' }
```

Devuelve `this`.

### AxiosHeaders#concat(...targets)

```
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
```

Combina la instancia con los destinos en una nueva instancia de `AxiosHeaders`. Si el destino es una cadena, se analizará como encabezados HTTP RAW.

Devuelve una nueva instancia de `AxiosHeaders`.

### AxiosHeaders#toJSON(asStrings?)

````
toJSON(asStrings?: boolean): RawAxiosHeaders;
````

Resuelve todos los valores internos de encabezados en un nuevo objeto con prototipo nulo.  
Establezca `asStrings` en true para resolver los arrays como una cadena que contiene todos los elementos, separados por comas.

### AxiosHeaders.from(thing?)

````
from(thing?: AxiosHeaders | RawAxiosHeaders | string): AxiosHeaders;
````

Devuelve una nueva instancia de `AxiosHeaders` creada a partir de los encabezados en bruto proporcionados,  
o simplemente devuelve el objeto de encabezados dado si es una instancia de `AxiosHeaders`.

### AxiosHeaders.concat(...targets)

````
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
````

Devuelve una nueva instancia de `AxiosHeaders` creada al fusionar los objetos de destino.

### Atajos

Están disponibles los siguientes atajos:

- `setContentType`, `getContentType`, `hasContentType`

- `setContentLength`, `getContentLength`, `hasContentLength`

- `setAccept`, `getAccept`, `hasAccept`

- `setUserAgent`, `getUserAgent`, `hasUserAgent`
- `setContentEncoding`, `getContentEncoding`, `hasContentEncoding`

## 🔥 Adaptador Fetch

El adaptador Fetch fue introducido en la versión `v1.7.0`. Por defecto, se utilizará si los adaptadores `xhr` y `http` no están disponibles en la compilación,
o no son compatibles con el entorno.
Para usarlo por defecto, debe seleccionarse explícitamente:

```js
const {data} = axios.get(url, {
  adapter: 'fetch' // por defecto ['xhr', 'http', 'fetch']
})
```

Puedes crear una instancia separada para esto:

```js
const fetchAxios = axios.create({
  adapter: 'fetch'
});

const {data} = fetchAxios.get(url);
```

El adaptador soporta la misma funcionalidad que el adaptador `xhr`, **incluyendo la captura de progreso de carga y descarga**.
Además, soporta tipos de respuesta adicionales como `stream` y `formdata` (si el entorno los soporta).

## Semver

Hasta que axios llegue a una versión `1.0`, los cambios incompatibles se publicarán con una nueva versión menor. Por ejemplo, `0.5.1` y `0.5.4` tendrán la misma API, pero `0.6.0` tendrá cambios incompatibles.

## Promesas

axios depende de una implementación nativa de Promesas ES6 para ser [soportado](https://caniuse.com/promises).
Si tu entorno no soporta Promesas ES6, puedes usar un [polyfill](https://github.com/jakearchibald/es6-promise).

## TypeScript

axios incluye definiciones de [TypeScript](https://typescriptlang.org) y un guard de tipos para errores de axios.

```typescript
let user: User = null;
try {
  const { data } = await axios.get('/user?ID=12345');
  user = data.userDetails;
} catch (error) {
  if (axios.isAxiosError(error)) {
    handleAxiosError(error);
  } else {
    handleUnexpectedError(error);
  }
}
```

Debido a que axios publica de manera dual con una exportación por defecto ESM y un `module.exports` de CJS, existen algunas consideraciones.
La configuración recomendada es usar `"moduleResolution": "node16"` (esto está implícito por `"module": "node16"`). Ten en cuenta que esto requiere TypeScript 4.7 o superior.
Si usas ESM, tu configuración debería estar bien.
Si compilas TypeScript a CJS y no puedes usar `"moduleResolution": "node16"`, tienes que habilitar `esModuleInterop`.
Si usas TypeScript para verificar tipos de código JavaScript CJS, tu única opción es usar `"moduleResolution": "node16"`.

## Configuración online con un clic

Puedes usar Gitpod, un IDE en línea (que es gratuito para Open Source) para contribuir o ejecutar los ejemplos en línea.

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/axios/axios/blob/main/examples/server.js)


## Recursos

* [Changelog](https://github.com/axios/axios/blob/v1.x/CHANGELOG.md)
* [Ecosistema](https://github.com/axios/axios/blob/v1.x/ECOSYSTEM.md)
* [Guía de contribución](https://github.com/axios/axios/blob/v1.x/CONTRIBUTING.md)
* [Código de conducta](https://github.com/axios/axios/blob/v1.x/CODE_OF_CONDUCT.md)

## Créditos

axios está fuertemente inspirado por el [$http service](https://docs.angularjs.org/api/ng/service/$http) proporcionado en [AngularJS](https://angularjs.org/). En última instancia, axios es un esfuerzo por proporcionar un servicio independiente similar a `$http` para su uso fuera de AngularJS.

## Licencia

[MIT](LICENSE)


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-30

---