{
  "id": 8,
  "origin": "```js\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Config order of precedence\n\nConfig will be merged with an order of precedence. The order is library defaults found in [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), then `defaults` property of the instance, and finally `config` argument for the request. The latter will take precedence over the former. Here's an example.\n\n```js\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nYou can intercept requests or responses before they are handled by `then` or `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\nIf you need to remove an interceptor later you can.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nYou can also clear all interceptors for requests or responses.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\nYou can add interceptors to a custom instance of axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay\nin the execution of your axios request when the main thread is blocked (a promise is created under the hood for\nthe interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag\nto the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nIf you want to execute a particular interceptor based on a runtime check,\nyou can add a `runWhen` function to the options object. The request interceptor will not be executed **if and only if** the return\nof `runWhen` is `false`. The function will be called with the config\nobject (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an\nasynchronous request interceptor that only needs to run at certain times.\n",
  "origin_sha": "6kwzhk6CE1CRCOj5zCcnL7pc/83OgVLCi9g0Hk4TRYk=",
  "translate": "```js\n// Thiết lập cấu hình mặc định khi tạo instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Thay đổi cấu hình mặc định sau khi instance đã được tạo\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n### Thứ tự ưu tiên của cấu hình\n\nCấu hình sẽ được hợp nhất theo một thứ tự ưu tiên. Thứ tự này là mặc định của thư viện được tìm thấy trong [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49), tiếp theo là thuộc tính `defaults` của instance, và cuối cùng là đối số `config` cho từng request. Đối số sau sẽ ưu tiên hơn đối số trước. Dưới đây là ví dụ.\n\n```js\n// Tạo một instance sử dụng cấu hình mặc định do thư viện cung cấp\n// Lúc này giá trị timeout là `0` như mặc định của thư viện\nconst instance = axios.create();\n\n// Ghi đè timeout mặc định của thư viện\n// Giờ tất cả các request sử dụng instance này sẽ đợi 2.5 giây trước khi timeout\ninstance.defaults.timeout = 2500;\n\n// Ghi đè timeout cho request này vì biết nó sẽ mất nhiều thời gian\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n## Interceptors\n\nBạn có thể can thiệp (intercept) vào request hoặc response trước khi chúng được xử lý bởi `then` hoặc `catch`.\n\n```js\n\nconst instance = axios.create();\n\n// Thêm request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Làm gì đó trước khi request được gửi\n    return config;\n  }, function (error) {\n    // Xử lý lỗi request\n    return Promise.reject(error);\n  });\n\n// Thêm response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Bất kỳ mã trạng thái nào nằm trong khoảng 2xx sẽ kích hoạt function này\n    // Xử lý dữ liệu response\n    return response;\n  }, function (error) {\n    // Bất kỳ mã trạng thái nào nằm ngoài khoảng 2xx sẽ kích hoạt function này\n    // Xử lý lỗi response\n    return Promise.reject(error);\n  });\n```\n\nNếu bạn cần loại bỏ một interceptor sau này, bạn hoàn toàn có thể làm điều đó.\n\n```js\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nBạn cũng có thể xoá tất cả interceptor cho request hoặc response.\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Xóa các interceptor của request\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Xóa các interceptor của response\n```\n\nBạn có thể thêm interceptor vào một instance tuỳ chỉnh của axios.\n\n```js\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n```\n\nKhi bạn thêm request interceptor, chúng mặc định được coi là bất đồng bộ. Điều này có thể gây ra độ trễ\ntrong việc thực thi request axios khi luồng chính bị chặn (một promise sẽ được tạo ngầm cho interceptor và request của bạn sẽ được đưa xuống dưới cùng của call stack). Nếu interceptor của bạn là đồng bộ, bạn có thể thêm một cờ\nvào object options để yêu cầu axios chạy mã đồng bộ và tránh mọi độ trễ khi thực thi request.\n\n```js\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'Tôi chỉ là một header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nNếu bạn muốn thực thi một interceptor cụ thể dựa trên kiểm tra lúc chạy,\nbạn có thể thêm function `runWhen` vào object options. Request interceptor sẽ không được thực thi **nếu và chỉ nếu** giá trị trả về\ncủa `runWhen` là `false`. Hàm này sẽ được gọi với object config\n(đừng quên bạn cũng có thể bind các đối số của riêng mình vào đó.) Điều này rất hữu ích khi bạn có một\nrequest interceptor bất đồng bộ nhưng chỉ cần chạy vào một số thời điểm nhất định.\n```",
  "status": "ok"
}