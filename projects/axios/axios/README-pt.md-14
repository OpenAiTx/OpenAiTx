{
  "id": 14,
  "origin": "      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // download speed in bytes\n      download: true; // download sign\n    }*/\n  }\n});  \n```\n\nYou can also track stream upload/download progress in node.js:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // avoid buffering the entire stream\n});\n````\n\n> **Note:**\n> Capturing FormData upload progress is not currently supported in node.js environments.\n\n> **âš ï¸ Warning**\n> It is recommended to disable redirects by setting maxRedirects: 0 to upload the stream in the **node.js** environment,\n> as follow-redirects package will buffer the entire stream in RAM without following the \"backpressure\" algorithm.\n\n\n## ğŸ†• Rate limiting\n\nDownload and upload rate limits can only be set for the http adapter (node.js):\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // 100KB/s limit\n});\n```\n\n## ğŸ†• AxiosHeaders\n\nAxios has its own `AxiosHeaders` class to manipulate headers using a Map-like API that guarantees caseless work.\nAlthough HTTP is case-insensitive in headers, Axios will retain the case of the original header for stylistic reasons\nand for a workaround when servers mistakenly consider the header's case.\nThe old approach of directly manipulating headers object is still available, but deprecated and not recommended for future usage.\n\n### Working with headers\n\nAn AxiosHeaders object instance can contain different types of internal values. that control setting and merging logic.\nThe final headers object with string values is obtained by Axios by calling the `toJSON` method.\n\n> Note: By JSON here we mean an object consisting only of string values intended to be sent over the network.\n\nThe header value can be one of the following types:\n- `string` - normal string value that will be sent to the server\n- `null` - skip header when rendering to JSON\n- `false` - skip header when rendering to JSON, additionally indicates that `set` method must be called with `rewrite` option set to `true`\n  to overwrite this value (Axios uses this internally to allow users to opt out of installing certain headers like `User-Agent` or `Content-Type`)\n- `undefined` - value is not set\n\n> Note: The header value is considered set if it is not equal to undefined.\n\nThe headers object is always initialized inside interceptors and transformers:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // disable subsequent setting the header by Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // direct access is deprecated\n    \n      return request;\n    }\n  );\n````\n\nYou can iterate over an `AxiosHeaders` instance using a `for...of` statement:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',",
  "origin_sha": "FK9fblZzMaAq7pcNVVG17lyaNO+0Z7qRCDVMdJcNTFs=",
  "translate": "```js\n      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // velocidade de download em bytes\n      download: true; // sinal de download\n    }*/\n  }\n});  \n```\n\nVocÃª tambÃ©m pode acompanhar o progresso de upload/download de streams no node.js:\n\n```js\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // evita armazenar em buffer todo o stream\n});\n````\n\n> **Nota:**\n> Capturar o progresso de upload de FormData atualmente nÃ£o Ã© suportado em ambientes node.js.\n\n> **âš ï¸ Aviso**\n> Recomenda-se desabilitar redirecionamentos definindo maxRedirects: 0 para fazer upload de streams no ambiente **node.js**,\n> pois o pacote follow-redirects irÃ¡ armazenar todo o stream em RAM sem seguir o algoritmo de \"backpressure\".\n\n\n## ğŸ†• LimitaÃ§Ã£o de taxa (Rate limiting)\n\nOs limites de taxa de download e upload sÃ³ podem ser definidos para o adaptador http (node.js):\n\n```js\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // limite de 100KB/s\n});\n```\n\n## ğŸ†• AxiosHeaders\n\nO Axios possui sua prÃ³pria classe `AxiosHeaders` para manipular cabeÃ§alhos usando uma API semelhante a Map, que garante funcionamento sem diferenciaÃ§Ã£o de maiÃºsculas/minÃºsculas.\nEmbora o HTTP nÃ£o diferencie maiÃºsculas/minÃºsculas nos cabeÃ§alhos, o Axios manterÃ¡ o caso do cabeÃ§alho original por razÃµes de estilo\ne como soluÃ§Ã£o alternativa para servidores que, por engano, consideram o caso do cabeÃ§alho.\nA abordagem antiga de manipulaÃ§Ã£o direta do objeto headers ainda estÃ¡ disponÃ­vel, mas estÃ¡ obsoleta e nÃ£o Ã© recomendada para uso futuro.\n\n### Trabalhando com cabeÃ§alhos\n\nUma instÃ¢ncia do objeto AxiosHeaders pode conter diferentes tipos de valores internos, que controlam a lÃ³gica de definiÃ§Ã£o e mesclagem.\nO objeto final de cabeÃ§alhos com valores em string Ã© obtido pelo Axios ao chamar o mÃ©todo `toJSON`.\n\n> Nota: Por JSON aqui entende-se um objeto composto apenas por valores de string destinados a serem enviados pela rede.\n\nO valor do cabeÃ§alho pode ser um dos seguintes tipos:\n- `string` - valor de string normal que serÃ¡ enviado ao servidor\n- `null` - ignora o cabeÃ§alho ao renderizar para JSON\n- `false` - ignora o cabeÃ§alho ao renderizar para JSON, alÃ©m de indicar que o mÃ©todo `set` deve ser chamado com a opÃ§Ã£o `rewrite` definida como `true`\n  para sobrescrever esse valor (o Axios usa isso internamente para permitir que usuÃ¡rios optem por nÃ£o instalar certos cabeÃ§alhos como `User-Agent` ou `Content-Type`)\n- `undefined` - valor nÃ£o definido\n\n> Nota: O valor do cabeÃ§alho Ã© considerado definido se nÃ£o for igual a undefined.\n\nO objeto headers Ã© sempre inicializado dentro de interceptadores e transformadores:\n\n```ts\n  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n      request.headers.set('My-header', 'value');\n\n      request.headers.set({\n        \"My-set-header1\": \"my-set-value1\",\n        \"My-set-header2\": \"my-set-value2\"\n      });\n      \n      request.headers.set('User-Agent', false); // desabilita a definiÃ§Ã£o subsequente deste cabeÃ§alho pelo Axios\n\n      request.headers.setContentType('text/plain');\n    \n      request.headers['My-set-header2'] = 'newValue' // o acesso direto estÃ¡ obsoleto\n    \n      return request;\n    }\n  );\n````\n\nVocÃª pode iterar sobre uma instÃ¢ncia de `AxiosHeaders` usando uma instruÃ§Ã£o `for...of`:\n\n````js\nconst headers = new AxiosHeaders({\n  foo: '1',\n```",
  "status": "ok"
}