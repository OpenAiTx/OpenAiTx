<h3 align="center"> 🥇 골드 스폰서 <br> </h3> <table align="center" width="100%"><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="38px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/stytch_white.png"> <img width="200px" height="38px" src="https://axios-http.com/assets/sponsors/stytch.png" alt="Stytch"/> </picture> </a> <p align="center" title="API-first authentication, authorization, and fraud prevention">API-우선 인증, 인가 및 사기 방지</p> <p align="center"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http"><b>웹사이트</b></a> | <a href="https://stytch.com/docs?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;docs-link&amp;utm_campaign&#x3D;axios-http"><b>문서</b></a> | <a href="https://github.com/stytchauth/stytch-node?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;node-sdk&amp;utm_campaign&#x3D;axios-http"><b>Node.js</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="133px" height="43px" src="https://axios-http.com/assets/sponsors/principal.svg" alt="Principal Financial Group"/> </a> <p align="center" title="We’re bound by one common purpose: to give you the financial tools, resources and information you need to live your best life.">우리는 한 가지 공통된 목표로 연결되어 있습니다: 여러분이 최고의 삶을 살 수 있도록 금융 도구, 리소스, 정보를 제공합니다.</p> <p align="center"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.principal.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="85px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buy-instagram-followers-twicsy.png" alt="Buy Instagram Followers Twicsy"/> </a> <p align="center" title="Buy real Instagram followers from Twicsy starting at only $2.97. Twicsy has been voted the best site to buy followers from the likes of US Magazine.">Twicsy에서 단 $2.97부터 실제 인스타그램 팔로워를 구매하세요. Twicsy는 US Magazine 등에서 최고의 팔로워 구매 사이트로 선정되었습니다.</p> <p align="center"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>twicsy.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="52px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/descope_white.png"> <img width="200px" height="52px" src="https://axios-http.com/assets/sponsors/descope.png" alt="Descope"/> </picture> </a> <p align="center" title="Hi, we&#x27;re Descope! We are building something in the authentication space for app developers and can’t wait to place it in your hands.">안녕하세요, 저희는 Descope입니다! 저희는 앱 개발자를 위한 인증 분야에서 새로운 것을 만들고 있으며, 곧 여러분께 선보일 수 있기를 기대합니다.</p> <p align="center"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>웹사이트</b></a> | <a href="https://docs.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>문서</b></a> | <a href="https://www.descope.com/community?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>커뮤니티</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="62px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buzzoid-buy-instagram-followers.png" alt="Buzzoid - Buy Instagram Followers"/> </a> <p align="center" title="At Buzzoid, you can buy Instagram followers quickly, safely, and easily with just a few clicks. Rated world&#x27;s #1 IG service since 2012.">Buzzoid에서 몇 번의 클릭만으로 인스타그램 팔로워를 빠르고, 안전하게, 쉽게 구매할 수 있습니다. 2012년부터 세계 1위 IG 서비스로 평가받고 있습니다.</p> <p align="center"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>buzzoid.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/famety-buy-instagram-followers.png" alt="Famety - Buy Instagram Followers"/> </a> <p align="center" title="At Famety, you can grow your social media following quickly, safely, and easily with just a few clicks. Rated the world’s #1 social media service since 2013.">Famety에서 몇 번의 클릭만으로 소셜 미디어 팔로워를 빠르고, 안전하게, 쉽게 늘릴 수 있습니다. 2013년부터 세계 1위 소셜 미디어 서비스로 평가받고 있습니다.</p> <p align="center"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.famety.net</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/instagram-likes.png" alt="Poprey - Buy Instagram Likes"/> </a> <p align="center" title="Buy Instagram Likes">인스타그램 좋아요 구매</p> <p align="center"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>poprey.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/youtube-subscribers-ssmarket.png" alt="Buy Youtube Subscribers"/> </a> <p align="center" title="SS Market offers professional social media services that rapidly increase your YouTube subscriber count, elevating your channel to a powerful position.">SS Market는 전문 소셜 미디어 서비스를 통해 유튜브 구독자 수를 빠르게 늘려 여러분의 채널을 강력한 위치로 올려드립니다.</p> <p align="center"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>ssmarket.net</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="200px" height="56px" src="https://axios-http.com/assets/sponsors/opencollective/smmpanelserver123.png" alt="smmpanelserver"/> </a> <p align="center" title="smmpanelserver - Best and Cheapest Smm Panel">smmpanelserver - 최고이자 가장 저렴한 SMM 패널</p> <p align="center"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>smmpanelserver.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 스폰서가 되어주세요</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 스폰서가 되어주세요</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 스폰서가 되어주세요</a>
</td></tr></table>

<!--<div>marker</div>-->
<br><br>
<div align="center">
   <a href="https://axios-http.com"><img src="https://axios-http.com/assets/logo.svg" /></a><br>
</div>

<p align="center">브라우저와 node.js를 위한 Promise 기반 HTTP 클라이언트</p>

<p align="center">
    <a href="https://axios-http.com/"><b>웹사이트</b></a> •
    <a href="https://axios-http.com/docs/intro"><b>문서</b></a>
</p>

<div align="center">

[![npm version](https://img.shields.io/npm/v/axios.svg?style=flat-square)](https://www.npmjs.org/package/axios)
[![CDNJS](https://img.shields.io/cdnjs/v/axios.svg?style=flat-square)](https://cdnjs.com/libraries/axios)
[![Build status](https://img.shields.io/github/actions/workflow/status/axios/axios/ci.yml?branch=v1.x&label=CI&logo=github&style=flat-square)](https://github.com/axios/axios/actions/workflows/ci.yml)
[![Gitpod Ready-to-Code](https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod&style=flat-square)](https://gitpod.io/#https://github.com/axios/axios)
[![code coverage](https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square)](https://coveralls.io/r/mzabriskie/axios)
[![install size](https://img.shields.io/badge/dynamic/json?url=https://packagephobia.com/v2/api.json?p=axios&query=$.install.pretty&label=install%20size&style=flat-square)](https://packagephobia.now.sh/result?p=axios)
[![npm bundle size](https://img.shields.io/bundlephobia/minzip/axios?style=flat-square)](https://bundlephobia.com/package/axios@latest)
[![npm downloads](https://img.shields.io/npm/dm/axios.svg?style=flat-square)](https://npm-stat.com/charts.html?package=axios)
[![gitter chat](https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square)](https://gitter.im/mzabriskie/axios)
[![code helpers](https://www.codetriage.com/axios/axios/badges/users.svg)](https://www.codetriage.com/axios/axios)
[![Known Vulnerabilities](https://snyk.io/test/npm/axios/badge.svg)](https://snyk.io/test/npm/axios)




</div>

## 목차

  - [기능](#features)
  - [브라우저 지원](#browser-support)
  - [설치](#installing)
    - [패키지 매니저](#package-manager)
    - [CDN](#cdn)
  - [예제](#example)
  - [Axios API](#axios-api)
  - [요청 메서드 별칭](#request-method-aliases)
  - [동시성 👎](#concurrency-deprecated)
  - [인스턴스 생성](#creating-an-instance)
  - [인스턴스 메서드](#instance-methods)
  - [요청 설정](#request-config)
  - [응답 스키마](#response-schema)
  - [설정 기본값](#config-defaults)
    - [글로벌 axios 기본값](#global-axios-defaults)
    - [사용자 인스턴스 기본값](#custom-instance-defaults)
    - [설정 우선순위](#config-order-of-precedence)
  - [인터셉터](#interceptors)
    - [다중 인터셉터](#multiple-interceptors)
  - [에러 처리](#handling-errors)
  - [요청 취소](#cancellation)
    - [AbortController](#abortcontroller)
    - [CancelToken 👎](#canceltoken-deprecated)
  - [application/x-www-form-urlencoded 형식 사용](#using-applicationx-www-form-urlencoded-format)
    - [URLSearchParams](#urlsearchparams)
    - [쿼리 스트링](#query-string-older-browsers)
    - [🆕 자동 직렬화](#-automatic-serialization-to-urlsearchparams)
  - [multipart/form-data 형식 사용](#using-multipartform-data-format)
    - [FormData](#formdata)
    - [🆕 자동 직렬화](#-automatic-serialization-to-formdata)
  - [파일 전송](#files-posting)
  - [HTML 폼 전송](#-html-form-posting-browser)
  - [🆕 진행률 캡처](#-progress-capturing)
  - [🆕 속도 제한](#-progress-capturing)
  - [🆕 AxiosHeaders](#-axiosheaders)
  - [🔥 Fetch 어댑터](#-fetch-adapter)
  - [Semver](#semver)
  - [Promises](#promises)
  - [TypeScript](#typescript)
  - [자료](#resources)
  - [크레딧](#credits)
  - [라이선스](#license)

## 기능

- 브라우저에서 [XMLHttpRequests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) 요청 가능
- node.js에서 [http](https://nodejs.org/api/http.html) 요청 가능
- [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API 지원
- 요청 및 응답 인터셉트
- 요청 및 응답 데이터 변환
- 요청 취소
- [JSON](https://www.json.org/json-en.html) 데이터에 대한 자동 변환
- 🆕 데이터 객체를 `multipart/form-data` 및 `x-www-form-urlencoded` 바디 인코딩으로 자동 직렬화
- [XSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) 공격으로부터 보호하기 위한 클라이언트 측 지원

## 브라우저 지원

![Chrome](https://raw.githubusercontent.com/alrra/browser-logos/main/src/chrome/chrome_48x48.png) | ![Firefox](https://raw.githubusercontent.com/alrra/browser-logos/main/src/firefox/firefox_48x48.png) | ![Safari](https://raw.githubusercontent.com/alrra/browser-logos/main/src/safari/safari_48x48.png) | ![Opera](https://raw.githubusercontent.com/alrra/browser-logos/main/src/opera/opera_48x48.png) | ![Edge](https://raw.githubusercontent.com/alrra/browser-logos/main/src/edge/edge_48x48.png) |
--- | --- | --- | --- | --- |
최신 ✔ | 최신 ✔ | 최신 ✔ | 최신 ✔ | 최신 ✔ | 11 ✔ |

[![Browser Matrix](https://saucelabs.com/open_sauce/build_matrix/axios.svg)](https://saucelabs.com/u/axios)

## 설치 방법

### 패키지 매니저

npm 사용 시:

```bash
$ npm install axios
```

bower 사용 시:

```bash
$ bower install axios
```

yarn 사용 시:

```bash
$ yarn add axios
```

pnpm 사용 시:

```bash
$ pnpm add axios
```

bun 사용 시:

```bash
$ bun add axios
```

패키지가 설치되면, `import` 또는 `require` 방식을 이용해 라이브러리를 가져올 수 있습니다:

```js
import axios, {isCancel, AxiosError} from 'axios';
```

명명된 내보내기는 Axios 팩토리에서 재내보내기된 것이므로, 기본 내보내기를 사용할 수도 있습니다:

```js
import axios from 'axios';

console.log(axios.isCancel('something'));
```

`require`로 불러오는 경우, **기본 내보내기만 사용할 수 있습니다**:

```js
const axios = require('axios');

console.log(axios.isCancel('something'));
```

일부 번들러 및 ES6 린터에서는 다음과 같이 작성해야 할 수도 있습니다:

```js
import { default as axios } from 'axios';
```

커스텀 또는 레거시 환경에서 모듈을 가져올 때 문제가 발생한 경우,
모듈 패키지를 직접 임포트하는 방법을 시도할 수 있습니다:

```js
const axios = require('axios/dist/browser/axios.cjs'); // 브라우저 commonJS 번들 (ES2017)
// const axios = require('axios/dist/node/axios.cjs'); // 노드 commonJS 번들 (ES2017)
```

### CDN

jsDelivr CDN 사용 (ES5 UMD 브라우저 모듈):

```html
<script src="https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js"></script>
```

unpkg CDN 사용:

```html
<script src="https://unpkg.com/axios@1.6.7/dist/axios.min.js"></script>
```

## 예시

> **참고**: CommonJS 사용  
> CommonJS의 `require()`로 import할 때 TypeScript 타입(인텔리센스/자동완성)을 얻으려면 다음 방법을 사용하세요:
```js
import axios from 'axios';
//const axios = require('axios'); // 레거시 방식

// 주어진 ID를 가진 사용자를 요청합니다.
axios.get('/user?ID=12345')
  .then(function (response) {
    // 성공 처리
    console.log(response);
  })
  .catch(function (error) {
    // 에러 처리
    console.log(error);
  })
  .finally(function () {
    // 항상 실행됨
  });

// 위의 요청은 다음과 같이도 할 수 있습니다.
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .finally(function () {
    // 항상 실행됨
  });

// async/await를 사용하고 싶으신가요? 외부 함수/메서드에 `async` 키워드를 추가하세요.
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
```

> **참고**: `async/await`는 ECMAScript 2017의 일부이며 Internet Explorer 및 구형 브라우저에서는 지원되지 않으므로 주의해서 사용하세요.

`POST` 요청 수행하기

```js
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

여러 동시 요청 수행하기

```js
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

Promise.all([getUserAccount(), getUserPermissions()])
  .then(function (results) {
    const acct = results[0];
    const perm = results[1];
  });
```

## axios API

관련된 config를 `axios`에 전달하여 요청을 만들 수 있습니다.

##### axios(config)

```js
// POST 요청 보내기
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});
```

```js
// node.js에서 원격 이미지를 GET 요청으로 받기
axios({
  method: 'get',
  url: 'https://bit.ly/2mTM3nY',
  responseType: 'stream'
})
  .then(function (response) {
    response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))
  });
```

##### axios(url[, config])

```js
// GET 요청 보내기 (기본 메서드)
axios('/user/12345');
```

### 요청 메서드 별칭

편의를 위해 모든 일반적인 요청 메서드에 대한 별칭이 제공됩니다.

##### axios.request(config)
##### axios.get(url[, config])
##### axios.delete(url[, config])
##### axios.head(url[, config])
##### axios.options(url[, config])
##### axios.post(url[, data[, config]])
##### axios.put(url[, data[, config]])
##### axios.patch(url[, data[, config]])

###### 참고
별칭 메서드를 사용할 때는 config에 `url`, `method`, `data` 속성을 명시할 필요가 없습니다.

### 동시성 (사용 중단됨)
아래 함수들은 `Promise.all`을 사용하여 대체해 주세요.

동시 요청을 처리하기 위한 헬퍼 함수입니다.

axios.all(iterable)
axios.spread(callback)

### 인스턴스 생성

사용자 정의 config로 새로운 axios 인스턴스를 생성할 수 있습니다.

##### axios.create([config])

```js
const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});
```

### 인스턴스 메서드

사용 가능한 인스턴스 메서드는 아래와 같습니다. 지정한 config는 인스턴스 config와 병합됩니다.

##### axios#request(config)
##### axios#get(url[, config])
##### axios#delete(url[, config])
##### axios#head(url[, config])
##### axios#options(url[, config])
##### axios#post(url[, data[, config]])
##### axios#put(url[, data[, config]])
##### axios#patch(url[, data[, config]])
##### axios#getUri([config])

## 요청 설정 (Request Config)

다음은 요청을 보낼 때 사용할 수 있는 config 옵션입니다. `url`만 필수입니다. `method`를 지정하지 않으면 기본값은 `GET`입니다.

```js
{
  // `url`은 요청에 사용할 서버 URL입니다.
  url: '/user',

  // `method`는 요청 시 사용할 HTTP 메서드입니다.
  method: 'get', // 기본값

  // `baseURL`은 `url` 앞에 붙으며, `url`이 절대경로이고 옵션 `allowAbsoluteUrls`가 true면 제외됩니다.
  // axios 인스턴스에 `baseURL`을 설정하면 해당 인스턴스의 메서드에 상대경로를 넘길 수 있습니다.
  baseURL: 'https://some-domain.com/api/',

  // `allowAbsoluteUrls`는 절대 URL이 설정된 `baseUrl`을 무시할지 여부를 결정합니다.
  // true(기본값)일 때 절대값 `url`이 `baseUrl`을 덮어씁니다.
  // false일 때는 절대값 `url`도 항상 `baseUrl`이 앞에 붙습니다.
  allowAbsoluteUrls: true,

  // `transformRequest`는 서버로 보내기 전에 요청 데이터를 변경할 수 있게 해줍니다.
  // 이 옵션은 'PUT', 'POST', 'PATCH', 'DELETE' 메서드에서만 적용됩니다.
  // 배열의 마지막 함수는 문자열, Buffer, ArrayBuffer, FormData, Stream 인스턴스 중 하나를 반환해야 합니다.
  // headers 객체를 수정할 수도 있습니다.
  transformRequest: [function (data, headers) {
    // 데이터를 원하는 대로 변환하세요
```
    return data;
  }],

  // `transformResponse`는 then/catch로 전달되기 전에 응답 데이터를 변경할 수 있도록 합니다.
  transformResponse: [function (data) {
    // 데이터를 원하는 대로 변환하세요.

    return data;
  }],

  // `headers`는 전송할 커스텀 헤더입니다.
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // `params`는 요청과 함께 전송할 URL 파라미터입니다.
  // 반드시 일반 객체 또는 URLSearchParams 객체여야 합니다.
  params: {
    ID: 12345
  },
  
  // `paramsSerializer`는 `params` 직렬화를 커스터마이즈할 수 있는 선택적 설정입니다.
  paramsSerializer: {

    // 키/값 쌍을 반복적으로 전송하는 커스텀 인코더 함수입니다.
    encode?: (param: string): string => { /* 여기서 커스텀 작업을 수행하고 변환된 문자열을 반환하세요 */ }, 
    
    // 전체 파라미터에 대한 커스텀 직렬화 함수입니다. 사용자가 1.x 이전 동작을 모방할 수 있습니다.
    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ), 
    
    // params에서 배열 인덱스 포맷을 설정하는 옵션입니다.
    indexes: false // 사용 가능한 세 가지 옵션: (1) indexes: null (대괄호 없음), (2) (기본값) indexes: false (빈 대괄호), (3) indexes: true (인덱스가 포함된 대괄호).
  },

  // `data`는 요청 본문으로 전송할 데이터입니다.
  // 'PUT', 'POST', 'DELETE', 'PATCH' 요청 메서드에만 해당됩니다.
  // `transformRequest`가 설정되지 않은 경우, 다음 타입 중 하나여야 합니다:
  // - 문자열, 일반 객체, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - 브라우저 전용: FormData, File, Blob
  // - Node 전용: Stream, Buffer, FormData (form-data 패키지)
  data: {
    firstName: 'Fred'
  },

  // 데이터 본문 전송을 위한 대체 문법
  // post 메서드
  // 키가 아닌 값만 전송됨
  data: 'Country=Brasil&City=Belo Horizonte',

  // `timeout`은 요청이 타임아웃되기 전까지의 밀리초를 지정합니다.
  // 요청이 `timeout`보다 오래 걸리면, 요청이 중단됩니다.
  timeout: 1000, // 기본값은 `0` (타임아웃 없음)

  // `withCredentials`는 교차 사이트 Access-Control 요청에서
  // 자격 증명을 사용할지 여부를 나타냅니다.
  withCredentials: false, // 기본값

  // `adapter`는 요청을 커스텀 핸들링할 수 있도록 하여 테스트가 더 쉬워집니다.
  // Promise를 반환하고 유효한 응답을 제공합니다 (lib/adapters/README.md 참고).
  adapter: function (config) {
    /* ... */
  },
  // 내장 어댑터의 이름을 설정하거나, 이름 배열을 제공하여
  // 환경에서 사용 가능한 첫 번째 것을 선택할 수 있습니다.
  adapter: 'xhr', // 'fetch' | 'http' | ['xhr', 'http', 'fetch']

  // `auth`는 HTTP Basic 인증 사용 여부와 자격 증명을 지정합니다.
  // 이 옵션을 사용하면 `Authorization` 헤더가 설정되며,
  // `headers`를 통해 설정한 기존 `Authorization` 커스텀 헤더를 덮어씁니다.
  // 오직 HTTP Basic 인증만 이 파라미터로 설정할 수 있습니다.
  // Bearer 토큰 등은 `Authorization` 커스텀 헤더를 사용하세요.
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

  // `responseType`은 서버가 응답할 데이터 타입을 지정합니다.
  // 옵션: 'arraybuffer', 'document', 'json', 'text', 'stream'
  //   브라우저 전용: 'blob'
  responseType: 'json', // 기본값

  // `responseEncoding`은 응답을 디코딩할 때 사용할 인코딩을 지정합니다 (Node.js 전용)
  // 참고: 'stream' 타입이나 클라이언트 측 요청에서는 무시됩니다.
  // 옵션: 'ascii', 'ASCII', 'ansi', 'ANSI', 'binary', 'BINARY', 'base64', 'BASE64', 'base64url',
  // 'BASE64URL', 'hex', 'HEX', 'latin1', 'LATIN1', 'ucs-2', 'UCS-2', 'ucs2', 'UCS2', 'utf-8', 'UTF-8',
  // 'utf8', 'UTF8', 'utf16le', 'UTF16LE'
  responseEncoding: 'utf8', // 기본값

  // `xsrfCookieName`은 xsrf 토큰 값으로 사용할 쿠키 이름입니다.
  xsrfCookieName: 'XSRF-TOKEN', // 기본값

  // `xsrfHeaderName`은 xsrf 토큰 값을 담는 http 헤더 이름입니다.
  xsrfHeaderName: 'X-XSRF-TOKEN', // 기본값
    
  // `undefined` (기본값) - 동일 출처 요청에만 XSRF 헤더를 설정
  withXSRFToken: boolean | undefined | ((config: InternalAxiosRequestConfig) => boolean | undefined),

  // `onUploadProgress`는 업로드 진행 이벤트를 처리할 수 있게 해줍니다.
  // 브라우저 & node.js
  onUploadProgress: function ({loaded, total, progress, bytes, estimated, rate, upload = true}) {
```markdown
    // Axios 진행 이벤트로 원하는 작업을 수행하세요
  },

  // `onDownloadProgress`는 다운로드에 대한 진행 이벤트를 처리할 수 있게 해줍니다
  // 브라우저 & node.js
  onDownloadProgress: function ({loaded, total, progress, bytes, estimated, rate, download = true}) {
    // Axios 진행 이벤트로 원하는 작업을 수행하세요
  },

  // `maxContentLength`는 node.js에서 허용되는 http 응답 콘텐츠의 최대 크기(바이트 단위)를 정의합니다
  maxContentLength: 2000,

  // `maxBodyLength` (Node 전용 옵션)는 node.js에서 허용되는 http 요청 콘텐츠의 최대 크기(바이트 단위)를 정의합니다
  maxBodyLength: 2000,

  // `validateStatus`는 주어진 HTTP 응답 상태 코드에 대해 프라미스를 resolve할지 reject할지를 정의합니다.
  // `validateStatus`가 `true`를 반환하거나 `null`, `undefined`로 설정되면 프라미스는 resolve됩니다.
  // 그렇지 않으면 프라미스는 reject됩니다.
  validateStatus: function (status) {
    return status >= 200 && status < 300; // 기본값
  },

  // `maxRedirects`는 node.js에서 따라갈 최대 리디렉션 횟수를 정의합니다.
  // 0으로 설정하면 리디렉션을 따라가지 않습니다.
  maxRedirects: 21, // 기본값

  // `beforeRedirect`는 리디렉션 전에 호출되는 함수를 정의합니다.
  // 리디렉션 시 요청 옵션을 조정하거나,
  // 최신 응답 헤더를 검사하거나,
  // 에러를 throw하여 요청을 취소할 수 있습니다.
  // maxRedirects가 0으로 설정된 경우 `beforeRedirect`는 사용되지 않습니다.
  beforeRedirect: (options, { headers }) => {
    if (options.hostname === "example.com") {
      options.auth = "user:password";
    }
  },

  // `socketPath`는 node.js에서 사용할 UNIX 소켓을 정의합니다.
  // 예: '/var/run/docker.sock'를 통해 도커 데몬에 요청을 보낼 수 있습니다.
  // `socketPath`와 `proxy` 중 하나만 지정할 수 있습니다.
  // 둘 다 지정된 경우, `socketPath`가 사용됩니다.
  socketPath: null, // 기본값
  
  // `transport`는 요청을 수행할 때 사용할 전송 방식을 결정합니다.
  // 정의되어 있으면 해당 방식을 사용합니다. 그렇지 않고 `maxRedirects`가 0이면,
  // `protocol`에 지정된 프로토콜에 따라 기본 `http` 또는 `https` 라이브러리를 사용합니다.
  // 그렇지 않으면, 다시 프로토콜에 따라 리디렉션을 처리할 수 있는
  // `httpFollow` 또는 `httpsFollow` 라이브러리를 사용합니다.
  transport: undefined, // 기본값

  // `httpAgent`와 `httpsAgent`는 node.js에서 각각 http와 https 요청을 수행할 때 사용할 커스텀 에이전트를 정의합니다.
  // 이를 통해 Node.js v19.0.0 이전에는 기본적으로 활성화되지 않은 `keepAlive` 같은 옵션을 추가할 수 있습니다.
  // Node.js v19.0.0 이후에는 `http.globalAgent`가 기본적으로 `keepAlive`를 활성화하므로 별도 설정이 필요 없습니다.
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),

  // `proxy`는 프록시 서버의 호스트명, 포트, 프로토콜을 정의합니다.
  // 일반적인 `http_proxy` 및 `https_proxy` 환경 변수를 사용해 프록시를 정의할 수도 있습니다.
  // 환경 변수를 사용하는 경우, 프록시를 사용하지 않을 도메인을 쉼표로 구분해 나열한 `no_proxy` 환경 변수도 정의할 수 있습니다.
  // 프록시를 비활성화하려면 `false`로 설정하면 환경 변수를 무시합니다.
  // `auth`는 프록시 연결 시 HTTP Basic 인증을 사용해야 함을 나타내며,
  // 인증 정보를 제공합니다.
  // 이 옵션을 사용하면 `Proxy-Authorization` 헤더가 설정되며,
  // `headers`를 통해 커스텀으로 설정한 기존 `Proxy-Authorization` 헤더를 덮어씁니다.
  // 프록시 서버가 HTTPS를 사용하는 경우, 프로토콜을 반드시 `https`로 설정해야 합니다.
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    // hostname: '127.0.0.1' // 'host'와 둘 다 정의된 경우, 'hostname'이 우선 적용됩니다
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  // `cancelToken`은 요청을 취소하는 데 사용할 수 있는 취소 토큰을 지정합니다
  // (자세한 내용은 아래의 취소(Cancellation) 섹션 참고)
  cancelToken: new CancelToken(function (cancel) {
  }),

  // AbortController를 사용한 Axios 요청 취소의 대체 방법
  signal: new AbortController().signal,

  // `decompress`는 응답 본문을 자동으로 압축 해제할지 여부를 나타냅니다.
  // `true`로 설정하면 압축 해제된 모든 응답 객체에서 'content-encoding' 헤더도 제거됩니다.
  // - Node 전용 (XHR에서는 압축 해제를 끌 수 없음)
  decompress: true, // 기본값

  // `insecureHTTPParser` 불리언.
  // 유효하지 않은 HTTP 헤더를 허용하는 비보안 HTTP 파서를 사용할지 여부를 나타냅니다.
  // 이는 표준을 준수하지 않는 HTTP 구현과의 상호 운용성을 허용할 수 있습니다.
  // 비보안 파서 사용은 가급적 피해야 합니다.
  // 옵션 참고: https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback
```
```js
  // 참고: https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none
  insecureHTTPParser: undefined, // 기본값

  // 향후 버전에서 제거될 수 있는 하위 호환성 전이적 옵션
  transitional: {
    // 조용한 JSON 파싱 모드
    // `true`  - JSON 파싱 오류를 무시하고 파싱에 실패하면 response.data를 null로 설정 (이전 동작)
    // `false` - JSON 파싱에 실패하면 SyntaxError를 throw (참고: responseType이 'json'이어야 함)
    silentJSONParsing: true, // 현재 Axios 버전의 기본값

    // `responseType`이 'json'이 아니더라도 응답 문자열을 JSON으로 파싱 시도
    forcedJSONParsing: true,

    // 요청 타임아웃 시 일반 ECONNABORTED 대신 ETIMEDOUT 오류를 throw
    clarifyTimeoutError: false,
  },

  env: {
    // 페이로드를 자동으로 FormData 객체로 직렬화하기 위해 사용할 FormData 클래스
    FormData: window?.FormData || global?.FormData
  },

  formSerializer: {
      visitor: (value, key, path, helpers) => {}, // 폼 값을 직렬화하는 커스텀 visitor 함수
      dots: boolean, // brackets 대신 dot 포맷 사용
      metaTokens: boolean, // 파라미터 키의 {}와 같은 특수 엔딩 유지
      indexes: boolean, // 배열 인덱스 포맷 null - 괄호 없음, false - 빈 괄호, true - 인덱스가 있는 괄호
  },

  // http 어댑터 전용 (node.js)
  maxRate: [
    100 * 1024, // 100KB/s 업로드 제한,
    100 * 1024  // 100KB/s 다운로드 제한
  ]
}
```

## 응답 스키마

요청에 대한 응답에는 다음 정보가 포함됩니다.

```js
{
  // `data`는 서버에서 제공한 응답 데이터입니다.
  data: {},

  // `status`는 서버 응답의 HTTP 상태 코드입니다.
  status: 200,

  // `statusText`는 서버 응답의 HTTP 상태 메시지입니다.
  statusText: 'OK',

  // `headers`는 서버가 응답한 HTTP 헤더입니다.
  // 모든 헤더 이름은 소문자이며 bracket 표기법으로 접근할 수 있습니다.
  // 예시: `response.headers['content-type']`
  headers: {},

  // `config`는 요청을 위해 `axios`에 제공된 설정입니다.
  config: {},

  // `request`는 이 응답을 생성한 요청 객체입니다.
  // 리다이렉트 시 node.js에서는 마지막 ClientRequest 인스턴스,
  // 브라우저에서는 XMLHttpRequest 인스턴스입니다.
  request: {}
}
```

`then`을 사용할 때, 다음과 같이 응답을 받을 수 있습니다:

```js
axios.get('/user/12345')
  .then(function (response) {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });
```

`catch`를 사용하거나 [rejection 콜백](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)을 `then`의 두 번째 매개변수로 전달하면, [오류 처리](#handling-errors) 섹션에 설명된 대로 `error` 객체를 통해 응답에 접근할 수 있습니다.

## Config 기본값

모든 요청에 적용될 config 기본값을 지정할 수 있습니다.

### 전역 axios 기본값

```js
axios.defaults.baseURL = 'https://api.example.com';

// 중요: axios가 여러 도메인에서 사용될 경우, AUTH_TOKEN이 모든 도메인에 전송됩니다.
// 아래의 Custom instance defaults 예제를 참고하세요.
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;

axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
```

### Custom instance defaults
```
```js
// 인스턴스 생성 시 기본 설정값 지정
const instance = axios.create({
  baseURL: 'https://api.example.com'
});

// 인스턴스 생성 후 기본값 변경
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;
```

### 설정값 우선순위

설정값은 우선순위에 따라 병합됩니다. 우선순위는 [lib/defaults/index.js](https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49)에서 찾을 수 있는 라이브러리 기본값, 그 다음은 인스턴스의 `defaults` 속성, 마지막으로 요청에 대한 `config` 인자입니다. 후자가 전자보다 우선합니다. 다음은 예시입니다.

```js
// 라이브러리에서 제공하는 기본 설정값을 이용해 인스턴스 생성
// 이 시점에서 timeout 값은 라이브러리의 기본값인 `0`입니다
const instance = axios.create();

// 라이브러리의 timeout 기본값을 재정의
// 이제 이 인스턴스를 사용하는 모든 요청은 2.5초 동안 대기 후 timeout이 발생합니다
instance.defaults.timeout = 2500;

// 해당 요청이 오래 걸릴 것으로 예상되어 timeout을 재정의
instance.get('/longRequest', {
  timeout: 5000
});
```

## 인터셉터(Interceptors)

`then`이나 `catch`로 처리되기 전에 요청 또는 응답을 가로챌 수 있습니다.

```js

const instance = axios.create();

// 요청 인터셉터 추가
instance.interceptors.request.use(function (config) {
    // 요청이 전송되기 전에 작업 수행
    return config;
  }, function (error) {
    // 요청 오류가 발생했을 때 작업 수행
    return Promise.reject(error);
  });

// 응답 인터셉터 추가
instance.interceptors.response.use(function (response) {
    // 2xx 범위 내의 상태 코드는 이 함수가 실행되도록 함
    // 응답 데이터로 작업 수행
    return response;
  }, function (error) {
    // 2xx 범위 밖의 상태 코드는 이 함수가 실행되도록 함
    // 응답 오류로 작업 수행
    return Promise.reject(error);
  });
```

나중에 인터셉터를 제거해야 한다면 가능합니다.

```js
const instance = axios.create();
const myInterceptor = instance.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

요청 또는 응답에 대한 모든 인터셉터를 제거할 수도 있습니다.
```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
instance.interceptors.request.clear(); // 요청에서 인터셉터 제거
instance.interceptors.response.use(function () {/*...*/});
instance.interceptors.response.clear(); // 응답에서 인터셉터 제거
```

axios의 사용자 정의 인스턴스에도 인터셉터를 추가할 수 있습니다.

```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
```

요청 인터셉터를 추가할 때, 기본적으로 비동기로 간주됩니다. 이로 인해 메인 스레드가 막힐 때 axios 요청 실행이 지연될 수 있습니다(인터셉터 내부적으로 promise가 생성되고 요청이 콜 스택의 가장 아래로 밀림). 만약 요청 인터셉터가 동기라면 옵션 객체에 플래그를 추가해 axios가 코드를 동기로 실행하도록 하여 요청 실행의 지연을 방지할 수 있습니다.

```js
axios.interceptors.request.use(function (config) {
  config.headers.test = 'I am only a header!';
  return config;
}, null, { synchronous: true });
```

실행 시점에 따라 특정 인터셉터를 실행하고 싶다면, 옵션 객체에 `runWhen` 함수를 추가할 수 있습니다. `runWhen`의 반환값이 `false`일 경우에만 요청 인터셉터가 실행되지 **않습니다**. 이 함수는 config 객체를 인자로 호출됩니다(여기에 사용자 인자를 바인딩할 수도 있습니다). 이는 특정 시점에만 실행되어야 하는 비동기 요청 인터셉터가 있을 때 유용합니다.
```
```js
function onGetCall(config) {
  return config.method === 'get';
}
axios.interceptors.request.use(function (config) {
  config.headers.test = 'special get headers';
  return config;
}, null, { runWhen: onGetCall });
```

> **참고:** options 파라미터(`synchronous`와 `runWhen` 속성을 가짐)는 현재로서는 요청 인터셉터에만 지원됩니다.

### 다중 인터셉터

여러 개의 응답 인터셉터를 추가했을 때  
그리고 응답이 성공적으로 완료되었을 때
- 각 인터셉터가 실행됩니다.
- 추가된 순서대로 실행됩니다.
- 마지막 인터셉터의 결과만 반환됩니다.
- 각 인터셉터는 바로 이전 인터셉터의 결과를 전달받습니다.
- 그리고 만약 성공 인터셉터에서 예외가 발생하면
    - 그 다음 성공 인터셉터는 호출되지 않습니다.
    - 그 다음 실패(거부) 인터셉터가 호출됩니다.
    - 한 번 예외가 처리되면, 그 다음 성공 인터셉터가 다시 호출됩니다(프로미스 체인과 동일).

이 모든 내용을 코드로 확인하려면 [인터셉터 테스트](https://raw.githubusercontent.com/axios/axios/v1.x/./test/specs/interceptors.spec.js)를 참고하세요.

## 에러 유형

axios에서 발생할 수 있는 다양한 에러 메시지는 에러의 구체적인 정보와 디버깅 기회를 제공할 수 있습니다.

axios 에러의 일반적인 구조는 다음과 같습니다:
| 속성      | 정의  |
| -------- | ----------  |
| message  | 에러 메시지의 간략한 요약과 실패한 상태 코드. |
| name     | 에러가 발생한 위치를 정의. axios의 경우 항상 'AxiosError'입니다. |
| stack    | 에러의 스택 트레이스를 제공합니다. | 
| config   | 요청이 발생했을 때 사용자가 정의한 특정 인스턴스 구성이 담긴 axios config 객체 |
| code     | axios에서 식별한 에러를 나타냅니다. 아래 표는 내부 axios 에러의 구체적 정의를 나열합니다. |
| status   | HTTP 응답 상태 코드. 일반적인 HTTP 응답 상태 코드 의미는 [여기](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)에서 확인하세요.

아래는 axios에서 식별할 수 있는 에러 목록입니다:

| 코드                      | 정의                                                                                                                                                                                                                                                                                                                                                                                     |
| --- | --- |
| ERR_BAD_OPTION_VALUE      | axios 설정에서 잘못된 값이 제공됨.                                                                                                                                                                                                                                                                                                                                                 |
| ERR_BAD_OPTION            | axios 설정에서 잘못된 옵션이 제공됨.                                                                                                                                                                                                                                                                                                                                                |
| ERR_NOT_SUPPORT           | 현재 axios 환경에서 지원되지 않는 기능 또는 메서드입니다.                                                                                                                                                                                                                                                                                                                              |
| ERR_DEPRECATED            | axios에서 더 이상 사용되지 않는 기능 또는 메서드가 사용됨.                                                                                                                                                                                                                                                                                                                                                    |
| ERR_INVALID_URL           | axios 요청에 잘못된 URL이 제공됨.                                                                                                                                                                                                                                                                                                                                                        |
| ECONNABORTED              | 보통 요청이 타임아웃되었을 때(단, `transitional.clarifyTimeoutError`가 설정되지 않은 경우) 또는 브라우저나 브라우저 플러그인에 의해 중단된 경우에 발생합니다.                                                                                                                                                                                                                                            |
| ERR_CANCELED              | AbortSignal(또는 CancelToken)을 사용하여 사용자가 명시적으로 기능이나 메서드를 취소한 경우 발생합니다.                                                                                                                                                                                                                                                                                                  |
| ETIMEDOUT                 | 기본 axios 시간 제한을 초과하여 요청이 타임아웃된 경우 발생합니다. `transitional.clarifyTimeoutError`가 `true`로 설정되어야 하며, 그렇지 않으면 일반적인 `ECONNABORTED` 에러가 대신 발생합니다.                                                                                                                                                                                                         |
| ERR_NETWORK               | 네트워크 관련 문제입니다. 브라우저에서는 [CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/CORS) 또는 [Mixed Content](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content) 정책 위반으로도 발생할 수 있습니다. 브라우저는 보안 문제로 인해 JS 코드가 실제 에러 원인을 확인할 수 없으니, 콘솔을 확인하세요. |
| ERR_FR_TOO_MANY_REDIRECTS | 요청이 너무 많이 리디렉션되어, axios 설정에서 지정한 최대 리디렉션 수를 초과함.                                                                                                                                                                                                                                                                                                  |
| ERR_BAD_RESPONSE          | 응답을 올바르게 파싱할 수 없거나 예상치 못한 형식임. 보통 `5xx` 상태 코드와 관련됨.                                                                                                                                                                                                                                                                          |
| ERR_BAD_REQUEST           | 요청이 예상치 못한 형식이거나 필수 파라미터가 누락됨. 보통 `4xx` 상태 코드와 관련됨.                                                                                                                                                                                                                                                                    |

## 에러 처리

기본 동작은 2xx 범위를 벗어나는 상태 코드로 반환된 모든 응답에 대해 거부하고, 이를 에러로 처리합니다.

```js
axios.get('/user/12345')
  .catch(function (error) {
    if (error.response) {
      // 요청이 이루어졌고 서버가 2xx 범위를 벗어나는 상태 코드로 응답함
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    } else if (error.request) {
      // 요청이 이루어졌으나 응답을 받지 못함
      // `error.request`는 브라우저에서는 XMLHttpRequest의 인스턴스이고,
      // node.js에서는 http.ClientRequest의 인스턴스입니다.
      console.log(error.request);
    } else {
      // 요청을 설정하는 중에 에러가 발생함
      console.log('Error', error.message);
    }
    console.log(error.config);
  });
```

`validateStatus` 설정 옵션을 사용하면 기본 조건(status >= 200 && status < 300)을 오버라이드하고, 에러를 발생시킬 HTTP 코드(들)를 직접 정의할 수 있습니다.

```js
axios.get('/user/12345', {
  validateStatus: function (status) {
    return status < 500; // 상태 코드가 500보다 작을 때만 resolve
  }
})
```

`toJSON`을 사용하면 HTTP 에러에 대한 더 많은 정보를 가진 객체를 얻을 수 있습니다.

```js
axios.get('/user/12345')
  .catch(function (error) {
    console.log(error.toJSON());
```
```markdown
  });
```

## 요청 취소

### AbortController

`v0.22.0`부터 Axios는 fetch API 방식으로 요청을 취소할 수 있도록 AbortController를 지원합니다:

```js
const controller = new AbortController();

axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 요청 취소
controller.abort()
```

### CancelToken `👎deprecated`

*CancelToken*을 사용하여 요청을 취소할 수도 있습니다.

> axios cancel token API는 철회된 [cancellable promises proposal](https://github.com/tc39/proposal-cancelable-promises)을 기반으로 합니다.

> 이 API는 v0.22.0부터 deprecated 되었으며, 신규 프로젝트에서는 사용하지 않는 것이 좋습니다.

다음과 같이 `CancelToken.source` 팩토리를 사용하여 cancel token을 생성할 수 있습니다:

```js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function (thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Request canceled', thrown.message);
  } else {
    // 에러 처리
  }
});

axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})

// 요청 취소 (message 파라미터는 선택 사항)
source.cancel('Operation canceled by the user.');
```

`CancelToken` 생성자에 executor 함수를 전달하여 cancel token을 만들 수도 있습니다:

```js
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 함수는 cancel 함수를 파라미터로 받습니다
    cancel = c;
  })
});

// 요청 취소
cancel();
```

> **참고:** 동일한 cancel token/abort controller로 여러 요청을 취소할 수 있습니다.
> Axios 요청 시작 시점에 취소 토큰이 이미 취소된 상태라면, 실제 요청 시도 없이 즉시 취소됩니다.

> 전환 기간 동안 두 가지 취소 API를 동시에, 심지어 동일한 요청에 대해서도 사용할 수 있습니다:

## `application/x-www-form-urlencoded` 포맷 사용

### URLSearchParams

기본적으로 axios는 자바스크립트 객체를 `JSON`으로 직렬화합니다. [`application/x-www-form-urlencoded` 포맷](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)으로 데이터를 전송하려면, 대부분의 브라우저와 [Node](https://nodejs.org/api/url.html#url_class_urlsearchparams) v10(2018년 출시) 이상에서 지원되는 [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) API를 사용할 수 있습니다.

```js
const params = new URLSearchParams({ foo: 'bar' });
params.append('extraparam', 'value');
axios.post('/foo', params);
```

### 쿼리 문자열 (구형 브라우저)

매우 구형 브라우저와의 호환성을 위해 [polyfill](https://github.com/WebReflection/url-search-params)이 제공됩니다(글로벌 환경에 polyfill을 적용해야 합니다).

또는, [`qs`](https://github.com/ljharb/qs) 라이브러리를 사용하여 데이터를 인코딩할 수도 있습니다:

```js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
```
```
또는 다른 방식(ES6)으로,

```js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
```

### 구버전 Node.js

구버전 Node.js 엔진에서는 [`querystring`](https://nodejs.org/api/querystring.html) 모듈을 다음과 같이 사용할 수 있습니다:

```js
const querystring = require('querystring');
axios.post('https://something.com/', querystring.stringify({ foo: 'bar' }));
```

[`qs`](https://github.com/ljharb/qs) 라이브러리도 사용할 수 있습니다.

> **참고**: 중첩 객체를 문자열로 변환해야 하는 경우에는 `querystring` 방식에 [알려진 문제](https://github.com/nodejs/node-v0.x-archive/issues/1665)가 있으므로, `qs` 라이브러리를 사용하는 것이 더 좋습니다.

### 🆕 URLSearchParams로 자동 직렬화

Axios는 content-type 헤더가 "application/x-www-form-urlencoded"로 설정되어 있으면 data 객체를 자동으로 urlencoded 형식으로 직렬화합니다.

```js
const data = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
};

await axios.postForm('https://postman-echo.com/post', data,
  {headers: {'content-type': 'application/x-www-form-urlencoded'}}
);
```

서버에서는 다음과 같이 처리됩니다:

```js
  {
    x: '1',
    'arr[]': [ '1', '2', '3' ],
    'arr2[0]': '1',
    'arr2[1][0]': '2',
    'arr2[2]': '3',
    'arr3[]': [ '1', '2', '3' ],
    'users[0][name]': 'Peter',
    'users[0][surname]': 'griffin',
    'users[1][name]': 'Thomas',
    'users[1][surname]': 'Anderson'
  }
````

백엔드의 body-parser(`express.js`의 `body-parser` 등)가 중첩 객체 디코딩을 지원한다면, 서버 측에서 동일한 객체를 자동으로 얻을 수 있습니다

```js
  var app = express();

  app.use(bodyParser.urlencoded({ extended: true })); // 인코딩된 바디 지원

  app.post('/', function (req, res, next) {
     // body를 JSON으로 반환
     res.send(JSON.stringify(req.body));
  });

  server = app.listen(3000);
```

## `multipart/form-data` 형식 사용하기

### FormData

데이터를 `multipart/formdata`로 전송하려면 formData 인스턴스를 페이로드로 전달해야 합니다.
Axios는 페이로드 타입을 기반으로 Content-Type 헤더를 자동으로 추측하기 때문에 별도의 설정이 필요 없습니다.

```js
const formData = new FormData();
formData.append('foo', 'bar');

axios.post('https://httpbin.org/post', formData);
```

node.js에서는 [`form-data`](https://github.com/form-data/form-data) 라이브러리를 다음과 같이 사용할 수 있습니다:

```js
const FormData = require('form-data');

const form = new FormData();
form.append('my_field', 'my value');
form.append('my_buffer', new Buffer(10));
form.append('my_file', fs.createReadStream('/foo/bar.jpg'));
```
axios.post('https://example.com', form)
```

### 🆕 FormData로의 자동 직렬화

`v0.27.0`부터 Axios는 요청의 `Content-Type` 헤더가 `multipart/form-data`로 설정된 경우 객체를 FormData 객체로 자동 직렬화하는 기능을 지원합니다.

다음과 같은 요청은 데이터를 FormData 형식으로 전송합니다 (브라우저 & Node.js):

```js
import axios from 'axios';

axios.post('https://httpbin.org/post', {x: 1}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));
```

`node.js` 빌드에서는 기본적으로 ([`form-data`](https://github.com/form-data/form-data)) 폴리필이 사용됩니다.

`env.FormData` 구성 변수를 설정하여 FormData 클래스를 오버로드할 수 있지만,
대부분의 경우에는 필요하지 않습니다:

```js
const axios = require('axios');
var FormData = require('form-data');

axios.post('https://httpbin.org/post', {x: 1, buf: new Buffer(10)}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));
```

Axios FormData 직렬화기는 다음과 같은 특수 접미사를 지원합니다:

- `{}` - 값을 JSON.stringify로 직렬화합니다.
- `[]` - 배열 형태의 객체를 동일한 키를 가진 개별 필드로 풀어서 추가합니다.

> **참고**: 배열 및 FileList 객체에는 기본적으로 풀어서/확장하는 동작이 사용됩니다.

FormData 직렬화기는 드물게 발생하는 경우를 처리하기 위해 `config.formSerializer: object` 속성을 통한 추가 옵션을 지원합니다:

- `visitor: Function` - 사용자가 정의한 방문자 함수로, 사용자 정의 규칙을 따라 데이터를 재귀적으로 FormData 객체로 직렬화할 때 호출됩니다.

- `dots: boolean = false` - 배열 및 객체를 직렬화할 때 대괄호 대신 점 표기법(dot notation)을 사용합니다.

- `metaTokens: boolean = true` - FormData 키에 특수 접미사(예: `user{}: '{"name": "John"}'`)를 추가합니다.
백엔드 body-parser가 이 메타정보를 사용하여 값을 자동으로 JSON으로 파싱할 수 있습니다.

- `indexes: null|false|true = false` - `flat` 배열 형태의 객체에서 풀어진 키에 인덱스를 어떻게 추가할지 제어합니다.

    - `null` - 대괄호를 추가하지 않음 (`arr: 1`, `arr: 2`, `arr: 3`)
    - `false`(기본값) - 빈 대괄호 추가 (`arr[]: 1`, `arr[]: 2`, `arr[]: 3`)
    - `true` - 인덱스가 포함된 대괄호 추가  (`arr[0]: 1`, `arr[1]: 2`, `arr[2]: 3`)

예를 들어 아래와 같은 객체가 있다고 가정해 봅시다:

```js
const obj = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
  'obj2{}': [{x:1}]
};
```

Axios 직렬화기는 내부적으로 다음과 같은 단계를 수행합니다:

```js
const formData = new FormData();
formData.append('x', '1');
formData.append('arr[]', '1');
formData.append('arr[]', '2');
formData.append('arr[]', '3');
formData.append('arr2[0]', '1');
formData.append('arr2[1][0]', '2');
formData.append('arr2[2]', '3');
formData.append('users[0][name]', 'Peter');
formData.append('users[0][surname]', 'Griffin');
formData.append('users[1][name]', 'Thomas');
formData.append('users[1][surname]', 'Anderson');
formData.append('obj2{}', '[{"x":1}]');
```

Axios는 다음과 같은 단축 메서드를 지원합니다: `postForm`, `putForm`, `patchForm`
이들은 각각의 http 메서드와 동일하지만, `Content-Type` 헤더가 `multipart/form-data`로 미리 설정되어 있습니다.

## 파일 전송

단일 파일을 쉽게 전송할 수 있습니다:

```js
await axios.postForm('https://httpbin.org/post', {
  'myVar' : 'foo',
  'file': document.querySelector('#fileInput').files[0]
});
```

또는 여러 파일을 `multipart/form-data`로 전송할 수 있습니다:

```js
await axios.postForm('https://httpbin.org/post', {
  'files[]': document.querySelector('#fileInput').files
});
```

`FileList` 객체를 직접 전달할 수 있습니다:

```js
await axios.postForm('https://httpbin.org/post', document.querySelector('#fileInput').files)
```

모든 파일은 동일한 필드 이름 `files[]`로 전송됩니다.

## 🆕 HTML 폼 전송 (브라우저)

HTML Form 요소를 payload로 전달하여 `multipart/form-data` 콘텐츠로 제출할 수 있습니다.

```js
await axios.postForm('https://httpbin.org/post', document.querySelector('#htmlForm'));
```

`FormData` 및 `HTMLForm` 객체도 `Content-Type` 헤더를 `application/json`으로 명시적으로 설정하면 `JSON`으로 전송할 수 있습니다:

```js
await axios.post('https://httpbin.org/post', document.querySelector('#htmlForm'), {
  headers: {
    'Content-Type': 'application/json'
  }
})
```

예를 들어, 아래와 같은 Form이 있을 때

```html
<form id="form">
  <input type="text" name="foo" value="1">
  <input type="text" name="deep.prop" value="2">
  <input type="text" name="deep prop spaced" value="3">
  <input type="text" name="baz" value="4">
  <input type="text" name="baz" value="5">

  <select name="user.age">
    <option value="value1">Value 1</option>
    <option value="value2" selected>Value 2</option>
    <option value="value3">Value 3</option>
  </select>

  <input type="submit" value="Save">
</form>
```

다음과 같은 JSON 객체로 제출됩니다:

```js
{
  "foo": "1",
  "deep": {
    "prop": {
      "spaced": "3"
    }
  },
  "baz": [
    "4",
    "5"
  ],
  "user": {
    "age": "value2"
  }
}
````

`Blobs`/`Files`를 JSON(`base64`)으로 전송하는 것은 현재 지원되지 않습니다.

## 🆕 진행 상황 캡처

Axios는 브라우저와 Node 환경 모두에서 요청 업로드/다운로드 진행 상황을 캡처하는 기능을 지원합니다.
진행 상황 이벤트의 빈도는 초당 최대 3회로 제한됩니다.

```js    
await axios.post(url, data, {
  onUploadProgress: function (axiosProgressEvent) {
    /*{
      loaded: number;
      total?: number;
      progress?: number; // 범위 [0..1]
      bytes: number; // 마지막 트리거 이후 전송된 바이트 수(델타)
      estimated?: number; // 예상 시간(초)
      rate?: number; // 업로드 속도(바이트)
      upload: true; // 업로드 여부 표시
    }*/
  },

  onDownloadProgress: function (axiosProgressEvent) {
    /*{
```js
      loaded: number;
      total?: number;
      progress?: number;
      bytes: number; 
      estimated?: number;
      rate?: number; // 다운로드 속도 (바이트 단위)
      download: true; // 다운로드 표시
    }*/
  }
});  
```

Node.js에서 스트림 업로드/다운로드 진행 상황도 추적할 수 있습니다:

```js
const {data} = await axios.post(SERVER_URL, readableStream, {
   onUploadProgress: ({progress}) => {
     console.log((progress * 100).toFixed(2));
   },
  
   headers: {
    'Content-Length': contentLength
   },

   maxRedirects: 0 // 전체 스트림 버퍼링 방지
});
````

> **참고:**
> FormData 업로드 진행 상황 캡처는 현재 node.js 환경에서는 지원되지 않습니다.

> **⚠️ 경고**
> **node.js** 환경에서 스트림 업로드 시 maxRedirects: 0으로 리다이렉트 비활성화를 권장합니다.
> follow-redirects 패키지는 "backpressure" 알고리즘을 따르지 않고 전체 스트림을 RAM에 버퍼링하기 때문입니다.


## 🆕 속도 제한 (Rate limiting)

다운로드 및 업로드 속도 제한은 오직 http 어댑터(node.js)에서만 설정할 수 있습니다:

```js
const {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {
  onUploadProgress: ({progress, rate}) => {
    console.log(`업로드 [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)
  },
   
  maxRate: [100 * 1024], // 100KB/s 제한
});
```

## 🆕 AxiosHeaders

Axios는 Map과 유사한 API를 사용하여 헤더를 조작할 수 있는 자체 `AxiosHeaders` 클래스를 제공합니다. 이는 대소문자 구분 없이 동작함을 보장합니다.
HTTP는 헤더에서 대소문자를 구분하지 않지만, Axios는 원본 헤더의 대소문자를 스타일상 이유와 서버가 헤더의 대소문자를 잘못 처리하는 경우에 대비하여 유지합니다.
헤더 객체를 직접 조작하는 이전 방식도 여전히 사용할 수 있지만, 이는 더 이상 권장되지 않으며 앞으로는 사용이 중단될 예정입니다.

### 헤더 다루기

AxiosHeaders 객체 인스턴스는 설정 및 병합 로직을 제어하는 다양한 유형의 내부 값을 가질 수 있습니다.
최종적으로 Axios가 `toJSON` 메서드를 호출하여 문자열 값만 포함하는 헤더 객체를 얻습니다.

> 참고: 여기서 JSON이란 네트워크 전송을 위해 오직 문자열 값만을 가지는 객체를 의미합니다.

헤더 값은 다음 중 하나일 수 있습니다:
- `string` - 서버로 전송될 일반 문자열 값
- `null` - JSON으로 렌더링 시 헤더 제외
- `false` - JSON으로 렌더링 시 헤더 제외, 또한 `set` 메서드 호출 시 `rewrite` 옵션을 true로 지정해야만 이 값을 덮어쓸 수 있음을 의미
  (Axios는 내부적으로 사용자가 `User-Agent`나 `Content-Type`과 같은 특정 헤더의 자동 설치를 선택 해제할 수 있도록 이 값을 사용)
- `undefined` - 값이 설정되지 않음

> 참고: 헤더 값이 undefined가 아니면 설정된 것으로 간주합니다.

헤더 객체는 항상 인터셉터 및 트랜스포머 내부에서 초기화됩니다:

```ts
  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {
      request.headers.set('My-header', 'value');

      request.headers.set({
        "My-set-header1": "my-set-value1",
        "My-set-header2": "my-set-value2"
      });
      
      request.headers.set('User-Agent', false); // 이후 Axios가 해당 헤더를 설정하지 않도록 비활성화

      request.headers.setContentType('text/plain');
    
      request.headers['My-set-header2'] = 'newValue' // 직접 접근은 더 이상 권장되지 않음
    
      return request;
    }
  );
````

`for...of` 문을 사용하여 `AxiosHeaders` 인스턴스를 순회할 수 있습니다:

````js
const headers = new AxiosHeaders({
  foo: '1',
```
````
  bar: '2',
  baz: '3'
});

for(const [header, value] of headers) {
  console.log(header, value);
}

// foo 1
// bar 2
// baz 3
````

### new AxiosHeaders(headers?)

새로운 `AxiosHeaders` 인스턴스를 생성합니다.

```
constructor(headers?: RawAxiosHeaders | AxiosHeaders | string);
```

headers 객체가 문자열인 경우, RAW HTTP 헤더로 파싱됩니다.

````js
const headers = new AxiosHeaders(`
Host: www.bing.com
User-Agent: curl/7.54.0
Accept: */*`);

console.log(headers);

// Object [AxiosHeaders] {
//   host: 'www.bing.com',
//   'user-agent': 'curl/7.54.0',
//   accept: '*/*'
// }
````

### AxiosHeaders#set

```ts
set(headerName, value: Axios, rewrite?: boolean);
set(headerName, value, rewrite?: (this: AxiosHeaders, value: string, name: string, headers: RawAxiosHeaders) => boolean);
set(headers?: RawAxiosHeaders | AxiosHeaders | string, rewrite?: boolean);
```

`rewrite` 인자는 덮어쓰기 동작을 제어합니다:
- `false` - 헤더 값이 이미 설정되어 있으면(값이 `undefined`가 아니면) 덮어쓰지 않음
- `undefined` (기본값) - 값이 `false`로 설정되지 않았다면 헤더를 덮어씀
- `true` - 무조건 덮어씀

이 옵션은 값이 덮어써져야 하는지를 결정하는 사용자 정의 함수도 받을 수 있습니다.

`this`를 반환합니다.

### AxiosHeaders#get(header)

```
  get(headerName: string, matcher?: true | AxiosHeaderMatcher): AxiosHeaderValue;
  get(headerName: string, parser: RegExp): RegExpExecArray | null;
````

헤더의 내부 값을 반환합니다. 추가 인자를 받아, `RegExp.exec`, matcher 함수 또는 내부 키-값 파서로 헤더 값을 파싱할 수 있습니다.

```ts
const headers = new AxiosHeaders({
  'Content-Type': 'multipart/form-data; boundary=Asrf456BGe4h'
});

console.log(headers.get('Content-Type')); 
// multipart/form-data; boundary=Asrf456BGe4h

console.log(headers.get('Content-Type', true)); // \s,;= 구분자로 분리된 문자열에서 키-값 쌍을 파싱:
// [Object: null prototype] {
//   'multipart/form-data': undefined,
//    boundary: 'Asrf456BGe4h'
// }


console.log(headers.get('Content-Type', (value, name, headers) => {
  return String(value).replace(/a/g, 'ZZZ');
}));
// multipZZZrt/form-dZZZtZZZ; boundZZZry=Asrf456BGe4h

console.log(headers.get('Content-Type', /boundary=(\w+)/)?.[0]);
// boundary=Asrf456BGe4h

```

헤더의 값을 반환합니다.

### AxiosHeaders#has(header, matcher?)

```
has(header: string, matcher?: AxiosHeaderMatcher): boolean;
```

해당 헤더가 설정되어 있다면(값이 `undefined`가 아니면) `true`를 반환합니다.
````
### AxiosHeaders#delete(header, matcher?)

```
delete(header: string | string[], matcher?: AxiosHeaderMatcher): boolean;
```

하나 이상의 헤더가 제거된 경우 `true`를 반환합니다.

### AxiosHeaders#clear(matcher?)

```
clear(matcher?: AxiosHeaderMatcher): boolean;
```

모든 헤더를 제거합니다.  
`delete` 메서드의 matcher와 달리, 이 선택적 matcher는 값이 아니라 헤더 이름과 일치하는 데 사용됩니다.

```ts
const headers = new AxiosHeaders({
  'foo': '1',
  'x-foo': '2',
  'x-bar': '3',
});

console.log(headers.clear(/^x-/)); // true

console.log(headers.toJSON()); // [Object: null prototype] { foo: '1' }
```

하나 이상의 헤더가 제거된 경우 `true`를 반환합니다.

### AxiosHeaders#normalize(format);

헤더 객체가 직접 변경된 경우, 대소문자가 다른 동일한 이름의 중복 항목이 있을 수 있습니다.  
이 메서드는 중복 키를 하나로 합쳐서 헤더 객체를 정규화합니다.  
Axios는 각 인터셉터 호출 후 내부적으로 이 메서드를 사용합니다.  
헤더 이름을 소문자로 변환하고 첫 글자를 대문자로 만들려면(`cOntEnt-type` => `Content-Type`) `format`을 true로 설정합니다.

```js
const headers = new AxiosHeaders({
  'foo': '1',
});

headers.Foo = '2';
headers.FOO = '3';

console.log(headers.toJSON()); // [Object: null prototype] { foo: '1', Foo: '2', FOO: '3' }
console.log(headers.normalize().toJSON()); // [Object: null prototype] { foo: '3' }
console.log(headers.normalize(true).toJSON()); // [Object: null prototype] { Foo: '3' }
```

`this`를 반환합니다.

### AxiosHeaders#concat(...targets)

```
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
```

인스턴스를 대상과 병합하여 새로운 `AxiosHeaders` 인스턴스로 만듭니다.  
대상이 문자열이면 RAW HTTP 헤더로 파싱됩니다.

새로운 `AxiosHeaders` 인스턴스를 반환합니다.

### AxiosHeaders#toJSON(asStrings?)

````
toJSON(asStrings?: boolean): RawAxiosHeaders;
````

모든 내부 헤더 값을 새로운 null prototype 객체로 변환합니다.  
`asStrings`를 true로 설정하면 배열을 각 요소를 쉼표로 구분한 문자열로 변환합니다.

### AxiosHeaders.from(thing?)

````
from(thing?: AxiosHeaders | RawAxiosHeaders | string): AxiosHeaders;
````

전달된 raw 헤더로부터 생성된 새로운 `AxiosHeaders` 인스턴스를 반환하거나,  
이미 `AxiosHeaders` 인스턴스인 경우 해당 헤더 객체를 그대로 반환합니다.

### AxiosHeaders.concat(...targets)

````
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
````

대상 객체들을 병합하여 생성된 새로운 `AxiosHeaders` 인스턴스를 반환합니다.

### 단축 메서드

다음과 같은 단축 메서드를 사용할 수 있습니다:

- `setContentType`, `getContentType`, `hasContentType`

- `setContentLength`, `getContentLength`, `hasContentLength`

- `setAccept`, `getAccept`, `hasAccept`

- `setUserAgent`, `getUserAgent`, `hasUserAgent`
- `setContentEncoding`, `getContentEncoding`, `hasContentEncoding`

## 🔥 Fetch 어댑터

Fetch 어댑터는 `v1.7.0`에서 도입되었습니다. 기본적으로, 빌드에서 `xhr`와 `http` 어댑터를 사용할 수 없거나,
환경에서 지원되지 않는 경우 사용됩니다.
기본적으로 사용하려면, 명시적으로 선택해야 합니다:

```js
const {data} = axios.get(url, {
  adapter: 'fetch' // 기본값 ['xhr', 'http', 'fetch']
})
```

이를 위해 별도의 인스턴스를 생성할 수 있습니다:

```js
const fetchAxios = axios.create({
  adapter: 'fetch'
});

const {data} = fetchAxios.get(url);
```

이 어댑터는 `xhr` 어댑터와 동일한 기능을 지원하며, **업로드 및 다운로드 진행 상황 캡처 포함**이 가능합니다. 
또한, 환경이 지원하는 경우 `stream` 및 `formdata`와 같은 추가 응답 유형도 지원합니다.

## Semver

axios가 `1.0` 릴리즈에 도달하기 전까지, 주요 변경 사항은 새로운 마이너 버전과 함께 릴리즈됩니다. 예를 들어 `0.5.1`과 `0.5.4`는 동일한 API를 가지지만, `0.6.0`에는 주요 변경 사항이 포함될 수 있습니다.

## 프로미스(Promises)

axios는 [지원되는](https://caniuse.com/promises) 네이티브 ES6 프로미스 구현에 의존합니다.
만약 환경에서 ES6 프로미스를 지원하지 않는 경우, [polyfill](https://github.com/jakearchibald/es6-promise)을 사용할 수 있습니다.

## 타입스크립트(TypeScript)

axios는 [TypeScript](https://typescriptlang.org) 정의와 axios 오류에 대한 타입 가드를 포함합니다.

```typescript
let user: User = null;
try {
  const { data } = await axios.get('/user?ID=12345');
  user = data.userDetails;
} catch (error) {
  if (axios.isAxiosError(error)) {
    handleAxiosError(error);
  } else {
    handleUnexpectedError(error);
  }
}
```

axios는 ESM 기본 내보내기와 CJS `module.exports`를 모두 지원하므로 몇 가지 주의 사항이 있습니다.
권장 설정은 `"moduleResolution": "node16"`을 사용하는 것입니다(이는 `"module": "node16"`에 의해 암시됩니다). 이 설정은 TypeScript 4.7 이상이 필요합니다.
ESM을 사용하는 경우, 별도의 설정이 필요하지 않습니다.
TypeScript를 CJS로 컴파일하고 `"moduleResolution": "node16"`을 사용할 수 없는 경우, `esModuleInterop`을 활성화해야 합니다.
TypeScript로 CJS 자바스크립트 코드를 타입 체크하는 경우, `"moduleResolution": "node16"`만 사용할 수 있습니다.

## 온라인 원클릭 설정

온라인 IDE인 Gitpod(오픈 소스에는 무료)를 사용하여 기여하거나 예제를 온라인에서 실행할 수 있습니다.

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/axios/axios/blob/main/examples/server.js)


## 리소스

* [변경 로그](https://github.com/axios/axios/blob/v1.x/CHANGELOG.md)
* [에코시스템](https://github.com/axios/axios/blob/v1.x/ECOSYSTEM.md)
* [기여 가이드](https://github.com/axios/axios/blob/v1.x/CONTRIBUTING.md)
* [행동 강령](https://github.com/axios/axios/blob/v1.x/CODE_OF_CONDUCT.md)

## 크레딧

axios는 [AngularJS](https://angularjs.org/)에서 제공하는 [$http 서비스](https://docs.angularjs.org/api/ng/service/$http)에서 많은 영감을 받았습니다. 궁극적으로 axios는 AngularJS 외부에서 사용할 수 있는 독립적인 `$http`-유사 서비스를 제공하려는 노력의 산물입니다.

## 라이선스

[MIT](LICENSE)


---

Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-30

---